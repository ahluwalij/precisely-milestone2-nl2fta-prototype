[
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.CUSIP",
    "description": "A nine-character alphanumeric identifier used to uniquely identify North American securities for trading and settlement purposes. The first eight characters are letters and digits, and the ninth character is a numeric check digit computed from the preceding characters.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z0-9]{8}[0-9]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4240,
    "headerPatterns": [
      {
        "regExp": "(?i).*security.*cusip.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "security_cusip"
        ],
        "negativeExamples": [
          "security_isin"
        ]
      },
      {
        "regExp": "(?i).*instrument.*cusip.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "instrument_cusip"
        ],
        "negativeExamples": [
          "instrument_code"
        ]
      },
      {
        "regExp": "(?i).*cusip.*(number|no|id).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "cusip_number"
        ],
        "negativeExamples": [
          "isin_code"
        ]
      },
      {
        "regExp": "(?i).*cusip.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cusip"
        ],
        "negativeExamples": [
          "isin"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "id"
        ]
      }
    ],
    "positiveContentExamples": [
      "037833100",
      "594918104",
      "023135106",
      "02079K305",
      "88160R101",
      "46625H100",
      "30303M102",
      "67066G104"
    ],
    "negativeContentExamples": [
      "03783310O",
      "59491810",
      "5949181043",
      "02079-K305",
      "88160R10X",
      "46625H10O",
      "30303m102",
      "67066 G104"
    ],
    "positiveHeaderExamples": [
      "security_cusip",
      "instrument_cusip",
      "cusip",
      "cusip_number",
      "cusip_id",
      "primary_cusip",
      "cusip_code"
    ],
    "negativeHeaderExamples": [
      "isin",
      "isin_code",
      "sedol",
      "ric",
      "ticker",
      "security_code",
      "security_id",
      "lei"
    ],
    "explanation": "CUSIP values are nine-character alphanumeric identifiers where the final character is a numeric check digit. This pattern enforces eight uppercase alphanumerics followed by one digit, using word boundaries to avoid partial matches. It is suitable for columns labeled with CUSIP-related terms and helps distinguish CUSIPs from other security identifiers like ISIN or SEDOL based on length and composition.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:17.832825"
  },
  {
    "resultType": "generated",
    "semanticType": "CONTINENT.CODE_EN",
    "description": "A two-character abbreviation representing one of the seven major continental landmasses used in geographic classification systems. Values are limited to the canonical set for Africa, Antarctica, Asia, Europe, North America, Oceania, and South America.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AF",
      "AN",
      "AS",
      "EU",
      "NA",
      "OC",
      "SA"
    ],
    "backout": "^[A-Z]{2}$",
    "confidenceThreshold": 97,
    "priority": 4380,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bcontinent\\b.*\\bcode\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "continent_code"
        ],
        "negativeExamples": [
          "country_code"
        ]
      },
      {
        "regExp": "(?i).*\\bcontinent\\b.*\\b(abbr|abbrev|cd)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "continent_abbr"
        ],
        "negativeExamples": [
          "state_abbr"
        ]
      },
      {
        "regExp": "(?i).*\\bgeo\\b.*\\bcontinent\\b.*\\bcode\\b.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "geo_continent_code"
        ],
        "negativeExamples": [
          "geography_code"
        ]
      },
      {
        "regExp": "(?i).*\\bcontinent\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "continent"
        ],
        "negativeExamples": [
          "country"
        ]
      },
      {
        "regExp": "(?i).*\\b(cont|cnt|cntnt)\\b.*\\bcode\\b.*",
        "confidence": 91,
        "mandatory": true,
        "positiveExamples": [
          "cont_code"
        ],
        "negativeExamples": [
          "content_code"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "AF",
      "AN",
      "AS",
      "EU",
      "NA",
      "OC",
      "SA"
    ],
    "negativeContentExamples": [
      "eu",
      "EU ",
      "E U",
      "AA",
      "OC1",
      "SA-",
      "NA/EU",
      "AFR"
    ],
    "positiveHeaderExamples": [
      "continent_code",
      "continent_abbr",
      "continent_cd",
      "geo_continent_code",
      "cont_code",
      "continent",
      "continent_2char_code",
      "continent_abbrev"
    ],
    "negativeHeaderExamples": [
      "country_code",
      "region_code",
      "content_code",
      "continent_name",
      "country_abbr",
      "zone_code",
      "geography_code",
      "state_code"
    ],
    "explanation": "This semantic type captures the small, finite set of two-letter English abbreviations for continents: AF, AN, AS, EU, NA, OC, and SA. It is useful for classifying compact geographic continent indicators and validating fields expected to contain standardized continent codes.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:19.684421"
  },
  {
    "resultType": "generated",
    "semanticType": "EMAIL",
    "description": "An electronic mail address used for sending and receiving digital messages across internet communication networks.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9-]+(\\.[A-Za-z0-9-]{2,})+\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4620,
    "headerPatterns": [
      {
        "regExp": "(?i).*primary.*email.*address.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "primary_email_address"
        ],
        "negativeExamples": [
          "primary_mailing_address"
        ]
      },
      {
        "regExp": "(?i).*customer.*email.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "customer_email"
        ],
        "negativeExamples": [
          "customer_contact"
        ]
      },
      {
        "regExp": "(?i).*contact.*email.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "contact_email"
        ],
        "negativeExamples": [
          "contact_name"
        ]
      },
      {
        "regExp": "(?i).*email.*addr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "user_email_addr"
        ],
        "negativeExamples": [
          "mailing_address"
        ]
      },
      {
        "regExp": "(?i).*email.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "email"
        ],
        "negativeExamples": [
          "username"
        ]
      }
    ],
    "positiveContentExamples": [
      "alice.smith@example.com",
      "bob+promo@sub.domain.co.uk",
      "jdoe_99@company.org",
      "sales-team@my-shop.io",
      "support@service123.net",
      "dev.ops@cloud-platform.com",
      "u123@dept.school.edu",
      "notify@newsletters.example.co"
    ],
    "negativeContentExamples": [
      "alice.smith@",
      "bob@domain",
      "jdoe@.org",
      "support@service.c",
      "sales team@shop.com",
      "@example.com",
      "user@domain_.com",
      "user@domain..com"
    ],
    "positiveHeaderExamples": [
      "email",
      "email_address",
      "primary_email",
      "customer_email",
      "contact_email",
      "login_email",
      "notification_email",
      "user_email_addr"
    ],
    "negativeHeaderExamples": [
      "mailing_address",
      "contact_name",
      "customer_phone",
      "login_id",
      "notification_method",
      "user_handle",
      "website_url",
      "support_mailbox"
    ],
    "explanation": "This type identifies strings that conform to common email address structure: a local part, an at-symbol, and a domain with at least one dot-separated label and a terminal segment of two or more characters. It is intended for detecting email addresses in datasets such as user profiles, contact lists, and communication logs, while avoiding overly permissive matching by requiring explicit tokens and boundaries.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:24.447043"
  },
  {
    "resultType": "generated",
    "semanticType": "DAY.ABBR_<LOCALE>",
    "description": "A shortened form of weekday names using locale-specific abbreviations, typically consisting of three letters in the specified language and region.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "MON",
      "TUE",
      "WED",
      "THU",
      "FRI",
      "SAT",
      "SUN"
    ],
    "backout": "^[A-Z]{3}$",
    "confidenceThreshold": 98,
    "priority": 4580,
    "headerPatterns": [
      {
        "regExp": "(?i).*weekday.*abbr.*",
        "confidence": 99,
        "mandatory": true,
        "positiveExamples": [
          "weekday_abbreviation"
        ],
        "negativeExamples": [
          "weekday_name"
        ]
      },
      {
        "regExp": "(?i).*day.*of.*week.*abbr.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "day_of_week_abbr"
        ],
        "negativeExamples": [
          "week_of_day_abbr"
        ]
      },
      {
        "regExp": "(?i).*dow.*abbrev.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "dow_abbrev"
        ],
        "negativeExamples": [
          "dow_index"
        ]
      },
      {
        "regExp": "(?i).*short.*weekday.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "short_weekday"
        ],
        "negativeExamples": [
          "short_month"
        ]
      },
      {
        "regExp": "(?i).*day.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "day"
        ],
        "negativeExamples": [
          "date"
        ]
      }
    ],
    "positiveContentExamples": [
      "MON",
      "TUE",
      "WED",
      "THU",
      "FRI",
      "SAT",
      "SUN"
    ],
    "negativeContentExamples": [
      "MO",
      "MONDAY",
      "TUES",
      "THUR",
      "FR",
      "SUN.",
      "LUN",
      "MON-"
    ],
    "positiveHeaderExamples": [
      "weekday_abbreviation",
      "day_of_week_abbr",
      "dow_abbrev",
      "short_weekday",
      "day_abbr",
      "abbr_day"
    ],
    "negativeHeaderExamples": [
      "month_abbreviation",
      "hour_abbreviation",
      "week_number",
      "date",
      "timestamp",
      "quarter_short"
    ],
    "explanation": "This semantic type identifies three-letter weekday abbreviations for a specific locale. It is suitable for columns that store compact day-of-week labels used in calendars, schedules, logs, or summaries. The list-based approach ensures high precision for the finite set of valid abbreviations while the anchored backout pattern provides a fallback shape check for three-letter uppercase tokens.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:28.903577"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.ISO-3166-2",
    "description": "A two-letter country code assigned by the International Organization for Standardization to uniquely identify nations and territories worldwide.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4480,
    "headerPatterns": [
      {
        "regExp": "(?i).*iso.*3166.*alpha.*2.*country.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iso3166_alpha2_country_code"
        ],
        "negativeExamples": [
          "iso3166_alpha3_country_code"
        ]
      },
      {
        "regExp": "(?i).*country.*iso.*2.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "country_iso2_code"
        ],
        "negativeExamples": [
          "country_iso3_code"
        ]
      },
      {
        "regExp": "(?i).*alpha2.*country.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "alpha2_country"
        ],
        "negativeExamples": [
          "alpha3_country"
        ]
      },
      {
        "regExp": "(?i).*iso2.*country.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iso2_country"
        ],
        "negativeExamples": [
          "iso3_country"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "US",
      "GB",
      "FR",
      "DE",
      "CN",
      "IN",
      "BR",
      "ZA"
    ],
    "negativeContentExamples": [
      "USA",
      "U1",
      "us",
      "U-S",
      "U S",
      "US1",
      "1U",
      "\u00dcS"
    ],
    "positiveHeaderExamples": [
      "country_iso2_code",
      "iso3166_1_alpha2",
      "iso2_country",
      "alpha2_country_code",
      "country_code_iso2",
      "nation_alpha2",
      "iso3166_country_alpha2",
      "country_alpha2"
    ],
    "negativeHeaderExamples": [
      "country_iso3_code",
      "iso3166_1_alpha3",
      "state_code",
      "country_name",
      "subdivision_code",
      "airport_code",
      "language_code",
      "postal_code"
    ],
    "explanation": "This semantic type targets ISO two-letter country identifiers (alpha-2), which are concise uppercase codes like US, GB, or FR. It is useful for validating and classifying columns containing standardized country codes in international datasets, ensuring interoperability and consistent country referencing.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:30.358106"
  },
  {
    "resultType": "generated",
    "semanticType": "CREDIT_CARD_TYPE",
    "description": "The brand or network name of a credit card issuer used to identify the payment processing network and card features.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "VISA",
      "MASTERCARD",
      "AMERICAN EXPRESS",
      "AMEX",
      "DISCOVER",
      "DINERS CLUB",
      "JCB",
      "UNIONPAY",
      "MAESTRO",
      "MIR",
      "RUPAY",
      "ELO",
      "HIPERCARD",
      "TROY",
      "VERVE",
      "CARTES BANCAIRES",
      "INTERAC"
    ],
    "backout": "^[A-Z][A-Z ]{1,24}$",
    "confidenceThreshold": 93,
    "priority": 4540,
    "headerPatterns": [
      {
        "regExp": "(?i).*credit.*card.*(brand|network|type).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "credit_card_brand"
        ],
        "negativeExamples": [
          "credit_card_number"
        ]
      },
      {
        "regExp": "(?i).*(payment|pay).*card.*(brand|network|type).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "payment_card_network"
        ],
        "negativeExamples": [
          "payment_method"
        ]
      },
      {
        "regExp": "(?i).*(cc|ccard|c_card).*(brand|network|type).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cc_brand"
        ],
        "negativeExamples": [
          "cc_expiration"
        ]
      },
      {
        "regExp": "(?i).*card.*(brand|type|network).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "card_type"
        ],
        "negativeExamples": [
          "card_id"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Visa",
      "Mastercard",
      "American Express",
      "Discover",
      "Diners Club",
      "JCB",
      "UnionPay",
      "RuPay"
    ],
    "negativeContentExamples": [
      "Visa Debit",
      "Master Card",
      "AMERICAN EXPRESS COMPANY",
      "Discover It",
      "Diners Club International",
      "Union Pay",
      "Credit Card",
      "Card Brand"
    ],
    "positiveHeaderExamples": [
      "credit_card_brand",
      "card_network",
      "payment_card_type",
      "cc_brand",
      "card_type",
      "credit_card_network"
    ],
    "negativeHeaderExamples": [
      "credit_card_number",
      "cc_expiration",
      "payment_method",
      "issuer_name",
      "bank_name",
      "cardholder_name"
    ],
    "explanation": "Identifies the payment network brand of a credit card, such as Visa, Mastercard, American Express, or other card networks. Useful for categorizing transactions, routing logic, and analytics where the card network is relevant rather than the card number or issuer details.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:30.699259"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.UPC",
    "description": "A twelve-digit barcode identifier used primarily in North American retail for product identification and inventory management systems.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{12}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4310,
    "headerPatterns": [
      {
        "regExp": "(?i).*product.*upc.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "product_upc_code"
        ],
        "negativeExamples": [
          "product_code"
        ]
      },
      {
        "regExp": "(?i).*upc.*code.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "upc_code"
        ],
        "negativeExamples": [
          "ean_code"
        ]
      },
      {
        "regExp": "(?i).*barcode.*upc.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "barcode_upc"
        ],
        "negativeExamples": [
          "barcode_ean"
        ]
      },
      {
        "regExp": "(?i).*upc.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "upc"
        ],
        "negativeExamples": [
          "sku"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "036000291452",
      "012345678905",
      "041631000019",
      "073366118238",
      "099482404512",
      "722252601404",
      "639382000393",
      "850021123456"
    ],
    "negativeContentExamples": [
      "03600029145",
      "0036000291452",
      "03600-0291452",
      "036000 291452",
      "03600029145A",
      "upc036000291452",
      "1234567890",
      "1234567890123"
    ],
    "positiveHeaderExamples": [
      "product_upc_code",
      "upc_code",
      "upc",
      "barcode_upc",
      "primary_upc",
      "upc_number",
      "upc12",
      "item_upc"
    ],
    "negativeHeaderExamples": [
      "ean_code",
      "sku",
      "barcode",
      "product_code",
      "isbn13",
      "tracking_number",
      "gtin",
      "serial_number"
    ],
    "explanation": "This semantic type targets UPC-A values represented as a contiguous 12-digit token. It is optimized for columns explicitly labeled as UPC or UPC code and avoids matching formatted variants with separators. Use this when extracting or validating product UPCs in retail and inventory datasets.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:32.163733"
  },
  {
    "resultType": "generated",
    "semanticType": "CURRENCY_CODE.ISO-4217",
    "description": "A three-letter currency code assigned by ISO to uniquely identify currencies used in international financial transactions.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b[A-Z]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4570,
    "headerPatterns": [
      {
        "regExp": "(?i).*iso.*4217.*currency.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "iso4217_currency_code"
        ],
        "negativeExamples": [
          "currency_code"
        ]
      },
      {
        "regExp": "(?i).*currency.*iso.*code.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "currency_iso_code"
        ],
        "negativeExamples": [
          "iso_country_code"
        ]
      },
      {
        "regExp": "(?i).*currency.*code.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "currency_code"
        ],
        "negativeExamples": [
          "airport_code"
        ]
      },
      {
        "regExp": "(?i).*ccy.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ccy_code"
        ],
        "negativeExamples": [
          "country_code"
        ]
      },
      {
        "regExp": "(?i).*fx.*currency.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fx_currency_code"
        ],
        "negativeExamples": [
          "foreign_exchange_rate"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "USD",
      "EUR",
      "JPY",
      "GBP",
      "AUD",
      "CAD",
      "CHF",
      "CNY"
    ],
    "negativeContentExamples": [
      "US",
      "EURO",
      "USDT",
      "GBP1",
      "U SD",
      "123",
      "EUR-",
      "usd$"
    ],
    "positiveHeaderExamples": [
      "iso4217_currency_code",
      "currency_iso_code",
      "currency_code",
      "ccy_code",
      "fx_currency_code",
      "currency_iso_4217_code",
      "iso_currency_code",
      "currency_three_letter_code"
    ],
    "negativeHeaderExamples": [
      "airport_code",
      "language_code",
      "currency_name",
      "country_code",
      "iso_language_code",
      "currency_symbol",
      "iban_code",
      "exchange_rate"
    ],
    "explanation": "Identifies three-letter ISO 4217 currency codes commonly found in financial datasets, transaction logs, and FX tables. The pattern is intentionally strict to three alphabetic characters, relying on header context to distinguish from other three-letter code systems such as airport or language codes.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:32.709722"
  },
  {
    "resultType": "generated",
    "semanticType": "DAY.FULL_<LOCALE>",
    "description": "The complete written names of the seven weekdays in English (United States), exactly as commonly spelled in full form. This captures values like Monday through Sunday without abbreviations, punctuation, or plurals.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "MONDAY",
      "TUESDAY",
      "WEDNESDAY",
      "THURSDAY",
      "FRIDAY",
      "SATURDAY",
      "SUNDAY"
    ],
    "backout": "^[A-Za-z]{6,9}$",
    "confidenceThreshold": 98,
    "priority": 4600,
    "headerPatterns": [
      {
        "regExp": "(?i).*full.*weekday.*name.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "full_weekday_name"
        ],
        "negativeExamples": [
          "weekday_name"
        ]
      },
      {
        "regExp": "(?i).*day.*of.*week.*name.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "day_of_week_name"
        ],
        "negativeExamples": [
          "day_of_week_code"
        ]
      },
      {
        "regExp": "(?i).*(weekday.*name|dayname).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "weekday_name"
        ],
        "negativeExamples": [
          "weekday_abbrev"
        ]
      },
      {
        "regExp": "(?i).*(dow|wday|wkday).*name.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "dow_name"
        ],
        "negativeExamples": [
          "dow_code"
        ]
      },
      {
        "regExp": "(?i).*(weekday|day.*of.*week).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "weekday"
        ],
        "negativeExamples": [
          "week"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Monday",
      "TUESDAY",
      "Wednesday",
      "ThuRSDay",
      "Friday",
      "saturday",
      "Sunday"
    ],
    "negativeContentExamples": [
      "Mon",
      "Mondays",
      "Mon day",
      "Monday-Friday",
      "Lundi",
      "Tue",
      "Wednsday",
      "Sun."
    ],
    "positiveHeaderExamples": [
      "full_weekday_name",
      "day_of_week_name",
      "weekday_name",
      "dayname",
      "dow_name",
      "name_of_day",
      "weekday_full"
    ],
    "negativeHeaderExamples": [
      "weekday_abbrev",
      "day_of_week_num",
      "week_day_code",
      "short_weekday",
      "dow",
      "week_number",
      "event_date",
      "date"
    ],
    "explanation": "This semantic type identifies values that are the fully spelled weekday names in English (United States). It is useful for columns storing human-readable day names, enabling precise detection distinct from abbreviations, numeric day-of-week codes, or localized non-English day names.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:32.862010"
  },
  {
    "resultType": "generated",
    "semanticType": "DAY.DIGITS",
    "description": "A numerical representation of the day within a calendar month, ranging from 1 to 31 depending on the specific month.",
    "pluginType": "regex",
    "regexPattern": "\\b(0?[1-9]|[12][0-9]|3[01])\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 92,
    "priority": 4590,
    "headerPatterns": [
      {
        "regExp": "(?i).*day.*of.*month.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "day_of_month"
        ],
        "negativeExamples": [
          "month_day"
        ]
      },
      {
        "regExp": "(?i).*(calendar|billing|invoice|due).*day.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "billing_day"
        ],
        "negativeExamples": [
          "invoice_date"
        ]
      },
      {
        "regExp": "(?i).*dom.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "dom"
        ],
        "negativeExamples": [
          "day_of_month"
        ]
      },
      {
        "regExp": "(?i).*day.*num.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "day_num"
        ],
        "negativeExamples": [
          "month_num"
        ]
      },
      {
        "regExp": "(?i).*day.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "day"
        ],
        "negativeExamples": [
          "date"
        ]
      }
    ],
    "positiveContentExamples": [
      "1",
      "3",
      "07",
      "09",
      "10",
      "15",
      "28",
      "31"
    ],
    "negativeContentExamples": [
      "0",
      "32",
      "00",
      "003",
      "3.0",
      "1st",
      "12-",
      "04/"
    ],
    "positiveHeaderExamples": [
      "day_of_month",
      "billing_day",
      "calendar_day",
      "dom",
      "day_num",
      "invoice_day",
      "due_day"
    ],
    "negativeHeaderExamples": [
      "month",
      "date",
      "year",
      "week_number",
      "invoice_date",
      "due_date",
      "timestamp"
    ],
    "explanation": "This type captures numeric day-of-month values expressed as integers 1\u201331, optionally with a single leading zero for days 1\u20139. It is useful for columns storing the day component extracted from calendar dates or billing cycles without month or year context.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:33.442511"
  },
  {
    "resultType": "generated",
    "semanticType": "DIRECTION",
    "description": "One of the four main compass directions used for navigation and geographic orientation on Earth's surface.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "N",
      "E",
      "S",
      "W",
      "NORTH",
      "EAST",
      "SOUTH",
      "WEST"
    ],
    "backout": "^[A-Z]{1,5}$",
    "confidenceThreshold": 97,
    "priority": 4610,
    "headerPatterns": [
      {
        "regExp": "(?i).*(compass|cardinal).*direction.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "compass_direction"
        ],
        "negativeExamples": [
          "compass_bearing"
        ]
      },
      {
        "regExp": "(?i).*(travel|wind|movement|route).*direction.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "travel_direction"
        ],
        "negativeExamples": [
          "wind_speed"
        ]
      },
      {
        "regExp": "(?i).*\\bdir\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "vehicle_dir"
        ],
        "negativeExamples": [
          "directory_path"
        ]
      },
      {
        "regExp": "(?i).*\\b(compass|cardinal)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "compass"
        ],
        "negativeExamples": [
          "cardinality"
        ]
      },
      {
        "regExp": "(?i).*\\bdirection\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "direction"
        ],
        "negativeExamples": [
          "orientation"
        ]
      }
    ],
    "positiveContentExamples": [
      "North",
      "EAST",
      "west",
      "SOUTH",
      "N",
      "E",
      "S",
      "W"
    ],
    "negativeContentExamples": [
      "NE",
      "NW",
      "NNE",
      "NORTHWEST",
      "EASTWARD",
      "NORTH EAST",
      "SOUTHERN",
      "E."
    ],
    "positiveHeaderExamples": [
      "travel_direction",
      "compass_direction",
      "wind_direction",
      "movement_direction",
      "route_direction",
      "cardinal_direction",
      "direction_of_travel",
      "vehicle_dir"
    ],
    "negativeHeaderExamples": [
      "directory_path",
      "wind_speed",
      "compass_bearing",
      "cardinality",
      "orientation",
      "latitude",
      "route_id",
      "heading_degrees"
    ],
    "explanation": "This semantic type identifies values that represent only the four principal compass directions: North, East, South, and West, including their single-letter abbreviations. It is useful for datasets that encode qualitative orientation rather than numeric bearings or coordinates.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:33.590927"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.SEDOL",
    "description": "A seven-character alphanumeric code used to identify securities traded on the London Stock Exchange and other UK financial markets. The first six characters are uppercase consonants and digits, and the seventh character is a numeric check digit.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9BCDFGHJKLMNPQRSTVWXYZ]{6}[0-9]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4300,
    "headerPatterns": [
      {
        "regExp": "(?i).*(security|instrument).*sedol.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "security_sedol_code"
        ],
        "negativeExamples": [
          "security_isin_code"
        ]
      },
      {
        "regExp": "(?i).*sedol.*(identifier|id).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "sedol_identifier"
        ],
        "negativeExamples": [
          "isin_identifier"
        ]
      },
      {
        "regExp": "(?i).*(lse|exchange).*sedol.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lse_sedol"
        ],
        "negativeExamples": [
          "exchange_isin"
        ]
      },
      {
        "regExp": "(?i).*sedol.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "sedol"
        ],
        "negativeExamples": [
          "isin"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "date"
        ]
      }
    ],
    "positiveContentExamples": [
      "0263494",
      "B1X3TL9",
      "C57LQK2",
      "2H33WZ5",
      "M5N7QK6",
      "3J7R9C8",
      "Z4T7VJ0",
      "N9S6BD1"
    ],
    "negativeContentExamples": [
      "026349A",
      "B1X3TL98",
      "C57LQK",
      "2H33WZ5A",
      "ME5N7Q6",
      "b1x3tl9",
      "2O33WZ5",
      "123-456"
    ],
    "positiveHeaderExamples": [
      "security_sedol_code",
      "sedol",
      "sedol_code",
      "lse_sedol",
      "instrument_sedol_id",
      "sedol_identifier",
      "primary_sedol",
      "sedol_ref"
    ],
    "negativeHeaderExamples": [
      "isin_code",
      "cusip",
      "ric",
      "ticker",
      "security_code",
      "isin_identifier",
      "bloomberg_ticker",
      "cusip_code"
    ],
    "explanation": "SEDOL is a structured seven-character identifier with a numeric check digit used predominantly in UK markets. This type focuses on the canonical form: six uppercase consonant/digit characters followed by a numeric check digit, enabling high-precision detection in security master datasets.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:34.815515"
  },
  {
    "resultType": "generated",
    "semanticType": "AIRLINE.IATA_CODE",
    "description": "An official two-letter airline designation code assigned by IATA to identify commercial carriers in global aviation systems.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z][A-Z0-9]|[0-9][A-Z])\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4200,
    "headerPatterns": [
      {
        "regExp": "(?i).*airline.*iata.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "airline_iata_code"
        ],
        "negativeExamples": [
          "airport_iata_code"
        ]
      },
      {
        "regExp": "(?i).*carrier.*iata.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "carrier_iata_code"
        ],
        "negativeExamples": [
          "airline_icao_code"
        ]
      },
      {
        "regExp": "(?i).*airline.*iata.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "marketing_airline_iata"
        ],
        "negativeExamples": [
          "airline_name"
        ]
      },
      {
        "regExp": "(?i).*carrier.*iata.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "operating_carrier_iata"
        ],
        "negativeExamples": [
          "carrier_id"
        ]
      },
      {
        "regExp": "(?i).*iata.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iata_carrier"
        ],
        "negativeExamples": [
          "icao_airline_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "airline_code_iata"
        ],
        "negativeExamples": [
          "flight_number"
        ]
      }
    ],
    "positiveContentExamples": [
      "AA",
      "BA",
      "LH",
      "QF",
      "U2",
      "3K",
      "0B",
      "D7"
    ],
    "negativeContentExamples": [
      "AAA",
      "11",
      "aa",
      "A_",
      "A-",
      "1a",
      "AB1",
      "A/1"
    ],
    "positiveHeaderExamples": [
      "airline_iata_code",
      "carrier_iata_code",
      "iata_airline_code",
      "operating_carrier_iata",
      "marketing_airline_iata",
      "airline_code_iata",
      "iata_carrier",
      "flight_carrier_iata"
    ],
    "negativeHeaderExamples": [
      "airline_icao_code",
      "airport_iata_code",
      "airport_iata",
      "carrier_id",
      "airline_name",
      "flight_number",
      "airport_code",
      "icao_airline_code"
    ],
    "explanation": "This semantic type identifies two-character IATA airline designator codes used to represent marketing or operating carriers in booking, scheduling, ticketing, and reporting systems. The value regex strictly allows two-character tokens where at least one character is an uppercase letter and the other may be an uppercase letter or digit, reflecting valid IATA airline code structure while excluding two-digit pairs and symbols. Header patterns prioritize columns explicitly describing airline or carrier IATA codes, then progressively broader patterns down to the primitive concept of a code.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:41.585282"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.LATITUDE_DMS",
    "description": "A geographic coordinate that specifies north-south position using traditional degrees, minutes, and seconds notation with cardinal direction indicators.",
    "pluginType": "regex",
    "regexPattern": "\\b([0-8]?\\d|90)[\u00b0 ]\\s*([0-5]?\\d)['\u2032]\\s*([0-5]?\\d(\\.\\d+)?) [\"\u2033]?\\s*[NnSs]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4420,
    "headerPatterns": [
      {
        "regExp": "(?i).*lat(itude)?[_\\s-]*dms.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "latitude_dms"
        ],
        "negativeExamples": [
          "longitude_dms"
        ]
      },
      {
        "regExp": "(?i).*geo[_\\s-]*lat(itude)?[_\\s-]*dms.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "geo_latitude_dms"
        ],
        "negativeExamples": [
          "geo_longitude_dms"
        ]
      },
      {
        "regExp": "(?i).*(lat|latitude)[_\\s-]*deg[_\\s-]*min[_\\s-]*sec.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "latitude_deg_min_sec"
        ],
        "negativeExamples": [
          "longitude_deg_min_sec"
        ]
      },
      {
        "regExp": "(?i).*lat(itude)?.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "lat"
        ],
        "negativeExamples": [
          "lon"
        ]
      },
      {
        "regExp": "(?i).*latitude.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "latitude"
        ],
        "negativeExamples": [
          "longitude"
        ]
      }
    ],
    "positiveContentExamples": [
      "45\u00b030'15\" N",
      "12 05'09\" S",
      "0\u00b00'0\" N",
      "89\u00b059'59.9\" S",
      "07\u00b003'15\" N",
      "90\u00b000'00\" N",
      "38\u00b012'0\" n",
      "23\u00b07'5\" S"
    ],
    "negativeContentExamples": [
      "91\u00b000'00\" N",
      "45\u00b060'00\" N",
      "45\u00b030'60\" S",
      "45\u00b030.5'15\" N",
      "N 45\u00b030'15\"",
      "45d30'15\" N",
      "45\u00b030'15\" E",
      "45\u00b030'15\""
    ],
    "positiveHeaderExamples": [
      "latitude_dms",
      "lat_dms",
      "geo_latitude_dms",
      "latitude_deg_min_sec",
      "lat_degminsec",
      "coord_latitude_dms",
      "gps_lat_dms"
    ],
    "negativeHeaderExamples": [
      "longitude_dms",
      "lat_dd",
      "gps_longitude",
      "latitude_decimal",
      "elevation",
      "coordinate",
      "geo_latitude_dd"
    ],
    "explanation": "Identifies latitude values written in degrees, minutes, and seconds with an explicit N or S suffix (or lowercase variant). Useful for geospatial datasets where coordinates are recorded in traditional DMS format rather than decimal degrees.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:42.177077"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE_PAIR.DECIMAL_PAREN",
    "description": "A combined latitude and longitude coordinate pair expressed in decimal degrees format enclosed in parentheses for precise geographic positioning.",
    "pluginType": "regex",
    "regexPattern": "\\(\\s*[+-]?\\d{1,2}\\.\\d+\\s*,\\s*[+-]?\\d{1,3}\\.\\d+\\s*\\)",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4470,
    "headerPatterns": [
      {
        "regExp": "(?i).*(lat.*lon).*(decimal).*(paren).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "lat_lon_decimal_paren"
        ],
        "negativeExamples": [
          "lat_lon"
        ]
      },
      {
        "regExp": "(?i).*(coordinate.*pair).*(decimal|dd).*(paren).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "coordinate_pair_dd_parentheses"
        ],
        "negativeExamples": [
          "coordinate_pair"
        ]
      },
      {
        "regExp": "(?i).*(coordinate.*pair).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "geo_coordinate_pair_dd"
        ],
        "negativeExamples": [
          "latitude_longitude"
        ]
      },
      {
        "regExp": "(?i).*(latlon|lat[_ ]lng|ll).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "latlng_decimal_parentheses"
        ],
        "negativeExamples": [
          "lat_lon"
        ]
      },
      {
        "regExp": "(?i).*(coordinate).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "location_coordinates_decimal"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      }
    ],
    "positiveContentExamples": [
      "(37.7749, -122.4194)",
      "(-33.8688, 151.2093)",
      "(51.5074, -0.1278)",
      "(0.0000, 0.0000)",
      "(+12.3456, -98.7654)",
      "(89.9999, 179.9999)",
      "(-45.5000, 170.7500)",
      "( -23.5505, -46.6333 )"
    ],
    "negativeContentExamples": [
      "37.7749, -122.4194",
      "(37, -122)",
      "(37.7749 -122.4194)",
      "[37.7749, -122.4194]",
      "(123.456, -45.678)",
      "(37.7749,-122.4194,10)",
      "(-37.7749; -122.4194)",
      "(51.5074, -.1278)"
    ],
    "positiveHeaderExamples": [
      "lat_lon_decimal_paren",
      "coordinate_pair_dd_parentheses",
      "latlng_decimal_parentheses",
      "coordinates_dd_parentheses",
      "decimal_coordinates_parenthesized",
      "geo_coordinate_pair_dd",
      "position_decimal_pair_paren",
      "location_coordinates_decimal"
    ],
    "negativeHeaderExamples": [
      "latitude",
      "longitude",
      "utm",
      "mgrs",
      "easting_northing",
      "geohash",
      "postal_code",
      "address"
    ],
    "explanation": "This semantic type identifies values that represent a latitude and longitude pair in decimal degrees, formatted within parentheses and separated by a comma. It requires decimals for both latitude and longitude, allows optional leading sign, and tolerates internal whitespace. Typical use cases include geospatial datasets where a single field stores decimal degree coordinate pairs for mapping, location analysis, or spatial joins.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:42.984888"
  },
  {
    "resultType": "generated",
    "semanticType": "FILENAME",
    "description": "The name of a computer file including its extension, used to identify and reference files within file systems. It typically consists of a base name and a mandatory extension, and may include multiple dot-separated segments before the final extension. Allowed characters are letters, digits, underscores, and hyphens in the base segments; spaces and path separators are excluded.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z0-9][A-Za-z0-9_-]*(\\.[A-Za-z0-9][A-Za-z0-9_-]*){0,2}\\.[A-Za-z0-9]{2,8}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4650,
    "headerPatterns": [
      {
        "regExp": "(?i).*(original|source|uploaded|upload|attachment|attached|download|export)[ _-]*file[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "original_file_name"
        ],
        "negativeExamples": [
          "original_file_size"
        ]
      },
      {
        "regExp": "(?i).*file[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "filename"
        ],
        "negativeExamples": [
          "filetype"
        ]
      },
      {
        "regExp": "(?i).*file.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "file"
        ],
        "negativeExamples": [
          "profile"
        ]
      },
      {
        "regExp": "(?i).*(fname|file[ _-]*nm|file[ _-]*nme|fn).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fname"
        ],
        "negativeExamples": [
          "fnumber"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "title"
        ]
      }
    ],
    "positiveContentExamples": [
      "report.pdf",
      "data_2024-05.csv",
      "archive.tar.gz",
      "IMG_0001.JPG",
      "financial-report_Q3_2023.xlsx",
      "backup.2024-08-18.sql",
      "my.resume.v2.docx",
      "video_1080p.h264"
    ],
    "negativeContentExamples": [
      ".env",
      "readme",
      "report.",
      "archive..zip",
      "my file.txt",
      "photo(1).jpg",
      "r\u00e9sum\u00e9.pdf",
      "report..final.pdf"
    ],
    "positiveHeaderExamples": [
      "file_name",
      "filename",
      "original_file_name",
      "attachment_filename",
      "uploaded_file_name",
      "document_name",
      "source_file_nm",
      "export_file_name"
    ],
    "negativeHeaderExamples": [
      "file_size",
      "file_path",
      "filetype",
      "image_url",
      "customer_name",
      "profile",
      "fnumber",
      "title"
    ],
    "explanation": "This semantic type identifies standalone file names that include a required extension, optionally with multiple dot-separated segments before the final extension. It is useful for classifying columns that store filenames for attachments, uploads, exports, logs, or media assets. The regex intentionally excludes spaces and path separators to reduce ambiguity with file paths and free text.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:43.813001"
  },
  {
    "resultType": "generated",
    "semanticType": "EPOCH.MILLISECONDS",
    "description": "A numeric timestamp representing milliseconds elapsed since January 1, 1970 UTC, commonly used in programming and data systems.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{13}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4630,
    "headerPatterns": [
      {
        "regExp": "(?i).*(epoch|unix).*millisecond.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "unix_epoch_milliseconds"
        ],
        "negativeExamples": [
          "epoch_seconds"
        ]
      },
      {
        "regExp": "(?i).*(timestamp|time).*millisecond.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "event_timestamp_milliseconds"
        ],
        "negativeExamples": [
          "event_timestamp_seconds"
        ]
      },
      {
        "regExp": "(?i).*(epoch|unix).*(ms|millis|msec).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "unix_time_ms"
        ],
        "negativeExamples": [
          "unix_time_ns"
        ]
      },
      {
        "regExp": "(?i).*(ts|tstamp).*(ms|millis|msec).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "log_ts_ms"
        ],
        "negativeExamples": [
          "log_ts"
        ]
      },
      {
        "regExp": "(?i).*timestamp.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "timestamp"
        ],
        "negativeExamples": [
          "date"
        ]
      }
    ],
    "positiveContentExamples": [
      "1609459200000",
      "1622505600456",
      "1654041600123",
      "1685577600789",
      "1704067200123",
      "1735689600000",
      "1577836800000",
      "1696118400456"
    ],
    "negativeContentExamples": [
      "1704067200",
      "170406720012",
      "17040672001234",
      "1704067200123456",
      "-1704067200123",
      "1704067200123.0",
      "1704 067200123",
      "1704067200ms"
    ],
    "positiveHeaderExamples": [
      "epoch_millis",
      "unix_epoch_ms",
      "event_timestamp_ms",
      "created_time_milliseconds",
      "log_ts_ms",
      "ts_millis",
      "request_time_ms",
      "ingest_epoch_msec"
    ],
    "negativeHeaderExamples": [
      "epoch_seconds",
      "timestamp",
      "time_ns",
      "unix_time",
      "event_time_sec",
      "ts",
      "ms_value",
      "duration_ms"
    ],
    "explanation": "Identifies 13-digit numeric values representing Unix time in milliseconds since 1970-01-01T00:00:00Z. This is useful for parsing logs, telemetry, and event data where timestamps are stored as integer milliseconds. The regex strictly matches exactly 13 consecutive digits to minimize confusion with seconds, microseconds, or IDs; header patterns prioritize columns explicitly indicating epoch/unix with millisecond context and fall back to generic timestamp naming.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:44.002093"
  },
  {
    "resultType": "generated",
    "semanticType": "COLOR.TEXT_NL",
    "description": "The common Dutch name for a color as used in everyday language and Dutch-speaking design contexts.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "ROOD",
      "BLAUW",
      "GROEN",
      "GEEL",
      "ORANJE",
      "PAARS",
      "ROZE",
      "ZWART",
      "WIT",
      "GRIJS",
      "BRUIN",
      "BEIGE",
      "MAGENTA",
      "CYAAN",
      "TURKOOIS",
      "IVOOR",
      "ZILVER",
      "GOUD",
      "KORAAL",
      "VIOLET",
      "BORDEAUX",
      "LILA"
    ],
    "backout": "^[A-Z]{2,12}$",
    "confidenceThreshold": 95,
    "priority": 4360,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bkleurnaam\\b.*\\bnl\\b.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "kleurnaam_nl"
        ],
        "negativeExamples": [
          "kleurcode_nl"
        ]
      },
      {
        "regExp": "(?i).*\\bkleur\\b.*\\bnaam\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "kleur_naam"
        ],
        "negativeExamples": [
          "kleurcode"
        ]
      },
      {
        "regExp": "(?i).*\\bkleur\\b.*\\bnl\\b.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "kleur_nl"
        ],
        "negativeExamples": [
          "kleur_en"
        ]
      },
      {
        "regExp": "(?i).*\\bcolor\\b.*\\bnl\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "color_name_nl"
        ],
        "negativeExamples": [
          "color_en"
        ]
      },
      {
        "regExp": "(?i).*\\bkleur\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "kleur"
        ],
        "negativeExamples": [
          "kleurcode"
        ]
      }
    ],
    "positiveContentExamples": [
      "rood",
      "blauw",
      "groen",
      "geel",
      "oranje",
      "paars",
      "zwart",
      "wit"
    ],
    "negativeContentExamples": [
      "roodd",
      "lichtblauw",
      "blauwgrijs",
      "blue",
      "Zwart ",
      "grijs-",
      "donker rood",
      "goudkleurig"
    ],
    "positiveHeaderExamples": [
      "kleurnaam_nl",
      "kleur_naam",
      "kleur_nl",
      "color_name_nl",
      "kleurnaam",
      "kleur",
      "kleur-nl-naam",
      "kleurnaam_nl_v1"
    ],
    "negativeHeaderExamples": [
      "kleurcode",
      "kleurcodes",
      "kleurwaarde",
      "colorkey",
      "color_code",
      "kleurhex",
      "kleurnummer",
      "kleurindex"
    ],
    "explanation": "This semantic type recognizes common Dutch color names typically found in consumer-facing datasets, product catalogs, and design contexts. It focuses on base color terms rather than descriptive shades or compound forms, enabling precise identification of simple color fields in Dutch.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:45.327105"
  },
  {
    "resultType": "generated",
    "semanticType": "COLOR.TEXT_ES",
    "description": "The common Spanish name for a color as used in everyday language and Spanish-speaking design contexts.",
    "pluginType": "regex",
    "regexPattern": "\\b(azul|rojo|verde|amarillo|negro|blanco|gris|marron|marr\u00f3n|morado|violeta|purpura|p\u00farpura|rosa|fucsia|magenta|cian|turquesa|naranja|dorado|plateado|beige|crema|lila|lavanda|indigo|\u00edndigo|oliva|carmesi|carmes\u00ed)\\b([ -](claro|oscuro|marino|pastel|neon|ne\u00f3n|oliva))?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4350,
    "headerPatterns": [
      {
        "regExp": "(?i).*(color).*(name|nombre|texto).*(es|espanol|espa\u00f1ol).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "color_name_es"
        ],
        "negativeExamples": [
          "color_name_fr"
        ]
      },
      {
        "regExp": "(?i).*(spanish|espanol|espa\u00f1ol|_?es\\b).*(color).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "spanish_color"
        ],
        "negativeExamples": [
          "color_span"
        ]
      },
      {
        "regExp": "(?i).*(color).*(name|nombre|texto).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "product_color_name"
        ],
        "negativeExamples": [
          "color_code"
        ]
      },
      {
        "regExp": "(?i).*(clr).*(name|nombre|texto).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "clr_name"
        ],
        "negativeExamples": [
          "clr_code"
        ]
      },
      {
        "regExp": "(?i).*(color).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "color"
        ],
        "negativeExamples": [
          "palette"
        ]
      }
    ],
    "positiveContentExamples": [
      "azul",
      "rojo",
      "verde oliva",
      "amarillo claro",
      "negro",
      "blanco",
      "gris oscuro",
      "azul-marino"
    ],
    "negativeContentExamples": [
      "azulado",
      "rojas",
      "verdoso",
      "marino",
      "ne\u00f3n",
      "cyan",
      "marrones",
      "plata"
    ],
    "positiveHeaderExamples": [
      "color_name_es",
      "spanish_color",
      "product_color_name",
      "clr_name",
      "color_text",
      "ui_color_label_es",
      "color_nombre"
    ],
    "negativeHeaderExamples": [
      "color_code",
      "favorite_color",
      "color_hex",
      "hex_color_name",
      "paint_code_es",
      "background",
      "palette"
    ],
    "explanation": "This semantic type identifies Spanish color names appearing as standalone values or with a simple qualifier (e.g., claro, oscuro, marino, pastel, ne\u00f3n, oliva). It is intended for datasets where colors are stored as human-readable Spanish text (e.g., product attributes, design metadata, labels). The header patterns prioritize fields explicitly labeled as Spanish color names while allowing common variations and abbreviations, with a final primitive pattern for generic color fields.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:45.945499"
  },
  {
    "resultType": "generated",
    "semanticType": "FREE_TEXT",
    "description": "Unstructured textual content used for descriptions, comments, notes, or other narrative information in data systems. This type captures multi-word narrative strings rather than codes, identifiers, or single-word labels.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z0-9][A-Za-z0-9'\"/\\-(),;:!?&%#@\\[\\].]*\\s+[A-Za-z0-9][A-Za-z0-9'\"/\\-(),;:!?&%#@\\[\\].]*\\s+[A-Za-z0-9][A-Za-z0-9'\"/\\-(),;:!?&%#@\\[\\].]*\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4670,
    "headerPatterns": [
      {
        "regExp": "(?i).*(free[_ ]?text|comment[_ ]?text|description[_ ]?text|notes?[_ ]?text|remark[_ ]?text|narrative[_ ]?text).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "comment_text"
        ],
        "negativeExamples": [
          "comment_count"
        ]
      },
      {
        "regExp": "(?i).*(issue|ticket|order|customer|product|case).*(description|comments?|notes?|remark|narrative).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "issue_description"
        ],
        "negativeExamples": [
          "order_id"
        ]
      },
      {
        "regExp": "(?i).*(desc|cmt|cmts|rmk|txt).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ticket_desc"
        ],
        "negativeExamples": [
          "ticket_date"
        ]
      },
      {
        "regExp": "(?i).*(description|comments?|notes?|remark|narrative).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "internal_remarks"
        ],
        "negativeExamples": [
          "internal_status"
        ]
      },
      {
        "regExp": "(?i).*text.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "text"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Please review the attached report and provide feedback.",
      "Customer reported intermittent failures after upgrading to v2.3.",
      "Left voicemail and sent follow-up email; awaiting response.",
      "This item was damaged upon arrival and needs replacement.",
      "Payment received; closing the case.",
      "Steps to reproduce: open app, tap Settings, then Sign Out.",
      "Notes: deliver to side entrance after 5 PM.",
      "The user requested a password reset and MFA enrollment."
    ],
    "negativeContentExamples": [
      "OK",
      "N/A",
      "Review",
      "Pending",
      "Main Street",
      "See note",
      "REF-2024-09",
      "1234567890"
    ],
    "positiveHeaderExamples": [
      "comment_text",
      "issue_description",
      "customer_notes",
      "product_review_text",
      "internal_remarks",
      "narrative_summary",
      "ticket_desc",
      "free_text"
    ],
    "negativeHeaderExamples": [
      "status",
      "title",
      "address_line",
      "reason_code",
      "phone_number",
      "reference_id",
      "quantity",
      "sku"
    ],
    "explanation": "FREE_TEXT identifies narrative, multi-word content typically found in comments, descriptions, notes, and similar fields. The content regex requires at least three space-separated tokens with letters and allows common punctuation, reducing false positives from short labels, codes, or identifiers. Header patterns progress from highly specific variants (e.g., comment_text) through common synonyms and abbreviations to the primitive term text. Use this type to capture unstructured narrative fields for search, summarization, or NLP.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:45.950545"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.ISO-3166-3",
    "description": "A three-letter country code assigned by the International Organization for Standardization to uniquely identify nations and territories worldwide.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4490,
    "headerPatterns": [
      {
        "regExp": "(?i).*country.*iso[-_ ]?3166[-_ ]?3.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "country_iso3166_3_code"
        ],
        "negativeExamples": [
          "country_iso3166_2_code"
        ]
      },
      {
        "regExp": "(?i).*country.*(alpha[-_ ]?3|iso[-_ ]?3166[-_ ]?3).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "country_iso3166_3"
        ],
        "negativeExamples": [
          "country_alpha2"
        ]
      },
      {
        "regExp": "(?i).*(alpha[-_ ]?3|iso[-_ ]?3166[-_ ]?3).*code.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "alpha3_code"
        ],
        "negativeExamples": [
          "alpha2_code"
        ]
      },
      {
        "regExp": "(?i).*country.*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "country_code_3"
        ],
        "negativeExamples": [
          "currency_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "USA",
      "GBR",
      "DEU",
      "FRA",
      "JPN",
      "AUS",
      "CAN",
      "BRA"
    ],
    "negativeContentExamples": [
      "us",
      "USA1",
      "EU",
      "U S A",
      "usa",
      "123",
      "GBRL",
      "U5A"
    ],
    "positiveHeaderExamples": [
      "country_iso3166_3_code",
      "iso3166_3_country_code",
      "country_alpha3",
      "alpha3_code",
      "country_alpha3_code",
      "country_iso3166_3",
      "country_code_3",
      "country_iso_alpha3"
    ],
    "negativeHeaderExamples": [
      "country_code",
      "alpha2_code",
      "currency_code",
      "country_name",
      "iso_3166_2",
      "state_alpha3",
      "airport_code",
      "country_id"
    ],
    "explanation": "This semantic type targets three-letter uppercase country codes, enabling recognition of standardized ISO-style country identifiers in datasets. It relies on strict three-letter tokens and header cues referencing alpha-3 or ISO 3166-3 to reduce ambiguity with other three-character abbreviations.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:46.373228"
  },
  {
    "resultType": "generated",
    "semanticType": "CONTINENT.TEXT_EN",
    "description": "The full English name of a recognized continent. Values include the standard continental landmasses written out in English words (e.g., North America, Europe) rather than abbreviations or codes.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AFRICA",
      "ANTARCTICA",
      "ASIA",
      "EUROPE",
      "NORTH AMERICA",
      "SOUTH AMERICA",
      "AUSTRALIA",
      "OCEANIA"
    ],
    "backout": "^[A-Z]{3,12}( [A-Z]{6,8})?$",
    "confidenceThreshold": 97,
    "priority": 4390,
    "headerPatterns": [
      {
        "regExp": "(?i).*continent.*(name|text).*en.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "continent_name_en"
        ],
        "negativeExamples": [
          "country_name_en"
        ]
      },
      {
        "regExp": "(?i).*continent.*english.*name.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "continent_english_name"
        ],
        "negativeExamples": [
          "state_english_name"
        ]
      },
      {
        "regExp": "(?i).*continent.*name.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "continent_name"
        ],
        "negativeExamples": [
          "continent_code"
        ]
      },
      {
        "regExp": "(?i).*(cont|contin).*(en|english).*(name|text).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "cont_en_name"
        ],
        "negativeExamples": [
          "continent_es_name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Africa",
      "ASIA",
      "Europe",
      "NORTH AMERICA",
      "South America",
      "Antarctica",
      "AUSTRALIA",
      "Oceania"
    ],
    "negativeContentExamples": [
      "Americas",
      "Eurasia",
      "SouthAmerica",
      "North-America",
      "European Union",
      "United States",
      "Middle East",
      "Northern America"
    ],
    "positiveHeaderExamples": [
      "continent_name_en",
      "continent_english_name",
      "continent_full_name_en",
      "continent_name_english",
      "cont_en_name",
      "continent_name",
      "continent_text_en",
      "continent_long_name_en"
    ],
    "negativeHeaderExamples": [
      "continent_code",
      "country_name_en",
      "region_name",
      "continent_abbr",
      "country_code",
      "language_name",
      "continent_id",
      "continent_iso_code"
    ],
    "explanation": "This semantic type identifies cells that contain the full English name of a continent. It is intended for datasets where continent values are expressed as human-readable names rather than abbreviations or codes. The list plugin ensures precise matching to a small, finite set of accepted English continent names, with a conservative backout pattern for fallback validation.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:46.635530"
  },
  {
    "resultType": "generated",
    "semanticType": "AIRPORT_CODE.IATA",
    "description": "A three-character airport identifier assigned by the International Air Transport Association to uniquely identify commercial airports worldwide.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4220,
    "headerPatterns": [
      {
        "regExp": "(?i).*airport.*iata.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "airport_iata_code"
        ],
        "negativeExamples": [
          "airline_iata_code"
        ]
      },
      {
        "regExp": "(?i).*iata.*airport.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iata_airport"
        ],
        "negativeExamples": [
          "icao_airport"
        ]
      },
      {
        "regExp": "(?i).*airport.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "airport_three_letter_code"
        ],
        "negativeExamples": [
          "airline_code"
        ]
      },
      {
        "regExp": "(?i).*iata.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iata_code"
        ],
        "negativeExamples": [
          "icao_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "JFK",
      "LAX",
      "ORD",
      "CDG",
      "HND",
      "DXB",
      "SYD",
      "YYZ"
    ],
    "negativeContentExamples": [
      "KJFK",
      "LAX1",
      "jfk",
      "L-AX",
      "LA",
      "SFOO",
      "12A",
      "CD G"
    ],
    "positiveHeaderExamples": [
      "airport_iata_code",
      "iata_airport_code",
      "airport_code_iata",
      "iata_code_airport",
      "iata_code",
      "airport_iata",
      "apt_iata_code",
      "airport_three_letter_code"
    ],
    "negativeHeaderExamples": [
      "airline_iata_code",
      "icao_airport_code",
      "airport_code",
      "airport_icao",
      "city_iata_code",
      "airport_name",
      "terminal_code",
      "flight_iata_code"
    ],
    "explanation": "This semantic type detects three-letter IATA airport codes. Values are constrained to exactly three uppercase letters using word boundaries to avoid overmatching. Header patterns prioritize explicit mentions of airport and IATA context to reduce collisions with airline or ICAO code fields. Use this for columns that store airport identifiers in IATA format.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:47.182135"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.LATITUDE_DECIMAL",
    "description": "A geographic coordinate that specifies the north-south position of a point on Earth's surface expressed as decimal degrees from the equator. Values range from -90 to +90 inclusive, optionally signed, and may include a fractional component.",
    "pluginType": "regex",
    "regexPattern": "\\b[+-]?([0-8]?\\d(\\.\\d+)?|90(\\.0+)?)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4410,
    "headerPatterns": [
      {
        "regExp": "(?i).*latitude.*decimal.*degrees.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gps_latitude_decimal_degrees"
        ],
        "negativeExamples": [
          "gps_latitude_dms"
        ]
      },
      {
        "regExp": "(?i).*lat.*decimal.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lat_decimal"
        ],
        "negativeExamples": [
          "lon_decimal"
        ]
      },
      {
        "regExp": "(?i).*coordinate.*latitude.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "coordinate_latitude"
        ],
        "negativeExamples": [
          "coordinate_longitude"
        ]
      },
      {
        "regExp": "(?i).*lat.*dd.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lat_dd"
        ],
        "negativeExamples": [
          "lon_dd"
        ]
      },
      {
        "regExp": "(?i).*latitude.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "latitude"
        ],
        "negativeExamples": [
          "longitude"
        ]
      }
    ],
    "positiveContentExamples": [
      "0",
      "-0.0",
      "45.123456",
      "-12.5",
      "+89.9999",
      "90",
      "-90.000000",
      "8.0"
    ],
    "negativeContentExamples": [
      "90.0001",
      "-90.0001",
      "91",
      "-100",
      "45.123N",
      "089.123456",
      "45,1234",
      "12.34.56"
    ],
    "positiveHeaderExamples": [
      "latitude_decimal_degrees",
      "lat_decimal",
      "gps_latitude_dd",
      "coordinate_latitude",
      "latitude",
      "lat_dd",
      "geo_latitude_decimal",
      "device_latitude"
    ],
    "negativeHeaderExamples": [
      "longitude_decimal_degrees",
      "lon_decimal",
      "coordinate_longitude",
      "lat_dms",
      "latlon",
      "y_coordinate",
      "latitude_direction",
      "lat_error"
    ],
    "explanation": "This semantic type identifies decimal-degree latitude values, enforcing the valid range from -90 to +90 (inclusive) and allowing optional signs and fractional parts. It excludes degrees-minutes-seconds formats, values with cardinal letters (N/S), comma decimals, and values outside the latitude range. Typical use cases include geolocation datasets, GPS telemetry, and mapping applications where latitude is stored as a standalone decimal number.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:48.061377"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.NORTHING",
    "description": "A Y-coordinate value in a projected coordinate system that measures northward distance from a defined origin point, typically expressed in meters.",
    "pluginType": "regex",
    "regexPattern": "\\b([0-9]{5,8}(\\.[0-9]{1,3})?|[0-9]{1,3}([ ,][0-9]{3}){1,2}(\\.[0-9]{1,3})?)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4450,
    "headerPatterns": [
      {
        "regExp": "(?i).*northing.*meter.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "northing_meters"
        ],
        "negativeExamples": [
          "easting_meters"
        ]
      },
      {
        "regExp": "(?i).*utm.*northing.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "utm_northing"
        ],
        "negativeExamples": [
          "utm_easting"
        ]
      },
      {
        "regExp": "(?i).*(y[ _]?northing|northing[ _]?y).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "y_northing"
        ],
        "negativeExamples": [
          "x_easting"
        ]
      },
      {
        "regExp": "(?i).*(y[ _]?(coordinate|coord)).*north.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "y_coordinate_northing"
        ],
        "negativeExamples": [
          "x_coordinate_easting"
        ]
      },
      {
        "regExp": "(?i).*northing.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "northing"
        ],
        "negativeExamples": [
          "easting"
        ]
      },
      {
        "regExp": "(?i).*coordinate.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "coordinate"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "5123456",
      "4 123 456",
      "7,654,321",
      "9876543.12",
      "10 000 000",
      "123456.7",
      "2,345,678.001",
      "1 000 000.5"
    ],
    "negativeContentExamples": [
      "-1234567",
      "1234",
      "123456789",
      "E 5123456",
      "5123 456",
      "1,2345,678",
      "123456.",
      "1 000 00"
    ],
    "positiveHeaderExamples": [
      "northing_meters",
      "utm_northing",
      "y_northing",
      "y_coordinate_northing",
      "grid_northing",
      "northing",
      "northing_m"
    ],
    "negativeHeaderExamples": [
      "easting",
      "easting_meters",
      "utm_easting",
      "longitude",
      "latitude",
      "zone",
      "identifier"
    ],
    "explanation": "This type targets numeric values representing northward distance in projected systems (e.g., UTM), typically in meters. It accepts 5\u20138 digit integers with optional thousand separators (space or comma) and an optional fractional component of 1\u20133 digits. Use this to classify the Y component in planar coordinate datasets where headers or context indicate northing.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:49.811871"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.TEXT_NL",
    "description": "De volledige Nederlandse naam van een land of natie zoals gebruikt in Nederlandstalige contexten en offici\u00eble documentatie.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "NEDERLAND",
      "BELGI\u00cb",
      "DUITSLAND",
      "FRANKRIJK",
      "VERENIGD KONINKRIJK",
      "VERENIGDE STATEN",
      "ZUID-AFRIKA",
      "SPANJE",
      "PORTUGAL",
      "ITALI\u00cb",
      "NOORWEGEN",
      "ZWEDEN",
      "FINLAND",
      "DENEMARKEN",
      "TSJECHI\u00cb",
      "POLEN",
      "OOSTENRIJK",
      "ZWITSERLAND",
      "GRIEKENLAND",
      "TURKIJE",
      "IVOORKUST",
      "MAROKKO",
      "EGYPTE",
      "JAPAN",
      "AUSTRALI\u00cb"
    ],
    "backout": "^[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff][A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff'\u2019\\- ]{1,49}$",
    "confidenceThreshold": 94,
    "priority": 4530,
    "headerPatterns": [
      {
        "regExp": "(?i).*(country|land).*(naam|name).*(nl|nederlands|dutch).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "country_name_nl"
        ],
        "negativeExamples": [
          "country_code_nl"
        ]
      },
      {
        "regExp": "(?i).*(landnaam|country name|country_name).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "landnaam"
        ],
        "negativeExamples": [
          "landcode"
        ]
      },
      {
        "regExp": "(?i).*(land|country).*(label|tekst|text|omschrijving|benaming).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "land_omschrijving"
        ],
        "negativeExamples": [
          "landnummer"
        ]
      },
      {
        "regExp": "(?i).*(ctry|cnty|lnd).*(naam|name).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "ctry_name"
        ],
        "negativeExamples": [
          "state_name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Nederland",
      "Belgi\u00eb",
      "Duitsland",
      "Verenigd Koninkrijk",
      "Verenigde Staten",
      "Zuid-Afrika",
      "Ivoorkust",
      "Tsjechi\u00eb"
    ],
    "negativeContentExamples": [
      "Amsterdam",
      "Europese Unie",
      "Noord-Amerika",
      "Nederlands",
      "Provincie Noord-Holland",
      "Verenigd Koninkrijk LLC",
      "Schengen",
      "Postcode"
    ],
    "positiveHeaderExamples": [
      "country_name_nl",
      "landnaam",
      "land_omschrijving",
      "country_text_dutch",
      "land_benaming",
      "country_name_dutch",
      "land_naam_nl",
      "ctry_name"
    ],
    "negativeHeaderExamples": [
      "country_code",
      "landcode",
      "continent_name",
      "city_name",
      "region",
      "state_code",
      "nation_id",
      "iso2"
    ],
    "explanation": "Deze semantische type definieert volledige landnamen in het Nederlands, inclusief mogelijke spaties, koppeltekens en diakritische tekens. Het gebruikt een representatieve lijst van veelvoorkomende landen in het Nederlands voor hoge precisie, met een backout-patroon dat de algemene vorm van dergelijke namen beschrijft. Het is bedoeld voor kolommen die expliciet de Nederlandstalige landsnaam bevatten en wordt ondersteund door top-down headerpatronen die naar Nederlandstalige context en naamvelden verwijzen.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:51.097879"
  },
  {
    "resultType": "generated",
    "semanticType": "FILENAME_EXT",
    "description": "The suffix portion of a filename that indicates the file type or format, typically starting with a period. Matches common single or multi-part extensions (e.g., .jpg, .tar.gz) comprised of alphanumeric segments.",
    "pluginType": "regex",
    "regexPattern": "\\.[A-Za-z0-9]{1,8}(\\.[A-Za-z0-9]{1,8}){0,2}",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4660,
    "headerPatterns": [
      {
        "regExp": "(?i).*filename.*extension.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "filename_extension"
        ],
        "negativeExamples": [
          "filename"
        ]
      },
      {
        "regExp": "(?i).*file.*extension.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "file_extension"
        ],
        "negativeExamples": [
          "file_type"
        ]
      },
      {
        "regExp": "(?i).*document.*extension.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "document_extension"
        ],
        "negativeExamples": [
          "document_format"
        ]
      },
      {
        "regExp": "(?i).*file.*ext.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "file_ext"
        ],
        "negativeExamples": [
          "ext_length"
        ]
      },
      {
        "regExp": "(?i).*extension.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "extension"
        ],
        "negativeExamples": [
          "type"
        ]
      }
    ],
    "positiveContentExamples": [
      ".jpg",
      ".PDF",
      ".tar.gz",
      ".docx",
      ".7z",
      ".md",
      ".csv",
      ".tar.bz2"
    ],
    "negativeContentExamples": [
      "jpg",
      ".",
      ".gitignore",
      ".pdf/",
      ".mp3?",
      ".tar.gz.zipx.rar",
      ".longextension",
      ".docx~"
    ],
    "positiveHeaderExamples": [
      "file_extension",
      "filename_extension",
      "document_extension",
      "attachment_extension",
      "report_file_extension",
      "source_extension",
      "file_ext",
      "extension"
    ],
    "negativeHeaderExamples": [
      "file_type",
      "filename",
      "document_format",
      "file_size",
      "attachment",
      "name",
      "type",
      "content_type"
    ],
    "explanation": "This semantic type identifies file extensions as standalone values, including single-part and common multi-part extensions comprised of 1\u20138 alphanumeric characters per segment, prefixed by a dot. It is useful for classifying columns that store just the extension rather than full filenames or MIME types.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:52.761895"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.LONGITUDE_DMS",
    "description": "A geographic coordinate that specifies east-west position using traditional degrees, minutes, and seconds notation with cardinal direction indicators.",
    "pluginType": "regex",
    "regexPattern": "\\b([EeWw])\\s*(180|1[0-7]\\d|0?\\d?\\d)\\s*\u00b0\\s*([0-5]?\\d)\\s*['\u2032]\\s*([0-5]?\\d(\\.\\d+)?)\\s*[\"\u2033]\\b|\\b(180|1[0-7]\\d|0?\\d?\\d)\\s*\u00b0\\s*([0-5]?\\d)\\s*['\u2032]\\s*([0-5]?\\d(\\.\\d+)?)\\s*[\"\u2033]\\s*([EeWw])\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4440,
    "headerPatterns": [
      {
        "regExp": "(?i).*longitude.*dms.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "longitude_dms"
        ],
        "negativeExamples": [
          "longitude_decimal"
        ]
      },
      {
        "regExp": "(?i).*(lon|long).*dms.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lon_dms"
        ],
        "negativeExamples": [
          "lat_dms"
        ]
      },
      {
        "regExp": "(?i).*(longitude|lon).*deg.*min.*sec.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "long_deg_min_sec"
        ],
        "negativeExamples": [
          "long_deg_min"
        ]
      },
      {
        "regExp": "(?i).*(e[_\\-]?w).*dms.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "e_w_dms"
        ],
        "negativeExamples": [
          "n_s_dms"
        ]
      },
      {
        "regExp": "(?i).*longitude.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "longitude"
        ],
        "negativeExamples": [
          "latitude"
        ]
      }
    ],
    "positiveContentExamples": [
      "73\u00b0 59' 08\" W",
      "E 077\u00b002'34\"",
      "122\u00b025'19\" W",
      "0\u00b000'00\" E",
      "180\u00b000'00\" W",
      "w 015\u00b030'45.5\"",
      "090\u00b000'00\"E",
      "e 000\u00b000'01\""
    ],
    "negativeContentExamples": [
      "190\u00b000'00\" E",
      "73\u00b0 60' 00\" W",
      "73\u00b0 59' 60\" W",
      "-73\u00b0 59' 08\"",
      "73\u00b0 59' 08\"",
      "73 59' 08\" W",
      "73\u00b0 59 08\" W",
      "73\u00b059'08\" N"
    ],
    "positiveHeaderExamples": [
      "longitude_dms",
      "lon_dms",
      "long_deg_min_sec",
      "longitude_deg_min_sec",
      "e_w_dms",
      "long_dms_value",
      "longitude_dms_text"
    ],
    "negativeHeaderExamples": [
      "latitude_dms",
      "longitude_decimal",
      "lon_dd",
      "long_deg_min",
      "lat_long_dms",
      "longitude",
      "coordinate_dms"
    ],
    "explanation": "This semantic type identifies longitude values expressed in degrees, minutes, and seconds with an east or west indicator (E/W), supporting both prefix and suffix direction markers and optional fractional seconds. It enforces valid structural components, including degree, minute, and second symbols, while constraining degrees to the 0\u2013180 range and minutes/seconds to 0\u201359.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:54.445965"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.TEXT_EN",
    "description": "The full English name for a country or nation as used in English-language contexts and international communication.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "UNITED STATES OF AMERICA",
      "UNITED KINGDOM",
      "CANADA",
      "AUSTRALIA",
      "NEW ZEALAND",
      "SOUTH AFRICA",
      "INDIA",
      "CHINA",
      "JAPAN",
      "GERMANY",
      "FRANCE",
      "ITALY",
      "SPAIN",
      "BRAZIL",
      "MEXICO",
      "ARGENTINA",
      "PAPUA NEW GUINEA",
      "BOSNIA AND HERZEGOVINA",
      "SAINT KITTS AND NEVIS",
      "SAO TOME AND PRINCIPE",
      "TIMOR-LESTE",
      "COTE D'IVOIRE",
      "SWITZERLAND",
      "NETHERLANDS",
      "NORWAY"
    ],
    "backout": "^[A-Za-z][A-Za-z .'\\-]{1,59}$",
    "confidenceThreshold": 95,
    "priority": 4510,
    "headerPatterns": [
      {
        "regExp": "(?i).*country.*name.*(english|en).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "country_name_en"
        ],
        "negativeExamples": [
          "country_code_en"
        ]
      },
      {
        "regExp": "(?i).*(english|en).*country.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "english_country_name"
        ],
        "negativeExamples": [
          "country_native_name"
        ]
      },
      {
        "regExp": "(?i).*country.*full.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "country_full_name_en"
        ],
        "negativeExamples": [
          "country_full_code"
        ]
      },
      {
        "regExp": "(?i).*(ctry|cntry).*name.*(en|english).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ctry_name_en"
        ],
        "negativeExamples": [
          "city_name_en"
        ]
      },
      {
        "regExp": "(?i).*country.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "country"
        ],
        "negativeExamples": [
          "region"
        ]
      }
    ],
    "positiveContentExamples": [
      "United States of America",
      "United Kingdom",
      "Canada",
      "Papua New Guinea",
      "Bosnia and Herzegovina",
      "Timor-Leste",
      "Sao Tome and Principe",
      "Cote d'Ivoire"
    ],
    "negativeContentExamples": [
      "United States",
      "England",
      "Hong Kong",
      "European Union",
      "New York",
      "California",
      "USA",
      "GBR"
    ],
    "positiveHeaderExamples": [
      "country_name_en",
      "english_country_name",
      "country_english_name",
      "country_full_name_en",
      "ctry_name_en",
      "cntry_english",
      "country_name_english"
    ],
    "negativeHeaderExamples": [
      "country_code",
      "country_iso",
      "nationality",
      "region_name",
      "city_name",
      "country_native_name",
      "state_province",
      "language"
    ],
    "explanation": "This type identifies full English country names as they commonly appear in datasets, including multi-word names, hyphenated forms, and names containing connectors like 'of' and 'and'. It is suitable for columns storing human-readable country names rather than codes, leveraging a representative list with a conservative backout shape and targeted header patterns.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:58.343369"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.EASTING",
    "description": "An X-coordinate value in a projected coordinate system that measures eastward distance from a defined origin point, typically expressed in meters.",
    "pluginType": "regex",
    "regexPattern": "\\b-?(\\d{1,3}([ ,]\\d{3})+|\\d{3,9})(\\.\\d{1,3})?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4400,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\butm[_ ]?easting\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "UTM_Easting"
        ],
        "negativeExamples": [
          "UTM_Northing"
        ]
      },
      {
        "regExp": "(?i).*\\beasting[_ ]?(m|meters)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Easting_m"
        ],
        "negativeExamples": [
          "EastingIndex"
        ]
      },
      {
        "regExp": "(?i).*\\b(x[_ ]?coordinate|xcoord)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "X_Coordinate"
        ],
        "negativeExamples": [
          "Y_Coordinate"
        ]
      },
      {
        "regExp": "(?i).*\\b(grid|proj|projected)[_ ]?x\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Projected_X"
        ],
        "negativeExamples": [
          "Projected_Y"
        ]
      },
      {
        "regExp": "(?i).*\\bcoordinate\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Coordinate"
        ],
        "negativeExamples": [
          "Location"
        ]
      }
    ],
    "positiveContentExamples": [
      "166023",
      "500000",
      "834196.12",
      "345,678",
      "3 456 789",
      "20037508.34",
      "-250000.5",
      "702312"
    ],
    "negativeContentExamples": [
      "99",
      "0.123",
      "1.234.567",
      "12 34 567",
      "20037508,34",
      "- 250000",
      "2,003,750.8.3",
      "500,00"
    ],
    "positiveHeaderExamples": [
      "UTM_Easting",
      "Easting",
      "Projected_Easting",
      "Easting_m",
      "Grid_X",
      "X_Coordinate",
      "Projected_X",
      "XCoord"
    ],
    "negativeHeaderExamples": [
      "UTM_Northing",
      "Northing",
      "East",
      "Longitude",
      "Y_Coordinate",
      "Grid_Y",
      "X_Index",
      "East_Bearing"
    ],
    "explanation": "This semantic type targets eastward (X-axis) coordinate values in projected coordinate systems, commonly represented in meters. The regex accepts signed or unsigned numeric values with optional thousand separators (space or comma) and an optional decimal fraction up to three digits, reflecting typical easting data formats while avoiding overly broad matches. Header patterns prioritize explicit 'easting' and UTM-specific variants, followed by X-coordinate representations, then general projected/grid X terms, and finally the primitive 'coordinate' concept for fallback.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:58.366159"
  },
  {
    "resultType": "generated",
    "semanticType": "CURRENCY.TEXT_EN",
    "description": "The full English name of a national or international currency used in financial transactions and monetary systems. This recognizes spelled-out currency names (e.g., \"United States Dollar\", \"Euro\") rather than codes or symbols.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(Euro|Pound Sterling|[A-Z][a-z]+(?:\\s[A-Z][a-z]+){0,3}\\s(Dollar|Yen|Yuan|Franc|Rupee|Riyal|Rial|Lira|Peso|Rand|Krona|Krone|Forint|Zloty|Dinar|Dirham|Shilling|Leu|Lei|Taka|Dong|Ruble|Rouble|Col\u00f3n|Colon|Won|Kwanza|Kyat|Ariary|Quetzal|Guarani|Balboa|Sol|Boliviano|C\u00f3rdoba|Cordoba|Gourde|Dalasi|Leone|Lilangeni|Pula|Rufiyaa|Tala|Kina|Ngultrum|Ouguiya|Birr|Manat|Somoni|Dram|Lari|Hryvnia|Ringgit|Baht|Pataca|Kip|Tenge|Som|Dobra|Rupiah|Pa\u2019anga|Paanga|Escudo|Kuna|Denar|Lek|Real|Naira|Kwacha|Metical|Afghani|Nakfa|Tugrik|Bolivar|Bol\u00edvar|Shekel|Sheqel))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 4560,
    "headerPatterns": [
      {
        "regExp": "(?i).*currency.*english.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "currency_english_name"
        ],
        "negativeExamples": [
          "currency_code"
        ]
      },
      {
        "regExp": "(?i).*currency.*full.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "currency_full_name"
        ],
        "negativeExamples": [
          "currency_symbol"
        ]
      },
      {
        "regExp": "(?i).*(iso|fx|base|reporting|transaction).*currency.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iso_currency_name"
        ],
        "negativeExamples": [
          "base_currency_code"
        ]
      },
      {
        "regExp": "(?i).*currency.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "currency_name"
        ],
        "negativeExamples": [
          "currency_type"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "United States Dollar",
      "Euro",
      "Japanese Yen",
      "Pound Sterling",
      "Swiss Franc",
      "Indian Rupee",
      "Australian Dollar",
      "Canadian Dollar"
    ],
    "negativeContentExamples": [
      "USD",
      "US Dollar",
      "Dollar",
      "Yen",
      "U.S. Dollar",
      "Hong-Kong Dollar",
      "United States $",
      "RMB"
    ],
    "positiveHeaderExamples": [
      "currency_name",
      "currency_full_name",
      "currency_english_name",
      "currency_name_en",
      "iso_currency_name",
      "base_currency_name",
      "reporting_currency_name",
      "transaction_currency_name"
    ],
    "negativeHeaderExamples": [
      "currency_code",
      "iso_currency_code",
      "currency_symbol",
      "fx_pair",
      "exchange_rate",
      "amount",
      "country",
      "payment_method"
    ],
    "explanation": "This semantic type detects full English currency names, emphasizing a spelled-out form rather than abbreviated codes or symbols. It is useful for columns storing human-readable currency names in financial datasets, enabling disambiguation from ISO codes (e.g., USD) and symbols (e.g., $).",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:59.732062"
  },
  {
    "resultType": "generated",
    "semanticType": "COMPANY_NAME",
    "description": "The official legal name of a business entity or organization as registered with government authorities and used in formal documentation. Typical values include a multi-word name with a recognized corporate designator such as Inc, LLC, Ltd, Corp, or GmbH at the end.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z0-9][A-Za-z0-9'&().,-]+(\\s+[A-Za-z0-9][A-Za-z0-9'&().,-]+){0,6}\\s*(,)?\\s+(Inc|Inc\\.|Incorporated|LLC|L\\.L\\.C\\.|Ltd|Ltd\\.|Limited|Co|Co\\.|Corp|Corp\\.|Corporation|PLC|LLP|L\\.L\\.P\\.|LP|L\\.P\\.|GmbH|AG|BV|NV|SAS|SARL|SRL|SpA|S\\.r\\.l\\.)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4370,
    "headerPatterns": [
      {
        "regExp": "(?i).*(registered.*company.*name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "registered_company_name"
        ],
        "negativeExamples": [
          "registered_company_code"
        ]
      },
      {
        "regExp": "(?i).*(legal.*(entity|business).*(name)).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "legal_entity_name"
        ],
        "negativeExamples": [
          "legal_entity_id"
        ]
      },
      {
        "regExp": "(?i).*((company|corporate|organization|organisation|business|firm).*(name)).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "corporate_name"
        ],
        "negativeExamples": [
          "corporate_id"
        ]
      },
      {
        "regExp": "(?i).*((co|corp|org|biz|entity).*(name)).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "corp_name"
        ],
        "negativeExamples": [
          "corp_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "title"
        ]
      }
    ],
    "positiveContentExamples": [
      "Acme Corporation",
      "Globex LLC",
      "Smith & Sons, Inc.",
      "Blue Ridge Holdings Ltd",
      "Northern Analytics GmbH",
      "Alpha-Beta Solutions Co.",
      "Orion Ventures L.P.",
      "Meridian Partners LLP"
    ],
    "negativeContentExamples": [
      "Acme Holdings",
      "Globex L.L.C",
      "Blue Ridge Limiteds",
      "Northern Analytics Gmb",
      "Alpha-Beta Solutions Cooperatives",
      "Orion Ventures LPX",
      "Meridian Partners L.L.P",
      "Smith and Sons Company Name"
    ],
    "positiveHeaderExamples": [
      "registered_company_name",
      "legal_entity_name",
      "business_legal_name",
      "corporate_name",
      "company_legal_name",
      "organization_legal_name",
      "official_company_name",
      "firm_registered_name"
    ],
    "negativeHeaderExamples": [
      "customer_name",
      "contact_name",
      "account_name",
      "company_code",
      "entity_id",
      "organization_type",
      "corporate_id",
      "file_name"
    ],
    "explanation": "This semantic type identifies legal company names that typically end with a recognized corporate designator (e.g., Inc, LLC, Ltd, Corp, GmbH). It is intended for fields storing official registered names used on contracts, filings, or invoices, and avoids over-broad matching by requiring a corporate suffix. Appropriate for entity resolution, compliance checks, and normalization of organization master data.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:49:59.758085"
  },
  {
    "resultType": "generated",
    "semanticType": "EPOCH.SECONDS",
    "description": "A numeric timestamp representing seconds elapsed since January 1, 1970 UTC, widely used in Unix systems and programming languages.",
    "pluginType": "regex",
    "regexPattern": "\\b[1-9]\\d{8,9}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4640,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bunix\\b.*\\bepoch\\b.*\\bseconds?\\b.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "unix_epoch_seconds"
        ],
        "negativeExamples": [
          "unix_epoch_millis"
        ]
      },
      {
        "regExp": "(?i).*\\bepoch\\b.*\\bseconds?\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "epoch_seconds"
        ],
        "negativeExamples": [
          "duration_seconds"
        ]
      },
      {
        "regExp": "(?i).*\\btimestamp\\b.*\\bseconds?\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "timestamp_seconds"
        ],
        "negativeExamples": [
          "timestamp_ms"
        ]
      },
      {
        "regExp": "(?i).*\\b(ts|tstamp)\\b.*\\bsecs?\\b.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "ts_secs"
        ],
        "negativeExamples": [
          "ts_ms"
        ]
      },
      {
        "regExp": "(?i).*\\bnumber\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "epoch number"
        ],
        "negativeExamples": [
          "account id"
        ]
      }
    ],
    "positiveContentExamples": [
      "946684800",
      "978307200",
      "1234567890",
      "1672531200",
      "1538352000",
      "2147483647",
      "315532800",
      "631152000"
    ],
    "negativeContentExamples": [
      "1697040000000",
      "1697040000.0",
      "01697040000",
      "99999999",
      "2021-01-01",
      "1,697,040,000",
      "86400",
      "+1697040000"
    ],
    "positiveHeaderExamples": [
      "unix_epoch_seconds",
      "epoch_seconds",
      "timestamp_seconds",
      "created_epoch_sec",
      "ts_secs",
      "posix_epoch_seconds",
      "event_epoch_seconds",
      "epoch_number"
    ],
    "negativeHeaderExamples": [
      "unix_epoch_millis",
      "timestamp",
      "event_time",
      "created_at",
      "duration_seconds",
      "epoch_ms",
      "timecode",
      "session_seconds"
    ],
    "explanation": "This semantic type captures Unix/Posix epoch timestamps expressed in whole seconds, typically appearing as 9\u201310 digit integers without separators or decimal points. It intentionally excludes millisecond or microsecond epochs, formatted dates, signed-plus values, and numbers with punctuation. Use it to identify numeric second-resolution timestamps during ingestion, normalization, or schema inference, especially when distinguishing from millisecond-based epochs.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:01.625530"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.ISIN",
    "description": "A twelve-character alphanumeric code that uniquely identifies securities such as stocks, bonds, and derivatives in global financial markets. Format: two letters, followed by nine alphanumeric characters, and a final numeric check digit; no spaces or separators.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2}[A-Z0-9]{9}\\d\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4280,
    "headerPatterns": [
      {
        "regExp": "(?i).*security.*isin.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "security_isin_code"
        ],
        "negativeExamples": [
          "security_sedol_code"
        ]
      },
      {
        "regExp": "(?i).*instrument.*isin.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "instrument_isin"
        ],
        "negativeExamples": [
          "instrument_sedol"
        ]
      },
      {
        "regExp": "(?i).*isin.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "isin_number"
        ],
        "negativeExamples": [
          "issue_number"
        ]
      },
      {
        "regExp": "(?i).*isin.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "isin_id"
        ],
        "negativeExamples": [
          "security_id"
        ]
      },
      {
        "regExp": "(?i).*isin.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "isin"
        ],
        "negativeExamples": [
          "sedol"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "US0378331005",
      "GB00B03MLX29",
      "DE000BAY0017",
      "FR0000131104",
      "JP3902900004",
      "AU0000XVGZA3",
      "NL0000009158",
      "CH0038863350"
    ],
    "negativeContentExamples": [
      "US037833100A",
      "DE000BAY001",
      "GB00B03MLX290",
      "1S0002634946",
      "us0378331005",
      "US 0378331005",
      "US-0378331005",
      "US0@78331005"
    ],
    "positiveHeaderExamples": [
      "isin",
      "isin_code",
      "security_isin",
      "instrument_isin",
      "isin number",
      "global_isin_code",
      "primary_isin",
      "isin_id"
    ],
    "negativeHeaderExamples": [
      "cusip",
      "sedol",
      "ticker",
      "security_id",
      "issue_number",
      "bond_symbol",
      "listing",
      "figi"
    ],
    "explanation": "This type identifies International Securities Identification Numbers (ISINs) in datasets. It matches 12-character strings with two leading letters, nine alphanumeric characters, and a final numeric check digit, without separators. Use it to classify security identifiers and to flag columns where ISINs are expected based on header context. Note: this pattern enforces format only; check-digit validation should be handled by downstream logic if required.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:02.838179"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.IBAN",
    "description": "An internationally standardized bank account number used for cross-border payments and account identification within European and other participating countries.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2}[0-9]{2}[A-Z0-9]{11,30}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4260,
    "headerPatterns": [
      {
        "regExp": "(?i).*international.*bank.*account.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "international bank account number"
        ],
        "negativeExamples": [
          "bank account id"
        ]
      },
      {
        "regExp": "(?i).*iban.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iban number"
        ],
        "negativeExamples": [
          "account number"
        ]
      },
      {
        "regExp": "(?i).*account.*iban.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "account iban"
        ],
        "negativeExamples": [
          "account swift"
        ]
      },
      {
        "regExp": "(?i).*bank.*account.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "bank account"
        ],
        "negativeExamples": [
          "email account"
        ]
      },
      {
        "regExp": "(?i).*iban.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iban"
        ],
        "negativeExamples": [
          "swift"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "number"
        ]
      }
    ],
    "positiveContentExamples": [
      "GB82WEST12345698765432",
      "DE89370400440532013000",
      "FR1420041010050500013M02606",
      "NL91ABNA0417164300",
      "ES9121000418450200051332",
      "IT60X0542811101000000123456",
      "BE68539007547034",
      "PL61109010140000071219812874"
    ],
    "negativeContentExamples": [
      "gb82west12345698765432",
      "GB82 WEST 1234 5698 7654 32",
      "GB82-WEST-12345698765432",
      "G182WEST12345698765432",
      "GB8WEST12345698765432",
      "NL91_ABNA0417164300",
      "IT60X05428/11101000000123456",
      "DE89370400440532013000000000000000000"
    ],
    "positiveHeaderExamples": [
      "iban",
      "iban_number",
      "international bank account number",
      "account_iban",
      "iban code",
      "bank_account_iban",
      "iban no",
      "iban_num"
    ],
    "negativeHeaderExamples": [
      "account number",
      "swift code",
      "bic",
      "routing number",
      "bank account",
      "bank name",
      "account holder",
      "payment reference"
    ],
    "explanation": "Identifies strings that conform to the generic structure of an IBAN: two uppercase letters for the country code, two digits for check digits, followed by an uppercase alphanumeric BBAN segment with overall length between 15 and 34 characters. Intended for detecting IBAN values in datasets for validation, parsing, and cross-border payment processing workflows.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:04.916194"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.AADHAAR_IN",
    "description": "A 12-digit unique identity number issued by the Unique Identification Authority of India (UIDAI) to residents of India. Values are exactly twelve numeric digits with no separators or formatting characters.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{12}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4770,
    "headerPatterns": [
      {
        "regExp": "(?i).*(aadhaar|aadhar).*(number|no|num|id).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "aadhaar_number"
        ],
        "negativeExamples": [
          "pan_number"
        ]
      },
      {
        "regExp": "(?i).*(uidai).*(number|id).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "uidai number"
        ],
        "negativeExamples": [
          "uid number"
        ]
      },
      {
        "regExp": "(?i).*(indian|india|resident).*(aadhaar|aadhar).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "indian aadhaar id"
        ],
        "negativeExamples": [
          "indian pan"
        ]
      },
      {
        "regExp": "(?i).*(aadhaar|aadhar).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "beneficiary_aadhaar"
        ],
        "negativeExamples": [
          "national_id"
        ]
      },
      {
        "regExp": "(?i).*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "id"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "234567890123",
      "102938475610",
      "567890123456",
      "000123456789",
      "849302167584",
      "709384756102",
      "415263789041",
      "981234567890"
    ],
    "negativeContentExamples": [
      "12345678901",
      "1234567890123",
      "1234 5678 9012",
      "1234-5678-9012",
      "1234567890AB",
      "O23456789012",
      "12345678901.2",
      "123456789_012"
    ],
    "positiveHeaderExamples": [
      "aadhaar_number",
      "aadhar no",
      "aadhaar id",
      "uidai number",
      "resident aadhaar",
      "indian aadhaar id",
      "beneficiary_aadhaar",
      "aadhaar_num"
    ],
    "negativeHeaderExamples": [
      "pan_number",
      "voter_id",
      "national_id",
      "uid",
      "employee_id",
      "passport_number",
      "taxpayer_id",
      "ssn"
    ],
    "explanation": "This semantic type targets Indian Aadhaar numbers represented as exactly 12 consecutive digits without spaces, hyphens, or other separators. It is intended for datasets storing resident identity fields tied to UIDAI-issued identifiers. The pattern focuses on strict digit length to minimize false positives while header patterns capture common Aadhaar-related column names and abbreviations.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:06.038322"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.ABA",
    "description": "A nine-digit bank routing number used in the United States to identify financial institutions for electronic transactions and check processing.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{9}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4230,
    "headerPatterns": [
      {
        "regExp": "(?i).*aba.*routing.*number.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "ABA Routing Number"
        ],
        "negativeExamples": [
          "Routing Transit Code"
        ]
      },
      {
        "regExp": "(?i).*routing.*transit.*number.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Routing Transit Number"
        ],
        "negativeExamples": [
          "Transit Routing Code"
        ]
      },
      {
        "regExp": "(?i).*(rtn|routing).*num.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "rtn_num"
        ],
        "negativeExamples": [
          "rtn_code"
        ]
      },
      {
        "regExp": "(?i).*(ach|bank).*routing.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Bank Routing"
        ],
        "negativeExamples": [
          "Routing Key"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "021202759",
      "031101142",
      "044000839",
      "053207361",
      "064102945",
      "075309118",
      "086000442",
      "097451203"
    ],
    "negativeContentExamples": [
      "02120275",
      "0311011427",
      "044-000-839",
      "053 207 361",
      "06410294A",
      "A75309118",
      "O86000442",
      "0974_51203"
    ],
    "positiveHeaderExamples": [
      "aba_routing_number",
      "routing_transit_number",
      "rtn_num",
      "bank_routing_number",
      "ach_routing_number",
      "aba_number",
      "routing_num",
      "financial_institution_routing_number"
    ],
    "negativeHeaderExamples": [
      "routing_transit_code",
      "routing_code",
      "aba_code",
      "rtn_id",
      "bank_route",
      "ach_code",
      "sort_code",
      "swift_code"
    ],
    "explanation": "This semantic type identifies U.S. ABA routing numbers as exactly nine consecutive digits, commonly used for ACH and check processing. The regex enforces digit count and token boundaries, while header patterns target common naming conventions from explicit ABA mentions to generic number fields.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:06.718496"
  },
  {
    "resultType": "generated",
    "semanticType": "COLOR.HEX",
    "description": "A hexadecimal color code used in web design and digital graphics to represent precise color values in RGB format.",
    "pluginType": "regex",
    "regexPattern": "\\b#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4330,
    "headerPatterns": [
      {
        "regExp": "(?i).*hex.*color.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "hex_color_code"
        ],
        "negativeExamples": [
          "hex_value"
        ]
      },
      {
        "regExp": "(?i).*(css|html|web).*hex.*color.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "css_hex_color"
        ],
        "negativeExamples": [
          "web_color_code"
        ]
      },
      {
        "regExp": "(?i).*rgb.*hex.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "rgb_hex"
        ],
        "negativeExamples": [
          "rgb_value"
        ]
      },
      {
        "regExp": "(?i).*hex.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "hex_value"
        ],
        "negativeExamples": [
          "binary_code"
        ]
      },
      {
        "regExp": "(?i).*color.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "color"
        ],
        "negativeExamples": [
          "hue"
        ]
      }
    ],
    "positiveContentExamples": [
      "#1A2B3C",
      "#fff",
      "#ABCDEF",
      "#123",
      "#09aFbc",
      "#0F0",
      "#000000",
      "#FfF"
    ],
    "negativeContentExamples": [
      "#1234",
      "#ABCDE",
      "123456",
      "#GGGGGG",
      "#12 34 56",
      "#ABCDEF00",
      "#abcg",
      "#-12345"
    ],
    "positiveHeaderExamples": [
      "hex_color_code",
      "css_hex_color",
      "html_color_hex",
      "web_hex_color",
      "rgb_hex",
      "color_hex",
      "hexcode_color",
      "hex_value_color"
    ],
    "negativeHeaderExamples": [
      "rgb_value",
      "color_name",
      "hsl_code",
      "paint_code",
      "status_code",
      "shade",
      "tint_level",
      "palette_name"
    ],
    "explanation": "This semantic type identifies hexadecimal color codes commonly used in CSS and design data, supporting both 3- and 6-digit forms with a leading '#'. It is useful for validating and classifying color fields where colors are encoded as hex strings.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:09.663788"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.EIN_US",
    "description": "A federal tax identification number assigned by the IRS to identify business entities operating in the United States. Typically a 9-digit numeric identifier formatted as XX-XXXXXXX, though sometimes stored without the hyphen.",
    "pluginType": "regex",
    "regexPattern": "(\\b\\d{2}-\\d{7}\\b|\\b\\d{9}\\b)",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4800,
    "headerPatterns": [
      {
        "regExp": "(?i).*employer.*identification.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "employer_identification_number"
        ],
        "negativeExamples": [
          "employee_identification_number"
        ]
      },
      {
        "regExp": "(?i).*(irs|federal).*ein.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "irs_ein"
        ],
        "negativeExamples": [
          "federal_id"
        ]
      },
      {
        "regExp": "(?i).*federal.*tax.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "federal_tax_id"
        ],
        "negativeExamples": [
          "state_tax_id"
        ]
      },
      {
        "regExp": "(?i).*(fein|ein).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fein"
        ],
        "negativeExamples": [
          "tin"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "12-3456789",
      "98-7654321",
      "01-2345678",
      "23-0000000",
      "10-9999999",
      "457890123",
      "009876543",
      "72-1357924"
    ],
    "negativeContentExamples": [
      "123-45-6789",
      "12-345678",
      "12-34567890",
      "12345678",
      "1234567890",
      "1-23456789",
      "12 3456789",
      "12.3456789"
    ],
    "positiveHeaderExamples": [
      "employer_identification_number",
      "irs_ein",
      "federal_ein",
      "fein",
      "business_tax_id",
      "federal_tax_id",
      "ein_us",
      "company_ein"
    ],
    "negativeHeaderExamples": [
      "employee_identification_number",
      "social_security_number",
      "state_tax_id",
      "taxpayer_id",
      "itin",
      "vat_number",
      "federal_id",
      "account_number"
    ],
    "explanation": "This semantic type detects U.S. Employer Identification Numbers (EIN), a 9-digit IRS business identifier, commonly written as two digits, a hyphen, and seven digits (XX-XXXXXXX) or stored as nine contiguous digits. The regex applies strict digit counts with word boundaries to avoid matching similarly shaped identifiers such as SSNs, while allowing both hyphenated and non-hyphenated storage formats. Header patterns prioritize specific EIN-related terms (EIN, FEIN, IRS EIN, employer identification number) and broader tax-ID wording, concluding with a primitive 'number' fallback.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:11.103791"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.EAN13",
    "description": "A thirteen-digit barcode identifier used globally for product identification and retail inventory management systems. Matches standalone 13-digit numeric tokens representing EAN-13 values, including the check digit.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{13}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4250,
    "headerPatterns": [
      {
        "regExp": "(?i).*ean[_\\s-]*13.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ean_13_code"
        ],
        "negativeExamples": [
          "ean_code"
        ]
      },
      {
        "regExp": "(?i).*barcode.*ean[_\\s-]*13.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "barcode_ean13"
        ],
        "negativeExamples": [
          "barcode_ean8"
        ]
      },
      {
        "regExp": "(?i).*(gtin[_\\s-]*13|ean[_\\s-]*13).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gtin13"
        ],
        "negativeExamples": [
          "gtin14"
        ]
      },
      {
        "regExp": "(?i).*(ean|gtin).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "product_ean"
        ],
        "negativeExamples": [
          "product_upc"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ean_code"
        ],
        "negativeExamples": [
          "sku_number"
        ]
      }
    ],
    "positiveContentExamples": [
      "5901234123457",
      "9780306406157",
      "4006381333931",
      "0885909950805",
      "6901234567892",
      "5012345678900",
      "8901234567894",
      "7612345678903"
    ],
    "negativeContentExamples": [
      "590123412345",
      "59012341234578",
      "59012341234A7",
      "5901 234123457",
      "590-1234123457",
      "978030640615",
      "97803064061570",
      "978030640615."
    ],
    "positiveHeaderExamples": [
      "ean_13_code",
      "barcode_ean13",
      "gtin13",
      "product_ean",
      "ean_code",
      "ean13",
      "product_barcode_ean13",
      "item_ean13"
    ],
    "negativeHeaderExamples": [
      "ean8",
      "gtin14",
      "upc_code",
      "isbn13",
      "barcode_text",
      "sku_code",
      "barcode_data",
      "serial_number"
    ],
    "explanation": "This semantic type identifies EAN-13 values as a single, contiguous 13-digit token, which includes a final check digit. It is suitable for classifying product barcodes and GTIN-13 identifiers represented as plain digits. It intentionally excludes similar identifiers that differ by length or format (e.g., EAN-8, UPC-A with 12 digits, or GTIN-14) and any strings containing separators such as spaces or hyphens.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:12.605685"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.TEXT_DE",
    "description": "The full German name for a country or nation as used in German-language contexts and official documentation.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z\u00c4\u00d6\u00dc\u00c0-\u00d6\u00d8-\u00de][A-Za-z\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]{1,})([ '\\-\u2019]((und|von|der|dem|des|d|de|la|le|l)|[A-Z\u00c4\u00d6\u00dc\u00c0-\u00d6\u00d8-\u00de][A-Za-z\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]{1,})){0,5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 4500,
    "headerPatterns": [
      {
        "regExp": "(?i).*(country|land|staat).*(name).*(de|ger|german|deutsch).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "country_name_de"
        ],
        "negativeExamples": [
          "country_code_de"
        ]
      },
      {
        "regExp": "(?i).*(german|deutsch|de|ger).*(country|land|staat).*(name).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "german_country_name"
        ],
        "negativeExamples": [
          "german_language"
        ]
      },
      {
        "regExp": "(?i).*(country|land|staat).*(de|ger|german|deutsch).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "land_de"
        ],
        "negativeExamples": [
          "country_code"
        ]
      },
      {
        "regExp": "(?i).*(ctry|nation).*(name).*(de|ger).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "ctry_name_ger"
        ],
        "negativeExamples": [
          "ctry_code"
        ]
      },
      {
        "regExp": "(?i).*country.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "country"
        ],
        "negativeExamples": [
          "city"
        ]
      }
    ],
    "positiveContentExamples": [
      "Deutschland",
      "\u00d6sterreich",
      "Schweiz",
      "Vereinigte Staaten von Amerika",
      "Vereinigtes K\u00f6nigreich",
      "Bosnien und Herzegowina",
      "C\u00f4te d\u2019Ivoire",
      "S\u00e3o Tom\u00e9 und Pr\u00edncipe"
    ],
    "negativeContentExamples": [
      "Deutschland, Berlin",
      "Deutschland 2021",
      "Vereinigtes K\u00f6nigreich.",
      "Schweiz AG",
      "\u00d6sterreich & Schweiz",
      "Timor - Leste",
      "C\u00f4te d\u2019Ivoire/Elfenbeink\u00fcste",
      "Papua\u2013Neuguinea"
    ],
    "positiveHeaderExamples": [
      "country_name_de",
      "land_name_de",
      "staat_name_de",
      "german_country_name",
      "ctry_name_ger",
      "de_country",
      "landname_de",
      "de_staat_name"
    ],
    "negativeHeaderExamples": [
      "country_code",
      "iso_country",
      "nationality_de",
      "state_name",
      "city",
      "language_de",
      "county",
      "billing_country_code"
    ],
    "explanation": "Identifies strings that represent the full German-language names of countries, accommodating common connectors (und, von, der, dem, des) and separators (space, hyphen, apostrophe) as found in official and general usage. Useful for datasets where country names are expected in German text fields and for harmonizing multilingual geographical data.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:15.482146"
  },
  {
    "resultType": "generated",
    "semanticType": "GENDER.TEXT_<LANGUAGE>",
    "description": "Textual gender values expressed in a specific language, representing categories such as male, female, and inclusive identities (e.g., non-binary). Intended for columns where the cell values are short text labels of gender rather than coded values.\nThis configuration expects language-specific terms; adapt the list to the target language indicated by <LANGUAGE>.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "MALE",
      "FEMALE",
      "MAN",
      "WOMAN",
      "M",
      "F",
      "NON-BINARY",
      "NONBINARY",
      "PREFER NOT TO SAY",
      "OTHER",
      "UNKNOWN",
      "UNSPECIFIED",
      "TRANSGENDER",
      "CISGENDER",
      "INTERSEX",
      "AGENDER"
    ],
    "backout": "^[A-Z][A-Z -]{0,24}$",
    "confidenceThreshold": 95,
    "priority": 4690,
    "headerPatterns": [
      {
        "regExp": "(?i).*customer.*gender.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_gender"
        ],
        "negativeExamples": [
          "customer_age"
        ]
      },
      {
        "regExp": "(?i).*user.*gender.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "userGender"
        ],
        "negativeExamples": [
          "user_group"
        ]
      },
      {
        "regExp": "(?i).*patient.*sex.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "patient_sex"
        ],
        "negativeExamples": [
          "patient_height"
        ]
      },
      {
        "regExp": "(?i).*gndr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gndr"
        ],
        "negativeExamples": [
          "gander_count"
        ]
      },
      {
        "regExp": "(?i).*gender.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gender"
        ],
        "negativeExamples": [
          "age"
        ]
      }
    ],
    "positiveContentExamples": [
      "MALE",
      "FEMALE",
      "M",
      "F",
      "MAN",
      "WOMAN",
      "NON-BINARY",
      "NONBINARY"
    ],
    "negativeContentExamples": [
      "MALEE",
      "FEM",
      "FM",
      "NON BINARY",
      "PREFER NOT TO DISCLOSE",
      "GENDERQUEER",
      "X",
      "NB"
    ],
    "positiveHeaderExamples": [
      "customer_gender",
      "userGender",
      "patient_sex",
      "employee_gender",
      "gndr",
      "gender"
    ],
    "negativeHeaderExamples": [
      "customer_age",
      "user_group",
      "birth_date",
      "gander_count",
      "gender_ratio",
      "code_gender"
    ],
    "explanation": "This semantic type classifies short textual gender labels for a specific language, including common binary and inclusive identities. Use it for columns where cells contain direct gender labels (e.g., MALE, FEMALE, NON-BINARY) rather than numerical or coded representations. The provided value list is representative and should be localized to the language designated by <LANGUAGE>.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:21.748918"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.BSN_NL",
    "description": "The Dutch Burgerservicenummer (BSN) is a unique 9-digit personal identification number assigned to all Dutch residents.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{9}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4780,
    "headerPatterns": [
      {
        "regExp": "(?i).*burgerservice.*nummer.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "burgerservicenummer"
        ],
        "negativeExamples": [
          "servicenummer"
        ]
      },
      {
        "regExp": "(?i).*(nl|dutch).*citizen.*service.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nl_citizen_service_number"
        ],
        "negativeExamples": [
          "citizen_service_number"
        ]
      },
      {
        "regExp": "(?i).*\\bbsn\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "bsn"
        ],
        "negativeExamples": [
          "ssn"
        ]
      },
      {
        "regExp": "(?i).*citizen.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "citizen_number_nl"
        ],
        "negativeExamples": [
          "citizenship_id"
        ]
      },
      {
        "regExp": "(?i).*(identity|id).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "id_number_nl"
        ],
        "negativeExamples": [
          "identity_code"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "123456789",
      "045678912",
      "801234567",
      "556782341",
      "270915384",
      "908172635",
      "362514789",
      "730029184"
    ],
    "negativeContentExamples": [
      "12345678",
      "1234567890",
      "123 456789",
      "123-456789",
      "A23456789",
      "12345678A",
      "00123456",
      "12 3456789"
    ],
    "positiveHeaderExamples": [
      "burgerservicenummer",
      "bsn",
      "dutch_bsn",
      "nl_citizen_service_number",
      "bsn_number",
      "citizen_number_nl",
      "identity_number_nl",
      "id_number_nl"
    ],
    "negativeHeaderExamples": [
      "servicenummer",
      "bsn_code",
      "citizenship_number",
      "ssn",
      "customer_number",
      "burgerservice_id",
      "identity_code",
      "national_id_nl"
    ],
    "explanation": "This semantic type targets Dutch BSN values that are exactly nine consecutive digits, bounded by word boundaries to avoid matching larger digit runs or values with separators. It is intended for identifying and validating Dutch personal identifiers in datasets where column names also suggest BSN/identity semantics. Checksum or country-specific validations are not enforced by the regex and should be applied separately if needed.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:21.877138"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.NI_UK",
    "description": "A unique identifier used in the UK for social security administration and employment record tracking. The format consists of two letters, six digits, and a suffix letter A\u2013D, with optional spaces between digit pairs.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-CEGHJ-PR-TW-Z]{2}\\s?\\d{2}\\s?\\d{2}\\s?\\d{2}\\s?[A-D]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4830,
    "headerPatterns": [
      {
        "regExp": "(?i).*national.*insurance.*number.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "National Insurance Number"
        ],
        "negativeExamples": [
          "Insurance Number"
        ]
      },
      {
        "regExp": "(?i).*(uk|gb).*national.*insurance.*number.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "UK National Insurance Number"
        ],
        "negativeExamples": [
          "EU National Insurance Number"
        ]
      },
      {
        "regExp": "(?i).*nino.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "NINO"
        ],
        "negativeExamples": [
          "NIN"
        ]
      },
      {
        "regExp": "(?i).*ni.*number.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "NI Number"
        ],
        "negativeExamples": [
          "NHS Number"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Number"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "AB123456C",
      "AC 12 34 56 A",
      "HJ123456D",
      "PR 12 34 56 B",
      "TW123456A",
      "ZX 12 34 56 C",
      "CE123456B",
      "GH 56 78 90 D"
    ],
    "negativeContentExamples": [
      "AB123456",
      "AB 12 34 56 E",
      "A123456C",
      "AB12345C",
      "AB 12 34 56 7 C",
      "AB-12-34-56-C",
      "AO123456B",
      "VI123456A"
    ],
    "positiveHeaderExamples": [
      "National Insurance Number",
      "UK NI Number",
      "NINO",
      "NI Number",
      "GB National Insurance No",
      "Employee National Insurance Number",
      "National Insurance No",
      "UK National Insurance ID"
    ],
    "negativeHeaderExamples": [
      "Insurance Code",
      "National Identity Card No",
      "NHS Identifier",
      "NI Category",
      "Insurance Policy Code",
      "National Insurance Rate",
      "Employee Identifier",
      "Benefit Reference"
    ],
    "explanation": "IDENTITY.NI_UK captures UK National Insurance numbers, recognizing the canonical structure of two initial letters, six digits, and a final suffix letter A\u2013D, with optional spaces between pairs of digits. It is useful for validating and classifying UK employment and social security identifiers while avoiding overly broad matches by enforcing letter and digit positions. The header patterns prioritize explicit terms like 'National Insurance Number' and 'NINO' before falling back to more generic 'number' terminology.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:25.370720"
  },
  {
    "resultType": "generated",
    "semanticType": "HASH.SHA256_HEX",
    "description": "A cryptographic hash value produced by the SHA-256 algorithm, represented as a 64-character hexadecimal string for enhanced data security verification.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9A-Fa-f]{64}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4740,
    "headerPatterns": [
      {
        "regExp": "(?i).*sha[-_ ]?256.*hash.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "sha256_hash"
        ],
        "negativeExamples": [
          "md5_hash"
        ]
      },
      {
        "regExp": "(?i).*sha[-_ ]?256.*hex.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "sha256_hex"
        ],
        "negativeExamples": [
          "sha256_base64"
        ]
      },
      {
        "regExp": "(?i).*sha[-_ ]?256.*sum.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "sha256sum"
        ],
        "negativeExamples": [
          "checksum"
        ]
      },
      {
        "regExp": "(?i).*sha[-_ ]?256.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "sha256"
        ],
        "negativeExamples": [
          "sha1"
        ]
      },
      {
        "regExp": "(?i).*hash.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "hash"
        ],
        "negativeExamples": [
          "checksum"
        ]
      }
    ],
    "positiveContentExamples": [
      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "9F86D081884C7D659A2FEAA0C55AD015A3BF4F1B2B0B822CD15D6C15B0F00A08",
      "1a2b3c4d5e6f708192a3b4c5d6e7f8090a1b2c3d4e5f607182a3b4c5d6e7f890",
      "AABBCCDDEEFF00112233445566778899A1B2C3D4E5F60718293A4B5C6D7E8F90",
      "0123456789abcdeffedcba98765432100a1b2c3d4e5f6a7b8c9d0e1f11223344",
      "deadbeefcafebabe00112233445566778899aabbccddeeff13579bdf02468ace",
      "AB12CD34EF56AB7890CD12EF3456AB90CDEF12345678ABCD90EF123456AB78CD",
      "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
    ],
    "negativeContentExamples": [
      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b85",
      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b8550",
      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b85g",
      "9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822c-d15d6c15b0f00a08",
      "0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08",
      "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
      "e3b0c44298fc1c149a fbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "sha256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
    ],
    "positiveHeaderExamples": [
      "sha256_hash",
      "sha256_hex",
      "sha256sum",
      "file_sha256",
      "content_sha256",
      "message_sha256_hex",
      "object_hash_sha256",
      "payload_sha256"
    ],
    "negativeHeaderExamples": [
      "md5_hash",
      "sha1",
      "checksum",
      "token_hash",
      "signature",
      "uuid",
      "file_hash",
      "content_checksum"
    ],
    "explanation": "Detects 64-character hexadecimal SHA-256 digests commonly used for file integrity, content addressing, and cryptographic verification. The regex enforces exactly 64 hex characters with word boundaries to avoid matching embedded or prefixed values, reducing false positives while accommodating uppercase and lowercase representations.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:26.539747"
  },
  {
    "resultType": "generated",
    "semanticType": "HONORIFIC_EN",
    "description": "A title or form of address that precedes a person's name to convey respect, courtesy, or professional status in English-speaking contexts (e.g., Mr, Ms, Dr, Prof). This type focuses on common English honorifics that typically appear before the given or family name.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(mr|mrs|ms|miss|mx|dr|doctor|prof|professor|sir|dame|rev|reverend|hon|honorable|honourable|lord|lady|capt|captain|col|colonel|gen|general|lt|lieutenant|sgt|sergeant|cpl|corporal|maj|major|cmdr|commander|fr|father|brother|sister|rabbi|imam|judge|justice|pres|president|gov|governor|amb|ambassador)\\.?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4750,
    "headerPatterns": [
      {
        "regExp": "(?i).*honorific.*(title|prefix|name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "honorific_title"
        ],
        "negativeExamples": [
          "job_title"
        ]
      },
      {
        "regExp": "(?i).*(name|person).*prefix.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name_prefix"
        ],
        "negativeExamples": [
          "address_prefix"
        ]
      },
      {
        "regExp": "(?i).*salutation.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "salutation"
        ],
        "negativeExamples": [
          "farewell"
        ]
      },
      {
        "regExp": "(?i).*(person|name).*title.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "person_title"
        ],
        "negativeExamples": [
          "document_title"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "title"
        ]
      }
    ],
    "positiveContentExamples": [
      "Mr",
      "Mr.",
      "Mrs",
      "Ms.",
      "Miss",
      "Dr.",
      "Prof.",
      "Sir"
    ],
    "negativeContentExamples": [
      "Jr.",
      "Sr.",
      "Esq.",
      "PhD",
      "Drs.",
      "Mrr",
      "Msr.",
      "Sir-"
    ],
    "positiveHeaderExamples": [
      "honorific_title",
      "person_honorific",
      "name_prefix",
      "salutation",
      "name_title",
      "person_title",
      "honorific",
      "customer_name_prefix"
    ],
    "negativeHeaderExamples": [
      "name_suffix",
      "suffix",
      "academic_degree",
      "credentials",
      "nickname",
      "file_name",
      "project_name",
      "honorarium"
    ],
    "explanation": "This semantic type identifies English honorifics and forms of address that appear before personal names, enabling extraction, validation, and normalization of name prefixes in contact and identity datasets. It is useful for parsing person records, standardizing salutations, and improving name formatting in customer, patient, or member directories.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:27.213772"
  },
  {
    "resultType": "generated",
    "semanticType": "GENDER.TEXT_ZH",
    "description": "A person's gender identity as expressed in Chinese language terms, indicating biological sex or gender classification.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "\u7537",
      "\u5973",
      "\u7537\u6027",
      "\u5973\u6027",
      "\u7537\u751f",
      "\u5973\u751f",
      "\u7537\u5b69",
      "\u5973\u5b69",
      "\u7537\u5b50",
      "\u5973\u5b50",
      "\u4e2d\u6027",
      "\u5176\u4ed6",
      "\u5176\u5b83",
      "\u672a\u77e5",
      "\u4fdd\u5bc6",
      "\u672a\u8bf4\u660e",
      "\u672a\u6307\u5b9a",
      "\u8de8\u6027\u522b",
      "\u8de8\u6027\u5225",
      "\u975e\u4e8c\u5143",
      "\u975e\u4e8c\u5143\u6027\u522b",
      "\u975e\u4e8c\u5143\u6027\u5225",
      "\u751f\u7406\u7537",
      "\u751f\u7406\u5973"
    ],
    "backout": "^[\\p{IsHan}]{1,6}$",
    "confidenceThreshold": 93,
    "priority": 4710,
    "headerPatterns": [
      {
        "regExp": "(?i).*(customer|user|patient|employee).*(gender_text|sex_text|\u6027\u522b\u6587\u672c|\u6027\u5225\u6587\u672c|\u6027\u522b\u8bf4\u660e|\u6027\u5225\u8aaa\u660e).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_gender_text"
        ],
        "negativeExamples": [
          "customer_gender_code"
        ]
      },
      {
        "regExp": "(?i).*(account|member|profile).*(gender|sex|\u6027\u522b|\u6027\u5225).*(text|desc|\u8bf4\u660e|\u8aaa\u660e).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "profile_sex_desc"
        ],
        "negativeExamples": [
          "profile_sex_cd"
        ]
      },
      {
        "regExp": "(?i).*(\u6027\u522b|\u6027\u5225).*(\u6587\u672c|\u8bf4\u660e|\u8aaa\u660e|\u63cf\u8ff0).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "\u6027\u522b\u8bf4\u660e"
        ],
        "negativeExamples": [
          "\u6027\u522b\u4ee3\u7801"
        ]
      },
      {
        "regExp": "(?i).*(sex).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "patient_sex"
        ],
        "negativeExamples": [
          "sex_code"
        ]
      },
      {
        "regExp": "(?i).*(gender).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "gender"
        ],
        "negativeExamples": [
          "age"
        ]
      }
    ],
    "positiveContentExamples": [
      "\u7537",
      "\u5973",
      "\u7537\u6027",
      "\u5973\u6027",
      "\u7537\u751f",
      "\u5973\u751f",
      "\u4e2d\u6027",
      "\u5176\u4ed6"
    ],
    "negativeContentExamples": [
      "\u7537/\u5973",
      "\u7537\u4eba",
      "\u5973\u4eba",
      "\u5973-\u751f",
      "\u6027\u522b: \u7537",
      "\u672a \u77e5",
      "\u8de8 \u6027 \u522b",
      "\u5973\u5b50\u7ec4"
    ],
    "positiveHeaderExamples": [
      "customer_gender_text",
      "\u7528\u6237\u6027\u522b",
      "\u6027\u5225",
      "patient_sex",
      "account_gender_text",
      "\u6027\u522b\u8bf4\u660e",
      "profile_sex_desc",
      "gender"
    ],
    "negativeHeaderExamples": [
      "user_age",
      "marital_status",
      "title",
      "salutation",
      "honorific",
      "pronouns",
      "demographics",
      "relationship"
    ],
    "explanation": "This semantic type identifies Chinese-language values representing gender or sex classifications. It is intended for columns storing text descriptors of gender (e.g., \u7537, \u5973, \u5176\u4ed6) rather than codes, abbreviations, or numeric identifiers. The header patterns prioritize fields explicitly labeled as gender text or descriptions, supporting both Chinese and English headers commonly found in multilingual datasets.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:27.654065"
  },
  {
    "resultType": "generated",
    "semanticType": "GUID",
    "description": "A 128-bit identifier designed to be globally unique across systems and time, typically represented as 32 hexadecimal digits in either a canonical 8-4-4-4-12 hyphenated form or as a continuous 32-character hex string. Commonly used in software and databases to uniquely identify records and resources.",
    "pluginType": "regex",
    "regexPattern": "\\b([0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}|[0-9A-Fa-f]{32})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4720,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\b(transaction|order|user|customer|session)\\b.*\\bguid\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "transaction_guid"
        ],
        "negativeExamples": [
          "transaction_id"
        ]
      },
      {
        "regExp": "(?i).*\\b(record|entity|object|resource)\\b.*\\bguid\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "record_guid"
        ],
        "negativeExamples": [
          "record_id"
        ]
      },
      {
        "regExp": "(?i).*\\buuid\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "order_uuid"
        ],
        "negativeExamples": [
          "order_id"
        ]
      },
      {
        "regExp": "(?i).*\\bglobal\\b.*\\bunique\\b.*\\bidentifier\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "global_unique_identifier"
        ],
        "negativeExamples": [
          "global_unique_id"
        ]
      },
      {
        "regExp": "(?i).*\\bguid\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "guid"
        ],
        "negativeExamples": [
          "guideline"
        ]
      }
    ],
    "positiveContentExamples": [
      "550e8400-e29b-41d4-a716-446655440000",
      "f47ac10b-58cc-4372-a567-0e02b2c3d479",
      "3F2504E0-4F89-11D3-9A0C-0305E82C3301",
      "6ba7b810-9dad-11d1-80b4-00c04fd430c8",
      "67E55044-10B1-426F-9247-BB680E5FE0C8",
      "e902893a-9d22-3c7e-a7b8-d6e313b71d9f",
      "0f8fad5b-d9cb-469f-a165-70867728950e",
      "00112233445566778899aabbccddeeff"
    ],
    "negativeContentExamples": [
      "550e8400-e29b-41d4-a716-44665544000",
      "550e8400e29b-41d4-a716-446655440000",
      "550e8400-e29b-41d4-a716-44665544ZZZZ",
      "f47ac10b58cc4372a5670e02b2c3d47",
      "{3F2504E0-4F89-11D3-9A0C-0305E82C3301}",
      "3F2504E0-4F89-11D3-9A0C-0305E82C3301-00",
      "g47ac10b-58cc-4372-a567-0e02b2c3d479",
      "67E55044-10B1-426F-9247-BB680E5FE0C"
    ],
    "positiveHeaderExamples": [
      "transaction_guid",
      "user_guid",
      "record_guid",
      "uuid",
      "entity_guid",
      "global_unique_identifier",
      "order_uuid"
    ],
    "negativeHeaderExamples": [
      "transaction_id",
      "user_token",
      "record_hash",
      "guideline",
      "global_unique_id",
      "customer_identifier",
      "hash"
    ],
    "explanation": "This semantic type recognizes GUID/UUID identifiers in their common textual representations: a canonical hyphenated 8-4-4-4-12 hexadecimal format or a compact 32-hex-character form. The regex uses word boundaries to prevent accidental matches within longer tokens and supports both uppercase and lowercase hexadecimal digits. Header patterns prioritize specific entity+type names and common variants (including UUID and spelled-out 'global unique identifier') before falling back to the primitive term 'guid'. Typical use cases include deduplicating records, joining across systems, and identifying resources in logs and APIs.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:33.068746"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE_PAIR.DECIMAL",
    "description": "A combined latitude and longitude coordinate pair expressed in decimal degrees format separated by a comma for precise geographic positioning. Values must be two numbers in the ranges: latitude -90 to 90 and longitude -180 to 180, optionally with fractional decimals, and optional spaces around the comma. Directional letters, degree symbols, or alternative separators are not included in this type.",
    "pluginType": "regex",
    "regexPattern": "\\b-?(([0-8]?\\d(\\.\\d+)?)|(90(\\.0+)?))\\s*,\\s*-?((([0-9]?\\d|1[0-7]\\d)(\\.\\d+)?)|(180(\\.0+)?))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4460,
    "headerPatterns": [
      {
        "regExp": "(?i).*(decimal|dd).*(coordinate|coordinates).*(pair).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "coordinate_pair_decimal"
        ],
        "negativeExamples": [
          "coordinates_format"
        ]
      },
      {
        "regExp": "(?i).*lat.*[,/_ -].*lon.*(decimal|dd).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lat-lon-decimal"
        ],
        "negativeExamples": [
          "lat_lon"
        ]
      },
      {
        "regExp": "(?i).*(gps|geo|map).*(coordinate|coordinates).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "gps_coordinates"
        ],
        "negativeExamples": [
          "gps_accuracy"
        ]
      },
      {
        "regExp": "(?i).*(latitude).*(longitude).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "latitude_longitude"
        ],
        "negativeExamples": [
          "longitude_only"
        ]
      },
      {
        "regExp": "(?i).*coordinates.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "coordinates"
        ],
        "negativeExamples": [
          "location"
        ]
      }
    ],
    "positiveContentExamples": [
      "37.7749, -122.4194",
      "48.8566, 2.3522",
      "-33.8688, 151.2093",
      "0, 0",
      "51.5074, -0.1278",
      "-23.5505, -46.6333",
      "90.0000, -180.0000",
      "34.052235, -118.243683"
    ],
    "negativeContentExamples": [
      "37.7749 -122.4194",
      "91.0000, 45.0000",
      "45.0000, 181.0000",
      "37.77; -122.42",
      "N37.7749, W122.4194",
      "90.1, 180",
      "+45.0, -73.0",
      "37,7749, -122,4194"
    ],
    "positiveHeaderExamples": [
      "decimal_coordinates",
      "lat_lon_decimal",
      "gps_coordinates",
      "latitude_longitude",
      "coordinate_pair_decimal",
      "dd_coordinates",
      "map_coordinates"
    ],
    "negativeHeaderExamples": [
      "postal_code",
      "ip_address",
      "country_name",
      "timezone",
      "address_line",
      "airport_code",
      "location",
      "customer_id"
    ],
    "explanation": "This semantic type identifies pairs of latitude and longitude in decimal degrees separated by a comma, with optional spaces. It enforces valid ranges for both components and excludes representations using degree symbols, cardinal letters, or alternative separators. Typical use cases include geocoding results, device GPS outputs formatted as decimal degrees, and normalized GIS datasets.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:33.150886"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.PERSONNUMMER_SE",
    "description": "Sweden's personal identity number (personnummer) is a structured identifier incorporating date of birth (YYMMDD or YYYYMMDD), an individual sequence, and a check digit. Common formats include YYMMDDNNNN, YYMMDD-NNNN, YYMMDD+NNNN, YYYYMMDDNNNN, and YYYYMMDD-NNNN. This definition enforces valid month/day ranges and accepted separators but does not compute or verify the Luhn check digit.",
    "pluginType": "regex",
    "regexPattern": "\\b((19|20)\\d{2}(0[1-9]|1[0-2])(0[1-9]|[12]\\d|3[01])(\\d{4}|-\\d{4})|\\d{2}(0[1-9]|1[0-2])(0[1-9]|[12]\\d|3[01])(\\d{4}|[-+]\\d{4}))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4850,
    "headerPatterns": [
      {
        "regExp": "(?i).*(swedish|sweden|se).*(personnummer|personal.*identity.*number).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "swedish_personal_identity_number"
        ],
        "negativeExamples": [
          "social_security_number"
        ]
      },
      {
        "regExp": "(?i).*(personnummer).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "applicant_personnummer"
        ],
        "negativeExamples": [
          "person_name"
        ]
      },
      {
        "regExp": "(?i).*(sweden|swedish|se).*(national.*id|identity.*number|id.*number).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "sweden_national_id_number"
        ],
        "negativeExamples": [
          "european_id_number"
        ]
      },
      {
        "regExp": "(?i).*(pnr|persnr).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "se_pnr"
        ],
        "negativeExamples": [
          "prn_code"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "id_number"
        ],
        "negativeExamples": [
          "code_value"
        ]
      }
    ],
    "positiveContentExamples": [
      "850709-9805",
      "850709+9805",
      "8507099805",
      "19900130-1234",
      "20021224-2396",
      "19850709-9805",
      "198507099805",
      "19731201-4321"
    ],
    "negativeContentExamples": [
      "850732-9805",
      "851309-9805",
      "850709/9805",
      "850709--9805",
      "19850709+9805",
      "850709-980",
      "850709-98056",
      "851300-9805"
    ],
    "positiveHeaderExamples": [
      "swedish_personal_identity_number",
      "se_personnummer",
      "personnummer",
      "se_pnr",
      "sweden_national_id_number",
      "applicant_personnummer"
    ],
    "negativeHeaderExamples": [
      "customer_id_number",
      "social_security_number",
      "tax_id",
      "se_organisationsnummer",
      "passport_number",
      "national_identity_number_no"
    ],
    "explanation": "This semantic type recognizes Swedish personal identity numbers (personnummer) with valid month (01\u201312) and day (01\u201331) ranges. It supports 10-digit forms with optional '-' or '+' (YYMMDDNNNN, YYMMDD-NNNN, YYMMDD+NNNN) and 12-digit forms with optional '-' (YYYYMMDDNNNN, YYYYMMDD-NNNN). The pattern is boundary-scoped using word boundaries and avoids anchors. Check-digit and age/century interpretation (e.g., '+' for 100+ years) are not validated by this regex.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:33.362681"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.TEXT_ES",
    "description": "The full Spanish name for a country or nation as used in Spanish-language contexts and official documentation.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc]+)(((\\s(de|del|y|la|las|los|el|san|santo|santa))*\\s[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc]+|-[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc]+){0,6})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4520,
    "headerPatterns": [
      {
        "regExp": "(?i).*(country|pa[i\u00ed]s).*(name|nombre).*(es|espanol|espa\u00f1ol).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "country_name_es"
        ],
        "negativeExamples": [
          "country_code_es"
        ]
      },
      {
        "regExp": "(?i).*(nombre|name).*(oficial|official).*(pa[i\u00ed]s|country).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "nombre_oficial_pais"
        ],
        "negativeExamples": [
          "codigo_oficial_pais"
        ]
      },
      {
        "regExp": "(?i).*(nombre|name).*(pa[i\u00ed]s|country).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "nombre_del_pais"
        ],
        "negativeExamples": [
          "nombre_region"
        ]
      },
      {
        "regExp": "(?i).*(ctry|pais|country).*(es|espanol|espa\u00f1ol).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "pais_es"
        ],
        "negativeExamples": [
          "country_code"
        ]
      },
      {
        "regExp": "(?i).*country.*",
        "confidence": 91,
        "mandatory": true,
        "positiveExamples": [
          "country"
        ],
        "negativeExamples": [
          "state"
        ]
      }
    ],
    "positiveContentExamples": [
      "Espa\u00f1a",
      "Estados Unidos",
      "Reino Unido",
      "Rep\u00fablica Dominicana",
      "Emiratos \u00c1rabes Unidos",
      "Bosnia y Herzegovina",
      "San Vicente y las Granadinas",
      "Pap\u00faa Nueva Guinea"
    ],
    "negativeContentExamples": [
      "provincia de buenos aires",
      "Rep\u00fablica de",
      "SAN VICENTE Y LAS GRANADINAS",
      "bosnia y herz\u00e9govina",
      "Estados unidos",
      "El salvador",
      "Guinea- bis\u00e1u",
      "Cabo-verde"
    ],
    "positiveHeaderExamples": [
      "country_name_es",
      "nombre_pais_es",
      "nombre_del_pais",
      "pais_oficial_es",
      "pais_en_espanol",
      "nombre_nacion_es",
      "descripcion_pais_es"
    ],
    "negativeHeaderExamples": [
      "country_code",
      "iso_country",
      "pais_id",
      "nationality_es",
      "region_name_es",
      "ciudad_nombre",
      "estado_provincia",
      "idioma_pais"
    ],
    "explanation": "This semantic type identifies full country names written in Spanish, accommodating common multi-word constructions, articles, and conjunctions found in official Spanish country names. It is useful for classifying columns containing standardized Spanish country names rather than codes or abbreviations, especially in multilingual datasets.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:33.809169"
  },
  {
    "resultType": "generated",
    "semanticType": "IPADDRESS.IPV4",
    "description": "A numerical label assigned to devices connected to computer networks using the Internet Protocol version 4 for identification and location addressing.",
    "pluginType": "regex",
    "regexPattern": "\\b(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])(\\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4930,
    "headerPatterns": [
      {
        "regExp": "(?i).*ipv4.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ipv4_address"
        ],
        "negativeExamples": [
          "ipv6_address"
        ]
      },
      {
        "regExp": "(?i).*(src|source|dst|dest|client|server).*(ipv4|ip4).*(addr|address).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "src_ipv4_addr"
        ],
        "negativeExamples": [
          "dst_port"
        ]
      },
      {
        "regExp": "(?i).*(ip|ipv4).*(addr|address).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ip_address_v4"
        ],
        "negativeExamples": [
          "mac_address"
        ]
      },
      {
        "regExp": "(?i).*(src|dst).*(ip).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "src_ip"
        ],
        "negativeExamples": [
          "server_name"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "address"
        ],
        "negativeExamples": [
          "email"
        ]
      }
    ],
    "positiveContentExamples": [
      "8.8.8.8",
      "0.0.0.0",
      "10.0.0.1",
      "172.16.254.1",
      "192.168.0.1",
      "127.0.0.1",
      "255.255.255.255",
      "1.2.3.4"
    ],
    "negativeContentExamples": [
      "256.0.0.1",
      "192.168.1",
      "192.168.1.1.1",
      "192.168.01.1",
      "192.168.1.-1",
      "1.2.3.",
      "1.2.3.400",
      "999.10.10.10"
    ],
    "positiveHeaderExamples": [
      "ipv4_address",
      "client_ipv4",
      "source_ip_v4",
      "device_ipv4_addr",
      "ip_address_v4",
      "src_ipv4",
      "server_ip4_address",
      "destination_ipv4"
    ],
    "negativeHeaderExamples": [
      "ipv6_address",
      "ip_range",
      "cidr",
      "mac_address",
      "hostname",
      "email_address",
      "postal_address",
      "dst_port"
    ],
    "explanation": "This semantic type identifies IPv4 dotted-quad addresses (four decimal octets separated by dots) with each octet in the range 0\u2013255 and without leading zeros in multi-digit octets. It is useful for classifying columns that store IPv4 host or interface addresses in logs, network inventories, and telemetry.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:34.406457"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.LUHN",
    "description": "A numeric identifier that uses the Luhn (mod 10) algorithm for validation, commonly found in payment card numbers, device identifiers (e.g., IMEI), and other financial instruments. Values typically consist of 13\u201319 digits and may include spaces or hyphens as separators between groups.",
    "pluginType": "regex",
    "regexPattern": "\\b(\\d{13,19}|\\d{4}[- ]\\d{4}[- ]\\d{4}[- ]\\d{4}|\\d{4}[- ]\\d{6}[- ]\\d{5}|\\d{4}[- ]\\d{4}[- ]\\d{4}[- ]\\d{4}[- ]\\d{3})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4290,
    "headerPatterns": [
      {
        "regExp": "(?i).*(credit|card|imei|device|account).*luhn.*(number|code|id).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "credit_card_luhn_number"
        ],
        "negativeExamples": [
          "credit_card_number"
        ]
      },
      {
        "regExp": "(?i).*luhn.*(number|id|identifier|code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "luhn_identifier"
        ],
        "negativeExamples": [
          "luhn_date"
        ]
      },
      {
        "regExp": "(?i).*(mod10|mod_10|mod 10).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mod10_number"
        ],
        "negativeExamples": [
          "mod11_number"
        ]
      },
      {
        "regExp": "(?i).*(checkdigit|check_digit|checksum).*luhn.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "luhn_checkdigit"
        ],
        "negativeExamples": [
          "checksum_sha1"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "card_number"
        ],
        "negativeExamples": [
          "account_code"
        ]
      }
    ],
    "positiveContentExamples": [
      "4111111111111111",
      "4012 8888 8888 1881",
      "4222222222222",
      "378282246310005",
      "6011 1111 1111 1117",
      "3530111333300000",
      "5555-5555-5555-4444",
      "490154203237518"
    ],
    "negativeContentExamples": [
      "4111 1111 1111 111",
      "4012_8888_8888_1881",
      "422222222222",
      "3782 82246 310005",
      "6011-1111-1111-111",
      "3530 1113 3330 0000 0",
      "5555-5555-5555-444",
      "49015420323751A"
    ],
    "positiveHeaderExamples": [
      "luhn_number",
      "credit_card_luhn",
      "device_imei_luhn",
      "account_luhn_code",
      "luhn_identifier",
      "mod10_number",
      "luhn_checkdigit",
      "card_luhn_id"
    ],
    "negativeHeaderExamples": [
      "luhn_date",
      "checksum_sha1",
      "mod11_number",
      "card_number",
      "credit_card_expiry",
      "imei_hash",
      "account_id",
      "account_code"
    ],
    "explanation": "This semantic type targets numeric identifiers that conform to shapes commonly associated with Luhn (mod 10) check-digit schemes, including continuous 13\u201319 digit sequences and standard grouped formats with spaces or hyphens (e.g., 4-4-4-4 for 16 digits or 4-6-5 for 15 digits). It is useful for detecting columns likely containing payment card-like numbers or IMEI-like identifiers. While the regex focuses on structural patterns and separators, downstream validation should apply the Luhn algorithm to confirm true positives.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:34.527163"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.INDIVIDUAL_NUMBER_JA",
    "description": "Japan's My Number is a 12-digit individual identification number assigned to all residents for administrative efficiency across government services.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{12}\\b|\\b\\d{4}[ -]\\d{4}[ -]\\d{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4810,
    "headerPatterns": [
      {
        "regExp": "(?i).*japan.*individual.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "japan individual number"
        ],
        "negativeExamples": [
          "japan identity code"
        ]
      },
      {
        "regExp": "(?i).*(jp|ja|japan).*my.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "jp my number"
        ],
        "negativeExamples": [
          "jp tax id"
        ]
      },
      {
        "regExp": "(?i).*my.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "my number"
        ],
        "negativeExamples": [
          "my id"
        ]
      },
      {
        "regExp": "(?i).*individual.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "individual number"
        ],
        "negativeExamples": [
          "individual id"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "123456789012",
      "012345678901",
      "765432109876",
      "1234-5678-9012",
      "9876 5432 1098",
      "0000-1111-2222",
      "2468 1357 9024",
      "5555-6666-7777"
    ],
    "negativeContentExamples": [
      "12345678901",
      "1234567890123",
      "1234-5678-901",
      "1234-5678-90123",
      "1234_5678_9012",
      "1234\u20135678\u20139012",
      "12345678O012",
      "1234-5678--9012"
    ],
    "positiveHeaderExamples": [
      "japan individual number",
      "japan my number",
      "ja my number",
      "jp my number",
      "individual number",
      "my number",
      "mynumber",
      "jp individual number"
    ],
    "negativeHeaderExamples": [
      "japan identity code",
      "ja identifier",
      "my id",
      "individual id",
      "jp tax id",
      "resident code",
      "person id",
      "national identifier"
    ],
    "explanation": "This semantic type targets Japan's 'My Number' (Individual Number), recognizing 12-digit values optionally formatted in three groups of four separated by a single space or hyphen. It is useful for datasets involving resident identification for administrative, tax, or social services where this specific national identifier is captured.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:36.134238"
  },
  {
    "resultType": "generated",
    "semanticType": "COLOR.TEXT_EN",
    "description": "The common English name for a color as used in everyday language and design applications. This covers standard color terms frequently seen in UI labels, product attributes, and design palettes.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "RED",
      "BLUE",
      "GREEN",
      "YELLOW",
      "ORANGE",
      "PURPLE",
      "PINK",
      "BROWN",
      "BLACK",
      "WHITE",
      "GRAY",
      "GREY",
      "CYAN",
      "MAGENTA",
      "NAVY",
      "TEAL",
      "MAROON",
      "BEIGE",
      "IVORY",
      "LAVENDER",
      "OLIVE",
      "GOLD",
      "SILVER",
      "TURQUOISE",
      "VIOLET"
    ],
    "backout": "^[A-Z]{3,12}([ -][A-Z]{3,12}){0,2}$",
    "confidenceThreshold": 93,
    "priority": 4340,
    "headerPatterns": [
      {
        "regExp": "(?i).*(english|en).*(color|colour).*name.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "english_color_name"
        ],
        "negativeExamples": [
          "color_code_en"
        ]
      },
      {
        "regExp": "(?i).*(color|colour).*name.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "colour_name"
        ],
        "negativeExamples": [
          "color_code"
        ]
      },
      {
        "regExp": "(?i).*(clr|col).*name.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "clr_name"
        ],
        "negativeExamples": [
          "col_code"
        ]
      },
      {
        "regExp": "(?i).*hue.*name.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "hue_name"
        ],
        "negativeExamples": [
          "hue_value"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "color_name"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "red",
      "navy",
      "turquoise",
      "violet",
      "magenta",
      "olive",
      "silver",
      "beige"
    ],
    "negativeContentExamples": [
      "reed",
      "navy blue",
      "turqoise",
      "greyish",
      "silvers",
      "olive green",
      "color",
      "#FF0000"
    ],
    "positiveHeaderExamples": [
      "color_name_en",
      "english_color_name",
      "colour_name",
      "clr_name",
      "hue_name",
      "en_colour_name",
      "colorname",
      "en_color_name"
    ],
    "negativeHeaderExamples": [
      "color_code",
      "paint_hex",
      "hue_value",
      "bg_color",
      "color_id",
      "shade",
      "palette",
      "rgb"
    ],
    "explanation": "This semantic type recognizes common English color names typically used in datasets for product attributes, UI themes, design tokens, and descriptive labeling. It is list-based to ensure precision and avoid over-matching arbitrary words, with a controlled set of widely recognized color terms. Header patterns prioritize explicit indicators of a color name field, including English language hints and common abbreviations, while a conservative backout regex provides a broader structural fallback.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:39.051596"
  },
  {
    "resultType": "generated",
    "semanticType": "LANGUAGE.ISO-639-2",
    "description": "A standardized three-letter code used to represent languages according to the International Organization for Standardization ISO 639-2 standard.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4970,
    "headerPatterns": [
      {
        "regExp": "(?i).*language.*iso[-_ ]?639[-_ ]?2.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "language_iso_639_2_code"
        ],
        "negativeExamples": [
          "language_iso_639_1_code"
        ]
      },
      {
        "regExp": "(?i).*iso[-_ ]?639[-_ ]?2.*language.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "iso639_2_language"
        ],
        "negativeExamples": [
          "iso639_1_language"
        ]
      },
      {
        "regExp": "(?i).*(lang|language).*3.*letter.*code.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "language_3_letter_code"
        ],
        "negativeExamples": [
          "language_2_letter_code"
        ]
      },
      {
        "regExp": "(?i).*(lang|language).*(alpha3|three[-_ ]?letter).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "language_alpha3"
        ],
        "negativeExamples": [
          "language_alpha2"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "eng",
      "fra",
      "deu",
      "spa",
      "ita",
      "zho",
      "ara",
      "RUS"
    ],
    "negativeContentExamples": [
      "en",
      "ENG1",
      "en_US",
      "eng-US",
      "zh-Hans",
      "123",
      "fr",
      "engl"
    ],
    "positiveHeaderExamples": [
      "language_iso_639_2_code",
      "iso639_2_language",
      "lang_iso-639-2",
      "language_3_letter_code",
      "language_alpha3",
      "language_bibliographic_code",
      "iso_639_2",
      "lang_code_3"
    ],
    "negativeHeaderExamples": [
      "language_iso_639_1_code",
      "locale",
      "country_alpha3_code",
      "currency_code",
      "language_name",
      "script_code",
      "lang",
      "iso_3166_1_alpha3"
    ],
    "explanation": "This semantic type identifies ISO 639-2 language codes, which are three-letter alphabetic identifiers for languages. The value pattern enforces exactly three alphabetic characters with word boundaries, accommodating both uppercase and lowercase. Header patterns prioritize explicit references to ISO 639-2 language codes and common three-letter/alpha3 terminology to reduce ambiguity with other code systems.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:39.051757"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTIFIER",
    "description": "A unique identifier used to distinguish one entity from another within a system or dataset. This type expects alphanumeric strings that include at least one letter and one digit, and may contain hyphens or underscores.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Za-z][A-Za-z0-9_-]*\\d[A-Za-z0-9_-]*|\\d+[A-Za-z0-9_-]*[A-Za-z][A-Za-z0-9_-]*)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4760,
    "headerPatterns": [
      {
        "regExp": "(?i).*transaction.*identifier.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "transaction_identifier"
        ],
        "negativeExamples": [
          "transaction_code"
        ]
      },
      {
        "regExp": "(?i).*customer.*identifier.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_identifier"
        ],
        "negativeExamples": [
          "customer_code"
        ]
      },
      {
        "regExp": "(?i).*record.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "record_id"
        ],
        "negativeExamples": [
          "record_count"
        ]
      },
      {
        "regExp": "(?i).*(guid|uid|rid|ref).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "user_guid"
        ],
        "negativeExamples": [
          "status"
        ]
      },
      {
        "regExp": "(?i).*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "id"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "A12B3",
      "USR_0001",
      "INV-2024-000123",
      "CUST_9Z7Y",
      "X9Y8Z7",
      "AB12-CD34",
      "order_581729",
      "TKT-7GH2M9"
    ],
    "negativeContentExamples": [
      "12345678",
      "ABCDEFGH",
      "user-id",
      "0000-0000",
      "abc_def",
      "A1!",
      "INV 2024 000123",
      "id-xyz"
    ],
    "positiveHeaderExamples": [
      "transaction_identifier",
      "customer_identifier",
      "record_id",
      "unique_id",
      "user_guid",
      "reference_id",
      "entity_identifier",
      "id"
    ],
    "negativeHeaderExamples": [
      "transaction_code",
      "customer_code",
      "record_count",
      "email_address",
      "phone_number",
      "status",
      "zipcode",
      "created_date"
    ],
    "explanation": "This semantic type captures generic system identifiers that include both letters and digits, allowing hyphens and underscores to accommodate common ID formats like order IDs, user IDs, and reference IDs. It is intentionally broad but constrained to avoid matching plain words or purely numeric strings, reducing ambiguity across datasets.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:39.988589"
  },
  {
    "resultType": "generated",
    "semanticType": "LANGUAGE.TEXT_EN",
    "description": "The full name of a language as it is commonly known and written in English, such as English, French, or German.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "ENGLISH",
      "SPANISH",
      "FRENCH",
      "GERMAN",
      "CHINESE",
      "JAPANESE",
      "KOREAN",
      "ARABIC",
      "PORTUGUESE",
      "RUSSIAN",
      "HINDI",
      "BENGALI",
      "URDU",
      "ITALIAN",
      "DUTCH",
      "SWEDISH",
      "POLISH",
      "TURKISH",
      "GREEK",
      "HEBREW",
      "SWAHILI",
      "VIETNAMESE",
      "INDONESIAN",
      "THAI",
      "SCOTTISH GAELIC"
    ],
    "backout": "^[A-Za-z][A-Za-z' -]{0,49}[A-Za-z]$",
    "confidenceThreshold": 96,
    "priority": 4980,
    "headerPatterns": [
      {
        "regExp": "(?i).*language.*(name|text).*(en|english).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "language_name_en"
        ],
        "negativeExamples": [
          "language_name"
        ]
      },
      {
        "regExp": "(?i).*language.*(english|en).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "language_english"
        ],
        "negativeExamples": [
          "language_code"
        ]
      },
      {
        "regExp": "(?i).*(primary|preferred).*(language).*(en|english).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "primary_language_english"
        ],
        "negativeExamples": [
          "primary_language_code"
        ]
      },
      {
        "regExp": "(?i).*(lang|lng).*(name|text).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lang_name"
        ],
        "negativeExamples": [
          "lang_id"
        ]
      },
      {
        "regExp": "(?i).*language.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "language"
        ],
        "negativeExamples": [
          "country"
        ]
      }
    ],
    "positiveContentExamples": [
      "English",
      "Spanish",
      "French",
      "German",
      "Chinese",
      "Scottish Gaelic",
      "Vietnamese",
      "Swahili"
    ],
    "negativeContentExamples": [
      "EN",
      "eng",
      "English (UK)",
      "Portuguese - Brazil",
      "Language: English",
      "German-English",
      "Mandarin Chinese",
      "English1"
    ],
    "positiveHeaderExamples": [
      "language_name_en",
      "language_english",
      "primary_language_en",
      "preferred_language_english",
      "lang_name",
      "user_language"
    ],
    "negativeHeaderExamples": [
      "language_code",
      "lang_id",
      "locale",
      "country_language",
      "spoken_languages",
      "translator"
    ],
    "explanation": "This semantic type identifies the full English name of a language as it would appear in typical datasets (e.g., English, French, German). It is intended for columns storing language names written out in English, not ISO codes or locale-specific variants. The list-based approach ensures high precision for common languages, while the backout pattern provides a broader safety net for validation.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:40.689171"
  },
  {
    "resultType": "generated",
    "semanticType": "MACADDRESS",
    "description": "A unique hardware identifier assigned to network interface controllers for communication within network segments at the data link layer.",
    "pluginType": "regex",
    "regexPattern": "\\b([0-9A-Fa-f]{2}([-:][0-9A-Fa-f]{2}){5}|[0-9A-Fa-f]{4}(\\.[0-9A-Fa-f]{4}){2}|[0-9A-Fa-f]{12})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4990,
    "headerPatterns": [
      {
        "regExp": "(?i).*mac.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mac_address"
        ],
        "negativeExamples": [
          "ip_address"
        ]
      },
      {
        "regExp": "(?i).*device.*mac.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "device_mac"
        ],
        "negativeExamples": [
          "device_id"
        ]
      },
      {
        "regExp": "(?i).*hardware.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "hardware_address"
        ],
        "negativeExamples": [
          "billing_address"
        ]
      },
      {
        "regExp": "(?i).*hwaddr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "hwaddr"
        ],
        "negativeExamples": [
          "ipaddr"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "address"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "00:1A:2B:3C:4D:5E",
      "0a:1b:2c:3d:4e:5f",
      "A0-B1-C2-D3-E4-F5",
      "aa-bb-cc-dd-ee-ff",
      "001A.2B3C.4D5E",
      "001a2b3c4d5e",
      "0A1B.2C3D.4E5F",
      "7F:8E:9D:0C:1B:2A"
    ],
    "negativeContentExamples": [
      "00;1A;2B;3C;4D;5E",
      "0A_1B_2C_3D_4E_5F",
      "0A:1B:2C:3D:4E",
      "0A:1B:2C:3D:4E:5",
      "0A:1B:2C:3D:4E:5Z",
      "001A2B3C4D5",
      "001A.2B3C.4D5",
      "GG:HH:II:JJ:KK:LL"
    ],
    "positiveHeaderExamples": [
      "mac_address",
      "device_mac",
      "wifi_mac",
      "ethernet_mac",
      "hardware_address",
      "hwaddr",
      "link_layer_address",
      "physical_address"
    ],
    "negativeHeaderExamples": [
      "ip_address",
      "email_address",
      "postal_address",
      "billing_address",
      "device_id",
      "serial_number",
      "ipaddr",
      "mac_os_version"
    ],
    "explanation": "This semantic type detects Media Access Control (MAC) addresses in common formats, including colon- or hyphen-separated octets, Cisco-style dotted quartets, and contiguous 12-hex-digit strings. It is useful for identifying network interface hardware identifiers in logs, device inventories, and network telemetry. The regex is strict to hex characters and common separators, avoiding overly broad matches while allowing typical real-world representations.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:41.162324"
  },
  {
    "resultType": "generated",
    "semanticType": "CRYPTOCURRENCY.TEXT_EN",
    "description": "The full English name of a digital cryptocurrency as used in trading platforms and financial applications. Examples include single-word names and multi-word names that may end with descriptors like Coin, Token, Network, Protocol, or Chain.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z][a-z]{2,}coin|[A-Z][a-z]{2,}swap|[A-Z][a-z]{2,}link|[A-Z][A-Za-z0-9]{1,}DAO|(([A-Z][a-z]{2,}|[A-Z]{2,5})( ([A-Z][a-z]{2,}|[A-Z]{2,5})){0,2} (Coin|Token|Network|Protocol|Chain))|Bitcoin Cash)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4550,
    "headerPatterns": [
      {
        "regExp": "(?i).*(cryptocurrency|crypto).*(full|long).*(name).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "cryptocurrency_full_name"
        ],
        "negativeExamples": [
          "cryptocurrency_code"
        ]
      },
      {
        "regExp": "(?i).*(cryptocurrency|crypto).*(asset|currency).*(name).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "crypto_asset_name"
        ],
        "negativeExamples": [
          "crypto_asset_id"
        ]
      },
      {
        "regExp": "(?i).*(crypto|cryptocurrency).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "crypto_name"
        ],
        "negativeExamples": [
          "crypto_symbol"
        ]
      },
      {
        "regExp": "(?i).*(coin|token).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "coin_name"
        ],
        "negativeExamples": [
          "token_symbol"
        ]
      },
      {
        "regExp": "(?i).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "title"
        ]
      }
    ],
    "positiveContentExamples": [
      "Bitcoin",
      "Dogecoin",
      "Litecoin",
      "Filecoin",
      "Chainlink",
      "Uniswap",
      "USD Coin",
      "Curve DAO Token"
    ],
    "negativeContentExamples": [
      "BitcoinCash",
      "BinanceCoin",
      "usd Coin",
      "Crypto Coin",
      "Coin",
      "Bitcoin (BTC)",
      "Lite coin",
      "Chain link"
    ],
    "positiveHeaderExamples": [
      "cryptocurrency_name",
      "cryptocurrency_full_name",
      "crypto_name",
      "crypto_asset_name",
      "coin_name",
      "token_name",
      "digital_currency_name"
    ],
    "negativeHeaderExamples": [
      "cryptocurrency_code",
      "crypto_symbol",
      "coin_symbol",
      "token_symbol",
      "currency_code",
      "asset_id",
      "blockchain"
    ],
    "explanation": "This semantic type identifies the full English name of a cryptocurrency asset as presented in trading and financial datasets. It emphasizes natural-language names (e.g., Bitcoin, USD Coin, Curve DAO Token) rather than ticker symbols or codes. The value pattern targets common cryptocurrency naming structures, while header patterns prioritize explicit crypto-related column names to reduce ambiguity.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:41.493144"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.SSN_CH",
    "description": "Switzerland's AHV number is a unique 13-digit social security identifier used for pension, insurance, and administrative purposes. It typically begins with 756 and may be written with dots or spaces between digit groups (e.g., 756.1234.5678.97).",
    "pluginType": "regex",
    "regexPattern": "\\b756(\\d{10}|[.\\s]\\d{4}[.\\s]\\d{4}[.\\s]\\d{2})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4870,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bahv\\b.*\\b(ch|che|swiss|switzerland)\\b.*\\b(number|no|nr|id)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "AHV CH number"
        ],
        "negativeExamples": [
          "Swiss tax number"
        ]
      },
      {
        "regExp": "(?i).*\\b(social\\s*security|social\\s*insurance)\\b.*\\b(ch|swiss|switzerland|che)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Switzerland social insurance number"
        ],
        "negativeExamples": [
          "Germany social insurance number"
        ]
      },
      {
        "regExp": "(?i).*\\bch\\b.*\\bssn\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CH SSN"
        ],
        "negativeExamples": [
          "US SSN"
        ]
      },
      {
        "regExp": "(?i).*\\b(ahv|avs)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "AHV"
        ],
        "negativeExamples": [
          "AHP code"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "7561234567897",
      "756.1234.5678.97",
      "756 1234 5678 97",
      "756.0000.0000.00",
      "756 3210 9876 54",
      "7561234098765",
      "756.1111.2222.33",
      "756 9999 8888 77"
    ],
    "negativeContentExamples": [
      "756-1234-5678-97",
      "756.12345.678.97",
      "756123456789",
      "756.1234.56789.7",
      "157.1234.5678.97",
      "756 1234 567897",
      "756.1234.5678.9",
      "756A123456789"
    ],
    "positiveHeaderExamples": [
      "AHV number",
      "CH SSN",
      "Switzerland AHV ID",
      "Swiss social insurance number",
      "AVS no",
      "CHE ssn",
      "CH AHV",
      "AHV Switzerland number"
    ],
    "negativeHeaderExamples": [
      "Swiss insurance id",
      "CH personal id",
      "SSN",
      "Swiss tax id",
      "Employee id",
      "Passport number",
      "VAT number",
      "National identifier"
    ],
    "explanation": "This semantic type identifies Switzerland's AHV (AVS) social security number, which always starts with 756 and contains 13 digits. The pattern accepts compact form (756XXXXXXXXXX) and separated forms using dots or spaces (756.XXXX.XXXX.XX or 756 XXXX XXXX XX). It excludes other separators (e.g., hyphens), wrong prefixes, and incorrect digit group lengths. Typical use cases include validating and classifying Swiss national social security identifiers in HR, benefits, insurance, and government datasets.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:43.604161"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.SSN_FR",
    "description": "France's INSEE number (NIR) is a 15-digit social security identifier that encodes gender, birth year, month, place of birth, an individual sequence, and a 2-digit key. This definition recognizes the NIR as 15 digits presented contiguously or grouped with single spaces or hyphens between components.",
    "pluginType": "regex",
    "regexPattern": "\\b[1278][ -]?\\d{2}[ -]?\\d{2}[ -]?\\d{2}[ -]?\\d{3}[ -]?\\d{3}[ -]?\\d{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4880,
    "headerPatterns": [
      {
        "regExp": "(?i).*(fr|france).*(insee|nir).*(number|num|no).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "fr_insee_number"
        ],
        "negativeExamples": [
          "insee_id"
        ]
      },
      {
        "regExp": "(?i).*(fr|france).*(social.*security|securite.*sociale).*(number|num|no).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "france_social_security_number"
        ],
        "negativeExamples": [
          "security_question"
        ]
      },
      {
        "regExp": "(?i).*(insee|nir|ssn).*(fr|france).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "nir_fr"
        ],
        "negativeExamples": [
          "ssn_us"
        ]
      },
      {
        "regExp": "(?i).*(securite.*sociale|social.*security).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "numero_securite_sociale"
        ],
        "negativeExamples": [
          "security_level"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "1 84 12 75 123 456 78",
      "2 99 01 13 045 321 09",
      "184127512345678",
      "2-75-07-93-123-456-12",
      "7 83 10 01 999 001 00",
      "8-71-12-20-123-999-34",
      "1 73 11 34 000 123 45",
      "2 00 12 97 543 210 33"
    ],
    "negativeContentExamples": [
      "3 84 12 75 123 456 78",
      "1 84 12 75 123 456 7A",
      "1 84 12 75 1234 56 78",
      "1 84 12 75 123 456 789",
      "18412751234567",
      "1--84--12--75--123--456--78",
      "9-84-12-75-123-456-78",
      "1_84_12_75_123_456_78"
    ],
    "positiveHeaderExamples": [
      "fr_insee_number",
      "france_social_security_number",
      "nir_fr",
      "numero_securite_sociale",
      "insee_num_fr",
      "ssn_france",
      "fr_nir_no",
      "french_social_security_number"
    ],
    "negativeHeaderExamples": [
      "insee_id",
      "security_question",
      "ssn_us",
      "health_insurance_id",
      "national_identifier",
      "tax_code",
      "insee_date",
      "passport_id"
    ],
    "explanation": "This semantic type detects the French INSEE/NIR social security number as a 15-digit identifier that may be written contiguously or with single spaces or hyphens between canonical groups. It is intended to identify French personal social security identifiers in datasets for classification, masking, or validation workflows.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:44.004777"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.SIN_CA",
    "description": "Canada's Social Insurance Number is a 9-digit identifier used for employment, taxation, and government benefit administration.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{3}[ -]\\d{3}[ -]\\d{3}\\b|\\b\\d{9}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4860,
    "headerPatterns": [
      {
        "regExp": "(?i).*canadian.*social.*insurance.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "canadian_social_insurance_number"
        ],
        "negativeExamples": [
          "social_insurance_number"
        ]
      },
      {
        "regExp": "(?i).*canada.*social.*insurance.*no.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "canada_social_insurance_no"
        ],
        "negativeExamples": [
          "canadian_social_insurance_number"
        ]
      },
      {
        "regExp": "(?i).*social.*insurance.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "social_insurance_number"
        ],
        "negativeExamples": [
          "insurance_number"
        ]
      },
      {
        "regExp": "(?i).*\\bnational\\b.*\\bid\\b.*\\bca\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "national_id_ca"
        ],
        "negativeExamples": [
          "national_id"
        ]
      },
      {
        "regExp": "(?i).*\\bsin\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "sin"
        ],
        "negativeExamples": [
          "sine_value"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "123456789",
      "123 456 789",
      "123-456-789",
      "987 654 321",
      "046-454-286",
      "621 495 770",
      "859-371-246",
      "640296385"
    ],
    "negativeContentExamples": [
      "123-45-6789",
      "123_456_789",
      "12 345 6789",
      "123-456-78",
      "12345678",
      "1234567890",
      "A23-456-789",
      "123\u2013456\u2013789"
    ],
    "positiveHeaderExamples": [
      "canadian_social_insurance_number",
      "canada_social_insurance_no",
      "social_insurance_number",
      "national_id_ca",
      "ca_sin",
      "sin",
      "canadian_sin",
      "canada sin number"
    ],
    "negativeHeaderExamples": [
      "ssn",
      "insurance_number",
      "customer_id",
      "national_id_mx",
      "security_number",
      "sine_value",
      "transaction_number",
      "tax_id"
    ],
    "explanation": "This semantic type detects Canadian Social Insurance Numbers (SIN), which are 9 digits and may be written as a continuous 9-digit string or grouped as 3-3-3 using spaces or hyphens. The value pattern avoids anchors and relies on word boundaries and explicit token counts to stay precise, with strong, Canada-specific header patterns to reduce ambiguity. Typical uses include identifying SIN fields for compliance, masking, and validation workflows.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:46.013781"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.NHS_UK",
    "description": "A unique 10-digit identifier assigned to patients registered with the National Health Service in England and Wales. Values may be presented as a continuous 10-digit string or grouped as 3-3-4 using single spaces or single hyphens.",
    "pluginType": "regex",
    "regexPattern": "\\b(\\d{10}|\\d{3}[ -]\\d{3}[ -]\\d{4})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4820,
    "headerPatterns": [
      {
        "regExp": "(?i).*nhs.*uk.*(number|id).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nhs uk number"
        ],
        "negativeExamples": [
          "national insurance number"
        ]
      },
      {
        "regExp": "(?i).*nhs.*patient.*(number|id).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nhs patient number"
        ],
        "negativeExamples": [
          "patient hospital number"
        ]
      },
      {
        "regExp": "(?i).*nhs.*(number|id).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nhs number"
        ],
        "negativeExamples": [
          "hospital number"
        ]
      },
      {
        "regExp": "(?i).*(nhs[-_ ]?(no|num|id)).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nhs_no"
        ],
        "negativeExamples": [
          "account_no"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "9434765919",
      "943 476 5919",
      "123 456 7890",
      "401 023 4567",
      "859-123-0476",
      "234-567-8901",
      "7001234567",
      "987 650 4321"
    ],
    "negativeContentExamples": [
      "943 4765 919",
      "943-476-591-9",
      "943_476_5919",
      "943476591",
      "09434765919",
      "943 476 591X",
      "943--476-5919",
      "943  476  5919"
    ],
    "positiveHeaderExamples": [
      "nhs uk number",
      "nhs patient number",
      "nhs number",
      "nhs_no",
      "nhs id",
      "nhs identifier",
      "patient nhs number",
      "nhs uk id number"
    ],
    "negativeHeaderExamples": [
      "national insurance number",
      "hospital patient number",
      "nhs trust code",
      "nhs hospital number",
      "medical record number",
      "nhs scheme code",
      "patient id",
      "insurance policy number"
    ],
    "explanation": "This semantic type detects UK NHS patient numbers as 10 digits, either unseparated or grouped 3-3-4 with single spaces or single hyphens. It focuses on the identifier\u2019s surface format without performing modulus/check-digit validation. Use this type to identify columns storing NHS numbers in patient-centric datasets and to distinguish them from other identifiers via header signals containing 'NHS'.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:46.664239"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.FIRST_LAST",
    "description": "A complete personal name combining first and last names in the conventional Western format with a single space separator.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z]+([-'][A-Za-z]+)? [A-Za-z]+([-'][A-Za-z]+)?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5040,
    "headerPatterns": [
      {
        "regExp": "(?i).*first.*last.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_first_last_name"
        ],
        "negativeExamples": [
          "first_name"
        ]
      },
      {
        "regExp": "(?i).*first.*last.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "user_first_last"
        ],
        "negativeExamples": [
          "last_name"
        ]
      },
      {
        "regExp": "(?i).*person.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "person_full_name"
        ],
        "negativeExamples": [
          "company_name"
        ]
      },
      {
        "regExp": "(?i).*full.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "contact_full_name"
        ],
        "negativeExamples": [
          "file_name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "email"
        ]
      }
    ],
    "positiveContentExamples": [
      "John Smith",
      "Mary Johnson",
      "Jean-Luc Picard",
      "Sean O'Neill",
      "Alice McCarthy",
      "Victor Hugo",
      "Chloe Brown",
      "Marco DeLuca"
    ],
    "negativeContentExamples": [
      "John",
      "John A Smith",
      "Smith, John",
      "J. Smith",
      "John  Smith",
      "John-Smith",
      "Mary Jane Watson",
      "Mr John Smith"
    ],
    "positiveHeaderExamples": [
      "first_last_name",
      "customer_first_last_name",
      "person_full_name",
      "user_first_last",
      "applicant_first_last",
      "contact_full_name",
      "employee_first_last_name",
      "registrant_name"
    ],
    "negativeHeaderExamples": [
      "first_name",
      "last_name",
      "company_name",
      "customer_username",
      "file_name",
      "display_name",
      "contact_id",
      "email_address"
    ],
    "explanation": "This type targets two-token personal names in Western order: a given name followed by a family name, separated by a single space. Each token consists of letters and may include a single internal hyphen or apostrophe (e.g., Jean-Luc, O'Neill). It excludes middle names/initials, prefixes/suffixes, commas, multiple spaces, and formats with more or fewer than two tokens. Typical use cases include contact lists, account holder names, and registrant fields where a simple First Last format is enforced.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:50.741077"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.DUNS",
    "description": "A unique 9-digit identifier assigned by Dun & Bradstreet to identify business entities worldwide for credit and business information purposes.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{9}\\b|\\b\\d{2}[- ]\\d{3}[- ]\\d{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 4790,
    "headerPatterns": [
      {
        "regExp": "(?i).*duns.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "duns_number"
        ],
        "negativeExamples": [
          "customer_number"
        ]
      },
      {
        "regExp": "(?i).*duns.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "duns_id"
        ],
        "negativeExamples": [
          "vendor_id"
        ]
      },
      {
        "regExp": "(?i).*dun.*bradstreet.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "dun_and_bradstreet_id"
        ],
        "negativeExamples": [
          "business_registry_id"
        ]
      },
      {
        "regExp": "(?i).*duns.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "company_duns"
        ],
        "negativeExamples": [
          "company_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "supplier_duns_code"
        ],
        "negativeExamples": [
          "supplier_id"
        ]
      }
    ],
    "positiveContentExamples": [
      "123456789",
      "15-048-3782",
      "00 123 4567",
      "004567890",
      "85-123-0001",
      "000000001",
      "73 210 9987",
      "987654321"
    ],
    "negativeContentExamples": [
      "12345678",
      "1234567890",
      "1-234-5678",
      "12-34-56789",
      "12_345_6789",
      "12-3456-789",
      "123-456-789",
      "O12345678"
    ],
    "positiveHeaderExamples": [
      "duns_number",
      "duns id",
      "dun and bradstreet id",
      "company_duns",
      "supplier_duns_code",
      "duns",
      "duns no",
      "dnb_duns_number"
    ],
    "negativeHeaderExamples": [
      "customer_number",
      "vendor_id",
      "tax_id",
      "company_code",
      "business_id",
      "credit_score",
      "registration_number",
      "ein"
    ],
    "explanation": "This semantic type detects Dun & Bradstreet D-U-N-S numbers used to uniquely identify business entities. It matches either a compact 9-digit form or a commonly used 2-3-4 grouping with spaces or hyphens. Header patterns prioritize explicit DUNS mentions and related business identifiers to reduce ambiguity with other numeric IDs.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:51.381657"
  },
  {
    "resultType": "generated",
    "semanticType": "MONTH.FULL_<LOCALE>",
    "description": "The complete name of calendar months as written and spoken in U.S. English (EN_US), using full month names (e.g., January, February) rather than abbreviations or numeric forms. This type is intended for textual month values in datasets where the month is expressed as a full word.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "JANUARY",
      "FEBRUARY",
      "MARCH",
      "APRIL",
      "MAY",
      "JUNE",
      "JULY",
      "AUGUST",
      "SEPTEMBER",
      "OCTOBER",
      "NOVEMBER",
      "DECEMBER"
    ],
    "backout": "^[A-Z]{3,9}$",
    "confidenceThreshold": 98,
    "priority": 5020,
    "headerPatterns": [
      {
        "regExp": "(?i).*(full|long).*month.*name.*",
        "confidence": 99,
        "mandatory": true,
        "positiveExamples": [
          "full_month_name"
        ],
        "negativeExamples": [
          "month_name"
        ]
      },
      {
        "regExp": "(?i).*month.*name.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "month_name"
        ],
        "negativeExamples": [
          "month_number"
        ]
      },
      {
        "regExp": "(?i).*(month.*text|text.*month|month.*label|label.*month).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "month_label"
        ],
        "negativeExamples": [
          "month_code"
        ]
      },
      {
        "regExp": "(?i).*(mnth|mon).*(name|nm).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "mnth_nm"
        ],
        "negativeExamples": [
          "mon_code"
        ]
      },
      {
        "regExp": "(?i).*\\bmonth\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "month"
        ],
        "negativeExamples": [
          "month_idx"
        ]
      }
    ],
    "positiveContentExamples": [
      "January",
      "FEBRUARY",
      "March",
      "April",
      "MAY",
      "June",
      "July",
      "December"
    ],
    "negativeContentExamples": [
      "Jan",
      "Sept",
      "Septembre",
      "Januari",
      "Feb-ruary",
      "02",
      "Monday",
      "Octobr"
    ],
    "positiveHeaderExamples": [
      "full_month_name",
      "long_month_name",
      "month_name",
      "month_text",
      "month_label",
      "mnth_nm",
      "mon_name",
      "month"
    ],
    "negativeHeaderExamples": [
      "month_number",
      "month_idx",
      "month_code",
      "billing_month",
      "month_abbr",
      "event_date",
      "quarter_name",
      "day_name"
    ],
    "explanation": "This semantic type captures the full English month names as used in the United States locale, suitable for fields where the month is stored as a complete word rather than a numeric or abbreviated representation. It is useful for parsing and validating textual month fields in transactional, logging, or survey data where the month is expressed in natural language.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:51.674029"
  },
  {
    "resultType": "generated",
    "semanticType": "GENDER.TEXT_JA",
    "description": "A person's gender identity as expressed in Japanese language terms, indicating biological sex or gender classification.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "\u7537\u6027",
      "\u5973\u6027",
      "\u7537",
      "\u5973",
      "\u4e2d\u6027",
      "\u4e0d\u660e",
      "\u305d\u306e\u4ed6",
      "\u672a\u8a2d\u5b9a",
      "\u56de\u7b54\u306a\u3057",
      "\u4e0d\u56de\u7b54",
      "\u30ce\u30f3\u30d0\u30a4\u30ca\u30ea\u30fc",
      "X\u30b8\u30a7\u30f3\u30c0\u30fc",
      "\u30c8\u30e9\u30f3\u30b9\u5973\u6027",
      "\u30c8\u30e9\u30f3\u30b9\u7537\u6027",
      "FtM",
      "MtF"
    ],
    "backout": "^[A-Za-z\u3041-\u3093\u30a1-\u30f6\u30fc\u4e00-\u9fa5\u3005]{1,10}$",
    "confidenceThreshold": 96,
    "priority": 4700,
    "headerPatterns": [
      {
        "regExp": "(?i).*(customer|user|member).*(gender|\u6027\u5225|\u30b8\u30a7\u30f3\u30c0\u30fc).*(ja|japanese|jp|\u65e5\u672c\u8a9e).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_gender_ja"
        ],
        "negativeExamples": [
          "customer_gender"
        ]
      },
      {
        "regExp": "(?i).*(gender|\u6027\u5225|\u30b8\u30a7\u30f3\u30c0\u30fc).*(ja|japanese|jp|\u65e5\u672c\u8a9e).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gender_japanese"
        ],
        "negativeExamples": [
          "gender_code"
        ]
      },
      {
        "regExp": "(?i).*(profile|demographic|demo).*(gender|\u6027\u5225|\u30b8\u30a7\u30f3\u30c0\u30fc).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "demographic_gender"
        ],
        "negativeExamples": [
          "demographic_age"
        ]
      },
      {
        "regExp": "(?i).*(gndr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gndr"
        ],
        "negativeExamples": [
          "gender"
        ]
      },
      {
        "regExp": "(?i).*gender.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gender"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "\u7537\u6027",
      "\u5973\u6027",
      "\u7537",
      "\u5973",
      "\u305d\u306e\u4ed6",
      "\u4e0d\u660e",
      "\u30ce\u30f3\u30d0\u30a4\u30ca\u30ea\u30fc",
      "X\u30b8\u30a7\u30f3\u30c0\u30fc"
    ],
    "negativeContentExamples": [
      "M",
      "F",
      "\u7537\u306e\u5b50",
      "\u5973\u306e\u5b50",
      "\u6027\u5225\u4e0d\u660e",
      "\u30b8\u30a7\u30f3\u30c0\u30fc\u30d5\u30eb\u30a4\u30c9",
      "\u30aa\u30b9",
      "\u30e1\u30b9"
    ],
    "positiveHeaderExamples": [
      "customer_gender_ja",
      "user_gender_jp",
      "gender_ja",
      "\u6027\u5225",
      "\u9867\u5ba2_\u6027\u5225",
      "\u6ce8\u6587\u8005_\u30b8\u30a7\u30f3\u30c0\u30fc",
      "gndr",
      "\u65e5\u672c\u8a9e_\u6027\u5225"
    ],
    "negativeHeaderExamples": [
      "age",
      "customer_id",
      "country_code",
      "email",
      "status_flag",
      "profile_language",
      "sex_at_birth",
      "preferred_pronouns"
    ],
    "explanation": "This semantic type captures gender values written in Japanese, enabling consistent identification of fields where Japanese gender labels are used. It is suited for datasets from Japanese sources or multilingual systems storing Japanese text values.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:56.276109"
  },
  {
    "resultType": "generated",
    "semanticType": "MONTH.DIGITS",
    "description": "A numerical representation of calendar months using integers from 1 to 12, where 1 represents January and 12 represents December. Also accepts a leading zero for months 1\u20139 (e.g., 01\u201309).",
    "pluginType": "regex",
    "regexPattern": "\\b(0?[1-9]|1[0-2])\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 5010,
    "headerPatterns": [
      {
        "regExp": "(?i).*(transaction|billing|fiscal).*month.*(number|num|no)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "transaction_month_number"
        ],
        "negativeExamples": [
          "transaction_month_name"
        ]
      },
      {
        "regExp": "(?i).*month.*(number|num|no|digit|idx|index)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "month_digit"
        ],
        "negativeExamples": [
          "month_name"
        ]
      },
      {
        "regExp": "(?i).*\\b(mon|mo)\\b.*(num|no|idx)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mo_num"
        ],
        "negativeExamples": [
          "mon_name"
        ]
      },
      {
        "regExp": "(?i).*month.*id\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "month_id"
        ],
        "negativeExamples": [
          "user_id"
        ]
      },
      {
        "regExp": "(?i).*month.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "month"
        ],
        "negativeExamples": [
          "quarter"
        ]
      }
    ],
    "positiveContentExamples": [
      "1",
      "2",
      "9",
      "10",
      "11",
      "12",
      "01",
      "07"
    ],
    "negativeContentExamples": [
      "0",
      "13",
      "1.5",
      "00",
      "12.0",
      "Jan",
      "012",
      "2Q"
    ],
    "positiveHeaderExamples": [
      "transaction_month_number",
      "billing_month_num",
      "fiscal_month_no",
      "month_digit",
      "month_index",
      "mon_num",
      "mo_num",
      "month_id"
    ],
    "negativeHeaderExamples": [
      "quarter_number",
      "weekday_num",
      "day_number",
      "period_num",
      "fiscal_period",
      "mm_yyyy",
      "date",
      "year"
    ],
    "explanation": "This semantic type identifies month values expressed as digits for calendar months (1\u201312), commonly used in tabular data where months are stored as numeric fields. It is useful for validating and classifying numeric month columns, including values with an optional leading zero (01\u201309), while excluding out-of-range and non-integer representations.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:56.689459"
  },
  {
    "resultType": "generated",
    "semanticType": "INDUSTRY_CODE.NAICS",
    "description": "A standardized 6-digit classification code used to categorize business establishments by their primary economic activity in North America.",
    "pluginType": "regex",
    "regexPattern": "\\b(11|21|22|23|31|32|33|42|44|45|48|49|51|52|53|54|55|56|61|62|71|72|81|92)[0-9]{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4910,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bnaics\\b.*\\bcode\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "naics_code"
        ],
        "negativeExamples": [
          "sic_code"
        ]
      },
      {
        "regExp": "(?i).*\\bprimary\\b.*\\bnaics\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "primary_naics_code"
        ],
        "negativeExamples": [
          "secondary_industry_code"
        ]
      },
      {
        "regExp": "(?i).*\\b(industry|sector)\\b.*\\bnaics\\b.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "industry_naics"
        ],
        "negativeExamples": [
          "industry_name"
        ]
      },
      {
        "regExp": "(?i).*\\b(industry|sector)\\b.*\\bcode\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "industry_code"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "541330",
      "722511",
      "236115",
      "311615",
      "524210",
      "221114",
      "492110",
      "333120"
    ],
    "negativeContentExamples": [
      "54133",
      "5413307",
      "54A330",
      "541-330",
      "541 330",
      "101234",
      "049999",
      "930000"
    ],
    "positiveHeaderExamples": [
      "naics_code",
      "naics",
      "primary_naics_code",
      "industry_naics",
      "naics6",
      "industry_code",
      "sector_naics_code",
      "naics_classification"
    ],
    "negativeHeaderExamples": [
      "sic_code",
      "hs_code",
      "industry_name",
      "sector",
      "postal_code",
      "naics_description",
      "customer_code",
      "product_code"
    ],
    "explanation": "This semantic type identifies 6-digit NAICS industry classification codes. The value pattern restricts matches to six digits beginning with valid NAICS sector prefixes (e.g., 11, 21, 22, 23, 31\u201333, 42, 44\u201345, 48\u201349, 51\u201356, 61\u201362, 71\u201372, 81, 92), minimizing false positives. Use this type to detect and validate NAICS-coded columns in datasets describing business activities, for tasks like industry segmentation, analytics, and regulatory reporting.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:50:58.200034"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.MIDDLE",
    "description": "A secondary given name positioned between the first name and surname, often honoring family members or cultural traditions.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Za-z]\\.?!?|[A-Za-z]{2,30}-[A-Za-z]{2,30}|[A-Za-z]{2,30}\\s[A-Za-z]{2,30}|[A-Za-z]{2,30})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5070,
    "headerPatterns": [
      {
        "regExp": "(?i).*middle[_ ]?name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "middle_name"
        ],
        "negativeExamples": [
          "first_name"
        ]
      },
      {
        "regExp": "(?i).*(customer|person|user|employee|applicant).*middle[_ ]?name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_middle_name"
        ],
        "negativeExamples": [
          "customer_last_name"
        ]
      },
      {
        "regExp": "(?i).*(mname|m_name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mname"
        ],
        "negativeExamples": [
          "lname"
        ]
      },
      {
        "regExp": "(?i).*middle[_ ]?initial.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "middle_initial"
        ],
        "negativeExamples": [
          "first_initial"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "email"
        ]
      }
    ],
    "positiveContentExamples": [
      "A.",
      "J",
      "Marie",
      "Anne-Marie",
      "Mary Jane",
      "Jean",
      "Lee",
      "Chao"
    ],
    "negativeContentExamples": [
      "A B",
      "J.-P.",
      "O'Neil",
      "Anne_Marie",
      "Li'",
      "Jo3",
      "Mary  Jane",
      "A-"
    ],
    "positiveHeaderExamples": [
      "middle_name",
      "middle name",
      "customer_middle_name",
      "person middle name",
      "mname",
      "m_name",
      "middle_initial",
      "applicant_middle_name"
    ],
    "negativeHeaderExamples": [
      "last_initial",
      "first_initial",
      "surname",
      "alias",
      "middle_index",
      "date_of_birth",
      "address",
      "contact"
    ],
    "explanation": "This semantic type identifies a person's middle given name or initial, typically stored as a single token, an initial with an optional period, a hyphenated form, or two simple given-name tokens. It is useful for datasets that separate first, middle, and last names to improve matching, deduplication, and entity resolution.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:05.113184"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.FIRST",
    "description": "A person's given name, typically assigned at birth and used as the primary personal identifier in most cultures and naming conventions.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z][a-z]{1,29}('[A-Z][a-z]{1,29})?( [A-Z][a-z]{1,29}|-[A-Z][a-z]{1,29})?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5030,
    "headerPatterns": [
      {
        "regExp": "(?i).*(contact|customer|employee|user)[_ ](first|given|forename)[_ ]name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_first_name"
        ],
        "negativeExamples": [
          "customer_last_name"
        ]
      },
      {
        "regExp": "(?i).*(first|given|forename)[_ ]name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "first_name"
        ],
        "negativeExamples": [
          "middle_name"
        ]
      },
      {
        "regExp": "(?i).*(fname|f[_ ]?name|firstnm).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fname"
        ],
        "negativeExamples": [
          "full_name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "John",
      "Maria",
      "De'Andre",
      "Anne-Marie",
      "Jean Paul",
      "Mary Jane",
      "Li",
      "Jo'Anne"
    ],
    "negativeContentExamples": [
      "JOHN",
      "mary",
      "Anne_Marie",
      "Jean-Paul II",
      "A",
      "McKenzie",
      "O'Neal",
      "D\u2019Angelo"
    ],
    "positiveHeaderExamples": [
      "first_name",
      "given_name",
      "forename",
      "customer_first_name",
      "contact_given_name",
      "employee_forename",
      "fname",
      "firstnm"
    ],
    "negativeHeaderExamples": [
      "last_name",
      "middle_name",
      "full_name",
      "first_purchase_date",
      "first_login_time",
      "contact_name",
      "name_prefix",
      "product_name"
    ],
    "explanation": "This semantic type identifies a personal given name (first name) as a standalone field, accommodating common forms such as single-token names, hyphenated names, apostrophe-internal names, and two-part given names separated by a space. It is intended for columns explicitly storing the first/given name of a person, not surnames, middle names, or composite full names.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:05.838215"
  },
  {
    "resultType": "generated",
    "semanticType": "MONTH.ABBR_<LOCALE>",
    "description": "A shortened form of month names in US English, typically three-letter abbreviations such as JAN, FEB, and MAR. Values are limited to the 12 standard three-letter month abbreviations used in en_US.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "JAN",
      "FEB",
      "MAR",
      "APR",
      "MAY",
      "JUN",
      "JUL",
      "AUG",
      "SEP",
      "OCT",
      "NOV",
      "DEC"
    ],
    "backout": "^[A-Z]{3}$",
    "confidenceThreshold": 97,
    "priority": 5000,
    "headerPatterns": [
      {
        "regExp": "(?i).*month.*abbr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "month_abbr_en_us"
        ],
        "negativeExamples": [
          "month_full"
        ]
      },
      {
        "regExp": "(?i).*month.*short.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "month_short_name"
        ],
        "negativeExamples": [
          "short_description"
        ]
      },
      {
        "regExp": "(?i).*mon.*abbr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mon_abbr"
        ],
        "negativeExamples": [
          "month_index"
        ]
      },
      {
        "regExp": "(?i).*month.*3.*letter.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "month_3_letter"
        ],
        "negativeExamples": [
          "month_two_letter"
        ]
      },
      {
        "regExp": "(?i).*month.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "month"
        ],
        "negativeExamples": [
          "day"
        ]
      }
    ],
    "positiveContentExamples": [
      "JAN",
      "FEB",
      "MAR",
      "APR",
      "MAY",
      "JUN",
      "JUL",
      "AUG"
    ],
    "negativeContentExamples": [
      "SEPT",
      "JANUARY",
      "JAN.",
      "02",
      "J\u00c4N",
      "AUGT",
      "NOV-",
      "MON"
    ],
    "positiveHeaderExamples": [
      "month_abbr",
      "month_abbrev",
      "month_short",
      "month_3_letter",
      "mon_abbr",
      "month_abbr_en_us",
      "short_month_name",
      "month_short_text"
    ],
    "negativeHeaderExamples": [
      "month",
      "month_name",
      "month_full",
      "month_number",
      "fiscal_month",
      "month_idx",
      "quarter_abbr",
      "weekday_abbr"
    ],
    "explanation": "This semantic type identifies three-letter month abbreviations used in US English datasets. It uses a finite list of 12 values for precise classification, with an anchored backout pattern that reflects the three-letter uppercase format to allow cautious fallback matching when header context supports it.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:07.463209"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.LAST_FIRST",
    "description": "A complete personal name formatted with the family name first, followed by a comma and space, then the given name. The expected structure is \"Last, First\" with optional additional given name tokens separated by single spaces.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z][A-Za-z]+([-'][A-Za-z]+)*)[,]{1} ([A-Z][A-Za-z]+( [A-Z][A-Za-z]+){0,2})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 5060,
    "headerPatterns": [
      {
        "regExp": "(?i).*(last[ _-]*,?[ _-]*first)[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "last, first name"
        ],
        "negativeExamples": [
          "first, last name"
        ]
      },
      {
        "regExp": "(?i).*((surname|family)[ _-]*,?[ _-]*(forename|given))[ _-]*name?.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "family, given name"
        ],
        "negativeExamples": [
          "given, family name"
        ]
      },
      {
        "regExp": "(?i).*(person|customer|employee|contact)[ _-]*(last[ _-]*,?[ _-]*first).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "customer last, first"
        ],
        "negativeExamples": [
          "customer first, last"
        ]
      },
      {
        "regExp": "(?i).*(lname[ _-]*,?[ _-]*fname).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "lname, fname"
        ],
        "negativeExamples": [
          "fname, lname"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "address"
        ]
      }
    ],
    "positiveContentExamples": [
      "Smith, John",
      "Garcia-Lopez, Ana Maria",
      "O'Connor, Sean",
      "Brown, Emily Rose",
      "D'Amico, Marco",
      "Nguyen, Thi Mai",
      "Patel, Rohan",
      "Chen, Li Wei"
    ],
    "negativeContentExamples": [
      "John Smith",
      "Smith,John",
      "Smith , John",
      "SMITH, JOHN",
      "Smith, J.",
      "Van Dyke, John",
      "Smith, Mary-Anne",
      "O'Neil, shaun"
    ],
    "positiveHeaderExamples": [
      "last, first name",
      "surname, forename",
      "customer last, first",
      "person last, first name",
      "lname, fname",
      "family, given name",
      "employee last, first",
      "contact last, first name"
    ],
    "negativeHeaderExamples": [
      "first, last name",
      "name last first",
      "full name",
      "customer_name",
      "first_name",
      "last_name",
      "surname",
      "given_name"
    ],
    "explanation": "This semantic type identifies personal names formatted specifically as family name first, followed by a comma and a single space, then the given name and optional additional given name tokens (e.g., \"Smith, John\" or \"Garcia-Lopez, Ana Maria\"). It supports hyphens and apostrophes in the family name and enforces proper capitalization to reduce ambiguity. Use this type to recognize datasets that standardize names in the \"Last, First\" presentation, especially for sorting or directory-style listings.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:09.629683"
  },
  {
    "resultType": "generated",
    "semanticType": "LANGUAGE.ISO-639-1",
    "description": "A standardized two-letter code used to represent languages according to the International Organization for Standardization ISO 639-1 standard.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4960,
    "headerPatterns": [
      {
        "regExp": "(?i).*language.*iso[_ -]?639[_ -]?1.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "language_iso_639_1_code"
        ],
        "negativeExamples": [
          "iso_3166_1_alpha2"
        ]
      },
      {
        "regExp": "(?i).*language.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "language_code"
        ],
        "negativeExamples": [
          "airport_code"
        ]
      },
      {
        "regExp": "(?i).*(lang|lng).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lang_code"
        ],
        "negativeExamples": [
          "country_code"
        ]
      },
      {
        "regExp": "(?i).*(iso[_ -]?639[_ -]?1|iso[_ -]?6391).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iso_639_1"
        ],
        "negativeExamples": [
          "iso_3166_1_alpha2"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "en",
      "FR",
      "es",
      "de",
      "pt",
      "zh",
      "ru",
      "ar"
    ],
    "negativeContentExamples": [
      "en-US",
      "eng",
      "deu",
      "e",
      "1n",
      "en_GB",
      "zh-Hans",
      "fr_CA"
    ],
    "positiveHeaderExamples": [
      "language_iso_639_1_code",
      "iso6391_language",
      "language_code",
      "lang_code",
      "iso_639_1",
      "iso639-1",
      "language"
    ],
    "negativeHeaderExamples": [
      "country_code",
      "iso_3166_1_alpha2",
      "locale",
      "region_code",
      "language_name",
      "iso_639_2",
      "content_language"
    ],
    "explanation": "This type validates standalone ISO 639-1 language codes consisting of exactly two alphabetic characters, case-insensitive (e.g., en, FR). It is intended for fields storing only the language code without regional or script extensions. The regex favors precision by requiring exactly two letters and using word boundaries, while header patterns add context to reduce conflicts with other two-letter code domains.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:10.147089"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.AGE",
    "description": "A numerical value representing a person's current age in years since birth, commonly used for demographic analysis and age verification.",
    "pluginType": "regex",
    "regexPattern": "\\b(0|[1-9]|[1-9][0-9]|1[01][0-9]|120)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5150,
    "headerPatterns": [
      {
        "regExp": "(?i).*person.*age.*years.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "person_age_years"
        ],
        "negativeExamples": [
          "account_age_years"
        ]
      },
      {
        "regExp": "(?i).*demographic.*age.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "demographic_age"
        ],
        "negativeExamples": [
          "demographic_index"
        ]
      },
      {
        "regExp": "(?i).*age_yrs.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "age_yrs"
        ],
        "negativeExamples": [
          "age_mths"
        ]
      },
      {
        "regExp": "(?i).*age.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "age"
        ],
        "negativeExamples": [
          "birth_year"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "age_number"
        ],
        "negativeExamples": [
          "age_code"
        ]
      }
    ],
    "positiveContentExamples": [
      "0",
      "1",
      "5",
      "18",
      "21",
      "34",
      "65",
      "120"
    ],
    "negativeContentExamples": [
      "03",
      "18.5",
      "121",
      "-1",
      "25 yrs",
      "100+",
      "1e2",
      "130"
    ],
    "positiveHeaderExamples": [
      "person_age_years",
      "demographic_age",
      "age_in_years",
      "age_yrs",
      "user_age",
      "customer_age",
      "profile_age",
      "age_number"
    ],
    "negativeHeaderExamples": [
      "years_of_service",
      "birth_year",
      "date_of_birth",
      "service_years",
      "tenure_years",
      "customer_since_year",
      "year_opened",
      "time_on_book_months"
    ],
    "explanation": "Identifies integer ages expressed in whole years between 0 and 120 inclusive. Useful for demographic analytics, segmentation, and age-based eligibility checks. The header patterns prioritize explicit age-in-years semantics before falling back to generic numeric terms to limit false positives.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:10.377399"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_BG",
    "description": "A four-digit numerical code used by Bulgarian postal services to identify delivery areas and facilitate mail distribution throughout Bulgaria.",
    "pluginType": "regex",
    "regexPattern": "\\b[1-9][0-9]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5230,
    "headerPatterns": [
      {
        "regExp": "(?i).*bulgarian.*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Bulgarian postal code"
        ],
        "negativeExamples": [
          "US postal code"
        ]
      },
      {
        "regExp": "(?i).*bg.*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "bg_postal_code"
        ],
        "negativeExamples": [
          "billing_postal_code"
        ]
      },
      {
        "regExp": "(?i).*(bulgaria|bg).*postcode.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Bulgaria postcode"
        ],
        "negativeExamples": [
          "UK postcode"
        ]
      },
      {
        "regExp": "(?i).*(bulgaria|bg).*zip.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "bulgaria zip code"
        ],
        "negativeExamples": [
          "us zip code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "1000",
      "1421",
      "1784",
      "4000",
      "5309",
      "7002",
      "9700"
    ],
    "negativeContentExamples": [
      "0999",
      "123",
      "12345",
      "1 234",
      "12-34",
      "1O00",
      "\u0662\u0663\u0664\u0665",
      "1000A"
    ],
    "positiveHeaderExamples": [
      "bg_postal_code",
      "Bulgarian postal code",
      "Bulgaria postcode",
      "bg postcode",
      "bulgaria zip code",
      "postal code (bg)",
      "bg_zip"
    ],
    "negativeHeaderExamples": [
      "postal code",
      "us postal code",
      "billing_postal_code",
      "shipping postcode",
      "zip code",
      "state code",
      "country code"
    ],
    "explanation": "This semantic type captures Bulgarian postal codes as four-digit numeric tokens, bounded by word boundaries to avoid matching longer numbers or embedded digits. It is intended for datasets containing address fields specific to Bulgaria and works best when paired with supportive header names indicating Bulgarian context.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:10.504735"
  },
  {
    "resultType": "generated",
    "semanticType": "FULL_ADDRESS_EN",
    "description": "A complete postal address including street number, street name with suffix, city, state/province abbreviation, and postal/ZIP code, written using English-language conventions. Typical formats include commas between street, city, and state, and use a two-letter state/province code followed by a US ZIP (5 or 9 digits) or a Canadian postal code.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{1,6}\\s+[A-Za-z0-9]+(\\s+[A-Za-z0-9\\.]+){0,4}\\s+(Street|St|Road|Rd|Avenue|Ave|Boulevard|Blvd|Lane|Ln|Drive|Dr|Court|Ct|Place|Pl|Parkway|Pkwy|Way|Highway|Hwy|Terrace|Ter|Loop|Circle|Cir|Square|Sq)\\.?\\b(\\s+(N|S|E|W|NE|NW|SE|SW))?\\s*,\\s*[A-Za-z]+([ -][A-Za-z]+){0,3}\\s*,\\s*[A-Z]{2}\\s+(\\d{5}(\\-\\d{4})?|[A-Za-z]\\d[A-Za-z][ -]?\\d[A-Za-z]\\d)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4680,
    "headerPatterns": [
      {
        "regExp": "(?i).*(full|primary).*(address).*(en).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "full_address_en"
        ],
        "negativeExamples": [
          "full_address_fr"
        ]
      },
      {
        "regExp": "(?i).*(billing|shipping|mailing|residence).*(address).*(en).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "mailing_address_en"
        ],
        "negativeExamples": [
          "shipping_address"
        ]
      },
      {
        "regExp": "(?i).*(addr).*(en).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "addr_en"
        ],
        "negativeExamples": [
          "adr_fr"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "address"
        ],
        "negativeExamples": [
          "location"
        ]
      }
    ],
    "positiveContentExamples": [
      "742 Evergreen Terrace, Springfield, IL 62704",
      "1600 Pennsylvania Ave NW, Washington, DC 20500",
      "350 5th Ave, New York, NY 10118",
      "500 W Madison St, Chicago, IL 60661",
      "1 Infinite Loop, Cupertino, CA 95014",
      "200 Bay St, Toronto, ON M5J 2J2",
      "555 Seymour St, Vancouver, BC V6B 3H6",
      "77 King Street West, Toronto, ON M5K 1A1"
    ],
    "negativeContentExamples": [
      "742 Evergreen Terrace Springfield IL 62704",
      "Evergreen Terrace, Springfield, IL 62704",
      "123 Main, Springfield, IL 62704",
      "123 Main St, Springfield, Illinois 62704",
      "123 Main St, Springfield, IL 6270",
      "10 Downing Street, London, SW1A 2AA",
      "200 Bay St, Toronto, Ontario M5J 2J2",
      "A12B Main St, Springfield, IL 62704"
    ],
    "positiveHeaderExamples": [
      "full_address_en",
      "mailing_address_en",
      "shipping_address_en",
      "billing_full_address_en",
      "contact_full_address_en",
      "residence_address_en",
      "address_en",
      "address"
    ],
    "negativeHeaderExamples": [
      "city_state_zip",
      "street",
      "postal_code",
      "address_line1",
      "region",
      "country",
      "coordinates",
      "location"
    ],
    "explanation": "This semantic type identifies complete postal addresses formatted in English, requiring a street number and name with a recognized suffix, a city, a two-letter state/province code, and a valid US ZIP or Canadian postal code. It is well-suited for detecting fully-qualified mailing/shipping addresses in datasets where English formatting is expected.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:11.840684"
  },
  {
    "resultType": "generated",
    "semanticType": "IPADDRESS.IPV6",
    "description": "A 128-bit network address identifier used in Internet Protocol version 6 to uniquely identify devices and provide significantly expanded addressing capacity.",
    "pluginType": "regex",
    "regexPattern": "\\b(([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}|([0-9A-Fa-f]{1,4}(:[0-9A-Fa-f]{1,4}){0,6})::([0-9A-Fa-f]{1,4}(:[0-9A-Fa-f]{1,4}){0,6})|::([0-9A-Fa-f]{1,4}(:[0-9A-Fa-f]{1,4}){0,6})|([0-9A-Fa-f]{1,4}(:[0-9A-Fa-f]{1,4}){0,6})::)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4940,
    "headerPatterns": [
      {
        "regExp": "(?i).*client.*ipv6.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "client_ipv6_address"
        ],
        "negativeExamples": [
          "client_ipv4_address"
        ]
      },
      {
        "regExp": "(?i).*(source|destination).*ipv6.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "source_ipv6"
        ],
        "negativeExamples": [
          "source_ip"
        ]
      },
      {
        "regExp": "(?i).*(src|dst|cli|srv).*(v6|ipv6).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "dst_v6"
        ],
        "negativeExamples": [
          "dst_ip"
        ]
      },
      {
        "regExp": "(?i).*(ipv6|ip[_ ]?v6).*(addr|address).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ipv6_addr"
        ],
        "negativeExamples": [
          "ip_address"
        ]
      },
      {
        "regExp": "(?i).*ip.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ip_address"
        ],
        "negativeExamples": [
          "mac_address"
        ]
      }
    ],
    "positiveContentExamples": [
      "2001:0db8:85a3:0000:0000:8a2e:0370:7334",
      "2001:db8:85a3:0:0:8a2e:370:7334",
      "2001:db8:85a3::8a2e:370:7334",
      "fe80::1",
      "::1",
      "2001:db8::",
      "2001:0db8::1428:57ab",
      "2001:db8:0:0:0:0:2:1"
    ],
    "negativeContentExamples": [
      "2001:db8:85a3::8a2e:370:7334:",
      "2001:db8:85a3:::8a2e:370:7334",
      "2001:db8:85a3:0:0:8a2e:370g:7334",
      "2001:db8:85a3",
      "2001:db8:85a3::8a2e::7334",
      "2001-db8-85a3-0000-0000-8a2e-0370-7334",
      "2001:db8:85a3:0:0:8a2e:370:7334:1234",
      "192.168.0.1"
    ],
    "positiveHeaderExamples": [
      "ipv6_address",
      "client_ipv6",
      "client_ipv6_address",
      "source_ipv6",
      "destination_ipv6",
      "ip_v6",
      "ipv6_addr",
      "dst_v6"
    ],
    "negativeHeaderExamples": [
      "ipv4_address",
      "ip_address",
      "mac_address",
      "hostname",
      "url",
      "email",
      "source_ip",
      "ip"
    ],
    "explanation": "This semantic type identifies IPv6 textual addresses, including fully expanded and compressed forms using ::. It is useful for parsing logs, network telemetry, and configuration datasets where IPv6 addresses appear in various normalized or shortened notations.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:12.505171"
  },
  {
    "resultType": "generated",
    "semanticType": "PERIOD.HALF",
    "description": "A six-month period designation used in business and academic contexts to represent either the first or second half of a calendar or fiscal year. Typical value formats include H1/H2, HY1/HY2, and 1H/2H, optionally combined with a year and/or FY/CY markers (e.g., FY2023 H1, 2022 H2).",
    "pluginType": "regex",
    "regexPattern": "\\b((FY|CY)\\s?\\d{2,4}\\s?[- ]?\\s?(H[12]|HY[12]|[12]H)|\\d{4}\\s?[- ]?\\s?(H[12]|HY[12]|[12]H)|(H[12]|HY[12]|[12]H)\\s?[- ]?\\s?((FY|CY)\\s?)?\\d{2,4}|(H[12]|HY[12]|[12]H))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 5120,
    "headerPatterns": [
      {
        "regExp": "(?i).*(fiscal[ _-]?year|fy)[ _-]?(half|h1|h2|hy1|hy2|1h|2h).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fiscal_year_h1"
        ],
        "negativeExamples": [
          "fy_quarter"
        ]
      },
      {
        "regExp": "(?i).*(calendar[ _-]?year|cy)[ _-]?(half|h1|h2|hy1|hy2|1h|2h).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cy_half"
        ],
        "negativeExamples": [
          "cy_q2"
        ]
      },
      {
        "regExp": "(?i).*period[ _-]?half.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "period_half"
        ],
        "negativeExamples": [
          "period_quarter"
        ]
      },
      {
        "regExp": "(?i).*\\b(h1|h2|hy1|hy2|1h|2h)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "sales_h2"
        ],
        "negativeExamples": [
          "sales_q2"
        ]
      },
      {
        "regExp": "(?i).*half.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "half"
        ],
        "negativeExamples": [
          "quarter"
        ]
      }
    ],
    "positiveContentExamples": [
      "H1",
      "H2",
      "HY1",
      "HY2",
      "1H",
      "2H",
      "H1 2024",
      "FY2023 H2",
      "H2 FY24",
      "2022 H1",
      "CY2021-H2"
    ],
    "negativeContentExamples": [
      "Q1 2023",
      "H3",
      "HY",
      "3H",
      "FY2023",
      "H12",
      "FY23 H0",
      "2HY"
    ],
    "positiveHeaderExamples": [
      "fiscal_year_h1",
      "fy_half",
      "calendar_year_half",
      "period_half",
      "sales_h2",
      "reporting_period_half",
      "half"
    ],
    "negativeHeaderExamples": [
      "quarter",
      "fy_quarter",
      "cy_q2",
      "period_quarter",
      "semester",
      "year",
      "fy2023"
    ],
    "explanation": "This semantic type detects half-year designations that indicate the first or second half of a specified or implied year in business or academic reporting. It supports common notations such as H1/H2, HY1/HY2, and 1H/2H, optionally paired with FY/CY and two- or four-digit years in either leading or trailing positions. Use this type to standardize and analyze half-year period fields across datasets where half-year periods are recorded in compact codes.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:12.690553"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.NPI_US",
    "description": "A unique 10-digit healthcare provider identification number assigned by the Centers for Medicare & Medicaid Services (CMS) to healthcare providers in the United States. Values are strictly 10 numeric digits with no separators or prefixes.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{10}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4840,
    "headerPatterns": [
      {
        "regExp": "(?i).*national.*provider.*identifier.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "national_provider_identifier"
        ],
        "negativeExamples": [
          "national_provider_id"
        ]
      },
      {
        "regExp": "(?i).*provider.*npi.*(id|number|identifier).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "provider_npi_id"
        ],
        "negativeExamples": [
          "provider_npi_flag"
        ]
      },
      {
        "regExp": "(?i).*cms.*npi.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cms_npi"
        ],
        "negativeExamples": [
          "cms_provider_type"
        ]
      },
      {
        "regExp": "(?i).*npi.*(id|number|identifier|code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "npi_number"
        ],
        "negativeExamples": [
          "provider_id"
        ]
      },
      {
        "regExp": "(?i).*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "id"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "1234567893",
      "1987654321",
      "2078567890",
      "1457382910",
      "1629394758",
      "1093857462",
      "2546678391",
      "2123456789"
    ],
    "negativeContentExamples": [
      "123456789",
      "12345678901",
      "123-456-7890",
      "123456789O",
      "NPI1234567890",
      "1234567890X",
      "12 34567890",
      "000000000"
    ],
    "positiveHeaderExamples": [
      "npi",
      "npi_number",
      "provider_npi",
      "cms_npi",
      "us_npi",
      "national_provider_identifier",
      "npi_id",
      "healthcare_provider_npi"
    ],
    "negativeHeaderExamples": [
      "provider_id",
      "npi_status",
      "npi_type",
      "medicare_id",
      "tax_id",
      "phone_number",
      "provider_npi_flag",
      "mpi"
    ],
    "explanation": "This semantic type targets U.S. National Provider Identifier (NPI) values: exact 10-digit numeric identifiers with no spaces, hyphens, or alphabetic prefixes/suffixes. Use when the column holds NPIs for healthcare providers; header cues such as 'npi', 'provider_npi', 'cms_npi', or the full phrase 'national_provider_identifier' strengthen detection.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:12.886256"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_ES",
    "description": "Spanish postal codes used for mail delivery and location identification within Spain. These are five-digit numeric codes that designate specific geographic areas for routing mail.",
    "pluginType": "regex",
    "regexPattern": "\\b(0[1-9]|[1-4][0-9]|5[0-2])[0-9]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 5270,
    "headerPatterns": [
      {
        "regExp": "(?i).*postal.*code.*es.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postal_code_es"
        ],
        "negativeExamples": [
          "postal_code_fr"
        ]
      },
      {
        "regExp": "(?i).*spanish.*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "spanish_postal_code"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      },
      {
        "regExp": "(?i).*codigo.*postal.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "codigo_postal"
        ],
        "negativeExamples": [
          "codigo_area"
        ]
      },
      {
        "regExp": "(?i).*(cp|zip).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cp_es"
        ],
        "negativeExamples": [
          "id"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "01002",
      "08001",
      "28013",
      "41001",
      "46023",
      "29015",
      "35010",
      "52006"
    ],
    "negativeContentExamples": [
      "00000",
      "99500",
      "2801",
      "280130",
      "28A13",
      "5 2003",
      "280-13",
      "53001"
    ],
    "positiveHeaderExamples": [
      "postal_code_es",
      "spanish_postal_code",
      "codigo_postal",
      "cp_es",
      "codigo-postal",
      "postal_code",
      "zip_es",
      "codigo_postal_es"
    ],
    "negativeHeaderExamples": [
      "zipcode",
      "address",
      "province_code",
      "country_code",
      "postalcode_pt",
      "postal_code_fr",
      "codigo_postal_mx",
      "area_code"
    ],
    "explanation": "This semantic type detects Spanish postal codes, which are five-digit numeric identifiers used by the Spanish postal system. The pattern enforces valid provincial prefixes (01\u201352) followed by three digits, ensuring realistic and accurate identification of Spanish postal codes in datasets.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:13.080855"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.VAT_<COUNTRY>",
    "description": "A Value Added Tax identification number used by businesses for tax registration and reporting across different countries.",
    "pluginType": "regex",
    "regexPattern": "\\bVAT[ _-]?[A-Z]{2}[ _-]?[A-Z0-9]{8,12}\\b|\\b[A-Z]{2}[ _-]?[A-Z0-9]{8,12}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 4890,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bvat[_ ]?(id|number|no|registration|reg)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "vat_id"
        ],
        "negativeExamples": [
          "tax_id"
        ]
      },
      {
        "regExp": "(?i).*\\bvat[_ ]?[a-z]{2}\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "vat_gb"
        ],
        "negativeExamples": [
          "vat_rate"
        ]
      },
      {
        "regExp": "(?i).*\\bvalue[_ ]added[_ ]tax\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "value_added_tax_number"
        ],
        "negativeExamples": [
          "sales_tax_code"
        ]
      },
      {
        "regExp": "(?i).*\\bvat[_ ]?reg\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "vat_reg_no"
        ],
        "negativeExamples": [
          "vat_amount"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "DE123456789",
      "FR12A3456789",
      "IT12345678901",
      "ESX1234567X",
      "PL1234567890",
      "NL123456789B01",
      "VAT-DE123456789",
      "VAT GB12345678"
    ],
    "negativeContentExamples": [
      "DE1234567",
      "DE1234567890123",
      "VAT-123456789",
      "D3-123456789",
      "DE 1234 5678",
      "FR_1234567",
      "VA-GB12345678",
      "VAT-DE12-345678"
    ],
    "positiveHeaderExamples": [
      "vat_id",
      "vat_number",
      "eu_vat_number",
      "supplier_vat_id",
      "company_vat_no",
      "customer_vat_registration",
      "vat_gb",
      "vat_de"
    ],
    "negativeHeaderExamples": [
      "tax_id",
      "gst_number",
      "vat_rate",
      "vat_amount",
      "tin",
      "ein_number",
      "fiscal_code",
      "product_code"
    ],
    "explanation": "This semantic type identifies VAT registration numbers that typically include a two-letter country prefix and an 8\u201312 character alphanumeric body, with optional 'VAT' prefix and separators between the prefix and the body. It targets business identifiers used for VAT reporting rather than monetary values or tax rates. The header strategy prioritizes explicit VAT field names before falling back to the primitive 'code' term.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:13.757146"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.LAST",
    "description": "A family name or surname that identifies the family lineage and is typically shared among family members and passed down through generations.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Za-z]{1,40})([-' ][A-Za-z]{2,40}){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5050,
    "headerPatterns": [
      {
        "regExp": "(?i).*customer.*last.*name.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "customer_last_name"
        ],
        "negativeExamples": [
          "customer_first_name"
        ]
      },
      {
        "regExp": "(?i).*person.*(last|surname|family).*(name|nm).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "person_last_name"
        ],
        "negativeExamples": [
          "person_first_name"
        ]
      },
      {
        "regExp": "(?i).*(billing|shipping|user|account).*last.*name.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "billing_last_name"
        ],
        "negativeExamples": [
          "billing_address_name"
        ]
      },
      {
        "regExp": "(?i).*(surname|family[_-]?name|last[_-]?name|lname|last_nm|l_name).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "surname"
        ],
        "negativeExamples": [
          "full_name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Smith",
      "O'Neil",
      "De la Cruz",
      "van der Meer",
      "McDonald",
      "D'Amato",
      "Li",
      "Ng"
    ],
    "negativeContentExamples": [
      "Smith Jr.",
      "O\u2019Neil",
      "De_la_Cruz",
      "Li.",
      "O''Neil",
      "Sm1th",
      "O'Neil3",
      "van--der-Meer"
    ],
    "positiveHeaderExamples": [
      "customer_last_name",
      "person_last_name",
      "surname",
      "family_name",
      "last_nm",
      "l_name",
      "user_lname",
      "billing_last_name"
    ],
    "negativeHeaderExamples": [
      "first_name",
      "full_name",
      "company_name",
      "given_name",
      "middle_name",
      "last_update_date",
      "account_number",
      "postal_code"
    ],
    "explanation": "This semantic type detects last names/surnames that may include hyphens, apostrophes, and multi-token family names separated by spaces. It is intended for person identity contexts where only the family name is stored, not full names or given names.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:14.335597"
  },
  {
    "resultType": "generated",
    "semanticType": "NATIONALITY_EN",
    "description": "A person's legal relationship to a nation-state, indicating citizenship, origin, or cultural affiliation as expressed in English language terms. Values are English demonyms such as American, South African, or New Zealander, typically used to describe nationality rather than a country name.\nThis type identifies nationality adjectives/demonyms and not country names or languages.",
    "pluginType": "regex",
    "regexPattern": "\\b(([A-Z][a-z]{2,}\\s){0,2}[A-Z][a-z]{2,}(ian|ean|an|ese|ish|i|er|ic)|Swiss|Thai|Czech|Greek|Dutch|Welsh)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 5100,
    "headerPatterns": [
      {
        "regExp": "(?i).*(person|applicant|customer|employee|passenger).*(nationality|citizenship).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "applicant_nationality"
        ],
        "negativeExamples": [
          "customer_country"
        ]
      },
      {
        "regExp": "(?i).*(country|place).*of.*(citizenship|nationality).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "country_of_citizenship"
        ],
        "negativeExamples": [
          "country_of_residence"
        ]
      },
      {
        "regExp": "(?i).*(citizenship|citizen).*status.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "citizenship_status"
        ],
        "negativeExamples": [
          "marital_status"
        ]
      },
      {
        "regExp": "(?i).*(citizenship|nationality).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "citizenship"
        ],
        "negativeExamples": [
          "country_code"
        ]
      },
      {
        "regExp": "(?i).*nationality.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nationality"
        ],
        "negativeExamples": [
          "country"
        ]
      }
    ],
    "positiveContentExamples": [
      "American",
      "British",
      "Canadian",
      "Chinese",
      "South African",
      "New Zealander",
      "Saudi Arabian",
      "Swiss"
    ],
    "negativeContentExamples": [
      "United States",
      "England",
      "Africa",
      "New Zealand",
      "American Samoa",
      "Brazilian-Portuguese",
      "U.S.",
      "EU"
    ],
    "positiveHeaderExamples": [
      "nationality",
      "person_nationality",
      "citizenship",
      "country_of_citizenship",
      "customer_citizenship",
      "applicant_nationality",
      "passport_nationality",
      "citizenship_status"
    ],
    "negativeHeaderExamples": [
      "country",
      "language",
      "ethnicity",
      "residence_country",
      "birth_country",
      "region",
      "state",
      "visa_status"
    ],
    "explanation": "This semantic type captures English demonyms and nationality descriptors that indicate an individual's citizenship or national affiliation (e.g., American, Brazilian, South African, New Zealander, Swiss). It is intended for fields representing a person's nationality, often used in customer, applicant, travel, or HR datasets. The regex emphasizes typical demonym suffixes and common two- or three-word constructions while including a few irregular forms, and header patterns prioritize explicit mentions of nationality or citizenship.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:16.783673"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.YEAR_OF_BIRTH",
    "description": "The calendar year in which a person was born, used for age calculation, generational analysis, and demographic categorization.",
    "pluginType": "regex",
    "regexPattern": "\\b(18[0-9]{2}|19[0-9]{2}|20[0-9]{2})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5210,
    "headerPatterns": [
      {
        "regExp": "(?i).*year[ _]?of[ _]?birth.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "year_of_birth"
        ],
        "negativeExamples": [
          "date_of_birth"
        ]
      },
      {
        "regExp": "(?i).*birth[ _]?year.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "birth year"
        ],
        "negativeExamples": [
          "birth_date"
        ]
      },
      {
        "regExp": "(?i).*\\byob\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "yob"
        ],
        "negativeExamples": [
          "dob"
        ]
      },
      {
        "regExp": "(?i).*person.*birth.*year.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "person_birth_year"
        ],
        "negativeExamples": [
          "customer_birth_year"
        ]
      },
      {
        "regExp": "(?i).*birth[ _]?yr.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "birth_yr"
        ],
        "negativeExamples": [
          "hire_yr"
        ]
      },
      {
        "regExp": "(?i).*year.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "year"
        ],
        "negativeExamples": [
          "date"
        ]
      }
    ],
    "positiveContentExamples": [
      "1985",
      "2001",
      "1970",
      "1999",
      "2010",
      "1963",
      "1900",
      "2005"
    ],
    "negativeContentExamples": [
      "85",
      "198",
      "2100",
      "0000",
      "20A0",
      "11990",
      "17-90",
      "196"
    ],
    "positiveHeaderExamples": [
      "year_of_birth",
      "birth_year",
      "yob",
      "person_birth_year",
      "birth_yr",
      "yr_of_birth",
      "yearborn",
      "child_birth_year"
    ],
    "negativeHeaderExamples": [
      "date_of_birth",
      "dob",
      "birthdate",
      "age",
      "anniversary_date",
      "hire_date",
      "birth_month",
      "graduation_date"
    ],
    "explanation": "Represents a 4-digit calendar year indicating when a person was born. Useful for age computation, cohort segmentation, and demographic analysis.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:17.084093"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_AU",
    "description": "A four-digit numerical code used by Australia Post to identify geographic delivery areas for mail sorting and distribution across Australia.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5220,
    "headerPatterns": [
      {
        "regExp": "(?i).*australia.*postal.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "australia postal code"
        ],
        "negativeExamples": [
          "canada postal code"
        ]
      },
      {
        "regExp": "(?i).*au.*postcode.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "au_postcode"
        ],
        "negativeExamples": [
          "uk_postcode"
        ]
      },
      {
        "regExp": "(?i).*au.*post.*code.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "shipping_post_code_au"
        ],
        "negativeExamples": [
          "shipping_post_code_us"
        ]
      },
      {
        "regExp": "(?i).*postcode.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_postcode"
        ],
        "negativeExamples": [
          "customer_postal_address"
        ]
      },
      {
        "regExp": "(?i).*pcode.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "billing_pcode"
        ],
        "negativeExamples": [
          "billing_zip"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "postcode_code"
        ],
        "negativeExamples": [
          "country_name"
        ]
      }
    ],
    "positiveContentExamples": [
      "0200",
      "0800",
      "0872",
      "2000",
      "2612",
      "3000",
      "4217",
      "6000"
    ],
    "negativeContentExamples": [
      "02108",
      "800",
      "2000A",
      "A200",
      "20 00",
      "200-0",
      "2O00",
      "12-34"
    ],
    "positiveHeaderExamples": [
      "australia postal code",
      "au_postcode",
      "postcode_au",
      "shipping_postcode_au",
      "customer_postcode",
      "billing_postcode",
      "delivery_postcode_au",
      "recipient_postcode"
    ],
    "negativeHeaderExamples": [
      "zip_code",
      "postal_code_ca",
      "uk_postcode",
      "country_code",
      "state_code",
      "area_code",
      "year",
      "invoice_code"
    ],
    "explanation": "This semantic type detects Australian postcodes as exactly four consecutive digits bounded by word boundaries, allowing leading zeros. It is intended for columns storing Australia Post delivery area codes. The value pattern is intentionally strict to avoid matching mixed-format or punctuated numeric strings, with header patterns guiding identification toward Australian postal code contexts.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:17.118409"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.AGE_RANGE",
    "description": "A span of ages expressed as a minimum and maximum value, used for demographic categorization and age-group analysis. This includes numeric ranges like 18-24, 25 to 34, or 35\u201344 and excludes single ages or open-ended forms.",
    "pluginType": "regex",
    "regexPattern": "\\b([0-9]{1,3})\\s*([-\u2013\u2014]|[Tt][Oo])\\s*([0-9]{1,3})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 5160,
    "headerPatterns": [
      {
        "regExp": "(?i).*(customer|member|applicant)[ _-]*age[ _-]*(range|band|bracket|group).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "customer_age_range"
        ],
        "negativeExamples": [
          "customer_age"
        ]
      },
      {
        "regExp": "(?i).*age[ _-]*(range|band|bracket|group).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "age_range"
        ],
        "negativeExamples": [
          "age_estimate"
        ]
      },
      {
        "regExp": "(?i).*(agegrp|agegrp|agerng|age_rng|ageband).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "agegrp"
        ],
        "negativeExamples": [
          "avg_age"
        ]
      },
      {
        "regExp": "(?i).*(demograph|demo)[ _-]*age.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "demographic_age"
        ],
        "negativeExamples": [
          "demographic_group"
        ]
      },
      {
        "regExp": "(?i).*age.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "age"
        ],
        "negativeExamples": [
          "dob"
        ]
      }
    ],
    "positiveContentExamples": [
      "0-9",
      "5\u201311",
      "10\u201319",
      "18 to 24",
      "25 - 34",
      "35\u201444",
      "45 - 54",
      "100-120"
    ],
    "negativeContentExamples": [
      "18/24",
      "18 and 24",
      "18 to twenty-four",
      "to 24",
      "18 to",
      "2018-2024",
      "18\u2014",
      "\u2014 24"
    ],
    "positiveHeaderExamples": [
      "age_range",
      "age band",
      "customer_age_range",
      "applicant_age_bracket",
      "member_age_group",
      "demographic_age_range",
      "age_bracket",
      "age_group"
    ],
    "negativeHeaderExamples": [
      "age",
      "average_age",
      "age_estimate",
      "min_age",
      "max_age",
      "dob",
      "birth_year",
      "age_category"
    ],
    "explanation": "This semantic type detects age ranges represented by two numeric ages with a clear separator (hyphen, en/em dash, or the word 'to'), enabling grouping and demographic segmentation tasks. It excludes single ages and open-ended expressions like '65+' or phrases that do not present both numeric bounds.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:19.730553"
  },
  {
    "resultType": "generated",
    "semanticType": "JOB_TITLE_EN",
    "description": "A professional position or role designation that describes an individual's function, responsibilities, or occupation within an organization.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z]{2,6})\\b|\\b([A-Za-z]{2,}|[A-Za-z]{1,3}\\.|[A-Za-z]+/[A-Za-z]+)([ -]([A-Z]{2,6}|[A-Za-z]{2,}|[A-Za-z]{1,3}\\.|of|and|for|the|in|to|&|[A-Za-z]+/[A-Za-z]+))\\b([ -]([A-Z]{2,6}|[A-Za-z]{2,}|[A-Za-z]{1,3}\\.|of|and|for|the|in|to|&|[A-Za-z]+/[A-Za-z]+)){0,4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4950,
    "headerPatterns": [
      {
        "regExp": "(?i).*employee.*job.*title.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "employee_job_title"
        ],
        "negativeExamples": [
          "employee_name"
        ]
      },
      {
        "regExp": "(?i).*(position|role).*title.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "position_title"
        ],
        "negativeExamples": [
          "job_code"
        ]
      },
      {
        "regExp": "(?i).*job.*(title|role|position).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "job_title"
        ],
        "negativeExamples": [
          "job_status"
        ]
      },
      {
        "regExp": "(?i).*(jt|posn).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "jt"
        ],
        "negativeExamples": [
          "id"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "position_name"
        ],
        "negativeExamples": [
          "department"
        ]
      }
    ],
    "positiveContentExamples": [
      "Senior Software Engineer",
      "VP of Sales",
      "Chief Technology Officer",
      "Sr. Product Manager",
      "Marketing Director",
      "Lead QA Analyst",
      "Head of Operations",
      "Customer Success Manager"
    ],
    "negativeContentExamples": [
      "C++ Developer",
      "3D Artist",
      "R&D Manager",
      "Director, Sales",
      "Manager/Supervisor",
      "VP/GM",
      "Level 2 Support",
      "Engineer (Electrical)"
    ],
    "positiveHeaderExamples": [
      "employee_job_title",
      "job_title",
      "position_title",
      "role_title",
      "employee_position",
      "position_name",
      "job_role",
      "staff_role"
    ],
    "negativeHeaderExamples": [
      "department",
      "employee_id",
      "company",
      "category",
      "division",
      "cost_center",
      "project",
      "location"
    ],
    "explanation": "The type identifies English job titles found in HR, recruiting, and organizational datasets. It supports common multi-word titles, acronyms (e.g., CEO, VP), dotted abbreviations (e.g., Sr.), and connector words like of/and/for. Header patterns prioritize specific phrases (employee job title) before broader category terms, ending with the primitive 'name' to align with NAME category.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:20.284265"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_SE",
    "description": "Swedish postal codes utilized by PostNord for mail distribution and geographic identification throughout Sweden. These five-digit codes are formatted with a space between the third and fourth digits for improved readability.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{3} \\d{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 5340,
    "headerPatterns": [
      {
        "regExp": "(?i).*swedish.*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Swedish Postal Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*se.*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SE Postal Code"
        ],
        "negativeExamples": [
          "US Postal Code"
        ]
      },
      {
        "regExp": "(?i).*(postnummer|postnr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postnummer"
        ],
        "negativeExamples": [
          "Postort"
        ]
      },
      {
        "regExp": "(?i).*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "Postal Area"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "114 55",
      "411 03",
      "981 07",
      "123 45",
      "752 63",
      "216 14",
      "903 28",
      "621 41"
    ],
    "negativeContentExamples": [
      "11455",
      "11 455",
      "114-55",
      "114 5",
      "114 555",
      "A14 55",
      "114 5B",
      "11A 55"
    ],
    "positiveHeaderExamples": [
      "Swedish Postal Code",
      "SE Postal Code",
      "Postnummer",
      "Postnr",
      "Postal Code SE",
      "Sweden Post Code",
      "Billing Postal Code (SE)",
      "Recipient Postnummer"
    ],
    "negativeHeaderExamples": [
      "ZIP Code",
      "Country Code",
      "Postort",
      "Postal Area",
      "Region Code",
      "Postcode UK",
      "Address Line",
      "Province Code"
    ],
    "explanation": "This semantic type identifies Swedish postal codes in the standard five-digit format with a single space between the third and fourth digits (DDD DD). It is useful for validating, parsing, and geolocating Swedish addresses where strict postal code formatting is required.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:21.764886"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.DATE_OF_BIRTH",
    "description": "The specific calendar date on which a person was born, used for identity verification, age calculation, and demographic analysis.",
    "pluginType": "regex",
    "regexPattern": "\\b(\\d{4}[-/.]\\d{1,2}[-/.]\\d{1,2}|\\d{1,2}[-/.]\\d{1,2}[-/.]\\d{4}|(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Sept|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)\\s+\\d{1,2},\\s+\\d{4}|(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Sept|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)\\s+\\d{1,2}\\s+\\d{4}|\\d{1,2}\\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Sept|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)\\s+\\d{4})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 5170,
    "headerPatterns": [
      {
        "regExp": "(?i).*(date.*of.*birth|birth.*date).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "date_of_birth"
        ],
        "negativeExamples": [
          "birth_place"
        ]
      },
      {
        "regExp": "(?i).*(person|individual|applicant|member).*(date.*of.*birth|birth.*date|dob).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "person_dob"
        ],
        "negativeExamples": [
          "person_age"
        ]
      },
      {
        "regExp": "(?i).*(birthdate|birth[_ ]?day).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "birthdate"
        ],
        "negativeExamples": [
          "hire_date"
        ]
      },
      {
        "regExp": "(?i).*(dob|bdate|birth[_ ]?dt).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "dob"
        ],
        "negativeExamples": [
          "doa"
        ]
      },
      {
        "regExp": "(?i).*date.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "date"
        ],
        "negativeExamples": [
          "time"
        ]
      }
    ],
    "positiveContentExamples": [
      "1990-01-05",
      "05/01/1990",
      "1/5/1990",
      "1990/1/5",
      "Jan 5, 1990",
      "January 5 1990",
      "5 Sept 1985",
      "5 September 1985"
    ],
    "negativeContentExamples": [
      "12/25/85",
      "19900101",
      "05-Jan-1990",
      "Jan-05-1990",
      "05_12_1990",
      "5 Jan 88",
      "1990 January 1",
      "1st January 1990"
    ],
    "positiveHeaderExamples": [
      "date_of_birth",
      "birth date",
      "person_dob",
      "applicant_birthdate",
      "member_bday",
      "dob",
      "birth_dt",
      "individual_birth_date"
    ],
    "negativeHeaderExamples": [
      "age",
      "birth_place",
      "anniversary_date",
      "hire_date",
      "created_date",
      "doa",
      "due_date",
      "time"
    ],
    "explanation": "Identifies cells containing a person's date of birth across common numeric and textual date formats with clear separators. Useful for identity verification, age computation, and demographic analytics while avoiding over-broad matches by requiring four-digit years and explicit tokens. Header patterns prioritize explicit DOB and birthdate cues, then fall back to the primitive 'date' term.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:21.888717"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_IN",
    "description": "Indian PIN codes used by India Post for mail sorting and delivery across the country. These six-digit numerical identifiers help organize postal delivery to specific geographic regions within India.",
    "pluginType": "regex",
    "regexPattern": "\\b[1-9][0-9]{2}[ -]?[0-9]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 5290,
    "headerPatterns": [
      {
        "regExp": "(?i).*(india|indian|in).*(pin.*code|pincode).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "india_pin_code"
        ],
        "negativeExamples": [
          "pin_status"
        ]
      },
      {
        "regExp": "(?i).*postal.*code.*(india|indian|in).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "postal_code_in"
        ],
        "negativeExamples": [
          "postal_area"
        ]
      },
      {
        "regExp": "(?i).*(pin.*code|pincode).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "delivery_pin_code"
        ],
        "negativeExamples": [
          "bank_pin_code"
        ]
      },
      {
        "regExp": "(?i).*address.*pin.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "address_pin_code"
        ],
        "negativeExamples": [
          "address_line"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "number"
        ]
      }
    ],
    "positiveContentExamples": [
      "110001",
      "560 001",
      "400001",
      "700 016",
      "600-034",
      "302015",
      "781005",
      "641 045"
    ],
    "negativeContentExamples": [
      "011001",
      "5600 01",
      "560_001",
      "560- 001",
      "5600011",
      "56001",
      "56 0001",
      "560A01"
    ],
    "positiveHeaderExamples": [
      "india_pin_code",
      "indian_postal_code",
      "pin_code_india",
      "pincode",
      "delivery_pin_code",
      "postal_code_in",
      "address_pin_code",
      "postal_code"
    ],
    "negativeHeaderExamples": [
      "zip_code",
      "area_code",
      "country_code",
      "pin_status",
      "postal_area",
      "pin_attempts",
      "bank_pin_code",
      "address_line"
    ],
    "explanation": "This semantic type identifies Indian PIN (Postal Index Number) codes: six-digit numbers used by India Post, beginning with digits 1\u20139 and often written as a contiguous 6-digit sequence or with a separator after the third digit (space or hyphen). It is useful for validating and parsing mailing addresses, geocoding, and routing within India. The pattern is strict to avoid confusion with other numeric identifiers or non-Indian postal formats.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:22.511488"
  },
  {
    "resultType": "generated",
    "semanticType": "PERIOD.QUARTER",
    "description": "A three-month period designation used in business and financial contexts to represent fiscal or calendar quarters within a year.",
    "pluginType": "regex",
    "regexPattern": "\\b(Q[1-4])\\b(\\s*[-/ ]\\s*((FY|FISCAL|CAL|CALENDAR)\\s*)?((19|20)\\d\\d))?\\b|\\b((FY|FISCAL|CAL|CALENDAR)\\s*)?((19|20)\\d\\d)\\s*[-/ ]\\s*(Q[1-4])\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 5130,
    "headerPatterns": [
      {
        "regExp": "(?i).*(fiscal|fy).*(quarter).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fiscal_quarter"
        ],
        "negativeExamples": [
          "fiscal_year"
        ]
      },
      {
        "regExp": "(?i).*(calendar|cal).*(quarter).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "calendar_quarter"
        ],
        "negativeExamples": [
          "calendar_year"
        ]
      },
      {
        "regExp": "(?i).*(reporting|report|statement|stmt).*(quarter).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "reporting_quarter"
        ],
        "negativeExamples": [
          "reporting_period"
        ]
      },
      {
        "regExp": "(?i).*(quarter).*(year|yr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "quarter_of_year"
        ],
        "negativeExamples": [
          "month_of_year"
        ]
      },
      {
        "regExp": "(?i).*(qtr).*(number|num|no).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "qtr_number"
        ],
        "negativeExamples": [
          "month_number"
        ]
      },
      {
        "regExp": "(?i).*quarter.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "quarter"
        ],
        "negativeExamples": [
          "month"
        ]
      }
    ],
    "positiveContentExamples": [
      "Q1",
      "Q2 2023",
      "2021 Q3",
      "FY2022 Q4",
      "Q1 FY2020",
      "2020-Q2",
      "Q3-2019",
      "FISCAL 2023 Q2"
    ],
    "negativeContentExamples": [
      "Q5",
      "Quarter 2",
      "2023Q2",
      "Q2-23",
      "FY23 Q2",
      "Q 3 2021",
      "2021Q3",
      "Q2/202A"
    ],
    "positiveHeaderExamples": [
      "fiscal_quarter",
      "calendar_quarter",
      "reporting_quarter",
      "quarter_of_year",
      "qtr_number",
      "quarter"
    ],
    "negativeHeaderExamples": [
      "fiscal_year",
      "calendar_year",
      "reporting_period",
      "month_of_year",
      "month_number",
      "semester"
    ],
    "explanation": "Identifies quarter designations in data fields, supporting standalone quarter tokens (Q1\u2013Q4) and common formats with years or fiscal labels on either side (e.g., FY2022 Q4, 2020-Q2). Useful for parsing and normalizing fiscal/calendar reporting periods in finance, accounting, and analytics workflows.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:23.081369"
  },
  {
    "resultType": "generated",
    "semanticType": "IMEI",
    "description": "A unique 15-digit identifier assigned to every mobile device for tracking and identification across cellular networks worldwide. The last digit is a Luhn check digit, and the value consists only of numeric characters with no separators.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{15}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4900,
    "headerPatterns": [
      {
        "regExp": "(?i).*imei.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "imei_number"
        ],
        "negativeExamples": [
          "serial_number"
        ]
      },
      {
        "regExp": "(?i).*device.*imei.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "device_imei"
        ],
        "negativeExamples": [
          "device_id"
        ]
      },
      {
        "regExp": "(?i).*(mobile|handset).*imei.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mobile_imei"
        ],
        "negativeExamples": [
          "mobile_model"
        ]
      },
      {
        "regExp": "(?i).*imei.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "imei"
        ],
        "negativeExamples": [
          "meid"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "352099001761481",
      "490154203237518",
      "356938035643809",
      "353918050038132",
      "355031079637429",
      "867400020123456",
      "861234050987654",
      "359876051234567"
    ],
    "negativeContentExamples": [
      "35209900176148",
      "3520990017614812",
      "35-209900-176148-1",
      "35209900176148A",
      "O52099001761481",
      "3520 9900 176148 1",
      "3520990017614",
      "352099001761481a"
    ],
    "positiveHeaderExamples": [
      "imei",
      "imei_number",
      "device_imei",
      "mobile_imei",
      "handset_imei",
      "imei_code",
      "imei_num"
    ],
    "negativeHeaderExamples": [
      "meid",
      "serial_number",
      "device_id",
      "imsi",
      "iccid",
      "mac_address",
      "area_code",
      "hardware_key"
    ],
    "explanation": "This semantic type targets 15-digit IMEI values used to identify mobile equipment. The regex focuses on a strict 15-digit numeric token bounded by word boundaries to avoid matching within longer strings or formatted variants. Use cases include telecom records, device inventory exports, and fraud or compliance datasets where raw IMEIs are stored without separators.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:24.418397"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.RACE_ABBR_EN",
    "description": "Abbreviated codes representing racial or ethnic categories used in demographic data collection and analysis, typically single letters or short abbreviations.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "W",
      "B",
      "A",
      "H",
      "N",
      "O",
      "U",
      "D",
      "M",
      "NH",
      "PI",
      "AI",
      "AN",
      "P",
      "MR",
      "AS"
    ],
    "backout": "^[A-Z]{1,2}$",
    "confidenceThreshold": 95,
    "priority": 5190,
    "headerPatterns": [
      {
        "regExp": "(?i).*race.*ethnic.*abbr.*en.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "race_ethnic_abbr_en"
        ],
        "negativeExamples": [
          "race_ethnic_name_en"
        ]
      },
      {
        "regExp": "(?i).*race.*ethnic.*code.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "race_ethnicity_code"
        ],
        "negativeExamples": [
          "ethnicity_code"
        ]
      },
      {
        "regExp": "(?i).*race.*abbr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "race_abbr"
        ],
        "negativeExamples": [
          "race_desc"
        ]
      },
      {
        "regExp": "(?i).*race.*cd.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "race_cd"
        ],
        "negativeExamples": [
          "race_id"
        ]
      },
      {
        "regExp": "(?i).*ethn.*code.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "ethn_code"
        ],
        "negativeExamples": [
          "ethn_group"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "W",
      "B",
      "A",
      "H",
      "N",
      "O",
      "NH",
      "PI"
    ],
    "negativeContentExamples": [
      "WB",
      "HI",
      "AIAN",
      "BLK",
      "WH",
      "UNK",
      "N/A",
      "ASI"
    ],
    "positiveHeaderExamples": [
      "race_ethnic_abbr_en",
      "race_ethnicity_code",
      "race_ethnic_code",
      "race_abbr",
      "ethn_code",
      "race_cd",
      "person_race_code",
      "demographic_race_code"
    ],
    "negativeHeaderExamples": [
      "race",
      "race_name",
      "race_description",
      "ethnicity",
      "ethnic_group",
      "person_race",
      "racial_category",
      "demographic_group"
    ],
    "explanation": "This semantic type targets short, English-language abbreviations used to encode race or ethnicity in datasets. It is intended for columns storing compact demographic codes rather than full descriptive labels, enabling precise detection of typical single- or two-character values.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:25.323421"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_UY",
    "description": "Uruguayan postal codes used by Correo Uruguayo for mail delivery and location identification throughout Uruguay. These five-digit numerical codes help organize postal distribution to specific geographic areas within the country.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 5360,
    "headerPatterns": [
      {
        "regExp": "(?i).*(uruguay|uruguayan|uy).*postal.*code.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "uruguay_postal_code"
        ],
        "negativeExamples": [
          "postal_code_ar"
        ]
      },
      {
        "regExp": "(?i).*(uruguay|uy).*(codigo|cod).*postal.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "codigo_postal_uruguay"
        ],
        "negativeExamples": [
          "codigo_postal"
        ]
      },
      {
        "regExp": "(?i).*(uruguay|uy).*zip.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "uy_zip_code"
        ],
        "negativeExamples": [
          "zip_code"
        ]
      },
      {
        "regExp": "(?i).*(uruguay|uy).*\\bcp\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "cp_uy"
        ],
        "negativeExamples": [
          "cp"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "postal"
        ]
      }
    ],
    "positiveContentExamples": [
      "11000",
      "11300",
      "12050",
      "20000",
      "27002",
      "30010",
      "45000",
      "70001"
    ],
    "negativeContentExamples": [
      "1130",
      "113000",
      "11 300",
      "1130O",
      "A11300",
      "11300A",
      "113-00",
      "11.300"
    ],
    "positiveHeaderExamples": [
      "uruguay_postal_code",
      "uy_postal_code",
      "codigo_postal_uruguay",
      "codigo_postal_uy",
      "uruguay_zip_code",
      "cp_uy",
      "uruguayan_postal_code",
      "postal_code_uy"
    ],
    "negativeHeaderExamples": [
      "postal_code",
      "zip_code",
      "codigo_postal",
      "postal_code_ar",
      "country_code",
      "uruguay_area_code",
      "address_code",
      "uruguay_phone_number"
    ],
    "explanation": "This semantic type identifies Uruguayan postal codes, which are strictly five-digit numeric values assigned for mail distribution across Uruguay. It is best used for datasets where values are plain five-digit codes and header context indicates Uruguay-specific postal data. The regex relies on word boundaries to minimize false positives in mixed-content strings, while header patterns prioritize country-qualified terms to distinguish UY postal codes from other five-digit postal systems.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:27.707280"
  },
  {
    "resultType": "generated",
    "semanticType": "NATIONALITY_NL",
    "description": "Dutch-language demonyms and nationality terms indicating a person's legal citizenship or national origin (e.g., Nederlands, Belgisch, Amerikaan). Values are single-word Dutch forms commonly used to denote nationality.",
    "pluginType": "regex",
    "regexPattern": "\\b(Nederlander|Nederlandse|Nederlands|Belgische|Belgisch|Belg|Duitse|Duits|Duitser|Franse|Frans|Fransman|Spaanse|Spaans|Spanjaard|Italiaanse|Italiaans|Italiaan|Portugese|Portugees|Poolse|Pools|Pool|Zweedse|Zweeds|Zweed|Noorse|Noors|Noor|Deense|Deens|Deen|Britse|Brits|Brit|Ierse|Iers|Ier|Amerikaanse|Amerikaans|Amerikaan|Canadese|Canadees|Mexicaanse|Mexicaans|Mexicaan|Turkse|Turks|Turk|Marokkaanse|Marokkaans|Marokkaan|Surinaamse|Surinaams|Surinamer|Indonesische|Indonesisch|Indonees|Chinese|Chinees|Japanse|Japans|Japanner|Russische|Russisch|Rus)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 5110,
    "headerPatterns": [
      {
        "regExp": "(?i).*(persoon|klant|burger).*nationaliteit.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "persoon_nationaliteit"
        ],
        "negativeExamples": [
          "persoon_land"
        ]
      },
      {
        "regExp": "(?i).*nationaliteit.*nl.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nationaliteit_nl"
        ],
        "negativeExamples": [
          "nationality_nl"
        ]
      },
      {
        "regExp": "(?i).*(staatsburgerschap|demoniem).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "staatsburgerschap"
        ],
        "negativeExamples": [
          "taal"
        ]
      },
      {
        "regExp": "(?i).*(land[ _]van[ _]herkomst).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "land_van_herkomst"
        ],
        "negativeExamples": [
          "herkomst_land"
        ]
      },
      {
        "regExp": "(?i).*nationaliteit.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nationaliteit"
        ],
        "negativeExamples": [
          "staatsburgerschap"
        ]
      }
    ],
    "positiveContentExamples": [
      "Nederlands",
      "Nederlandse",
      "Nederlander",
      "Belgisch",
      "Duitse",
      "Frans",
      "Spanjaard",
      "Amerikaan"
    ],
    "negativeContentExamples": [
      "Nederland",
      "Duitsland",
      "Franseman",
      "Portugezen",
      "Italian",
      "Turkije",
      "Russen",
      "Canadisch"
    ],
    "positiveHeaderExamples": [
      "nationaliteit",
      "nationaliteit_nl",
      "persoon_nationaliteit",
      "klant_nationaliteit",
      "staatsburgerschap",
      "land_van_herkomst",
      "demoniem_nl",
      "nationaliteit_beschrijving"
    ],
    "negativeHeaderExamples": [
      "land",
      "land_code",
      "geboorteland",
      "etniciteit",
      "taal",
      "naam",
      "residentieland",
      "landnaam_nl"
    ],
    "explanation": "This semantic type identifies Dutch-language nationality (demonym) values that denote a person's citizenship or national origin. It is useful for datasets capturing personal attributes where nationality is represented in Dutch as a single-word term rather than a country name or code.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:27.817021"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_NL",
    "description": "Dutch postal codes used by PostNL for mail sorting and delivery throughout the Netherlands. These alphanumeric codes combine four digits with two letters and a space to create precise geographic identification.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{4} [A-Z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 5320,
    "headerPatterns": [
      {
        "regExp": "(?i).*netherlands.*postal.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "netherlands_postal_code"
        ],
        "negativeExamples": [
          "postal_code_nl"
        ]
      },
      {
        "regExp": "(?i).*nl.*postal.*code.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "nl_postal_code"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      },
      {
        "regExp": "(?i).*dutch.*postcode.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "dutch_postcode"
        ],
        "negativeExamples": [
          "postcode_nl"
        ]
      },
      {
        "regExp": "(?i).*nl.*zip.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "nl_zip"
        ],
        "negativeExamples": [
          "us_zip"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "status"
        ]
      }
    ],
    "positiveContentExamples": [
      "1011 AB",
      "2511 BV",
      "3012 ES",
      "5211 DN",
      "8001 GA",
      "9712 CP",
      "1234 XY",
      "9999 ZZ"
    ],
    "negativeContentExamples": [
      "1011AB",
      "101 AB",
      "10110 AB",
      "1011 A",
      "1011 ABC",
      "1011-AB",
      "1011 ab",
      "1O11 AB"
    ],
    "positiveHeaderExamples": [
      "netherlands_postal_code",
      "nl_postal_code",
      "dutch_postcode",
      "postcode_nl",
      "delivery_postcode_nl",
      "postnl_postcode",
      "nl_zip",
      "postal_code_nl"
    ],
    "negativeHeaderExamples": [
      "postal_code",
      "zip_code",
      "postcode",
      "nl_area_code",
      "netherlands_address",
      "us_zip",
      "postal_zone_nl",
      "billing_code"
    ],
    "explanation": "This semantic type identifies Dutch postal codes in the canonical format of four digits, a single space, and two uppercase letters (e.g., 1234 AB). It is useful for validating, profiling, and standardizing address data specific to the Netherlands. The regex enforces the strict token structure without anchors, ensuring compatibility with FTA and minimizing false positives.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:27.923220"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_JA",
    "description": "Japanese postal codes employed by Japan Post for mail delivery and location identification throughout Japan. These seven-digit codes are formatted with a hyphen separator to facilitate mail processing and geographic routing. Format: three digits, hyphen, four digits (e.g., 123-4567).",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{3}-\\d{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 5300,
    "headerPatterns": [
      {
        "regExp": "(?i).*japan.*postal.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "japan postal code"
        ],
        "negativeExamples": [
          "jp postal code"
        ]
      },
      {
        "regExp": "(?i).*japanese.*postcode.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "japanese postcode"
        ],
        "negativeExamples": [
          "japanese post code"
        ]
      },
      {
        "regExp": "(?i).*(jp|jpn).*postal.*code.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "jp postal code"
        ],
        "negativeExamples": [
          "japan postal code"
        ]
      },
      {
        "regExp": "(?i).*zip.*code.*japan.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "zip code japan"
        ],
        "negativeExamples": [
          "zip code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "postal"
        ]
      }
    ],
    "positiveContentExamples": [
      "100-0001",
      "150-0002",
      "060-0042",
      "530-0003",
      "810-0021",
      "900-0014",
      "980-0011",
      "460-0008"
    ],
    "negativeContentExamples": [
      "1000001",
      "10-00001",
      "1000-001",
      "100-000",
      "A00-0001",
      "100-00001",
      "100 - 0001",
      "1234-5678"
    ],
    "positiveHeaderExamples": [
      "japan postal code",
      "japanese postcode",
      "jp postal code",
      "zip code japan",
      "delivery postcode japan",
      "recipient jp postal code",
      "address postal code (jp)",
      "jpn postcode"
    ],
    "negativeHeaderExamples": [
      "postal code",
      "postcode",
      "zip code",
      "japan area code",
      "jp product code",
      "country code jp",
      "japanese prefecture code",
      "jp address code"
    ],
    "explanation": "This semantic type targets Japanese postal codes in the fixed pattern NNN-NNNN, where N is a digit and a single hyphen separates the third and fourth digits. It is useful for validating, parsing, and standardizing address fields specific to Japan while minimizing collisions with other countries' postal formats.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:28.488853"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_CO",
    "description": "A six-digit numerical code used by the Colombian postal system to identify specific delivery areas and facilitate mail distribution throughout Colombia. Values consist of exactly six digits with no separators or letters.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5250,
    "headerPatterns": [
      {
        "regExp": "(?i).*colombia.*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "colombia_postal_code"
        ],
        "negativeExamples": [
          "colombia_area_code"
        ]
      },
      {
        "regExp": "(?i).*\\bco\\b.*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postal_code_co"
        ],
        "negativeExamples": [
          "co_area_code"
        ]
      },
      {
        "regExp": "(?i).*codigo.*postal.*\\bco\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "codigo_postal_co"
        ],
        "negativeExamples": [
          "codigo_postal_mx"
        ]
      },
      {
        "regExp": "(?i).*zip.*code.*colombia.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "zip_code_colombia"
        ],
        "negativeExamples": [
          "zip_code_mexico"
        ]
      },
      {
        "regExp": "(?i).*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postal_code"
        ],
        "negativeExamples": [
          "postal_zone"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "110111",
      "050001",
      "080001",
      "760001",
      "130001",
      "170004",
      "680006",
      "660002"
    ],
    "negativeContentExamples": [
      "11011",
      "1101110",
      "110-111",
      "11 0111",
      "A10111",
      "11011O",
      "11,0111",
      "CO1101"
    ],
    "positiveHeaderExamples": [
      "colombia_postal_code",
      "postal_code_co",
      "codigo_postal_colombia",
      "zip_code_colombia",
      "co_postal_code",
      "codigo_postal_co",
      "postal_code",
      "postalcode_co"
    ],
    "negativeHeaderExamples": [
      "colombia_postal_zone",
      "postal_area_co",
      "zip_colombia",
      "region_postal",
      "postal_identifier",
      "cp_colombia",
      "area_colombia",
      "zip_mx"
    ],
    "explanation": "This semantic type targets Colombian postal codes, which are exactly six digits with no separators or letters. The regex is intentionally strict to avoid matching phone numbers, area codes, or other numeric identifiers. Header patterns prioritize explicit references to Colombia (\"colombia\", country code \"co\", and Spanish \"codigo postal\"), then back off to general postal code terms, and finally to a primitive \"code\" keyword to allow weak header signals to be combined with strong content validation.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:29.862485"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.ISBN",
    "description": "A thirteen-digit book identifier with hyphen separators used by publishers and retailers for cataloging and inventory management of published works.",
    "pluginType": "regex",
    "regexPattern": "\\b97[89]-[0-9]{1,5}-[0-9]{1,7}-[0-9]{1,6}-[0-9]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4270,
    "headerPatterns": [
      {
        "regExp": "(?i).*isbn[-_ ]?13.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "isbn_13"
        ],
        "negativeExamples": [
          "issn"
        ]
      },
      {
        "regExp": "(?i).*book.*isbn.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "book_isbn"
        ],
        "negativeExamples": [
          "book_id"
        ]
      },
      {
        "regExp": "(?i).*product.*isbn.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "product_isbn"
        ],
        "negativeExamples": [
          "product_code"
        ]
      },
      {
        "regExp": "(?i).*isbn.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "isbn"
        ],
        "negativeExamples": [
          "ean_13"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "978-0-306-40615-7",
      "978-1-4028-9462-6",
      "978-3-16-148410-0",
      "979-10-90636-07-1",
      "979-1-2345-6789-6",
      "978-0-545-01022-1",
      "978-1-86197-876-9",
      "979-12-200-5151-3"
    ],
    "negativeContentExamples": [
      "978-0-306-40615-",
      "978-0-306-40615-7-2",
      "977-1-4028-9462-6",
      "978-1-4028-94626",
      "978-1-4028-9462-X",
      "978-14028-9462-6",
      "978-1-4028-946-26",
      "978-1-4028--9462-6"
    ],
    "positiveHeaderExamples": [
      "isbn_13",
      "book_isbn",
      "isbn",
      "isbn-13",
      "product_isbn",
      "publication_isbn",
      "isbn_code"
    ],
    "negativeHeaderExamples": [
      "issn",
      "ean_13",
      "upc",
      "book_id",
      "isbn10",
      "catalog_number",
      "product_code",
      "title"
    ],
    "explanation": "This semantic type identifies hyphen-separated ISBN-13 values with a 978 or 979 prefix, four internal numeric groups of variable length, and a single-digit check character at the end. It is suitable for classifying book identifiers used in publishing, retail, and catalog systems. The regex focuses on structural validation (token count, separators, and allowed digits) without computing the check digit; header patterns help disambiguate usage.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:30.072361"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_CA",
    "description": "A six-character alphanumeric identifier used by Canada Post to designate specific geographic delivery areas across Canada, formatted with a space separator.",
    "pluginType": "regex",
    "regexPattern": "\\b[ABCEGHJ-NPRSTVXY][0-9][ABCEGHJ-NPRSTVWXYZ] [0-9][ABCEGHJ-NPRSTVWXYZ][0-9]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 5240,
    "headerPatterns": [
      {
        "regExp": "(?i).*canadian[ _-]*postal[ _-]*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "canadian_postal_code"
        ],
        "negativeExamples": [
          "postal_code_ca"
        ]
      },
      {
        "regExp": "(?i).*postal[ _-]*code[ _-]*canada.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postal_code_canada"
        ],
        "negativeExamples": [
          "canadian_postal_code"
        ]
      },
      {
        "regExp": "(?i).*ca[ _-]*postal[ _-]*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ca_postal_code"
        ],
        "negativeExamples": [
          "postal_code_ca"
        ]
      },
      {
        "regExp": "(?i).*(postal[ _-]*code|postalcode|pcode).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postalcode"
        ],
        "negativeExamples": [
          "area_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "postal"
        ]
      }
    ],
    "positiveContentExamples": [
      "K1A 0B1",
      "H0H 0H0",
      "V6B 1A1",
      "M5V 2T6",
      "T2N 1N4",
      "B3H 2Y9",
      "R2W 3C5",
      "X0A 0H0"
    ],
    "negativeContentExamples": [
      "K1A0B1",
      "K1A-0B1",
      "W1A 0B1",
      "K1I 0B1",
      "A1A 1A",
      "A1A 1A1A",
      "A1A Q1A",
      "A1A 1O1"
    ],
    "positiveHeaderExamples": [
      "canadian_postal_code",
      "ca_postal_code",
      "postal_code_canada",
      "postalcode_ca",
      "shipping_postal_code_ca",
      "recipient_postal_code",
      "canada_post_code"
    ],
    "negativeHeaderExamples": [
      "zip_code",
      "us_postal_code",
      "post_code_uk",
      "postcode",
      "area_code",
      "country_code",
      "province_code"
    ],
    "explanation": "This type captures Canadian postal codes in the standard A1A 1A1 format with a required space separator and restricted letter set per Canada Post conventions. It is useful for validating, profiling, and standardizing address data fields specific to Canada.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:32.307890"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_FR",
    "description": "French postal codes utilized by La Poste for mail routing and geographic identification throughout France. These standardized five-digit numerical codes enable precise location targeting within French territories.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5280,
    "headerPatterns": [
      {
        "regExp": "(?i).*french.*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "french_postal_code"
        ],
        "negativeExamples": [
          "postal_code_fr"
        ]
      },
      {
        "regExp": "(?i).*(fr|france).*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postal_code_fr"
        ],
        "negativeExamples": [
          "postal_code_de"
        ]
      },
      {
        "regExp": "(?i).*(code[_ ]?postal|cp).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code_postal"
        ],
        "negativeExamples": [
          "area_code"
        ]
      },
      {
        "regExp": "(?i).*(postcode|zip).*fr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fr_postcode"
        ],
        "negativeExamples": [
          "us_zip_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "01000",
      "13015",
      "20090",
      "29200",
      "33000",
      "69008",
      "75001",
      "97419"
    ],
    "negativeContentExamples": [
      "7500",
      "750010",
      "75 001",
      "7500A",
      "A7501",
      "75001-",
      "FR-75001",
      "75001.0"
    ],
    "positiveHeaderExamples": [
      "french_postal_code",
      "postal_code_fr",
      "fr_postcode",
      "code_postal",
      "france_zip_code",
      "cp",
      "fr_cp",
      "french_zip"
    ],
    "negativeHeaderExamples": [
      "postal_code_de",
      "zipcode",
      "country_code",
      "fr_address",
      "department_code",
      "us_postal_code",
      "post_code_uk",
      "area_code"
    ],
    "explanation": "This semantic type detects French postal codes, which are exactly five digits and used for mail routing and geographic identification across France and its territories. It is intended for datasets containing standardized French postal codes in numeric form and aligns with common header naming conventions, including French abbreviations such as 'code_postal' and 'cp'. The high confidence threshold and moderate priority help avoid conflicts with other numeric or postal code formats.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:34.510252"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_MX",
    "description": "Mexican postal codes utilized by Correos de M\u00e9xico for mail distribution and geographic identification throughout Mexico. These five-digit numerical codes facilitate efficient mail routing to specific locations within Mexican territory.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 5310,
    "headerPatterns": [
      {
        "regExp": "(?i).*mexico.*postal.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "mexico_postal_code"
        ],
        "negativeExamples": [
          "mexico_area_code"
        ]
      },
      {
        "regExp": "(?i).*(codigo|postal).*mexico.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "codigo_postal_mexico"
        ],
        "negativeExamples": [
          "area_code_mexico"
        ]
      },
      {
        "regExp": "(?i).*(postal|codigo).*mx.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "postal_code_mx"
        ],
        "negativeExamples": [
          "codigo_area_mx"
        ]
      },
      {
        "regExp": "(?i).*cp.*mexico.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cp_mexico"
        ],
        "negativeExamples": [
          "cuenta_mexico"
        ]
      },
      {
        "regExp": "(?i).*cp.*mx.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cp_mx"
        ],
        "negativeExamples": [
          "mx_cp"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "01000",
      "02800",
      "11529",
      "20000",
      "27000",
      "64000",
      "97108",
      "99998"
    ],
    "negativeContentExamples": [
      "1234",
      "123456",
      "01 000",
      "CP01000",
      "0100A",
      "10.000",
      "97I08",
      "0I000"
    ],
    "positiveHeaderExamples": [
      "mexico_postal_code",
      "codigo_postal_mexico",
      "postal_code_mx",
      "cp_mx",
      "cp_mexico",
      "codigo_postal_mx",
      "mx_postal_code"
    ],
    "negativeHeaderExamples": [
      "zip",
      "zip_us",
      "postal",
      "billing_postal",
      "area_mx",
      "postal_zone_mx",
      "country_postal"
    ],
    "explanation": "This semantic type identifies five-digit Mexican postal codes (C\u00f3digos Postales) used nationwide for mail routing and location reference. It is useful for validating address data within Mexico and for geospatial joins keyed by Mexican CPs. Header patterns prioritize explicit mentions of Mexico or MX along with postal/code terminology to reduce confusion with other five-digit postal systems.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:37.283109"
  },
  {
    "resultType": "generated",
    "semanticType": "INDUSTRY_EN",
    "description": "A descriptive name identifying the primary business sector or economic activity of an organization or establishment.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b([A-Za-z]+[A-Za-z&/,-]*\\s+){0,5}(manufacturing|retail|wholesale|technology|information|financial|banking|insurance|healthcare|agriculture|mining|utilities|construction|transportation|warehousing|logistics|hospitality|accommodation|food|beverage|education|training|entertainment|recreation|telecommunications|media|pharmaceutical|chemical|automotive|aerospace|energy|oil|gas|renewable|waste|water|software|ecommerce|marketing|advertising|consulting|trade|real\\s+estate|public\\s+administration|social\\s+assistance|professional\\s+services|scientific|technical|biotechnology)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4920,
    "headerPatterns": [
      {
        "regExp": "(?i).*(primary|main).*industry.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "primary_industry"
        ],
        "negativeExamples": [
          "primary_contact"
        ]
      },
      {
        "regExp": "(?i).*industry.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "industry_name"
        ],
        "negativeExamples": [
          "name_of_company"
        ]
      },
      {
        "regExp": "(?i).*(business|company).*industry.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "business_industry"
        ],
        "negativeExamples": [
          "business_unit"
        ]
      },
      {
        "regExp": "(?i).*(economic|business).*sector.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "economic_sector"
        ],
        "negativeExamples": [
          "sector_code"
        ]
      },
      {
        "regExp": "(?i).*(sector|industry).*(activity|activities).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "sector_of_activity"
        ],
        "negativeExamples": [
          "activity_type"
        ]
      },
      {
        "regExp": "(?i).*industry.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "industry"
        ],
        "negativeExamples": [
          "department"
        ]
      }
    ],
    "positiveContentExamples": [
      "Manufacturing",
      "Retail Trade",
      "Information Technology",
      "Financial Services",
      "Healthcare",
      "Real Estate",
      "Transportation and Warehousing",
      "Professional, Scientific and Technical Services"
    ],
    "negativeContentExamples": [
      "Retailer Operations",
      "Consultancy",
      "Finance",
      "Tech",
      "Public Sector",
      "Real Estates",
      "Bank",
      "IT Services"
    ],
    "positiveHeaderExamples": [
      "primary_industry",
      "industry_name",
      "business_industry",
      "economic_sector",
      "sector_of_activity",
      "main_industry",
      "industry_description",
      "primary_business_sector"
    ],
    "negativeHeaderExamples": [
      "company_name",
      "sector_code",
      "business_unit",
      "department",
      "product_category",
      "market_segment",
      "job_function",
      "naics_code"
    ],
    "explanation": "This semantic type identifies human-readable industry/sector names in English, such as Manufacturing, Retail Trade, or Information Technology. It is suitable for columns describing an organization\u2019s primary line of business, rather than coded taxonomies. The pattern emphasizes common industry keywords and allows typical separators (spaces, commas, hyphens, slashes, ampersands) found in real-world labels.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:39.949829"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_PT",
    "description": "Portuguese postal codes managed by CTT for mail delivery and location identification across Portugal. These seven-digit codes are formatted with a hyphen to separate the main postal area from the specific delivery zone. The canonical structure is four digits, a hyphen, and three digits (e.g., 1234-567).",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{4}-\\d{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5330,
    "headerPatterns": [
      {
        "regExp": "(?i).*ctt.*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CTT postal code"
        ],
        "negativeExamples": [
          "CTT customer id"
        ]
      },
      {
        "regExp": "(?i).*(portugal|pt).*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Portugal postal code"
        ],
        "negativeExamples": [
          "PT region"
        ]
      },
      {
        "regExp": "(?i).*portuguese.*(postal|post).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Portuguese postcode"
        ],
        "negativeExamples": [
          "Portuguese city"
        ]
      },
      {
        "regExp": "(?i).*(zip|post).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "zip code portugal"
        ],
        "negativeExamples": [
          "zip number"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "postal reference"
        ]
      }
    ],
    "positiveContentExamples": [
      "1000-001",
      "1250-096",
      "2785-017",
      "4150-123",
      "9000-054",
      "2860-001",
      "1100-279",
      "5000-000"
    ],
    "negativeContentExamples": [
      "1000001",
      "1000 001",
      "1000/001",
      "100A-001",
      "100-000",
      "10000-001",
      "1000-0000",
      "1000-1A1"
    ],
    "positiveHeaderExamples": [
      "CTT postal code",
      "Portugal postal code",
      "PT postal code",
      "Portuguese postcode",
      "postal code pt",
      "pt_zip_code",
      "zip code portugal",
      "delivery postal code"
    ],
    "negativeHeaderExamples": [
      "CTT customer id",
      "Portugal address line",
      "postal area",
      "zip number",
      "PT region",
      "municipality",
      "delivery zone",
      "address id"
    ],
    "explanation": "This semantic type identifies Portuguese postal codes in the CTT format, consisting of exactly four digits, a hyphen, and three digits (e.g., 1234-567). It is suitable for validating and classifying address-related fields specific to Portugal where the postal code is expected to be present and correctly formatted.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:40.245744"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.RACE_EN",
    "description": "Full descriptive terms for racial or ethnic categories used in demographic analysis, census data, and diversity reporting in English language contexts.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "WHITE",
      "BLACK OR AFRICAN AMERICAN",
      "AFRICAN AMERICAN",
      "AFRICAN-AMERICAN",
      "ASIAN",
      "AMERICAN INDIAN OR ALASKA NATIVE",
      "AMERICAN INDIAN",
      "ALASKA NATIVE",
      "NATIVE HAWAIIAN OR OTHER PACIFIC ISLANDER",
      "NATIVE HAWAIIAN",
      "OTHER PACIFIC ISLANDER",
      "PACIFIC ISLANDER",
      "HISPANIC OR LATINO",
      "HISPANIC",
      "LATINO",
      "NOT HISPANIC OR LATINO",
      "MIDDLE EASTERN OR NORTH AFRICAN",
      "MIDDLE EASTERN",
      "NORTH AFRICAN",
      "TWO OR MORE RACES",
      "MULTIRACIAL",
      "MULTI-RACIAL",
      "SOME OTHER RACE",
      "OTHER RACE",
      "MENA"
    ],
    "backout": "^[A-Z][A-Z /-]{2,60}$",
    "confidenceThreshold": 95,
    "priority": 5200,
    "headerPatterns": [
      {
        "regExp": "(?i).*(respondent|person|individual).*(race|ethnicity).*(en|english).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "respondent_race_en"
        ],
        "negativeExamples": [
          "respondent_race_es"
        ]
      },
      {
        "regExp": "(?i).*demographic.*(race|ethnicity).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "demographic_ethnicity"
        ],
        "negativeExamples": [
          "demographic_language"
        ]
      },
      {
        "regExp": "(?i).*(ethnicity|eth|ethn|racecat|race_cat).*(en|english).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "eth_en"
        ],
        "negativeExamples": [
          "ethn_category"
        ]
      },
      {
        "regExp": "(?i).*(race|ethnicity).*(desc|label|group|category).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "race_group"
        ],
        "negativeExamples": [
          "ethnicity_code"
        ]
      },
      {
        "regExp": "(?i).*(race|ethnicity).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "race"
        ],
        "negativeExamples": [
          "gender"
        ]
      }
    ],
    "positiveContentExamples": [
      "White",
      "Black or African American",
      "African-American",
      "Asian",
      "American Indian or Alaska Native",
      "Native Hawaiian or Other Pacific Islander",
      "Hispanic or Latino",
      "Middle Eastern or North African"
    ],
    "negativeContentExamples": [
      "Caucasian",
      "Black/African",
      "Asian Pacific",
      "Hispanic/Latina",
      "Two or more",
      "Native Hawaiian and Other Pacific Islander",
      "American Indian/Alaska Native",
      "Middle Eastern & North African"
    ],
    "positiveHeaderExamples": [
      "respondent_race_en",
      "person_ethnicity_english",
      "demographic_race",
      "demographics_ethnicity",
      "race_group",
      "eth_en",
      "race_category",
      "individual_race_en"
    ],
    "negativeHeaderExamples": [
      "language_en",
      "nationality",
      "gender",
      "demographic_language",
      "country_of_birth",
      "customer_name",
      "birth_date",
      "ethnic_code"
    ],
    "explanation": "This semantic type identifies English-language racial or ethnic category labels commonly used in demographic and diversity datasets. It is intended for columns containing the spelled-out category description rather than codes or abbreviations. Using a curated list keeps classification precise and avoids false positives from loosely related demographic terms.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:43.351609"
  },
  {
    "resultType": "generated",
    "semanticType": "SSN",
    "description": "United States Social Security Numbers issued by the Social Security Administration for identification and benefits tracking. These nine-digit identifiers are formatted with hyphens to separate the area, group, and serial number components for citizen identification.",
    "pluginType": "regex",
    "regexPattern": "\\b(?!000)\\d{3}-(?!00)\\d{2}-(?!0000)\\d{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5410,
    "headerPatterns": [
      {
        "regExp": "(?i).*social.*security.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "social_security_number"
        ],
        "negativeExamples": [
          "social_security_code"
        ]
      },
      {
        "regExp": "(?i).*social.*security.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "social_security"
        ],
        "negativeExamples": [
          "security_social"
        ]
      },
      {
        "regExp": "(?i).*ssn.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "ssn"
        ],
        "negativeExamples": [
          "snn"
        ]
      },
      {
        "regExp": "(?i).*soc.*sec.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "soc_sec_no"
        ],
        "negativeExamples": [
          "sec_society_id"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "123-45-6789",
      "001-01-0001",
      "212-09-3456",
      "457-65-4321",
      "512-34-0007",
      "078-05-1120",
      "219-09-9999",
      "860-12-3456"
    ],
    "negativeContentExamples": [
      "123456789",
      "123-456-789",
      "12-345-6789",
      "123-45-678",
      "123 45 6789",
      "123-4A-6789",
      "000-12-3456",
      "123-00-6789"
    ],
    "positiveHeaderExamples": [
      "social_security_number",
      "ssn",
      "social_security_id_number",
      "us_ssn",
      "taxpayer_ssn",
      "soc_sec_no",
      "social_security"
    ],
    "negativeHeaderExamples": [
      "social_security_code",
      "security_social",
      "snn",
      "sec_society_id",
      "national_id",
      "identifier",
      "account_id"
    ],
    "explanation": "This type recognizes hyphenated U.S. Social Security Numbers in the form NNN-NN-NNNN using word boundaries and strict digit groupings. It rejects values with all-zero segments and non-numeric characters, and it does not match unformatted 9-digit strings without hyphens.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:48.787911"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_UK",
    "description": "United Kingdom postcodes used by Royal Mail for mail delivery and precise location identification across England, Scotland, Wales, and Northern Ireland. These alphanumeric codes combine letters and numbers with specific formatting to enable accurate geographic targeting.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-PR-UWYZa-pr-uwyz][A-HK-Ya-hk-y]?[0-9][0-9A-HJKMNPR-Ya-hjkmnpr-y]?\\s[0-9][ABD-HJLNP-UW-Zabd-hjlnp-uw-z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5350,
    "headerPatterns": [
      {
        "regExp": "(?i).*royal.*mail.*postcod.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "royal_mail_postcode"
        ],
        "negativeExamples": [
          "royal_mail_reference"
        ]
      },
      {
        "regExp": "(?i).*(uk|gb|british).*postcod.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "uk_postcode"
        ],
        "negativeExamples": [
          "us_postal_code"
        ]
      },
      {
        "regExp": "(?i).*(uk|gb).*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gb_postal_code"
        ],
        "negativeExamples": [
          "eu_postal_zone"
        ]
      },
      {
        "regExp": "(?i).*post.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "post_code"
        ],
        "negativeExamples": [
          "zip"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "SW1A 1AA",
      "EC1A 1BB",
      "W1A 0AX",
      "M1 1AE",
      "B33 8TH",
      "CR2 6XH",
      "DN55 1PT",
      "G1 1XQ"
    ],
    "negativeContentExamples": [
      "SW1A1AA",
      "SW1A 1A1",
      "Q1 1AA",
      "SW1  1AA",
      "EC1A 1C0",
      "EC1A 11B",
      "CR26XH",
      "E1C 1BB"
    ],
    "positiveHeaderExamples": [
      "uk_postcode",
      "gb_postal_code",
      "royal_mail_postcode",
      "british_postcode",
      "postal_code_uk",
      "post_code_gb",
      "recipient_postcode_uk",
      "delivery_postcode"
    ],
    "negativeHeaderExamples": [
      "zip",
      "us_postal",
      "area",
      "address",
      "city",
      "county",
      "region",
      "delivery_area"
    ],
    "explanation": "This semantic type identifies UK postcodes in their standard outward and inward format with a mandatory single space, using strict letter and digit sets to minimize false positives. It is suitable for validating and classifying address-related fields containing Royal Mail\u2013style UK postcodes.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:49.347878"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.ZIP5_US",
    "description": "United States ZIP codes utilized by USPS for mail sorting and delivery across all states and territories. These five-digit numerical codes serve as the primary postal identifier for geographic areas within the US postal system.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 5380,
    "headerPatterns": [
      {
        "regExp": "(?i).*us.*zip.*5.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "us_zip5"
        ],
        "negativeExamples": [
          "us_zip_code"
        ]
      },
      {
        "regExp": "(?i).*us.*zip.*code.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "us_zip_code"
        ],
        "negativeExamples": [
          "zip_code_ca"
        ]
      },
      {
        "regExp": "(?i).*zip.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "zipcode"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      },
      {
        "regExp": "(?i).*postal.*code.*",
        "confidence": 91,
        "mandatory": true,
        "positiveExamples": [
          "postal_code"
        ],
        "negativeExamples": [
          "postal_zone"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "number"
        ]
      }
    ],
    "positiveContentExamples": [
      "02115",
      "10001",
      "30301",
      "60614",
      "75201",
      "85001",
      "94105",
      "99501"
    ],
    "negativeContentExamples": [
      "1234",
      "123456",
      "12345-6789",
      "12345 6789",
      "A2345",
      "12O45",
      "12 345",
      "1234B"
    ],
    "positiveHeaderExamples": [
      "us_zip5",
      "us_zip_code",
      "zip5",
      "zip",
      "zipcode",
      "zip_code",
      "postal_code",
      "postcode"
    ],
    "negativeHeaderExamples": [
      "postal_zone",
      "us_postal",
      "post_region",
      "mail_zone",
      "address_region",
      "delivery_area",
      "routing_key",
      "location_id"
    ],
    "explanation": "This type identifies US 5-digit ZIP codes only, allowing leading zeros and enforcing exactly five numeric digits via word boundaries. It excludes ZIP+4 formats and any values containing non-digit characters or separators.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:49.509026"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_FIPS_US",
    "description": "United States county FIPS codes used by federal agencies for statistical and administrative identification of counties. These five-digit numerical codes provide standardized reference numbers for all counties within the US governmental data systems.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5450,
    "headerPatterns": [
      {
        "regExp": "(?i).*county.*fips.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "county_fips_code"
        ],
        "negativeExamples": [
          "county_name"
        ]
      },
      {
        "regExp": "(?i).*us.*county.*fips.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "us_county_fips"
        ],
        "negativeExamples": [
          "state_fips"
        ]
      },
      {
        "regExp": "(?i).*(fips.*county|county.*fips).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fips_county"
        ],
        "negativeExamples": [
          "county_iso_code"
        ]
      },
      {
        "regExp": "(?i).*(cnty|co).*fips.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cnty_fips"
        ],
        "negativeExamples": [
          "co_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "01001",
      "06037",
      "36061",
      "17031",
      "12086",
      "04013",
      "48113",
      "53033"
    ],
    "negativeContentExamples": [
      "0600",
      "06001.0",
      "06-001",
      "06 001",
      "0600I",
      "O6001",
      "060001",
      "6001"
    ],
    "positiveHeaderExamples": [
      "county_fips_code",
      "us_county_fips",
      "fips_county_code",
      "county_fips",
      "cnty_fips",
      "co_fips",
      "fips5_county"
    ],
    "negativeHeaderExamples": [
      "county_name",
      "state_fips_code",
      "zip_code",
      "census_tract_code",
      "county_iso_code",
      "fips_state_code",
      "country_code",
      "geoid"
    ],
    "explanation": "This semantic type identifies five-digit U.S. County FIPS codes in the SSCCC numeric format used across federal datasets. It is suited for fields storing standardized county identifiers and can help link to geographic reference data and federal statistics.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:50.401855"
  },
  {
    "resultType": "generated",
    "semanticType": "CITY",
    "description": "The name of an incorporated city, town, or urban municipality as recognized by local government authorities.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z][A-Za-z]+([ '-][A-Z][A-Za-z.]+){0,5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4320,
    "headerPatterns": [
      {
        "regExp": "(?i).*(city|municipality|town|borough).*name.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "city_name"
        ],
        "negativeExamples": [
          "city_code"
        ]
      },
      {
        "regExp": "(?i).*(billing|shipping|home|residence|birth|current|primary).*city.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "home_city"
        ],
        "negativeExamples": [
          "home_country"
        ]
      },
      {
        "regExp": "(?i).*(municipality|town|borough).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "municipality"
        ],
        "negativeExamples": [
          "country"
        ]
      },
      {
        "regExp": "(?i).*(cty|muni|boro).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "cty_name"
        ],
        "negativeExamples": [
          "ctr_name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "New York",
      "Los Angeles",
      "San Francisco",
      "St. Louis",
      "Ho Chi Minh City",
      "Fort Worth",
      "O'Fallon",
      "Santa Fe"
    ],
    "negativeContentExamples": [
      "los angeles",
      "123 Springfield",
      "New York 2",
      "Washington, DC",
      "N. York",
      "San Jos\u00e9",
      "Paris-",
      "Los  Angeles"
    ],
    "positiveHeaderExamples": [
      "city_name",
      "municipality_name",
      "home_city",
      "billing_city",
      "residence_city",
      "town",
      "urban_municipality",
      "primary_city"
    ],
    "negativeHeaderExamples": [
      "city_code",
      "city_id",
      "country_name",
      "state_province",
      "zipcode",
      "address_line1",
      "timezone_name",
      "customer_name"
    ],
    "explanation": "This type identifies strings that look like proper city or town names, composed of one to six capitalized tokens separated by spaces, hyphens, or apostrophes, and allowing common abbreviations like 'St.' within tokens. Use it to classify location fields that specifically hold municipality names rather than broader regions or codes. The header patterns prioritize explicit 'city_name' forms, then broader city/municipality indicators, with a final primitive fallback on 'name'. Threshold and priority are set high to avoid conflicts with other generic name-like types.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:50.476245"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.DISTRICT_NAME_PT",
    "description": "Portuguese district names representing the administrative divisions within Portugal's territorial organization system. These districts serve as primary territorial units for government administration and regional coordination throughout Portuguese mainland territory.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AVEIRO",
      "BEJA",
      "BRAGA",
      "BRAGAN\u00c7A",
      "CASTELO BRANCO",
      "COIMBRA",
      "\u00c9VORA",
      "FARO",
      "GUARDA",
      "LEIRIA",
      "LISBOA",
      "PORTALEGRE",
      "PORTO",
      "SANTAR\u00c9M",
      "SET\u00daBAL",
      "VIANA DO CASTELO",
      "VILA REAL",
      "VISEU"
    ],
    "backout": "^[A-Z\u00c1\u00c2\u00c3\u00c0\u00c9\u00ca\u00cd\u00d3\u00d4\u00d5\u00da\u00c7 ]{3,20}$",
    "confidenceThreshold": 98,
    "priority": 5530,
    "headerPatterns": [
      {
        "regExp": "(?i).*(portugal|pt).*(district|distrito).*(name|nome).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Portugal District Name"
        ],
        "negativeExamples": [
          "District Name"
        ]
      },
      {
        "regExp": "(?i).*(distrito).*(nome).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Nome do Distrito"
        ],
        "negativeExamples": [
          "Distrito C\u00f3digo"
        ]
      },
      {
        "regExp": "(?i).*(district|distrito).*(name|nome).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "PT_District_Name"
        ],
        "negativeExamples": [
          "District Code"
        ]
      },
      {
        "regExp": "(?i).*(portugal|pt).*(district|distrito).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "District (Portugal)"
        ],
        "negativeExamples": [
          "Province (PT)"
        ]
      },
      {
        "regExp": "(?i).*(dist).*(name|nome|nm).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "dist_nm"
        ],
        "negativeExamples": [
          "dist_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Lisboa",
      "Porto",
      "Braga",
      "Viana do Castelo",
      "Vila Real",
      "Viseu",
      "Castelo Branco",
      "Santar\u00e9m"
    ],
    "negativeContentExamples": [
      "Lisbon",
      "Evora",
      "Braganca",
      "Castelo Branco District",
      "Porto (Distrito)",
      "Braga, PT",
      "Madeira",
      "A\u00e7ores"
    ],
    "positiveHeaderExamples": [
      "Portugal District Name",
      "Nome do Distrito",
      "PT_District_Name",
      "District (Portugal)",
      "Distrito - Nome",
      "District Name PT",
      "Nome Distrito PT",
      "PT District Name"
    ],
    "negativeHeaderExamples": [
      "Province Name",
      "Municipality Name",
      "State Name",
      "Country Name",
      "Postal Code",
      "County Name",
      "Region Name",
      "District Code"
    ],
    "explanation": "This semantic type identifies the names of the 18 mainland Portuguese districts (distritos) as used in administrative and territorial datasets. It is implemented as a finite list to ensure high precision and to avoid confusion with municipalities, regions, or autonomous regions. Typical use cases include geocoding, territorial aggregation, and data validation where district names must match the official Portuguese designations.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:53.912073"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_HU",
    "description": "Hungarian county names representing the administrative divisions within Hungary's territorial organization system. These megy\u00e9k serve as primary regional units for government administration and statistical reporting throughout the Hungarian state.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "B\u00c1CS-KISKUN",
      "BARANYA",
      "B\u00c9K\u00c9S",
      "BORSOD-ABA\u00daJ-ZEMPL\u00c9N",
      "CSONGR\u00c1D-CSAN\u00c1D",
      "FEJ\u00c9R",
      "GY\u0150R-MOSON-SOPRON",
      "HAJD\u00da-BIHAR",
      "HEVES",
      "J\u00c1SZ-NAGYKUN-SZOLNOK",
      "KOM\u00c1ROM-ESZTERGOM",
      "N\u00d3GR\u00c1D",
      "PEST",
      "SOMOGY",
      "SZABOLCS-SZATM\u00c1R-BEREG",
      "TOLNA",
      "VAS",
      "VESZPR\u00c9M",
      "ZALA"
    ],
    "backout": "^[A-Z\u00c1\u00c9\u00cd\u00d3\u00d6\u0150\u00da\u00dc\u0170-]{3,30}$",
    "confidenceThreshold": 98,
    "priority": 5460,
    "headerPatterns": [
      {
        "regExp": "(?i).*(hungarian|hu).*county.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "hu_county_name"
        ],
        "negativeExamples": [
          "hu_country_name"
        ]
      },
      {
        "regExp": "(?i).*(megye).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "megye_name"
        ],
        "negativeExamples": [
          "jaras_name"
        ]
      },
      {
        "regExp": "(?i).*(hungarian|hu).*county.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "hungarian_county"
        ],
        "negativeExamples": [
          "hungarian_country"
        ]
      },
      {
        "regExp": "(?i).*(county[_ ]?hu|hu[_ ]?county|megye).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "county_hu"
        ],
        "negativeExamples": [
          "province_hu"
        ]
      },
      {
        "regExp": "(?i).*county.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "county"
        ],
        "negativeExamples": [
          "country"
        ]
      }
    ],
    "positiveContentExamples": [
      "B\u00e1cs-Kiskun",
      "Baranya",
      "Borsod-Aba\u00faj-Zempl\u00e9n",
      "Csongr\u00e1d-Csan\u00e1d",
      "Gy\u0151r-Moson-Sopron",
      "J\u00e1sz-Nagykun-Szolnok",
      "Szabolcs-Szatm\u00e1r-Bereg",
      "Veszpr\u00e9m"
    ],
    "negativeContentExamples": [
      "Budapest",
      "Csongr\u00e1d",
      "Bacs-Kiskun",
      "B\u00e1cs Kiskun",
      "Gy\u00f6r-Moson-Sopron",
      "Veszprem",
      "Borsod Aba\u00faj Zempl\u00e9n",
      "Csongr\u00e1d-Csanad"
    ],
    "positiveHeaderExamples": [
      "hu_county_name",
      "megye_name",
      "hungarian_county",
      "county_hu",
      "county_name",
      "hu_county",
      "megye",
      "county"
    ],
    "negativeHeaderExamples": [
      "country",
      "province",
      "state_name",
      "county_code",
      "county_id",
      "district",
      "region",
      "municipality"
    ],
    "explanation": "This semantic type captures the official names of Hungary's counties (megy\u00e9k). It is designed for datasets containing textual county names used for administrative, statistical, and regional aggregation tasks. The finite list ensures high precision in matching Hungarian county names while excluding non-county administrative units or alternate spellings.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:54.145843"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.INSEE_CODE_FR",
    "description": "French INSEE codes used by the National Institute of Statistics for official identification of French communes and administrative territories. These five-digit numerical codes provide standardized reference numbers for statistical reporting and government data systems throughout France.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 5540,
    "headerPatterns": [
      {
        "regExp": "(?i).*commune.*insee.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "commune_insee_code"
        ],
        "negativeExamples": [
          "commune_code"
        ]
      },
      {
        "regExp": "(?i).*code.*commune.*insee.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code_commune_insee"
        ],
        "negativeExamples": [
          "commune_insee"
        ]
      },
      {
        "regExp": "(?i).*fr.*insee.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fr_insee_code"
        ],
        "negativeExamples": [
          "fr_postal"
        ]
      },
      {
        "regExp": "(?i).*insee.*commune.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "insee_commune"
        ],
        "negativeExamples": [
          "insee_population"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "75056",
      "13055",
      "69388",
      "31555",
      "06088",
      "44109",
      "33063",
      "35238"
    ],
    "negativeContentExamples": [
      "7505",
      "750560",
      "75 056",
      "750-56",
      "2A123",
      "75056A",
      "075056",
      "7505O"
    ],
    "positiveHeaderExamples": [
      "commune_insee_code",
      "code_commune_insee",
      "insee_code",
      "code_insee",
      "fr_insee_code",
      "insee_commune",
      "insee_commune_code"
    ],
    "negativeHeaderExamples": [
      "postal",
      "zip",
      "department",
      "siren",
      "commune",
      "insee",
      "population"
    ],
    "explanation": "This semantic type identifies five-digit French INSEE commune codes, enabling consistent linking of administrative territorial data across datasets. Use it for columns storing official INSEE identifiers for communes or similar French administrative entities, commonly found in government, statistical, and geographic datasets. The value pattern is strictly five digits to minimize confusion with other identifiers; rely on header cues including 'insee' and 'commune' for best precision.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:54.337027"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.LONGITUDE_DECIMAL",
    "description": "A geographic coordinate that specifies the east-west position of a point on Earth's surface expressed as decimal degrees from the prime meridian.",
    "pluginType": "regex",
    "regexPattern": "\\b[+-]?((1[0-7]\\d|[1-9]?\\d)(\\.\\d{1,7})?|180(\\.0{1,7})?)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4430,
    "headerPatterns": [
      {
        "regExp": "(?i).*(decimal[ _-]*longitude|longitude[ _-]*decimal|lon[ _-]*decimal).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "longitude_decimal"
        ],
        "negativeExamples": [
          "longitude_dms"
        ]
      },
      {
        "regExp": "(?i).*(coordinate[ _-]*longitude|geo[ _-]*longitude|longitude[ _-]*coord).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "coordinate_longitude"
        ],
        "negativeExamples": [
          "coordinate_latitude"
        ]
      },
      {
        "regExp": "(?i).*(lon|lng)[ _-]*decimal.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lng_decimal"
        ],
        "negativeExamples": [
          "lng_dms"
        ]
      },
      {
        "regExp": "(?i).*geo[ _-]*(lon|lng).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "geo_lon"
        ],
        "negativeExamples": [
          "geo_lat"
        ]
      },
      {
        "regExp": "(?i).*longitude.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "longitude"
        ],
        "negativeExamples": [
          "latitude"
        ]
      }
    ],
    "positiveContentExamples": [
      "-73.985656",
      "120",
      "180",
      "-0.127758",
      "45.0",
      "+179.9999",
      "-180",
      "9.75"
    ],
    "negativeContentExamples": [
      "181",
      "-180.0000001",
      "180.1",
      "200",
      "45.123 N",
      "E 120.5",
      "122\u00b0W",
      "100.00000000"
    ],
    "positiveHeaderExamples": [
      "longitude_decimal",
      "decimal_longitude",
      "lon_decimal_deg",
      "coordinate_longitude",
      "geo_longitude",
      "lng_decimal",
      "geo_lon"
    ],
    "negativeHeaderExamples": [
      "latitude_decimal",
      "longitude_dms",
      "length",
      "long_description",
      "coordinate_latitude",
      "geo_lat",
      "lat"
    ],
    "explanation": "This type recognizes decimal-degree longitudes ranging from -180 to 180 inclusive, allowing an optional leading sign and up to 7 fractional digits. It ensures that values equal to 180 only include zero fractional parts to maintain geographic validity. Typical use cases include mapping datasets, GPS-derived positions, and geospatial analytics where longitude is stored independently in decimal degrees.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:51:55.663886"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_CODE_BR",
    "description": "Brazilian municipality codes used by IBGE for official statistical identification of municipal territories within Brazil. These seven-digit numerical codes provide standardized reference numbers for demographic data collection and government administrative systems throughout Brazilian states.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{7}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5570,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bibge\\b.*\\bmunicipality\\b.*\\bcode\\b.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "IBGE municipality code"
        ],
        "negativeExamples": [
          "IBGE state code"
        ]
      },
      {
        "regExp": "(?i).*\\bcodigo\\b.*\\bmunicipio\\b.*\\bibge\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "codigo municipio IBGE"
        ],
        "negativeExamples": [
          "codigo estado IBGE"
        ]
      },
      {
        "regExp": "(?i).*\\bmunicipality\\b.*\\bcode\\b.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "municipality code"
        ],
        "negativeExamples": [
          "municipality name"
        ]
      },
      {
        "regExp": "(?i).*\\bmunicipal\\b.*\\bcode\\b.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "municipal code"
        ],
        "negativeExamples": [
          "municipal boundary"
        ]
      },
      {
        "regExp": "(?i).*\\bmun\\b.*\\bcode\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "mun code"
        ],
        "negativeExamples": [
          "mun name"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "1100015",
      "3550308",
      "3304557",
      "5300108",
      "2927408",
      "4106902",
      "3106200",
      "1501402"
    ],
    "negativeContentExamples": [
      "355030",
      "35503080",
      "33O4557",
      "33045A7",
      "330-4557",
      "330 4557",
      "330.4557",
      "3304557.0"
    ],
    "positiveHeaderExamples": [
      "IBGE municipality code",
      "codigo municipio IBGE",
      "municipality code BR",
      "municipal code",
      "mun code",
      "municipality code",
      "municipality code (IBGE)"
    ],
    "negativeHeaderExamples": [
      "municipality name",
      "city",
      "ibge state id",
      "state abbreviation",
      "geographic unit",
      "postal zipcode",
      "municipality latitude"
    ],
    "explanation": "This semantic type targets the seven-digit numeric IBGE municipality identifiers used across Brazilian administrative and statistical datasets. Use it to recognize and validate fields containing Brazilian municipality reference codes, often used for joining demographic, economic, or geographic tables at the municipal level.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:04.991311"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_NL",
    "description": "Netherlands province names representing the administrative divisions within the Dutch territorial organization system. These provincies serve as primary territorial units for regional government administration and public service coordination throughout the Netherlands.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "GRONINGEN",
      "FRIESLAND",
      "DRENTHE",
      "OVERIJSSEL",
      "FLEVOLAND",
      "GELDERLAND",
      "UTRECHT",
      "NOORD-HOLLAND",
      "ZUID-HOLLAND",
      "ZEELAND",
      "NOORD-BRABANT",
      "LIMBURG"
    ],
    "backout": "^[- A-Z]{6,20}$",
    "confidenceThreshold": 98,
    "priority": 5690,
    "headerPatterns": [
      {
        "regExp": "(?i).*(netherlands|nl|dutch).*(province|provincie).*name.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "nl_province_name"
        ],
        "negativeExamples": [
          "province_code"
        ]
      },
      {
        "regExp": "(?i).*provincie.*naam.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "provincie_naam"
        ],
        "negativeExamples": [
          "provincie_code"
        ]
      },
      {
        "regExp": "(?i).*(netherlands|nl|dutch).*(province|provincie).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "dutch_province"
        ],
        "negativeExamples": [
          "state_province"
        ]
      },
      {
        "regExp": "(?i).*(prov|prv|province|provincie).*name.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "prov_name"
        ],
        "negativeExamples": [
          "prov_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Noord-Holland",
      "Zuid-Holland",
      "Utrecht",
      "Flevoland",
      "Noord-Brabant",
      "Gelderland",
      "Overijssel",
      "Groningen"
    ],
    "negativeContentExamples": [
      "North Holland",
      "South Holland",
      "Holland",
      "Noord Holland",
      "Brabant",
      "Frisia",
      "Groningen City",
      "Frysl\u00e2n"
    ],
    "positiveHeaderExamples": [
      "nl_province_name",
      "provincie_naam",
      "province_name_nl",
      "dutch_province",
      "netherlands_province",
      "province_name",
      "prov_name"
    ],
    "negativeHeaderExamples": [
      "province_code",
      "state_name",
      "region_name",
      "country_province",
      "nl_state",
      "city_name",
      "province_id",
      "county_name"
    ],
    "explanation": "This semantic type identifies Dutch province names (provincies) within the Netherlands. Use it to classify columns containing the official province names used for regional administration. The finite, well-defined list ensures high precision and minimizes ambiguity with regions or cities.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:08.857431"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.ZIP5_PLUS4_US",
    "description": "United States ZIP+4 codes used by USPS for enhanced mail delivery precision and routing efficiency. These extended postal codes combine the standard five-digit ZIP with an additional four-digit segment for more specific location targeting.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{5}-\\d{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5370,
    "headerPatterns": [
      {
        "regExp": "(?i).*us.*zip.*\\+?4.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "US ZIP+4 Code"
        ],
        "negativeExamples": [
          "ZIP+4 Code"
        ]
      },
      {
        "regExp": "(?i).*(zip\\+?4|zip4|zip_4|zipplus4|zip-4|zip_plus4).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ZIP-4"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      },
      {
        "regExp": "(?i).*(zipcode|zip_code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "zipcode"
        ],
        "negativeExamples": [
          "area code"
        ]
      },
      {
        "regExp": "(?i).*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postal code"
        ],
        "negativeExamples": [
          "zip code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "00501-0001",
      "02110-1234",
      "10001-0001",
      "30301-4444",
      "33109-4567",
      "60614-7890",
      "94105-6789",
      "96801-1122"
    ],
    "negativeContentExamples": [
      "123456789",
      "12345 6789",
      "12345-678",
      "1234-5678",
      "A2345-6789",
      "12345-678X",
      "12345\u20136789",
      "12345- 6789"
    ],
    "positiveHeaderExamples": [
      "US ZIP+4 Code",
      "ZIP+4",
      "zip4",
      "zip_plus4",
      "ZIPPLUS4",
      "ZIP-4",
      "US Zip+4",
      "Postal ZIP+4"
    ],
    "negativeHeaderExamples": [
      "ZIP Code",
      "Postal Code",
      "Area Code",
      "US ZIP",
      "ZIP",
      "Postcode",
      "Address Code",
      "City Code"
    ],
    "explanation": "This semantic type identifies United States ZIP+4 postal codes in the canonical 5-digit hyphen 4-digit format, ensuring precise routing and delivery segments (e.g., 12345-6789). It uses a strict boundary-based regex to match only five digits, a hyphen, and four digits, preventing false positives such as nine contiguous digits or values with spaces or letters. Use this to recognize columns storing USPS ZIP+4 values for address verification, geocoding enrichment, or mail routing tasks.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:08.893486"
  },
  {
    "resultType": "generated",
    "semanticType": "PERIOD.YEAR_RANGE",
    "description": "A temporal span expressed as a beginning year and ending year, typically used to indicate duration, validity periods, or historical timeframes.",
    "pluginType": "regex",
    "regexPattern": "\\b(1[6-9][0-9]{2}|20[0-9]{2}|2100)\\s*[-\u2013]\\s*(1[6-9][0-9]{2}|20[0-9]{2}|2100)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 5140,
    "headerPatterns": [
      {
        "regExp": "(?i).*fiscal.*year.*range.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fiscal_year_range"
        ],
        "negativeExamples": [
          "fiscal_quarter_range"
        ]
      },
      {
        "regExp": "(?i).*(coverage|validity|reporting).*year.*(range|span).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "coverage_year_span"
        ],
        "negativeExamples": [
          "coverage_period_days"
        ]
      },
      {
        "regExp": "(?i).*(project|employment).*year.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "project_years"
        ],
        "negativeExamples": [
          "project_months"
        ]
      },
      {
        "regExp": "(?i).*(period|span).*year.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "period_of_years"
        ],
        "negativeExamples": [
          "period_of_months"
        ]
      },
      {
        "regExp": "(?i).*year.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "year"
        ],
        "negativeExamples": [
          "date"
        ]
      }
    ],
    "positiveContentExamples": [
      "1999-2003",
      "2010\u20132015",
      "1900-1905",
      "2001-2001",
      "1987 \u2013 1992",
      "1600-1699",
      "2050-2100"
    ],
    "negativeContentExamples": [
      "199-2003",
      "201A-2015",
      "2015/2019",
      "2020-19",
      "2020\u20142024",
      "1600- 169",
      "2101-2105",
      "1500-1599"
    ],
    "positiveHeaderExamples": [
      "fiscal_year_range",
      "project_years",
      "coverage_year_span",
      "validity_year_range",
      "period_of_years",
      "employment_years"
    ],
    "negativeHeaderExamples": [
      "fiscal_quarter_range",
      "project_months",
      "coverage_period_days",
      "validity_date_range",
      "year_of_birth",
      "employment_duration"
    ],
    "explanation": "This semantic type targets values that represent a start year and an end year separated by a hyphen or en dash, supporting typical temporal spans such as fiscal periods, project durations, and validity intervals. It restricts years to a reasonable historical/modern range and requires two four-digit years with a clear separator to avoid ambiguity.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:09.664003"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_IT",
    "description": "Italian province codes used for administrative and postal identification of provinces within Italy's regional system. These standardized two-letter abbreviations enable efficient reference to specific provincial jurisdictions in government and business processes throughout Italian regions.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5630,
    "headerPatterns": [
      {
        "regExp": "(?i).*italy.*province.*code.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "italy_province_code"
        ],
        "negativeExamples": [
          "province_code"
        ]
      },
      {
        "regExp": "(?i).*(italian|ita|it).*prov.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "italian_prov_code"
        ],
        "negativeExamples": [
          "prov_code"
        ]
      },
      {
        "regExp": "(?i).*(province|prov).*code.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "province_code"
        ],
        "negativeExamples": [
          "region_code"
        ]
      },
      {
        "regExp": "(?i).*(province|prov).*(abbr|abbrev|short).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "province_abbr"
        ],
        "negativeExamples": [
          "postal_abbr"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "RM",
      "MI",
      "TO",
      "NA",
      "FI",
      "BO",
      "BA",
      "GE"
    ],
    "negativeContentExamples": [
      "rm",
      "R M",
      "R1",
      "ROM",
      "RM.",
      "RM-",
      "RM_IT",
      "ROMA"
    ],
    "positiveHeaderExamples": [
      "italy_province_code",
      "prov_code_it",
      "province_code",
      "italian_prov_code",
      "province_abbr",
      "it_province_code",
      "province_short_code",
      "provincial_code_it"
    ],
    "negativeHeaderExamples": [
      "region_code_it",
      "postal_code",
      "state_code",
      "province_name",
      "city_code",
      "country_code",
      "county_code",
      "municipality_code"
    ],
    "explanation": "This semantic type targets two-letter Italian province abbreviations used in administrative and postal contexts. Values are expected to be exactly two uppercase alphabetic characters. Header patterns prioritize explicit references to Italy and provinces, then abbreviations, and finally the primitive term 'code' to ensure safe classification.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:10.908139"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_CA",
    "description": "Canadian province codes used for administrative and postal identification of the provinces and territories within Canada. These standardized two-letter abbreviations enable efficient reference to specific provincial jurisdictions in government and business processes throughout the Canadian federation.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AB",
      "BC",
      "MB",
      "NB",
      "NL",
      "NS",
      "NT",
      "NU",
      "ON",
      "PE",
      "QC",
      "SK",
      "YT"
    ],
    "backout": "^[A-Z]{2}$",
    "confidenceThreshold": 98,
    "priority": 5620,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bca\\b.*(province|prov|territory|terr).*(code|abbr|abbrev).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ca_province_code"
        ],
        "negativeExamples": [
          "province_code"
        ]
      },
      {
        "regExp": "(?i).*(canada|canadian).*prov.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "canadian_prov_code"
        ],
        "negativeExamples": [
          "canadian_province_name"
        ]
      },
      {
        "regExp": "(?i).*(province|prov|territory|terr).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province_code"
        ],
        "negativeExamples": [
          "province_name"
        ]
      },
      {
        "regExp": "(?i).*(province|prov|territory|terr).*(abbr|abbrev|short).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "billing_province_abbr"
        ],
        "negativeExamples": [
          "state_abbr"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "ON",
      "QC",
      "BC",
      "AB",
      "MB",
      "NB",
      "NS",
      "NL"
    ],
    "negativeContentExamples": [
      "on",
      "ONT",
      "PQ",
      "NF",
      "QB",
      "BC-",
      "AB1",
      "YY"
    ],
    "positiveHeaderExamples": [
      "ca_province_code",
      "province_code",
      "prov_code_ca",
      "canadian_prov_code",
      "province_territory_code",
      "billing_province_abbr",
      "shipping_prov_code",
      "ca_territory_code"
    ],
    "negativeHeaderExamples": [
      "province_name",
      "state_code",
      "postal_code",
      "country_code",
      "ca_state_code",
      "territory_name",
      "subdivision_code",
      "region_code"
    ],
    "explanation": "This semantic type captures the official two-letter codes for Canadian provinces and territories. It is a finite, standardized list suitable for precise validation and normalization in datasets involving Canadian addresses, shipping, taxation, and administrative records. Using a list-based plugin ensures only valid codes are accepted, while the anchored backout pattern enforces the general two-letter uppercase shape for graceful degradation.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:12.919655"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_CA",
    "description": "Canadian province names representing the official designations of provinces and territories within Canada's federal system. These geographic administrative divisions serve as primary political and territorial units for regional government and public services throughout the Canadian confederation.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "ALBERTA",
      "BRITISH COLUMBIA",
      "MANITOBA",
      "NEW BRUNSWICK",
      "NEWFOUNDLAND AND LABRADOR",
      "NOVA SCOTIA",
      "ONTARIO",
      "PRINCE EDWARD ISLAND",
      "QUEBEC",
      "SASKATCHEWAN",
      "NORTHWEST TERRITORIES",
      "NUNAVUT",
      "YUKON"
    ],
    "backout": "^[A-Za-z][A-Za-z ]{3,25}$",
    "confidenceThreshold": 98,
    "priority": 5640,
    "headerPatterns": [
      {
        "regExp": "(?i).*(canada|canadian).*(province|territory).*name.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Canadian province name"
        ],
        "negativeExamples": [
          "Canadian province code"
        ]
      },
      {
        "regExp": "(?i).*province.*name.*(canada|ca).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "province_name_ca"
        ],
        "negativeExamples": [
          "province_code_ca"
        ]
      },
      {
        "regExp": "(?i).*(province|territory).*(full|long).*name.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "territory full name"
        ],
        "negativeExamples": [
          "territory short code"
        ]
      },
      {
        "regExp": "(?i).*(prov|terr).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "prov_name"
        ],
        "negativeExamples": [
          "prov_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Alberta",
      "British Columbia",
      "Manitoba",
      "New Brunswick",
      "Newfoundland and Labrador",
      "Ontario",
      "Quebec",
      "Yukon"
    ],
    "negativeContentExamples": [
      "Alberta Province",
      "Province of Ontario",
      "Quebec City",
      "New-Brunswick",
      "British Colombia",
      "Northwest Territory",
      "Yukon Territory",
      "PEI"
    ],
    "positiveHeaderExamples": [
      "Canadian province name",
      "province_name_ca",
      "Canada territory full name",
      "prov_name",
      "territory long name",
      "ca_province_name",
      "name_province_canada",
      "province of canada name"
    ],
    "negativeHeaderExamples": [
      "Canadian province code",
      "province_abbreviation",
      "province_id",
      "territory_code_ca",
      "country name",
      "state name",
      "city name",
      "region code"
    ],
    "explanation": "This semantic type identifies columns whose values are the official names of Canadian provinces and territories. The plugin uses a finite, curated list of valid names and supportive header patterns to distinguish these fields from similar location-related columns. It is well-suited for datasets containing administrative geography fields where full province/territory names are expected.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:13.241359"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.MIDDLE_INITIAL",
    "description": "A single letter representing the first character of a person's middle name, typically followed by a period in formal contexts.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z]\\b(\\.)?",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5080,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bmiddle\\b.*\\binitial\\b.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "middle_initial"
        ],
        "negativeExamples": [
          "first_initial"
        ]
      },
      {
        "regExp": "(?i).*\\bmiddle\\b.*\\bname\\b.*\\binitial\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "middle name initial"
        ],
        "negativeExamples": [
          "middle last initial"
        ]
      },
      {
        "regExp": "(?i).*\\bm[._ ]?i[._ ]?\\b.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "m.i."
        ],
        "negativeExamples": [
          "miami"
        ]
      },
      {
        "regExp": "(?i).*\\bmiddle\\b.*\\bname\\b.*",
        "confidence": 91,
        "mandatory": true,
        "positiveExamples": [
          "middle name"
        ],
        "negativeExamples": [
          "full name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "A.",
      "B",
      "c.",
      "d",
      "E.",
      "f",
      "G.",
      "h"
    ],
    "negativeContentExamples": [
      "AB",
      "A.B",
      "AJ",
      "A..",
      "4",
      "Z-",
      "\u00c4.",
      "A B"
    ],
    "positiveHeaderExamples": [
      "middle_initial",
      "middle initial",
      "middle name initial",
      "m.i.",
      "m initial",
      "person_middle_initial",
      "middle name",
      "middle name initial"
    ],
    "negativeHeaderExamples": [
      "first_initial",
      "last_initial",
      "middle_names",
      "middle",
      "initials",
      "name_code",
      "middle_last_initial",
      "miami"
    ],
    "explanation": "This semantic type detects a single alphabetic character representing a person's middle initial, optionally followed by a period. It is useful for parsing formal names where the middle name is abbreviated to an initial, supporting both uppercase and lowercase inputs and common punctuation formats.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:15.396187"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PREFECTURE_NAME_JA",
    "description": "Japanese prefecture names representing the primary administrative divisions within Japan's governmental system. These tod\u014dfuken serve as fundamental territorial units for regional administration, public services, and local government coordination throughout Japanese territory.",
    "pluginType": "regex",
    "regexPattern": "(\u5317\u6d77\u9053|\u9752\u68ee\u770c|\u5ca9\u624b\u770c|\u5bae\u57ce\u770c|\u79cb\u7530\u770c|\u5c71\u5f62\u770c|\u798f\u5cf6\u770c|\u8328\u57ce\u770c|\u6803\u6728\u770c|\u7fa4\u99ac\u770c|\u57fc\u7389\u770c|\u5343\u8449\u770c|\u6771\u4eac\u90fd|\u795e\u5948\u5ddd\u770c|\u65b0\u6f5f\u770c|\u5bcc\u5c71\u770c|\u77f3\u5ddd\u770c|\u798f\u4e95\u770c|\u5c71\u68a8\u770c|\u9577\u91ce\u770c|\u5c90\u961c\u770c|\u9759\u5ca1\u770c|\u611b\u77e5\u770c|\u4e09\u91cd\u770c|\u6ecb\u8cc0\u770c|\u4eac\u90fd\u5e9c|\u5927\u962a\u5e9c|\u5175\u5eab\u770c|\u5948\u826f\u770c|\u548c\u6b4c\u5c71\u770c|\u9ce5\u53d6\u770c|\u5cf6\u6839\u770c|\u5ca1\u5c71\u770c|\u5e83\u5cf6\u770c|\u5c71\u53e3\u770c|\u5fb3\u5cf6\u770c|\u9999\u5ddd\u770c|\u611b\u5a9b\u770c|\u9ad8\u77e5\u770c|\u798f\u5ca1\u770c|\u4f50\u8cc0\u770c|\u9577\u5d0e\u770c|\u718a\u672c\u770c|\u5927\u5206\u770c|\u5bae\u5d0e\u770c|\u9e7f\u5150\u5cf6\u770c|\u6c96\u7e04\u770c)",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5610,
    "headerPatterns": [
      {
        "regExp": "(?i).*(ja|jp|jpn).*prefecture.*name.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "ja_prefecture_name"
        ],
        "negativeExamples": [
          "prefecture_name"
        ]
      },
      {
        "regExp": "(?i).*\u90fd\u9053\u5e9c\u770c.*\u540d.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "\u90fd\u9053\u5e9c\u770c\u540d"
        ],
        "negativeExamples": [
          "\u90fd\u9053\u5e9c\u770c\u30b3\u30fc\u30c9"
        ]
      },
      {
        "regExp": "(?i).*(japan|jp|jpn).*prefecture.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "japan_prefecture"
        ],
        "negativeExamples": [
          "prefecture_code"
        ]
      },
      {
        "regExp": "(?i).*(pref|prefect).*name.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "pref_name"
        ],
        "negativeExamples": [
          "pref_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "\u6771\u4eac\u90fd",
      "\u5317\u6d77\u9053",
      "\u4eac\u90fd\u5e9c",
      "\u5927\u962a\u5e9c",
      "\u795e\u5948\u5ddd\u770c",
      "\u6c96\u7e04\u770c",
      "\u798f\u5ca1\u770c",
      "\u9577\u91ce\u770c"
    ],
    "negativeContentExamples": [
      "\u6771\u4eac",
      "\u6771\u4eac\u90fd",
      "\u4eac\u90fd\u770c",
      "\u5927\u962a\u5e02",
      "\u795e\u5948\u5ddd",
      "\u6c96\u7e04",
      "\u798f\u5ca1",
      "\u9577\u91ce\u5e02"
    ],
    "positiveHeaderExamples": [
      "prefecture_name_ja",
      "ja_prefecture_name",
      "\u90fd\u9053\u5e9c\u770c\u540d",
      "japanese_prefecture",
      "prefecture_name_jp",
      "jp_prefecture",
      "pref_name",
      "jpn_prefecture_name"
    ],
    "negativeHeaderExamples": [
      "prefecture_code",
      "city_name_ja",
      "state_name",
      "province_code",
      "country_name_ja",
      "region_name",
      "municipality_name",
      "prefecture_id"
    ],
    "explanation": "This semantic type identifies official Japanese prefecture names (tod\u014dfuken) written in Japanese script (Kanji), including the correct administrative suffixes: \u90fd, \u9053, \u5e9c, or \u770c. It enumerates all 47 prefectural names to provide precise matching without relying on broad wildcards or anchors. Typical uses include standardizing location dimensions, validating address components, and enriching geospatial datasets where Japanese administrative divisions are required. Values that omit the administrative suffix or reference municipalities (e.g., cities) are intentionally excluded.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:16.967140"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.DEPARTMENT_CO",
    "description": "Colombian department names representing the primary administrative divisions within Colombia's federal structure. These departamentos serve as major territorial units for regional government, public services, and administrative coordination throughout the Colombian territory.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(amazonas|antioquia|arauca|atl[a\u00e1]ntico|bol[i\u00ed]var|boyac[a\u00e1]|caldas|caquet[a\u00e1]|casanare|cauca|cesar|choc[o\u00f3]|c[o\u00f3]rdoba|cundinamarca|guain[i\u00ed]a|guaviare|huila|la guajira|magdalena|meta|nari[n\u00f1]o|norte de santander|putumayo|quind[i\u00ed]o|risaralda|san andr[e\u00e9]s y providencia|santander|sucre|tolima|valle del cauca|vaup[e\u00e9]s|vichada|bogot[a\u00e1]|bogot[a\u00e1]\\s*d\\.?\\s*c\\.?)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5500,
    "headerPatterns": [
      {
        "regExp": "(?i).*(colombia|co)[_\\s-]*(department|departamento)[_\\s-]*(name|nombre).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "co_department_name"
        ],
        "negativeExamples": [
          "co_department_code"
        ]
      },
      {
        "regExp": "(?i).*(department|departamento)[_\\s-]*(colombia|co).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "department_colombia"
        ],
        "negativeExamples": [
          "department_code"
        ]
      },
      {
        "regExp": "(?i).*(dept|depto)[_\\s-]*(co|col).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "dept_co"
        ],
        "negativeExamples": [
          "dept_id"
        ]
      },
      {
        "regExp": "(?i).*(state|province|region)[_\\s-]*(colombia|co).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "province_co"
        ],
        "negativeExamples": [
          "province_name"
        ]
      },
      {
        "regExp": "(?i).*(department|departamento|dept|depto).*",
        "confidence": 91,
        "mandatory": true,
        "positiveExamples": [
          "department"
        ],
        "negativeExamples": [
          "province"
        ]
      }
    ],
    "positiveContentExamples": [
      "Antioquia",
      "Atl\u00e1ntico",
      "Valle del Cauca",
      "Norte de Santander",
      "San Andres y Providencia",
      "Quind\u00edo",
      "C\u00f3rdoba",
      "Bogot\u00e1 D.C."
    ],
    "negativeContentExamples": [
      "Antioquia Dept",
      "Departamento de Cundinamarca",
      "Valle del Cauca Department",
      "Norte Santander",
      "San Andres Providencia",
      "Bogot\u00e1, D.C.",
      "La Guajaira",
      "Cordova"
    ],
    "positiveHeaderExamples": [
      "co_department_name",
      "colombia_departamento",
      "department_colombia",
      "dept_co",
      "region_colombia",
      "departamento_nombre",
      "departamento_co"
    ],
    "negativeHeaderExamples": [
      "province_name",
      "municipality",
      "division_name",
      "admin_area",
      "state_code",
      "estado_colombia",
      "city"
    ],
    "explanation": "This semantic type targets values that are the official names of Colombia's first-level administrative divisions (departamentos), including common diacritic variations and typical forms such as Bogot\u00e1 D.C. It is useful for normalizing region-level attributes, validating location fields, and harmonizing geographic dimensions in datasets focused on Colombian territories.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:18.584292"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_ZA",
    "description": "South African province names representing the administrative divisions within South Africa's federal system. These provinces serve as primary territorial units for regional government administration and public service delivery throughout the South African territory.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "EASTERN CAPE",
      "FREE STATE",
      "GAUTENG",
      "KWAZULU-NATAL",
      "LIMPOPO",
      "MPUMALANGA",
      "NORTH WEST",
      "NORTHERN CAPE",
      "WESTERN CAPE"
    ],
    "backout": "^([A-Z]|[A-Z][A-Z\\s\\-]{2,30})$",
    "confidenceThreshold": 98,
    "priority": 5710,
    "headerPatterns": [
      {
        "regExp": "(?i).*(south\\s*africa|za).*province.*name.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "south_africa_province_name"
        ],
        "negativeExamples": [
          "south_africa_province_code"
        ]
      },
      {
        "regExp": "(?i).*south\\s*africa.*province.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "south_africa_province"
        ],
        "negativeExamples": [
          "south_africa_state_name"
        ]
      },
      {
        "regExp": "(?i).*za.*province.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "za_province"
        ],
        "negativeExamples": [
          "za_postal_code"
        ]
      },
      {
        "regExp": "(?i).*prov.*name.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "prov_name"
        ],
        "negativeExamples": [
          "prov_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "GAUTENG",
      "WESTERN CAPE",
      "EASTERN CAPE",
      "NORTHERN CAPE",
      "FREE STATE",
      "NORTH WEST",
      "LIMPOPO",
      "KWAZULU-NATAL"
    ],
    "negativeContentExamples": [
      "GAUTENG PROVINCE",
      "KWAZULU NATAL",
      "KWA ZULU NATAL",
      "NORTHWEST",
      "NORTHERN-CAPE",
      "WESTERN CAPE.",
      "EASTERN CAPES",
      "FREESTATE"
    ],
    "positiveHeaderExamples": [
      "south_africa_province_name",
      "province_name_za",
      "za_province",
      "province_name",
      "prov_name",
      "province",
      "za_province_name",
      "province_name_south_africa"
    ],
    "negativeHeaderExamples": [
      "province_code",
      "state_name",
      "postal_code",
      "country",
      "city_name",
      "region",
      "territory_name",
      "admin_level"
    ],
    "explanation": "This semantic type captures the official names of South Africa's nine provinces, enabling accurate classification and validation of administrative division fields in ZA-focused datasets. Use this type to validate province fields, standardize region filters, and improve geospatial joins where full province names are expected. The list-based approach ensures precise matching to the finite canon of province names, with a conservative backout shape for sanity checks.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:18.893991"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_IE",
    "description": "Irish province names representing the traditional historic divisions within Ireland's geographic organization. These ancient provinces serve as cultural and regional identifiers that predate modern administrative boundaries in both the Republic of Ireland and Northern Ireland.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "LEINSTER",
      "MUNSTER",
      "ULSTER",
      "CONNACHT",
      "CONNAUGHT",
      "C\u00daIGE LAIGHEAN",
      "C\u00daIGE MUMHAN",
      "C\u00daIGE ULADH",
      "C\u00daIGE CHONNACHT",
      "LAIGHEAN",
      "MUMHAN",
      "ULADH"
    ],
    "backout": "^[A-Z\u00c1\u00c9\u00cd\u00d3\u00da ]{4,20}$",
    "confidenceThreshold": 98,
    "priority": 5670,
    "headerPatterns": [
      {
        "regExp": "(?i).*(irish|ie).*province.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ie_province_name"
        ],
        "negativeExamples": [
          "province_code"
        ]
      },
      {
        "regExp": "(?i).*province.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province_name"
        ],
        "negativeExamples": [
          "region_name"
        ]
      },
      {
        "regExp": "(?i).*(prov|cuige).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "prov_name"
        ],
        "negativeExamples": [
          "state_name"
        ]
      },
      {
        "regExp": "(?i).*(province|prov|cuige).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cuige"
        ],
        "negativeExamples": [
          "county"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Leinster",
      "Munster",
      "Ulster",
      "Connacht",
      "Connaught",
      "C\u00faige Laighean",
      "C\u00faige Uladh",
      "Mumhan"
    ],
    "negativeContentExamples": [
      "Province of Connacht",
      "Connacht Province",
      "Ulsters",
      "Munstar",
      "Leicester",
      "Laighin",
      "Ulad",
      "Mumnhan"
    ],
    "positiveHeaderExamples": [
      "ie_province_name",
      "irish_province",
      "province_name",
      "province",
      "prov_name",
      "cuige",
      "province_ie",
      "province_nm"
    ],
    "negativeHeaderExamples": [
      "county_name",
      "state_name",
      "region",
      "country",
      "province_code",
      "province_id",
      "prov_code",
      "state_province"
    ],
    "explanation": "This semantic type targets the four traditional Irish provinces and their common English and Irish forms, enabling precise classification of datasets containing province names for Ireland. It is useful for geodemographic segmentation, cultural/regional grouping, and historical analyses where provinces serve as identifiers rather than current administrative units.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:20.972564"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_UK",
    "description": "United Kingdom county names representing the ceremonial and administrative divisions across England, Scotland, Wales, and Northern Ireland. These historic counties serve as important geographic and administrative reference units within the UK governmental system.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b((County\\s+[A-Z][a-z]+(\\s+[A-Z][a-z]+)?)|((Isle|Isles)\\s+of\\s+[A-Z][a-z]+)|((East|West|North|South|Greater)\\s+[A-Z][a-z]+(shire)?)|([A-Z][a-z]+shire)|(Tyne\\s+and\\s+Wear|West\\s+Midlands|East\\s+Midlands|Greater\\s+London|City\\s+of\\s+London|City\\s+of\\s+Bristol|Isles\\s+of\\s+Scilly|East\\s+Riding\\s+of\\s+Yorkshire|North\\s+Yorkshire|South\\s+Yorkshire|West\\s+Yorkshire|County\\s+Durham|Isle\\s+of\\s+Wight|Scottish\\s+Borders|Highland))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 5480,
    "headerPatterns": [
      {
        "regExp": "(?i).*(uk|united\\s+kingdom|gb|great\\s+britain).*(county|counties).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "uk_county_name"
        ],
        "negativeExamples": [
          "uk_country_name"
        ]
      },
      {
        "regExp": "(?i).*(ceremonial|administrative).*(county|counties).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "ceremonial_county"
        ],
        "negativeExamples": [
          "administrative_area"
        ]
      },
      {
        "regExp": "(?i).*(england|scotland|wales|northern\\s+ireland).*(county|counties).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "england_county"
        ],
        "negativeExamples": [
          "england_city"
        ]
      },
      {
        "regExp": "(?i).*(county|counties).*(name|nm|label).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "county_name"
        ],
        "negativeExamples": [
          "country_name"
        ]
      },
      {
        "regExp": "(?i).*(county|counties).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "county"
        ],
        "negativeExamples": [
          "country"
        ]
      }
    ],
    "positiveContentExamples": [
      "Oxfordshire",
      "County Down",
      "Greater Manchester",
      "Tyne and Wear",
      "Isle of Wight",
      "West Sussex",
      "East Riding of Yorkshire",
      "Scottish Borders"
    ],
    "negativeContentExamples": [
      "Manchester",
      "London",
      "City of York",
      "Mid Sussex",
      "Bristol",
      "Argyll and Bute",
      "Southend-on-Sea",
      "London Borough of Camden"
    ],
    "positiveHeaderExamples": [
      "uk_county",
      "county_name",
      "ceremonial_county",
      "england_county",
      "gb_counties",
      "administrative_county",
      "uk_county_name",
      "county"
    ],
    "negativeHeaderExamples": [
      "uk_country",
      "country_name",
      "city",
      "region_code",
      "borough",
      "province",
      "district_name",
      "postcode"
    ],
    "explanation": "This semantic type targets strings that plausibly represent UK county names across the home nations, including common naming constructs such as \u201cCounty X\u201d, \u201cXshire\u201d, \u201cGreater X\u201d, \u201cIsle(s) of X\u201d, and a small set of established multi-word county forms. It is intended for geographic administrative/cadastral classification at the county-equivalent level and uses a pattern-based approach to avoid enumerating a large, evolving list of names.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:22.739161"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.CANTON_NAME_CH",
    "description": "Swiss canton names representing the official designations of the 26 federal states within Switzerland. These geographic administrative divisions serve as primary political and territorial units in the Swiss federal system.",
    "pluginType": "regex",
    "regexPattern": "\\b(Z\u00fcrich|Bern|Berne|Luzern|Uri|Schwyz|Obwalden|Nidwalden|Glarus|Zug|Fribourg|Freiburg|Solothurn|Basel-Stadt|Basel-Landschaft|Schaffhausen|Appenzell Ausserrhoden|Appenzell Innerrhoden|St\\. Gallen|Graub\u00fcnden|Grischun|Grisons|Grigioni|Aargau|Thurgau|Ticino|Vaud|Valais|Wallis|Neuch\u00e2tel|Gen\u00e8ve|Jura)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5430,
    "headerPatterns": [
      {
        "regExp": "(?i).*(ch|swiss).*(canton|kanton).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CH canton name"
        ],
        "negativeExamples": [
          "CH canton code"
        ]
      },
      {
        "regExp": "(?i).*(canton|kanton).*(full).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "canton full name"
        ],
        "negativeExamples": [
          "canton short name"
        ]
      },
      {
        "regExp": "(?i).*(canton|kanton).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "canton"
        ],
        "negativeExamples": [
          "province"
        ]
      },
      {
        "regExp": "(?i).*(cantonal|kt).*(name).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "kt name"
        ],
        "negativeExamples": [
          "kt code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Z\u00fcrich",
      "Berne",
      "Luzern",
      "Basel-Stadt",
      "Appenzell Innerrhoden",
      "Gen\u00e8ve",
      "Graub\u00fcnden",
      "Valais"
    ],
    "negativeContentExamples": [
      "Zurich",
      "St Gallen",
      "Basel Stadt",
      "Appenzell Inner Rhoden",
      "Geneva",
      "Fribourg, CH",
      "Wallis canton",
      "GR Graub\u00fcnden"
    ],
    "positiveHeaderExamples": [
      "CH canton name",
      "swiss canton",
      "canton full name",
      "cantonal name",
      "kt name",
      "canton",
      "canton label",
      "canton_name"
    ],
    "negativeHeaderExamples": [
      "canton code",
      "state name",
      "province",
      "country name",
      "region",
      "state code",
      "timezone name",
      "airport name"
    ],
    "explanation": "This semantic type identifies values that are official Swiss canton names, including multilingual official variants used by bilingual and trilingual cantons. It is intended for columns containing only canton names, not codes or anglicized forms, and excludes misspellings, abbreviations, or additional qualifiers.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:24.222516"
  },
  {
    "resultType": "generated",
    "semanticType": "SPATIAL.WKT",
    "description": "Well-Known Text representations used for describing geometric objects in spatial databases and GIS applications. These standardized text formats encode spatial geometries using coordinate sequences within predefined geometric type structures.",
    "pluginType": "regex",
    "regexPattern": "\\b(SRID=[0-9]+;\\s*)?((GEOMETRYCOLLECTION)\\s*\\(\\s*[A-Za-z0-9\\-\\+\\.,\\s\\(\\)]+\\)|(POINT|LINESTRING|POLYGON|MULTIPOINT|MULTILINESTRING|MULTIPOLYGON)\\s*(EMPTY|\\(\\s*[-+0-9\\.,\\s\\(\\)]+\\)))",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5400,
    "headerPatterns": [
      {
        "regExp": "(?i).*(geometry|geom|shape).*wkt.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "geometry_wkt"
        ],
        "negativeExamples": [
          "geometry"
        ]
      },
      {
        "regExp": "(?i).*wkt.*(geometry|geom|shape).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "wkt_geometry"
        ],
        "negativeExamples": [
          "spatial_wkt"
        ]
      },
      {
        "regExp": "(?i).*well.*known.*text.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "well_known_text"
        ],
        "negativeExamples": [
          "coordinate_text"
        ]
      },
      {
        "regExp": "(?i).*(spatial).*wkt.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "spatial_wkt"
        ],
        "negativeExamples": [
          "spatial_ref"
        ]
      },
      {
        "regExp": "(?i).*wkt.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "wkt"
        ],
        "negativeExamples": [
          "geojson"
        ]
      }
    ],
    "positiveContentExamples": [
      "POINT (30 10)",
      "LINESTRING (30 10, 10 30, 40 40)",
      "POLYGON ((30 10, 40 40, 20 40, 10 20, 30 10))",
      "MULTIPOINT (10 40, 40 30, 20 20, 30 10)",
      "MULTILINESTRING ((10 10, 20 20), (15 15, 30 15))",
      "MULTIPOLYGON (((30 20, 45 40, 10 40, 30 20)))",
      "GEOMETRYCOLLECTION (POINT (40 10), LINESTRING (10 10, 20 20))",
      "SRID=4326;POINT (12.34 -45.67)"
    ],
    "negativeContentExamples": [
      "POINT 30 10",
      "LINE STRING (30 10, 10 30)",
      "SRID=abc;POINT (30 10)",
      "GEOMETRYCOLLECTION POINT (40 10)",
      "EPSG:4326;POINT (30 10)",
      "POINT ()",
      "POINTZ (30 10 5)",
      "POLYGON 30 10, 40 40, 20 40, 10 20, 30 10"
    ],
    "positiveHeaderExamples": [
      "geometry_wkt",
      "wkt_geometry",
      "geom_wkt",
      "well_known_text",
      "spatial_wkt",
      "shape_wkt",
      "wkt_string"
    ],
    "negativeHeaderExamples": [
      "geometry",
      "geom",
      "geojson",
      "spatial_ref",
      "srid",
      "coordinate_text",
      "shape_type"
    ],
    "explanation": "This semantic type identifies strings that represent spatial geometries in Well-Known Text form, including POINT, LINESTRING, POLYGON, multiparts, and geometry collections. It optionally recognizes an SRID prefix. Use this to detect and validate columns storing WKT geometry payloads for GIS processing, spatial indexing, and ETL normalization.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:25.873546"
  },
  {
    "resultType": "generated",
    "semanticType": "SPATIAL.GEOJSON",
    "description": "GeoJSON geometric objects used for representing spatial data in geographic information systems and web mapping applications. These standardized JSON structures encode geographic features including points, lines, and polygons with coordinate information.",
    "pluginType": "regex",
    "regexPattern": "((\\{\\s*\"type\"\\s*:\\s*\"(Point|MultiPoint|LineString|MultiLineString|Polygon|MultiPolygon)\"\\s*,\\s*\"coordinates\"\\s*:\\s*\\[)|(\\{\\s*\"type\"\\s*:\\s*\"GeometryCollection\"\\s*,\\s*\"geometries\"\\s*:\\s*\\[)|(\\{\\s*\"type\"\\s*:\\s*\"Feature\"\\s*,\\s*\"geometry\"\\s*:\\s*\\{)|(\\{\\s*\"type\"\\s*:\\s*\"FeatureCollection\"\\s*,\\s*\"features\"\\s*:\\s*\\[))",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 5390,
    "headerPatterns": [
      {
        "regExp": "(?i).*(geometry|feature|shape|boundary|footprint).*geojson.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "feature_geojson"
        ],
        "negativeExamples": [
          "feature_json"
        ]
      },
      {
        "regExp": "(?i).*geojson.*(geometry|feature|shape|polygon|line|point).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "geojson_geometry"
        ],
        "negativeExamples": [
          "geojson_format"
        ]
      },
      {
        "regExp": "(?i).*(spatial|gis|map).*geojson.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "spatial_geojson"
        ],
        "negativeExamples": [
          "spatial_json"
        ]
      },
      {
        "regExp": "(?i).*(geomjson|geo_json|gjson|gj).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "route_gjson"
        ],
        "negativeExamples": [
          "geom_wkt"
        ]
      },
      {
        "regExp": "(?i).*geojson.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "geojson"
        ],
        "negativeExamples": [
          "json"
        ]
      }
    ],
    "positiveContentExamples": [
      "{\"type\":\"Point\",\"coordinates\":[102.0, 0.5]}",
      "{\"type\":\"Point\",\"coordinates\":[-71.060316, 42.357575, 12]}",
      "{\"type\":\"LineString\",\"coordinates\":[[102.0, 0.0],[103.0, 1.0]]}",
      "{\"type\":\"Polygon\",\"coordinates\":[[[100.0,0.0],[101.0,0.0],[101.0,1.0],[100.0,1.0],[100.0,0.0]]]}",
      "{\"type\":\"MultiPoint\",\"coordinates\":[[100.0, 0.0],[101.0, 1.0]]}",
      "{\"type\":\"Feature\",\"geometry\":{\"type\":\"Point\",\"coordinates\":[125.6, 10.1]},\"properties\":{\"name\":\"Dinagat\"}}",
      "{\"type\":\"FeatureCollection\",\"features\":[{\"type\":\"Feature\",\"geometry\":{\"type\":\"Point\",\"coordinates\":[0,0]},\"properties\":{}}]}",
      "{\"type\":\"GeometryCollection\",\"geometries\":[{\"type\":\"Point\",\"coordinates\":[100.0, 0.0]}]}"
    ],
    "negativeContentExamples": [
      "{\"type\":\"Point\",\"coordinate\":[102.0, 0.5]}",
      "{\"coordinates\":[102.0, 0.5],\"type\":\"Point\"}",
      "{\"type\":\"Feature\",\"properties\":{\"name\":\"Only properties\"}}",
      "{\"type\":\"FeatureCollection\",\"feature\":[{\"type\":\"Feature\",\"geometry\":{\"type\":\"Point\",\"coordinates\":[0,0]},\"properties\":{}}]}",
      "POINT(102 0.5)",
      "{\"type\":\"GeometryCollection\",\"coordinates\":[[0,0]]}",
      "{\"type\":\"LineString\",\"coordinates\":\"[102.0, 0.0]\"}",
      "{\"type\":\"Polygon\",\"coordinates\":{}}"
    ],
    "positiveHeaderExamples": [
      "geometry_geojson",
      "feature_geojson",
      "route_geometry_geojson",
      "boundary_geojson",
      "spatial_geojson",
      "geojson_geometry",
      "geomjson"
    ],
    "negativeHeaderExamples": [
      "geometry_json",
      "geometry_wkt",
      "spatial_ref",
      "wkb_geom",
      "topojson",
      "coordinates",
      "geo_uri"
    ],
    "explanation": "This semantic type identifies text values containing GeoJSON objects, including core geometry types (Point, LineString, Polygon, and their multi-variants), GeometryCollection, Feature, and FeatureCollection. It is useful for classifying columns that store spatial geometries or feature payloads in GeoJSON format within GIS and mapping datasets.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:27.112880"
  },
  {
    "resultType": "generated",
    "semanticType": "HASH.SHA1_HEX",
    "description": "A cryptographic hash value produced by the SHA-1 algorithm, represented as a 40-character hexadecimal string for data integrity verification.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9A-Fa-f]{40}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4730,
    "headerPatterns": [
      {
        "regExp": "(?i).*sha[ _-]?1[ _-]?hex.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "sha1_hex"
        ],
        "negativeExamples": [
          "sha1digest"
        ]
      },
      {
        "regExp": "(?i).*sha[ _-]?1.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "sha1"
        ],
        "negativeExamples": [
          "sha256"
        ]
      },
      {
        "regExp": "(?i).*sha[ _-]?1[ _-]?hash.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "sha1_hash"
        ],
        "negativeExamples": [
          "file_hash"
        ]
      },
      {
        "regExp": "(?i).*sha[ _-]?1[ _-]?digest.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "sha1_digest"
        ],
        "negativeExamples": [
          "digest_sha256"
        ]
      },
      {
        "regExp": "(?i).*hash.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "file_hash"
        ],
        "negativeExamples": [
          "checksum"
        ]
      }
    ],
    "positiveContentExamples": [
      "da39a3ee5e6b4b0d3255bfef95601890afd80709",
      "2fd4e1c67a2d28fced849ee1bb76e7391b93eb12",
      "A9993E364706816ABA3E25717850C26C9CD0D89D",
      "84983E441C3BD26EBAAE4AA1F95129E5E54670F1",
      "3F786850E387550FDAB836ED7E6DC881DE23001B",
      "e242ed3bffccdf271b7fbaf34ed72d089537b42f",
      "7C222FB2927D828AF22F592134E8932480637C0D",
      "5baa61e4c9b93f3f0682250b6cf8331b7ee68fd8"
    ],
    "negativeContentExamples": [
      "da39a3ee5e6b4b0d3255bfef95601890afd8070",
      "da39a3ee5e6b4b0d3255bfef95601890afd807090",
      "2fd4e1c67a2d28fced849ee1bb76e7391b93eb1z",
      "2fd4e1c67a2d28fc-ed849ee1bb76e7391b93eb12",
      "0x2fd4e1c67a2d28fced849ee1bb76e7391b93eb12",
      "900150983cd24fb0d6963f7d28e17f72",
      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "2fd4e1c67a2d28fced849ee1bb76e7391 b93eb12"
    ],
    "positiveHeaderExamples": [
      "sha1_hex",
      "sha1",
      "sha1_hash",
      "sha1_digest",
      "file_sha1",
      "content_sha1_hex",
      "sha1_checksum",
      "artifact_hash_sha1"
    ],
    "negativeHeaderExamples": [
      "sha256_hash",
      "md5_checksum",
      "sha256_digest",
      "md5sum",
      "content_md5",
      "encryption_key",
      "checksum_total",
      "data_signature"
    ],
    "explanation": "This type identifies SHA-1 cryptographic digests encoded as hexadecimal, enforcing exactly 40 hexadecimal characters and allowing uppercase or lowercase digits. It is useful for recognizing columns that store file checksums, content digests, or identifiers derived from SHA-1.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:29.171356"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_AU",
    "description": "A standardized abbreviation representing one of the six states or territories of Australia for administrative and postal identification purposes. Uses the official 2\u20133 letter uppercase forms (ACT, NSW, NT, QLD, SA, TAS, VIC, WA).",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "ACT",
      "NSW",
      "NT",
      "QLD",
      "SA",
      "TAS",
      "VIC",
      "WA"
    ],
    "backout": "^[A-Z]{2,3}$",
    "confidenceThreshold": 98,
    "priority": 5770,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\b(australia|au)\\b.*\\b(state|territory)\\b.*\\b(code|abbr|abbrev|short)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "au_state_code"
        ],
        "negativeExamples": [
          "state_code_us"
        ]
      },
      {
        "regExp": "(?i).*\\b(australian|au)\\b.*\\b(state|territory)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "australian_state"
        ],
        "negativeExamples": [
          "state_province"
        ]
      },
      {
        "regExp": "(?i).*\\b(state|territory)\\b.*\\b(abbr|abbrev|code|short)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_abbr"
        ],
        "negativeExamples": [
          "country_code"
        ]
      },
      {
        "regExp": "(?i).*\\bstate\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state"
        ],
        "negativeExamples": [
          "status"
        ]
      }
    ],
    "positiveContentExamples": [
      "NSW",
      "VIC",
      "QLD",
      "SA",
      "WA",
      "TAS",
      "ACT",
      "NT"
    ],
    "negativeContentExamples": [
      "N.S.W",
      "NS-W",
      "QLDS",
      "Vic",
      "ACT1",
      "WAU",
      "A C T",
      "NEW SOUTH WALES"
    ],
    "positiveHeaderExamples": [
      "au_state_code",
      "state_abbr_au",
      "australian_state",
      "state_territory_au",
      "state_code",
      "state_short",
      "au_territory_code",
      "state_abbr"
    ],
    "negativeHeaderExamples": [
      "province_code",
      "us_state",
      "country_code",
      "postcode_au",
      "timezone_au",
      "territory_name",
      "state_status",
      "state_id_number"
    ],
    "explanation": "This semantic type identifies Australian state and territory abbreviations as standardized 2\u20133 letter uppercase codes. It is suited for columns storing postal or administrative state/territory codes in Australian datasets. Using a finite list ensures high precision while the backout pattern constrains the general shape for fallbacks.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:29.342922"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_MX",
    "description": "A standardized abbreviation representing one of the thirty-two federal entities of Mexico for administrative and postal identification purposes.",
    "pluginType": "regex",
    "regexPattern": "\\bMX-[A-Z]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5800,
    "headerPatterns": [
      {
        "regExp": "(?i).*(mexico|mx).*(state|province|estado|entidad).*(code|codigo|abbr|abbrev).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mexico_state_code"
        ],
        "negativeExamples": [
          "mexico_state_name"
        ]
      },
      {
        "regExp": "(?i).*(mx|mexico).*(subdivision|federal|federativa).*(code|codigo).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mx_subdivision_code"
        ],
        "negativeExamples": [
          "mx_subdivision_name"
        ]
      },
      {
        "regExp": "(?i).*(state|province|estado|entidad).*(mx|mexico).*(code|codigo).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_mx_code"
        ],
        "negativeExamples": [
          "state_mx_name"
        ]
      },
      {
        "regExp": "(?i).*(mx).*(st|prov).*(code|cd).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mx_st_code"
        ],
        "negativeExamples": [
          "mx_st_name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "MX-AGU",
      "MX-BCN",
      "MX-BCS",
      "MX-CMX",
      "MX-CHH",
      "MX-JAL",
      "MX-MEX",
      "MX-ROO"
    ],
    "negativeContentExamples": [
      "AGU",
      "MX-AG",
      "MX-AGUA",
      "US-CA",
      "MX-123",
      "mx-ver",
      "MXBCN",
      "MX-BCN1"
    ],
    "positiveHeaderExamples": [
      "mx_state_code",
      "mexico_state_code",
      "state_code_mx",
      "mx_subdivision_code",
      "entidad_federativa_codigo",
      "provincia_mx_code",
      "estado_codigo_mx",
      "federal_entity_code_mx"
    ],
    "negativeHeaderExamples": [
      "mx_state_name",
      "state_abbr",
      "province_code",
      "country_code_mx",
      "mx_postal_code",
      "state_id_mx",
      "us_state_code",
      "mexico_region_name"
    ],
    "explanation": "This semantic type captures ISO-like Mexican federal entity abbreviations formatted as an 'MX-' prefix followed by three uppercase letters, enabling consistent identification of Mexico\u2019s states and Mexico City in datasets. It is useful for normalization, validation, and joining to reference tables of Mexican subdivisions where values are stored as standardized short codes.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:29.640875"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.REGION_NAME_PE",
    "description": "The name of one of the twenty-five regions of Peru, representing the primary administrative divisions of the Peruvian territory.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AMAZONAS",
      "ANCASH",
      "APURIMAC",
      "AREQUIPA",
      "AYACUCHO",
      "CAJAMARCA",
      "CALLAO",
      "CUSCO",
      "HUANCAVELICA",
      "HUANUCO",
      "ICA",
      "JUNIN",
      "LA LIBERTAD",
      "LAMBAYEQUE",
      "LIMA",
      "LORETO",
      "MADRE DE DIOS",
      "MOQUEGUA",
      "PASCO",
      "PIURA",
      "PUNO",
      "SAN MARTIN",
      "TACNA",
      "TUMBES",
      "UCAYALI"
    ],
    "backout": "^[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1]{2,}( [A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1]{2,}){0,3}$",
    "confidenceThreshold": 98,
    "priority": 5750,
    "headerPatterns": [
      {
        "regExp": "(?i).*peru.*region.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "peru_region_name"
        ],
        "negativeExamples": [
          "peru_region_code"
        ]
      },
      {
        "regExp": "(?i).*\\bpe\\b.*region.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "region_name_pe"
        ],
        "negativeExamples": [
          "pe_region_code"
        ]
      },
      {
        "regExp": "(?i).*peru.*region.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "peru_region"
        ],
        "negativeExamples": [
          "country_region"
        ]
      },
      {
        "regExp": "(?i).*department.*peru.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "department_name_peru"
        ],
        "negativeExamples": [
          "department_code"
        ]
      },
      {
        "regExp": "(?i).*(pe[_ -]?region|region[_ -]?pe).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "region_pe"
        ],
        "negativeExamples": [
          "region_id"
        ]
      },
      {
        "regExp": "(?i).*region.*",
        "confidence": 91,
        "mandatory": true,
        "positiveExamples": [
          "region"
        ],
        "negativeExamples": [
          "province"
        ]
      }
    ],
    "positiveContentExamples": [
      "AMAZONAS",
      "ANCASH",
      "AREQUIPA",
      "LA LIBERTAD",
      "LORETO",
      "MADRE DE DIOS",
      "SAN MARTIN",
      "UCAYALI"
    ],
    "negativeContentExamples": [
      "LIMA PROVINCE",
      "CUSCO REGION",
      "JUNIN-PE",
      "SAN MARTIN, PE",
      "LA_LIBERTAD",
      "AREQUIPA PERU",
      "CALLAO PROVINCIA",
      "AMAZONAS DEPARTMENT"
    ],
    "positiveHeaderExamples": [
      "peru_region_name",
      "region_name_pe",
      "peruvian_region_name",
      "department_name_peru",
      "administrative_region_peru",
      "pe_region",
      "region"
    ],
    "negativeHeaderExamples": [
      "province_name_pe",
      "state_province_code_pe",
      "region_code",
      "region_id",
      "country_region",
      "city_region_name",
      "peru_department_code"
    ],
    "explanation": "This semantic type identifies the official names of Peru's 25 administrative regions. It is suitable for columns containing normalized region names without suffixes like 'REGION', 'DEPARTMENT', or appended country references. The list-based approach ensures high precision and disambiguation from other geopolitical units such as provinces or districts.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:29.862934"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.MARITAL_STATUS_EN",
    "description": "A person's legal relationship status regarding marriage, indicating whether they are single, married, divorced, widowed, or in other recognized relationship states.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "SINGLE",
      "MARRIED",
      "DIVORCED",
      "WIDOWED",
      "SEPARATED",
      "NEVER MARRIED",
      "CIVIL UNION",
      "DOMESTIC PARTNER",
      "IN RELATIONSHIP",
      "ENGAGED",
      "ANNULLED",
      "PARTNERED",
      "COHABITING",
      "PREFER NOT TO SAY",
      "UNKNOWN"
    ],
    "backout": "^[A-Z]+( [A-Z]+){0,3}$",
    "confidenceThreshold": 97,
    "priority": 5180,
    "headerPatterns": [
      {
        "regExp": "(?i).*(marital|marriage).*status.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "marital_status"
        ],
        "negativeExamples": [
          "employment_status"
        ]
      },
      {
        "regExp": "(?i).*(relationship|spousal|partner|civil).*status.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "relationship status"
        ],
        "negativeExamples": [
          "relationship_id"
        ]
      },
      {
        "regExp": "(?i).*(mar[_ ]?stat|mstatus|rel[_ ]?stat).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mar_stat"
        ],
        "negativeExamples": [
          "market_status"
        ]
      },
      {
        "regExp": "(?i).*(marital|relationship|spousal|partner|civil).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "marital"
        ],
        "negativeExamples": [
          "marriage_date"
        ]
      },
      {
        "regExp": "(?i).*status.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "status"
        ],
        "negativeExamples": [
          "state"
        ]
      }
    ],
    "positiveContentExamples": [
      "SINGLE",
      "MARRIED",
      "DIVORCED",
      "WIDOWED",
      "SEPARATED",
      "NEVER MARRIED",
      "CIVIL UNION",
      "DOMESTIC PARTNER"
    ],
    "negativeContentExamples": [
      "SINGLES",
      "MARRIED/SEPARATED",
      "WIDOW",
      "DIVORCEE",
      "UNMARRIED",
      "IN-RELATIONSHIP",
      "ENGAGED!",
      "MARRIED - SEPARATED"
    ],
    "positiveHeaderExamples": [
      "marital_status",
      "marriage status",
      "relationship status",
      "spousal status",
      "civil union status",
      "mar_stat",
      "mstatus",
      "status"
    ],
    "negativeHeaderExamples": [
      "employment_status",
      "order_status",
      "account_status",
      "state",
      "relationship_id",
      "marital_code",
      "spouse_name",
      "marriage_date"
    ],
    "explanation": "This semantic type captures English marital/relationship status values used in HR, CRM, and survey datasets. It is modeled as a finite list of common, standardized statuses, with a conservative backout pattern to constrain false positives. Header patterns progress from specific marital-status terms to the primitive 'status' to support flexible schema detection.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:30.072020"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_PE",
    "description": "Peruvian province names representing the administrative divisions within Peru's regional organization system. These provincias serve as intermediate territorial units for regional government administration and public service coordination throughout Peruvian regions.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc]+)([ -]([A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc]+|de|del|la|las|los|el|y)){0,4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 5700,
    "headerPatterns": [
      {
        "regExp": "(?i).*(peru|pe).*(province|provincia).*(name|nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province_name_pe"
        ],
        "negativeExamples": [
          "province_code"
        ]
      },
      {
        "regExp": "(?i).*(peru|pe).*(province|provincia).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "peru_province"
        ],
        "negativeExamples": [
          "country_province_name"
        ]
      },
      {
        "regExp": "(?i).*(prov|provincia|province).*(name|nombre|nm).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "prov_name"
        ],
        "negativeExamples": [
          "prov_code"
        ]
      },
      {
        "regExp": "(?i).*(prov|provincia|province).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "provincia"
        ],
        "negativeExamples": [
          "region"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Lima",
      "Arequipa",
      "Cusco",
      "Puno",
      "Huaraz",
      "Mariscal Nieto",
      "Coronel Portillo",
      "La Convenci\u00f3n"
    ],
    "negativeContentExamples": [
      "lima",
      "Arequipa-2",
      "Cusco-",
      "Trujillo/Per\u00fa",
      "Huaraz.",
      "Puno, Per\u00fa",
      "Mariscal  Nieto",
      "Coronel_Portillo"
    ],
    "positiveHeaderExamples": [
      "peru_province_name",
      "province_name_pe",
      "provincia_nombre",
      "pe_prov_name",
      "prov_name",
      "province_nombre",
      "peruvian_province_name",
      "pe_province"
    ],
    "negativeHeaderExamples": [
      "province_code",
      "region_name",
      "district_name",
      "country_name",
      "state_province",
      "province_id",
      "peru_region_name",
      "municipality_name"
    ],
    "explanation": "This semantic type identifies values that are names of provinces (provincias) within Peru. The content pattern accepts one to five tokens composed of letters (including Spanish diacritics), with single spaces or hyphens as separators, and allows common Spanish connectors such as de, del, la, las, los, el, and y to appear between words. This helps capture multi-word province names like Mariscal Nieto or La Convenci\u00f3n while excluding values with digits, punctuation, underscores, or improper casing. Header detection prioritizes Peru-specific province name fields and gracefully backs off to common province-name variations and ultimately the primitive 'name' token.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:30.683994"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_CODE_NL",
    "description": "Dutch municipality codes used by Statistics Netherlands (CBS) for official identification of municipal territories within the Netherlands. These four-digit numerical codes provide standardized reference numbers for statistical reporting and administrative systems throughout Dutch provinces.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 5580,
    "headerPatterns": [
      {
        "regExp": "(?i).*cbs.*municipality.*code.*nl.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cbs_municipality_code_nl"
        ],
        "negativeExamples": [
          "cbs_municipality_name_nl"
        ]
      },
      {
        "regExp": "(?i).*cbs.*gemeente.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cbs_gemeente_code"
        ],
        "negativeExamples": [
          "cbs_gemeente_naam"
        ]
      },
      {
        "regExp": "(?i).*nl.*municipality.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nl_municipality_code"
        ],
        "negativeExamples": [
          "municipality_code_us"
        ]
      },
      {
        "regExp": "(?i).*(municipality|gemeente).*(code|id).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality_code"
        ],
        "negativeExamples": [
          "municipality_name"
        ]
      },
      {
        "regExp": "(?i).*(muni|gem).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "muni_code"
        ],
        "negativeExamples": [
          "muni_name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "id"
        ]
      }
    ],
    "positiveContentExamples": [
      "0034",
      "0363",
      "0197",
      "0828",
      "1701",
      "1926",
      "0743",
      "1427"
    ],
    "negativeContentExamples": [
      "034",
      "03630",
      "36-30",
      "36 30",
      "NL1234",
      "1234A",
      "A1234",
      "1.234"
    ],
    "positiveHeaderExamples": [
      "cbs_municipality_code_nl",
      "cbs_gemeente_code",
      "nl_municipality_code",
      "gemeente_code_nl",
      "gemeentecode",
      "municipality_code_nl",
      "municipality_code",
      "muni_code"
    ],
    "negativeHeaderExamples": [
      "municipality_name",
      "province_code_nl",
      "postal_code",
      "country_code_nl",
      "cbs_municipality_name",
      "city_code",
      "region_code",
      "cbs_gemeente_naam"
    ],
    "explanation": "This semantic type identifies Dutch CBS municipality codes as four-digit numeric tokens, used to standardize and link records to municipalities across administrative and statistical datasets. Detection relies on a strict four-digit token shape combined with header cues referencing CBS, NL, municipality, or gemeente to distinguish from other 4-digit numerics such as years or internal identifiers.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:30.852911"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.DEPARTMENT_NAME_FR",
    "description": "French department names representing the administrative divisions within France's territorial organization system. These d\u00e9partements serve as primary units for local government administration, public services, and regional coordination throughout French territory.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AIN",
      "AISNE",
      "ALLIER",
      "ALPES-MARITIMES",
      "ARD\u00c8CHE",
      "BAS-RHIN",
      "BOUCHES-DU-RH\u00d4NE",
      "CORSE-DU-SUD",
      "C\u00d4TES-D'ARMOR",
      "FINIST\u00c8RE",
      "GARD",
      "GIRONDE",
      "HAUTE-CORSE",
      "HAUTE-GARONNE",
      "HAUTES-ALPES",
      "H\u00c9RAULT",
      "ILLE-ET-VILAINE",
      "LOIRE-ATLANTIQUE",
      "NORD",
      "PARIS",
      "PYR\u00c9N\u00c9ES-ATLANTIQUES",
      "SEINE-SAINT-DENIS",
      "TERRITOIRE DE BELFORT",
      "VAL-D'OISE",
      "HAUT-RHIN"
    ],
    "backout": "^([A-Z\u00c0-\u00d6\u00d8-\u00dd]+([ '-][A-Z\u00c0-\u00d6\u00d8-\u00dd]+)*)$",
    "confidenceThreshold": 97,
    "priority": 5510,
    "headerPatterns": [
      {
        "regExp": "(?i).*(d[\u00e9e]partement).*name.*fr.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "departement_name_fr"
        ],
        "negativeExamples": [
          "department_code_fr"
        ]
      },
      {
        "regExp": "(?i).*(french|fr).*(d[\u00e9e]partement).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "fr_departement"
        ],
        "negativeExamples": [
          "french_department_code"
        ]
      },
      {
        "regExp": "(?i).*(dept|dep).*name.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "dept_name_fr"
        ],
        "negativeExamples": [
          "dept_code"
        ]
      },
      {
        "regExp": "(?i).*nom.*d[\u00e9e]partement.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "nom_departement"
        ],
        "negativeExamples": [
          "code_departement"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "AIN",
      "ALPES-MARITIMES",
      "ARD\u00c8CHE",
      "BOUCHES-DU-RH\u00d4NE",
      "C\u00d4TES-D'ARMOR",
      "HAUTE-GARONNE",
      "ILLE-ET-VILAINE",
      "LOIRE-ATLANTIQUE"
    ],
    "negativeContentExamples": [
      "LOIRE ATLANTIQUE",
      "PYRENEES-ATLANTIQUES",
      "VAL D'OISE",
      "SEINE ET MARNE",
      "ALPES MARITIMES",
      "HAUTE GARONNE",
      "CORSE DU SUD",
      "\u00ceLE-DE-FRANCE"
    ],
    "positiveHeaderExamples": [
      "department_name_fr",
      "departement_nom",
      "french_department",
      "nom_departement_fr",
      "dept_name_fr",
      "dep_nom",
      "departement_name",
      "fr_departement"
    ],
    "negativeHeaderExamples": [
      "department_code_fr",
      "region_name_fr",
      "province",
      "state",
      "city_name",
      "country",
      "postal_code",
      "insee_code"
    ],
    "explanation": "This semantic type identifies French d\u00e9partement names, accounting for diacritics, hyphens, apostrophes, and common multi-token constructs used in official naming (e.g., Seine-Saint-Denis, C\u00f4tes-d'Armor). It is useful for classifying location attributes tied to administrative departments in France for analytics, geospatial joins, and data normalization.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:33.168411"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_IT",
    "description": "Italian province names representing the administrative divisions within Italy's regional system. These provincie serve as intermediate territorial units for regional government administration and public service coordination throughout Italian regions.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "TORINO",
      "ASTI",
      "CUNEO",
      "ALESSANDRIA",
      "NOVARA",
      "VERBANO-CUSIO-OSSOLA",
      "MILANO",
      "BERGAMO",
      "BRESCIA",
      "VARESE",
      "VERONA",
      "PADOVA",
      "VENEZIA",
      "BOLOGNA",
      "MODENA",
      "FIRENZE",
      "PISA",
      "PERUGIA",
      "ANCONA",
      "L'AQUILA"
    ],
    "backout": "^[A-Z][A-Z' -]{1,29}$",
    "confidenceThreshold": 95,
    "priority": 5680,
    "headerPatterns": [
      {
        "regExp": "(?i).*(italian|italy|it).*province.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "italian_province_name"
        ],
        "negativeExamples": [
          "province_code"
        ]
      },
      {
        "regExp": "(?i).*province.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province_name"
        ],
        "negativeExamples": [
          "province_code"
        ]
      },
      {
        "regExp": "(?i).*(provincia|prov).*nome.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "provincia_nome"
        ],
        "negativeExamples": [
          "provincia_codice"
        ]
      },
      {
        "regExp": "(?i).*(provincia|province).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "provincia"
        ],
        "negativeExamples": [
          "region_name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "TORINO",
      "ALESSANDRIA",
      "CUNEO",
      "VERBANO-CUSIO-OSSOLA",
      "MILANO",
      "PADOVA",
      "FIRENZE",
      "L'AQUILA"
    ],
    "negativeContentExamples": [
      "LOMBARDIA",
      "LAZIO",
      "TOSCANA",
      "SICILIA",
      "VENETO",
      "REGGIO NELL'EMILIA",
      "PROVINCIA DI TORINO",
      "ITALIA"
    ],
    "positiveHeaderExamples": [
      "province_name",
      "provincia",
      "italian_province_name",
      "province_it",
      "province",
      "provincia_nome",
      "it_province_name",
      "provincia_italiana"
    ],
    "negativeHeaderExamples": [
      "province_code",
      "region_name",
      "country",
      "state_province_code",
      "city_name",
      "postal_code",
      "municipality",
      "county_name"
    ],
    "explanation": "This semantic type targets Italian province-level administrative unit names as they typically appear in datasets, using a curated list of representative province names across regions. The list plugin provides precise matching to reduce ambiguity with cities or regions; the backout pattern ensures reasonable shape control, and header patterns guide detection toward province-name contexts.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:36.108495"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_IE",
    "description": "Irish county names representing the traditional administrative divisions within Ireland's territorial organization. These historic counties serve as fundamental geographic and administrative units for both the Republic of Ireland and Northern Ireland.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b((county|co)\\.?\\s+)?(Antrim|Armagh|Carlow|Cavan|Clare|Cork|Derry|Londonderry|Donegal|Down|Dublin|Fermanagh|Galway|Kerry|Kildare|Kilkenny|Laois|Leitrim|Limerick|Longford|Louth|Mayo|Meath|Monaghan|Offaly|Roscommon|Sligo|Tipperary|Tyrone|Waterford|Westmeath|Wexford|Wicklow)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5470,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bcounty\\b.*\\bireland\\b.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "county_ireland"
        ],
        "negativeExamples": [
          "county_england"
        ]
      },
      {
        "regExp": "(?i).*\\b(irish|ie)\\b.*\\bcounty\\b.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "irish_county"
        ],
        "negativeExamples": [
          "ie_country"
        ]
      },
      {
        "regExp": "(?i).*\\bcounty\\b.*\\bname\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "county_name"
        ],
        "negativeExamples": [
          "country_name"
        ]
      },
      {
        "regExp": "(?i).*\\b(home|birth|residence)\\b.*\\bcounty\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "home_county"
        ],
        "negativeExamples": [
          "home_country"
        ]
      },
      {
        "regExp": "(?i).*\\bcounty\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "county"
        ],
        "negativeExamples": [
          "country"
        ]
      }
    ],
    "positiveContentExamples": [
      "Dublin",
      "County Kerry",
      "Co. Cork",
      "Galway",
      "Co Limerick",
      "Londonderry",
      "Derry",
      "Westmeath"
    ],
    "negativeContentExamples": [
      "Dublinn",
      "CountyDown",
      "Louths",
      "Kildaree",
      "Tipprary",
      "Fermanah",
      "Long ford",
      "Londonderrry"
    ],
    "positiveHeaderExamples": [
      "county_ireland",
      "irish_county",
      "ie_county",
      "county_name",
      "home_county",
      "birth_county",
      "county_of_residence",
      "county"
    ],
    "negativeHeaderExamples": [
      "country",
      "province",
      "state",
      "region",
      "city",
      "district",
      "borough",
      "parish"
    ],
    "explanation": "This semantic type identifies Irish county names, optionally prefixed with 'County', 'Co', or 'Co.' and supports both 'Derry' and 'Londonderry'. It is suitable for columns containing the county of residence, birthplace county, or general geographic fields specific to Ireland.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:36.956933"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.REGION_NAME_IT",
    "description": "The name of one of the twenty administrative regions of Italy, representing the primary territorial divisions of the Italian Republic.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "ABRUZZO",
      "BASILICATA",
      "CALABRIA",
      "CAMPANIA",
      "EMILIA-ROMAGNA",
      "FRIULI-VENEZIA GIULIA",
      "LAZIO",
      "LIGURIA",
      "LOMBARDIA",
      "MARCHE",
      "MOLISE",
      "PIEMONTE",
      "PUGLIA",
      "SARDEGNA",
      "SICILIA",
      "TOSCANA",
      "TRENTINO-ALTO ADIGE",
      "UMBRIA",
      "VALLE D'AOSTA",
      "VENETO"
    ],
    "backout": "^[A-Z][A-Z' -]{2,29}$",
    "confidenceThreshold": 98,
    "priority": 5740,
    "headerPatterns": [
      {
        "regExp": "(?i).*(italy|italian).*region.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "italy_region_name"
        ],
        "negativeExamples": [
          "italy_region_code"
        ]
      },
      {
        "regExp": "(?i).*(italy|italian).*region.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "italian_region"
        ],
        "negativeExamples": [
          "italian_province"
        ]
      },
      {
        "regExp": "(?i).*(region[ _-]*name[ _-]*it|it[ _-]*region[ _-]*name|regione[ _-]*nome).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "region_name_it"
        ],
        "negativeExamples": [
          "region_code_it"
        ]
      },
      {
        "regExp": "(?i).*(reg[ _-]*it|it[ _-]*reg).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "reg_it"
        ],
        "negativeExamples": [
          "it_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Lombardia",
      "Sicilia",
      "Friuli-Venezia Giulia",
      "Emilia-Romagna",
      "Trentino-Alto Adige",
      "Valle d'Aosta",
      "Puglia",
      "Piemonte"
    ],
    "negativeContentExamples": [
      "Lombardy",
      "Sardinia",
      "Emilia Romagna",
      "Friuli Venezia Giulia",
      "South Tyrol",
      "Rome",
      "Regione Veneto",
      "Valle d\u2019Aosta"
    ],
    "positiveHeaderExamples": [
      "italy_region_name",
      "italian_region_name",
      "region_name_it",
      "it_region_name",
      "nome_regione_italia",
      "regione_nome",
      "italian_region",
      "it_region"
    ],
    "negativeHeaderExamples": [
      "italy_region_code",
      "country_name",
      "province_name",
      "city_name",
      "state_code_it",
      "region_number",
      "italian_province",
      "postal_code"
    ],
    "explanation": "This semantic type captures the official names of Italy's twenty first-level administrative regions. It is suitable for datasets containing region names used for geographic segmentation, regional analytics, or address normalization within Italy. Using a finite list ensures precise matching and minimizes false positives against other territorial names such as provinces or cities.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:37.835377"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_DE",
    "description": "A five-digit numerical code used by Deutsche Post to identify delivery areas and facilitate mail distribution throughout Germany.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5260,
    "headerPatterns": [
      {
        "regExp": "(?i).*(de|german).*(postal[ _]?code|postleitzahl|plz).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "de_postal_code"
        ],
        "negativeExamples": [
          "us_postal_code"
        ]
      },
      {
        "regExp": "(?i).*(postleitzahl|plz).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "postleitzahl"
        ],
        "negativeExamples": [
          "postal address"
        ]
      },
      {
        "regExp": "(?i).*(shipping|billing|residential|mailing).*(postal|zip).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "billing_zip_code"
        ],
        "negativeExamples": [
          "billing_country_code"
        ]
      },
      {
        "regExp": "(?i).*(postal[ _]?code|zip[ _]?code).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "shipping_postal_code"
        ],
        "negativeExamples": [
          "zip_archive"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "01067",
      "10115",
      "20095",
      "28195",
      "04109",
      "50667",
      "80331",
      "89073"
    ],
    "negativeContentExamples": [
      "1011",
      "101150",
      "D10115",
      "10 115",
      "1011a",
      "101-15",
      "10115-001",
      "ABCDE"
    ],
    "positiveHeaderExamples": [
      "de_postal_code",
      "german postal code",
      "postleitzahl",
      "plz",
      "billing_zip_code",
      "shipping_postal_code",
      "residential_pcode",
      "zip"
    ],
    "negativeHeaderExamples": [
      "country_code",
      "area_code",
      "qr_code",
      "zip_archive",
      "address_line",
      "postal_town",
      "phone_number",
      "name"
    ],
    "explanation": "This semantic type detects German postal codes (PLZ), which are exactly five digits and appear as a standalone numeric token. It is useful for validating and classifying address-related columns in German datasets, including shipping and billing addresses.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:40.498426"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_US",
    "description": "United States county names representing the primary administrative subdivisions within US states for local government services. These county jurisdictions serve as fundamental territorial units for law enforcement, taxation, and municipal services across American states.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z][A-Za-z.'-]*( [A-Za-z][A-Za-z.'-]*){0,4} ([Cc]ounty|[Pp]arish|[Bb]orough|[Cc]ensus [Aa]rea|[Cc]ity and [Bb]orough|[Mm]unicipality)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 5490,
    "headerPatterns": [
      {
        "regExp": "(?i).*(us|usa|united states).*county.*name.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "US county name"
        ],
        "negativeExamples": [
          "US county code"
        ]
      },
      {
        "regExp": "(?i).*(county|parish|borough|census area|city and borough).*name.*(us|usa|united states).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "county name (United States)"
        ],
        "negativeExamples": [
          "county name (CA)"
        ]
      },
      {
        "regExp": "(?i).*(county|parish|borough|census area|city and borough).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "parish name"
        ],
        "negativeExamples": [
          "parish code"
        ]
      },
      {
        "regExp": "(?i).*(\\bcnty\\b|\\bco\\b|\\bpar\\b|\\bboro\\b|\\bcens area\\b).*name.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "cnty name"
        ],
        "negativeExamples": [
          "co code"
        ]
      },
      {
        "regExp": "(?i).*county.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "county"
        ],
        "negativeExamples": [
          "state"
        ]
      }
    ],
    "positiveContentExamples": [
      "Los Angeles County",
      "Cook County",
      "Miami-Dade County",
      "Prince George's County",
      "Orleans Parish",
      "Matanuska-Susitna Borough",
      "Prince of Wales-Hyder Census Area",
      "Juneau City and Borough"
    ],
    "negativeContentExamples": [
      "Los Angeles",
      "Cook Cty",
      "Orleans Parish, LA",
      "Juneau City & Borough",
      "Prince of Wales\u2013Hyder Census Area",
      "Douglas County WA",
      "New York County (Manhattan)",
      "Borough of Brooklyn"
    ],
    "positiveHeaderExamples": [
      "US county name",
      "county name",
      "parish name",
      "borough name",
      "census area name",
      "city and borough name",
      "county_name_us",
      "county name (United States)"
    ],
    "negativeHeaderExamples": [
      "county code",
      "province name",
      "state name",
      "country name",
      "city name",
      "zip code",
      "fips county code",
      "municipality code"
    ],
    "explanation": "This semantic type identifies textual values that are names of U.S. county-level jurisdictions, including counties, Louisiana parishes, Alaska boroughs, Alaska census areas, and consolidated city-boroughs/municipalities where applicable. It is intended for datasets storing the proper name of the county-level geography, not codes or identifiers. The pattern requires the jurisdiction suffix (e.g., County, Parish, Borough) to avoid ambiguous matches when only the base place name is present.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:41.933097"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_EC",
    "description": "Ecuadorian province names representing the administrative divisions within Ecuador's territorial organization system. These provincias serve as primary units for regional government administration and public service coordination throughout Ecuadorian territory.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AZUAY",
      "BOL\u00cdVAR",
      "CA\u00d1AR",
      "CARCHI",
      "CHIMBORAZO",
      "COTOPAXI",
      "EL ORO",
      "ESMERALDAS",
      "GAL\u00c1PAGOS",
      "GUAYAS",
      "IMBABURA",
      "LOJA",
      "LOS R\u00cdOS",
      "MANAB\u00cd",
      "MORONA SANTIAGO",
      "NAPO",
      "ORELLANA",
      "PASTAZA",
      "PICHINCHA",
      "SANTA ELENA",
      "SANTO DOMINGO DE LOS TS\u00c1CHILAS",
      "SUCUMB\u00cdOS",
      "TUNGURAHUA",
      "ZAMORA CHINCHIPE"
    ],
    "backout": "^[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1 ]{3,40}$",
    "confidenceThreshold": 98,
    "priority": 5650,
    "headerPatterns": [
      {
        "regExp": "(?i).*(ecuador|ec).*(province|provincia).*(name|nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ec_province_name"
        ],
        "negativeExamples": [
          "province_code_ec"
        ]
      },
      {
        "regExp": "(?i).*(province|provincia).*(name|nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province_name"
        ],
        "negativeExamples": [
          "province_code"
        ]
      },
      {
        "regExp": "(?i).*(prov_name|provnm|prov_nombre|prov_nm).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "prov_nm_ec"
        ],
        "negativeExamples": [
          "prov_code"
        ]
      },
      {
        "regExp": "(?i).*(ecuador|ec).*(province|provincia).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ecuador_provincia"
        ],
        "negativeExamples": [
          "country_province_map"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "AZUAY",
      "BOL\u00cdVAR",
      "GUAYAS",
      "LOS R\u00cdOS",
      "MANAB\u00cd",
      "PICHINCHA",
      "SANTO DOMINGO DE LOS TS\u00c1CHILAS",
      "ZAMORA CHINCHIPE"
    ],
    "negativeContentExamples": [
      "ECUADOR",
      "QUITO",
      "PROVINCIA DE LOJA",
      "PICHINCHA PROVINCE",
      "SANTO DOMINGO",
      "MANABI",
      "EL-ORO",
      "GUAYAS, ECUADOR"
    ],
    "positiveHeaderExamples": [
      "ec_province_name",
      "ecuador_province_name",
      "province_name",
      "prov_nm_ec",
      "prov_name",
      "ecuador_provincia",
      "primary_province_name",
      "provincia_nombre"
    ],
    "negativeHeaderExamples": [
      "province_code",
      "ec_province_code",
      "state_code_ec",
      "region",
      "city",
      "country",
      "postal_code",
      "department_code"
    ],
    "explanation": "This semantic type identifies Ecuador's official first-level administrative divisions (provincias) by their standard names. It is best applied to columns containing province names in uppercase, often with spaces and diacritics common to Spanish. Using a finite list ensures high precision; the backout pattern provides a safe fallback shape for uppercase Spanish names if list expansion is needed.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:47.681338"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_FIPS_US",
    "description": "A standardized two-digit numerical code assigned by the Federal Information Processing Standards to identify US states and territories for government data processing.",
    "pluginType": "regex",
    "regexPattern": "\\b(0[1-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-6]|60|66|69|72|78)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 5790,
    "headerPatterns": [
      {
        "regExp": "(?i).*us.*state.*fips.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "us_state_fips_code"
        ],
        "negativeExamples": [
          "us_state_iso_code"
        ]
      },
      {
        "regExp": "(?i).*(united.*states|us).*fips.*state.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "us_fips_state"
        ],
        "negativeExamples": [
          "state_fips_code"
        ]
      },
      {
        "regExp": "(?i).*(state|st).*fips.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_fips_code"
        ],
        "negativeExamples": [
          "st_postal_code"
        ]
      },
      {
        "regExp": "(?i).*fips.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fips_code"
        ],
        "negativeExamples": [
          "naics_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "01",
      "02",
      "06",
      "11",
      "36",
      "48",
      "56",
      "78"
    ],
    "negativeContentExamples": [
      "00",
      "57",
      "59",
      "61",
      "80",
      "99",
      "9",
      "001"
    ],
    "positiveHeaderExamples": [
      "us_state_fips_code",
      "state_fips_code",
      "fips_state_code",
      "us_fips_state",
      "fips_state",
      "state_fips",
      "fips_code",
      "state_fips_value"
    ],
    "negativeHeaderExamples": [
      "state_iso_code",
      "state_postal_code",
      "county_fips_code",
      "fips_county_code",
      "province_code",
      "state_abbr",
      "state_name",
      "country_fips_code"
    ],
    "explanation": "This type recognizes two-digit FIPS state and territory codes used in U.S. governmental datasets. The regex strictly permits 01\u201356 plus designated territory codes 60, 66, 69, 72, and 78, while excluding invalid numbers and non-numeric strings. Header patterns progress from highly specific 'US state FIPS code' forms to the primitive 'code' term to support top-down identification without over-matching.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:50.093221"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_AU",
    "description": "The full name of one of the six states or two territories of Australia, representing the complete official designation of Australian administrative divisions.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "NEW SOUTH WALES",
      "QUEENSLAND",
      "VICTORIA",
      "TASMANIA",
      "SOUTH AUSTRALIA",
      "WESTERN AUSTRALIA",
      "NORTHERN TERRITORY",
      "AUSTRALIAN CAPITAL TERRITORY"
    ],
    "backout": "^[A-Z ]{8,27}$",
    "confidenceThreshold": 98,
    "priority": 5810,
    "headerPatterns": [
      {
        "regExp": "(?i).*(australia|au).*(state|territory).*(full).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "australian state full name"
        ],
        "negativeExamples": [
          "australian state code"
        ]
      },
      {
        "regExp": "(?i).*(australia|au).*(state|territory).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state name au"
        ],
        "negativeExamples": [
          "state code au"
        ]
      },
      {
        "regExp": "(?i).*(australia|au).*(state|territory).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "au territory"
        ],
        "negativeExamples": [
          "us territory"
        ]
      },
      {
        "regExp": "(?i).*(state|territory).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "territory name"
        ],
        "negativeExamples": [
          "territory code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "NEW SOUTH WALES",
      "QUEENSLAND",
      "VICTORIA",
      "TASMANIA",
      "SOUTH AUSTRALIA",
      "WESTERN AUSTRALIA",
      "NORTHERN TERRITORY",
      "AUSTRALIAN CAPITAL TERRITORY"
    ],
    "negativeContentExamples": [
      "NEW SOUTH WALE",
      "QUEENSLANDS",
      "VICTORIA STATE",
      "NORTHERN TERRITORY, AUSTRALIA",
      "WESTERN AUSTRALIA REGION",
      "AUSTRALIAN CAPITAL TERRITOR",
      "SOUTH-AUSTRALIA",
      "TASMANIA, AU"
    ],
    "positiveHeaderExamples": [
      "australian state full name",
      "state name au",
      "australia territory name",
      "au state name",
      "state_province_name_au",
      "australia state name",
      "australian territory full name"
    ],
    "negativeHeaderExamples": [
      "state code au",
      "au state abbreviation",
      "province name ca",
      "us territory code",
      "state id australia",
      "country name au",
      "region name au"
    ],
    "explanation": "This semantic type identifies the full official names of Australian states and territories. It is useful for normalizing and validating geographic administrative divisions specific to Australia, differentiating full names from abbreviations or codes.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:51.298776"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_BR",
    "description": "A two-letter abbreviation representing one of the twenty-six states or the federal district of Brazil for administrative and postal identification.",
    "pluginType": "regex",
    "regexPattern": "\\b(A[CLMP]|BA|CE|DF|ES|GO|M[AGST]|P[ABERI]|R[JNORS]|S[CEP]|TO)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5780,
    "headerPatterns": [
      {
        "regExp": "(?i).*(br|brazil).*(state|uf).*(code|abbr|abbrev).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "br_state_code"
        ],
        "negativeExamples": [
          "state_name"
        ]
      },
      {
        "regExp": "(?i).*(br|brazil).*(state|uf).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "brazil_uf"
        ],
        "negativeExamples": [
          "us_state"
        ]
      },
      {
        "regExp": "(?i).*(estado).*(br|brazil).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "estado_br"
        ],
        "negativeExamples": [
          "estado_civil"
        ]
      },
      {
        "regExp": "(?i).*(state|province).*(br|brazil).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_br"
        ],
        "negativeExamples": [
          "province_code"
        ]
      },
      {
        "regExp": "(?i).*state.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state"
        ],
        "negativeExamples": [
          "country"
        ]
      }
    ],
    "positiveContentExamples": [
      "SP",
      "RJ",
      "MG",
      "RS",
      "BA",
      "DF",
      "AM",
      "CE"
    ],
    "negativeContentExamples": [
      "BR",
      "CA",
      "rj",
      "Sp",
      "SPS",
      "R J",
      "PR1",
      "TOO"
    ],
    "positiveHeaderExamples": [
      "br_state_code",
      "brazil_uf",
      "uf_br",
      "estado_br",
      "state_br",
      "br_state_abbrev",
      "brazil_state",
      "uf_code_br"
    ],
    "negativeHeaderExamples": [
      "country_code",
      "state_name",
      "province_uk",
      "region_name",
      "postal_code_br",
      "territory",
      "timezone",
      "city_code"
    ],
    "explanation": "Identifies Brazilian state abbreviations (UF) used in addresses, regional reporting, and geospatial aggregation. Useful for validating and standardizing Brazilian administrative subdivision codes in datasets.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:52.125126"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_US",
    "description": "A two-letter abbreviation representing one of the fifty states or the federal district of the United States for administrative and postal identification. Values are uppercase postal abbreviations such as NY, CA, or DC.",
    "pluginType": "regex",
    "regexPattern": "\\b(AL|AK|AZ|AR|CA|CO|CT|DE|FL|GA|HI|ID|IL|IN|IA|KS|KY|LA|ME|MD|MA|MI|MN|MS|MO|MT|NE|NV|NH|NJ|NM|NY|NC|ND|OH|OK|OR|PA|RI|SC|SD|TN|TX|UT|VT|VA|WA|WV|WI|WY|DC)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 5900,
    "headerPatterns": [
      {
        "regExp": "(?i).*us.*state.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "us_state_code"
        ],
        "negativeExamples": [
          "state_code"
        ]
      },
      {
        "regExp": "(?i).*state.*us.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "state_us"
        ],
        "negativeExamples": [
          "state_name"
        ]
      },
      {
        "regExp": "(?i).*state.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "billing_state_code"
        ],
        "negativeExamples": [
          "country_code"
        ]
      },
      {
        "regExp": "(?i).*state.*abbr.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "state_abbr"
        ],
        "negativeExamples": [
          "state_name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "NY",
      "CA",
      "TX",
      "FL",
      "IL",
      "PA",
      "WA",
      "DC"
    ],
    "negativeContentExamples": [
      "ny",
      "PR",
      "NB",
      "NYY",
      "C A",
      "AL.",
      "C2",
      "US"
    ],
    "positiveHeaderExamples": [
      "us_state_code",
      "state_us",
      "billing_state_code",
      "state_abbr",
      "ship_to_state_code",
      "state_province_code_us",
      "st_cd",
      "state_code"
    ],
    "negativeHeaderExamples": [
      "country_code",
      "province_code",
      "state_name",
      "postal_code",
      "timezone",
      "region_code",
      "airport_code",
      "country_state"
    ],
    "explanation": "This semantic type identifies two-letter USPS-style abbreviations for the 50 U.S. states and the District of Columbia. It is useful for validating and standardizing address fields, geographic keys, and administrative region codes in U.S.-centric datasets. The pattern enforces uppercase two-letter tokens limited to recognized state and DC codes, reducing false positives from unrelated two-letter codes.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:56.209843"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_MX",
    "description": "Mexican municipality names representing the local administrative divisions within Mexico's state system. These municipios serve as primary units for local government services, urban planning, and municipal administration throughout Mexican states.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1\u00e1\u00e9\u00ed\u00f3\u00fa\u00fc\u00f1][A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1\u00e1\u00e9\u00ed\u00f3\u00fa\u00fc\u00f1'\u2019-]{1,}( ([A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1\u00e1\u00e9\u00ed\u00f3\u00fa\u00fc\u00f1]{1,3}\\.|[A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1\u00e1\u00e9\u00ed\u00f3\u00fa\u00fc\u00f1][A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1\u00e1\u00e9\u00ed\u00f3\u00fa\u00fc\u00f1'\u2019-]{1,})){1,5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5590,
    "headerPatterns": [
      {
        "regExp": "(?i).*(municipality|municipio).*(mexico|m\u00e9xico|mx).*(name|nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mx_municipality_name"
        ],
        "negativeExamples": [
          "mexico_state_name"
        ]
      },
      {
        "regExp": "(?i).*(municipality|municipio).*(mexico|m\u00e9xico|mx).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipio_mexico"
        ],
        "negativeExamples": [
          "state_mexico"
        ]
      },
      {
        "regExp": "(?i).*(municipality|municipio).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality"
        ],
        "negativeExamples": [
          "county"
        ]
      },
      {
        "regExp": "(?i).*(mpio|muni|ayuntamiento).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mpio_nombre"
        ],
        "negativeExamples": [
          "depto_nombre"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Benito Ju\u00e1rez",
      "Ecatepec de Morelos",
      "San Pedro Garza Garc\u00eda",
      "Oth\u00f3n P. Blanco",
      "L\u00e1zaro C\u00e1rdenas",
      "Tlalnepantla de Baz",
      "Valle de Bravo",
      "General Escobedo"
    ],
    "negativeContentExamples": [
      "San-Pedro",
      "Benito_Ju\u00e1rez",
      "Jos\u00e9-Azueta",
      "Tlalnepantla_de_Baz",
      "Gral. Escobedo",
      "Othon P Blanco",
      "Valle-de-Bravo-",
      "Cd. Juarez"
    ],
    "positiveHeaderExamples": [
      "mx_municipality_name",
      "municipio_nombre",
      "municipality_mx",
      "municipio_mexico",
      "municipality",
      "mpio_nombre",
      "local_municipality",
      "municipio"
    ],
    "negativeHeaderExamples": [
      "state_name",
      "city_name",
      "postal_code",
      "county",
      "province",
      "parish",
      "neighborhood",
      "department_name"
    ],
    "explanation": "This semantic type targets strings that look like Mexican municipality names, allowing multi-token Spanish names with accents, connectors (e.g., de, del), and optional initials (e.g., P.), while disallowing digits and unsupported separators. It is intended for columns containing municipio names used for local governance within Mexican states and is guided by header patterns referencing municipality/municipio and Mexico context.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:52:57.304344"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.REGION_NAME_TZ",
    "description": "The name of one of the administrative regions of Tanzania, representing the primary territorial divisions of the United Republic of Tanzania. Includes both Mainland and Zanzibar region names, in common English or Swahili forms.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(Arusha|Dar es Salaam|Dodoma|Geita|Iringa|Kagera|Katavi|Kigoma|Kilimanjaro|Lindi|Manyara|Mara|Mbeya|Morogoro|Mtwara|Mwanza|Njombe|Pwani|Rukwa|Ruvuma|Shinyanga|Simiyu|Singida|Songwe|Tabora|Tanga|Kaskazini Pemba|Kusini Pemba|Kaskazini Unguja|Kusini Unguja|Mjini Magharibi|Pemba North|Pemba South|Unguja North|Unguja South|Zanzibar Urban West)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 5760,
    "headerPatterns": [
      {
        "regExp": "(?i).*tanzania.*region.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "tanzania_region_name"
        ],
        "negativeExamples": [
          "tanzania_region_code"
        ]
      },
      {
        "regExp": "(?i).*tz.*region.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "tz_region_name"
        ],
        "negativeExamples": [
          "tz_region_code"
        ]
      },
      {
        "regExp": "(?i).*tanzania.*administrative.*region.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "tanzania_administrative_region"
        ],
        "negativeExamples": [
          "tanzania_administrative_area"
        ]
      },
      {
        "regExp": "(?i).*(region|mkoa).*(name|nm).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "region_nm"
        ],
        "negativeExamples": [
          "region_code"
        ]
      },
      {
        "regExp": "(?i).*(tanzania|tz).*(region).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "tanzania_region"
        ],
        "negativeExamples": [
          "tz_country"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Dar es Salaam",
      "Dodoma",
      "Mwanza",
      "Arusha",
      "Kilimanjaro",
      "Morogoro",
      "Kaskazini Unguja",
      "Mjini Magharibi"
    ],
    "negativeContentExamples": [
      "Dar-es-Salaam",
      "Kilimanjaro Region",
      "Mwanza City",
      "Pemba North Region",
      "North Pemba",
      "Zanzibar Urban/West",
      "Dodoma, TZ",
      "Mara District"
    ],
    "positiveHeaderExamples": [
      "tz_region_name",
      "tanzania_region_name",
      "region_name_tz",
      "mkoa_name_tanzania",
      "tanzania_administrative_region_name",
      "region_nm_tz",
      "tanzanian_region"
    ],
    "negativeHeaderExamples": [
      "tanzania_district_name",
      "tz_region_code",
      "province_name",
      "country_name",
      "city_region_name",
      "county_name",
      "state_province_code"
    ],
    "explanation": "This type identifies Tanzanian first-order administrative divisions (mikoa/regions) by their standard names as they would appear in datasets, including common English and Swahili variants for Zanzibar regions. It is intended for columns containing region names (not codes) and helps distinguish Tanzania\u2019s regions from other geographic or administrative levels.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:53:06.007281"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_ES",
    "description": "Spanish province names representing the administrative divisions within Spain's territorial organization system. These provincias serve as primary units for regional government administration and public service coordination throughout Spanish territory.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(\u00c1lava|Araba|Albacete|Alicante|Alacant|Almer\u00eda|\u00c1vila|Badajoz|Barcelona|Burgos|C\u00e1ceres|C\u00e1diz|Cantabria|Castell\u00f3n|Castell\u00f3|Ciudad Real|C\u00f3rdoba|Cuenca|Gipuzkoa|Guip\u00fazcoa|Girona|Gerona|Granada|Guadalajara|Huelva|Huesca|Illes Balears|Islas Baleares|Ja\u00e9n|A Coru\u00f1a|La Coru\u00f1a|La Rioja|Le\u00f3n|Lleida|L\u00e9rida|Lugo|Madrid|M\u00e1laga|Murcia|Navarra|Nafarroa|Ourense|Orense|Palencia|Las Palmas|Pontevedra|Salamanca|Santa Cruz de Tenerife|Segovia|Sevilla|Soria|Tarragona|Teruel|Toledo|Valencia|Val\u00e8ncia|Valladolid|Bizkaia|Vizcaya|Zamora|Zaragoza|Asturias)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5660,
    "headerPatterns": [
      {
        "regExp": "(?i).*(spanish|es|espa\u00f1a).*(provincia|province).*(name|nombre).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "spanish_province_name"
        ],
        "negativeExamples": [
          "province_spain"
        ]
      },
      {
        "regExp": "(?i).*(provincia|province).*(es|espa\u00f1a|spain).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "province_spain"
        ],
        "negativeExamples": [
          "province_name"
        ]
      },
      {
        "regExp": "(?i).*(provincia|province).*(name|nombre).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "nombre_provincia"
        ],
        "negativeExamples": [
          "autonomous_community"
        ]
      },
      {
        "regExp": "(?i).*(prov|provincia|province).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "provincia_es"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Barcelona",
      "Gipuzkoa",
      "Sevilla",
      "A Coru\u00f1a",
      "Santa Cruz de Tenerife",
      "Castell\u00f3n",
      "Illes Balears",
      "\u00c1lava"
    ],
    "negativeContentExamples": [
      "Catalu\u00f1a",
      "Andaluc\u00eda",
      "Ceuta",
      "Melilla",
      "Tenerife",
      "Oviedo",
      "Cordoba",
      "La Coruna"
    ],
    "positiveHeaderExamples": [
      "province_name_es",
      "nombre_provincia_es",
      "spanish_province_name",
      "provincia_nombre",
      "es_prov_name",
      "province_spain",
      "provincia_es",
      "prov_name_es"
    ],
    "negativeHeaderExamples": [
      "country_name",
      "region_name",
      "autonomous_community",
      "city_name",
      "state_code",
      "postal_code",
      "county_name",
      "municipality"
    ],
    "explanation": "This semantic type identifies Spanish province names, including co-official language variants (e.g., Catalan, Basque, Galician) and multi-word forms. The value regex enumerates known province names with word boundaries for precision and avoids anchors to meet FTA compatibility. Header patterns follow a top-down progression from specific Spanish province naming to the primitive 'name' concept to reduce ambiguity and integrate cleanly with other types.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:53:06.189091"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_PROVINCE_NAME_NA",
    "description": "The full name of administrative first-level divisions within the United States, Canada, or Mexico (e.g., U.S. states and the District of Columbia, Canadian provinces/territories, and Mexican states, including Ciudad de M\u00e9xico). This type expects the complete official or commonly accepted full names, without abbreviations or appended country names.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(Alabama|Alaska|Arizona|Arkansas|California|Colorado|Connecticut|Delaware|Florida|Georgia|Hawaii|Idaho|Illinois|Indiana|Iowa|Kansas|Kentucky|Louisiana|Maine|Maryland|Massachusetts|Michigan|Minnesota|Mississippi|Missouri|Montana|Nebraska|Nevada|New Hampshire|New Jersey|New Mexico|New York|North Carolina|North Dakota|Ohio|Oklahoma|Oregon|Pennsylvania|Rhode Island|South Carolina|South Dakota|Tennessee|Texas|Utah|Vermont|Virginia|Washington|West Virginia|Wisconsin|Wyoming|District of Columbia|Alberta|British Columbia|Manitoba|New Brunswick|Newfoundland and Labrador|Nova Scotia|Ontario|Prince Edward Island|Quebec|Saskatchewan|Northwest Territories|Nunavut|Yukon|Aguascalientes|Baja California|Baja California Sur|Campeche|Chiapas|Chihuahua|Coahuila|Colima|Ciudad de M\u00e9xico|Durango|Guanajuato|Guerrero|Hidalgo|Jalisco|Estado de M\u00e9xico|Michoac\u00e1n|Morelos|Nayarit|Nuevo Le\u00f3n|Oaxaca|Puebla|Quer\u00e9taro|Quintana Roo|San Luis Potos\u00ed|Sinaloa|Sonora|Tabasco|Tamaulipas|Tlaxcala|Veracruz|Yucat\u00e1n|Zacatecas)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 5870,
    "headerPatterns": [
      {
        "regExp": "(?i).*(us|ca|mx).*(state|province).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "us_ca_mx_state_province_name"
        ],
        "negativeExamples": [
          "state_code"
        ]
      },
      {
        "regExp": "(?i).*(state|province).*(full|long).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province_state_full_name"
        ],
        "negativeExamples": [
          "province_abbrev"
        ]
      },
      {
        "regExp": "(?i).*(admin|administrative|subnational).*(division|region).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "admin_division_name"
        ],
        "negativeExamples": [
          "region_code"
        ]
      },
      {
        "regExp": "(?i).*(st|prov).*(nm|name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "st_prov_nm_na"
        ],
        "negativeExamples": [
          "country_nm"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "California",
      "New York",
      "British Columbia",
      "Quebec",
      "Ciudad de M\u00e9xico",
      "Nuevo Le\u00f3n",
      "San Luis Potos\u00ed",
      "Baja California Sur"
    ],
    "negativeContentExamples": [
      "New York State",
      "British Columbia, Canada",
      "Mexico City",
      "Nuevo Leon",
      "Qu\u00e9bec",
      "Rhode Is.",
      "San Luis Potosi",
      "Baja California Sur State"
    ],
    "positiveHeaderExamples": [
      "state_province_name_na",
      "us_ca_mx_state_province_name",
      "province_state_full_name",
      "admin_division_name",
      "subnational_region_name",
      "state_name_na"
    ],
    "negativeHeaderExamples": [
      "state_code",
      "province_abbrev",
      "country_name",
      "city_name",
      "region_code",
      "postal_code"
    ],
    "explanation": "This semantic type detects full names of first-level administrative divisions across the United States, Canada, and Mexico. It enumerates accepted names to avoid ambiguity with country names, abbreviations, or partial phrases. Use this to normalize or validate subnational region names in North American datasets while excluding abbreviations (e.g., CA, ON), appended qualifiers (e.g., 'State', 'Canada'), or translations not present in the list (e.g., 'Mexico City').",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:53:06.268987"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_NUMBER",
    "description": "A numeric identifier assigned to buildings and properties along a street for postal delivery and location identification purposes. Typical forms include pure integers (e.g., 12), integers with a trailing letter (e.g., 12A), hyphenated numbers (e.g., 25-16), and occasional fractional halves (e.g., 12 1/2).",
    "pluginType": "regex",
    "regexPattern": "\\b(\\d{1,6}\\s1/2|\\d{1,5}-\\d{1,5}|\\d{1,6}[A-Za-z]|\\d{1,6})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 6010,
    "headerPatterns": [
      {
        "regExp": "(?i).*street[_\\s]*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "street_number"
        ],
        "negativeExamples": [
          "street_name"
        ]
      },
      {
        "regExp": "(?i).*house[_\\s]*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "house number"
        ],
        "negativeExamples": [
          "house_name"
        ]
      },
      {
        "regExp": "(?i).*building[_\\s]*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "building_number"
        ],
        "negativeExamples": [
          "building_name"
        ]
      },
      {
        "regExp": "(?i).*street[_\\s]*no\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "street_no"
        ],
        "negativeExamples": [
          "unit_no"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "7",
      "12",
      "105",
      "1000",
      "221B",
      "25-16",
      "12 1/2",
      "99999"
    ],
    "negativeContentExamples": [
      "A12",
      "12 Apt 4",
      "PO Box 123",
      "12/3",
      "12-",
      "-12",
      "12.5",
      "12 1/4"
    ],
    "positiveHeaderExamples": [
      "street_number",
      "house number",
      "building_number",
      "street_no",
      "house_no",
      "door_number",
      "number"
    ],
    "negativeHeaderExamples": [
      "street_name",
      "house_name",
      "building_name",
      "unit_no",
      "postal_code",
      "address_line1",
      "street_code"
    ],
    "explanation": "This semantic type targets the numeric component identifying a street address, commonly used in geocoding, address normalization, and postal validation workflows. The value regex is constrained to typical street number shapes while avoiding over-broad matches, and header patterns progress from specific terms (street/house/building number) to the primitive concept of number.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:53:10.142295"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_DE",
    "description": "The full name of one of the sixteen federal states of Germany, representing the complete official designation of German Bundesl\u00e4nder.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "BADEN-W\u00dcRTTEMBERG",
      "BAYERN",
      "BERLIN",
      "BRANDENBURG",
      "BREMEN",
      "HAMBURG",
      "HESSEN",
      "MECKLENBURG-VORPOMMERN",
      "NIEDERSACHSEN",
      "NORDRHEIN-WESTFALEN",
      "RHEINLAND-PFALZ",
      "SAARLAND",
      "SACHSEN",
      "SACHSEN-ANHALT",
      "SCHLESWIG-HOLSTEIN",
      "TH\u00dcRINGEN"
    ],
    "backout": "^[A-Z\u00c4\u00d6\u00dc\\- ]{3,30}$",
    "confidenceThreshold": 98,
    "priority": 5830,
    "headerPatterns": [
      {
        "regExp": "(?i).*bundesland.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "bundesland_name"
        ],
        "negativeExamples": [
          "bundesland_code"
        ]
      },
      {
        "regExp": "(?i).*(german|de).*state.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_name_de"
        ],
        "negativeExamples": [
          "state_code_de"
        ]
      },
      {
        "regExp": "(?i).*state.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "german_state_name"
        ],
        "negativeExamples": [
          "state_number"
        ]
      },
      {
        "regExp": "(?i).*(province|land).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province_name_de"
        ],
        "negativeExamples": [
          "province_code"
        ]
      },
      {
        "regExp": "(?i).*(bundesland|german|de).*(state|province|land).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "german_state"
        ],
        "negativeExamples": [
          "region_de"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Baden-W\u00fcrttemberg",
      "Bayern",
      "Berlin",
      "Mecklenburg-Vorpommern",
      "Nordrhein-Westfalen",
      "Rheinland-Pfalz",
      "Sachsen-Anhalt",
      "Th\u00fcringen"
    ],
    "negativeContentExamples": [
      "Bavaria",
      "Baden Wuerttemberg",
      "Nordrhein Westfalen",
      "Mecklenburg Vorpommern",
      "Sachsen Anhalt",
      "Thuringen",
      "Hamburg City",
      "Berlin DE"
    ],
    "positiveHeaderExamples": [
      "bundesland_name",
      "german_state_name",
      "state_name_de",
      "bundesland",
      "land_name",
      "province_name_de",
      "state_de",
      "german_state"
    ],
    "negativeHeaderExamples": [
      "country_name",
      "state_code",
      "region",
      "city_name",
      "province_code",
      "county",
      "postal_code",
      "timezone_name"
    ],
    "explanation": "A finite, curated list of the official German Bundesl\u00e4nder names for validating and classifying columns containing full state names in German. This type helps distinguish complete German state names from abbreviations, codes, or English translations; header patterns target common ways such columns are labeled.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:53:17.672640"
  },
  {
    "resultType": "generated",
    "semanticType": "TIMEZONE.IANA",
    "description": "A standardized time zone identifier from the IANA Time Zone Database used for accurate time representation across different geographic regions.",
    "pluginType": "regex",
    "regexPattern": "\\b(UTC|GMT|[A-Za-z]{2,}(/[A-Za-z0-9._+-]{1,}){1,2})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 6030,
    "headerPatterns": [
      {
        "regExp": "(?i).*iana.*time.?zone.*(id|identifier|name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iana_timezone_id"
        ],
        "negativeExamples": [
          "timezone_offset"
        ]
      },
      {
        "regExp": "(?i).*(tzdb|tz_database|iana).*(tzid|id|identifier|name).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "tz_database_identifier"
        ],
        "negativeExamples": [
          "tz_offset"
        ]
      },
      {
        "regExp": "(?i).*(time.?zone|tz).*(id|identifier|name|code).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "timezone_identifier"
        ],
        "negativeExamples": [
          "time_zone_abbrev"
        ]
      },
      {
        "regExp": "(?i).*(tzid|tz_name|tz_code).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "tzid"
        ],
        "negativeExamples": [
          "utc_offset"
        ]
      },
      {
        "regExp": "(?i).*time.?zone.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "time_zone"
        ],
        "negativeExamples": [
          "local_time"
        ]
      }
    ],
    "positiveContentExamples": [
      "America/New_York",
      "Europe/London",
      "Asia/Kolkata",
      "Africa/Johannesburg",
      "Australia/Sydney",
      "America/Argentina/Buenos_Aires",
      "Etc/UTC",
      "US/Eastern"
    ],
    "negativeContentExamples": [
      "PST",
      "America/Los Angeles",
      "Europe/",
      "2021-07-01T12:00:00Z",
      "London",
      "GMT+0530",
      "Asia/Kolkata/Calcutta/Extra",
      "America\\New_York"
    ],
    "positiveHeaderExamples": [
      "iana_timezone",
      "iana_timezone_id",
      "timezone_identifier",
      "tz_database_name",
      "tzid",
      "tz_code",
      "timezone_iana",
      "time_zone"
    ],
    "negativeHeaderExamples": [
      "timezone_offset",
      "utc_offset",
      "time_zone_abbrev",
      "local_time",
      "daylight_saving",
      "region",
      "country_code",
      "date_time"
    ],
    "explanation": "This semantic type captures IANA Time Zone Database identifiers such as Area/Location or multi-segment forms (e.g., America/Argentina/Buenos_Aires), along with canonical aliases like UTC and GMT. It helps normalize timestamps and schedule conversions by providing a stable, standardized zone key rather than ambiguous abbreviations.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:53:17.876154"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.SUFFIX",
    "description": "A generational or honorific designation that follows a person's name to indicate family lineage, academic achievement, or social status. Typical examples include generational markers (Jr., Sr., II\u2013X), professional titles (Esq.), and academic/professional degrees (MD, PhD).",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "JR",
      "JR.",
      "SR",
      "SR.",
      "II",
      "III",
      "IV",
      "V",
      "VI",
      "VII",
      "VIII",
      "IX",
      "X",
      "ESQ",
      "ESQ.",
      "MD",
      "M.D.",
      "PHD",
      "PH.D.",
      "DDS",
      "DVM",
      "DO",
      "JD",
      "MBA",
      "CPA"
    ],
    "backout": "^(I|II|III|IV|V|VI|VII|VIII|IX|X|[A-Z]{2,4}|[A-Z]{2,4}\\.|[A-Z]{1,3}\\.[A-Z]{1,3}\\.)$",
    "confidenceThreshold": 93,
    "priority": 5090,
    "headerPatterns": [
      {
        "regExp": "(?i).*(person|customer|individual|contact|applicant|employee).*(name).*(suffix|sfx|sufx).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_name_suffix"
        ],
        "negativeExamples": [
          "customer_name_prefix"
        ]
      },
      {
        "regExp": "(?i).*(legal|full|preferred).*(name).*(suffix|sfx).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "legal_name_suffix"
        ],
        "negativeExamples": [
          "preferred_name"
        ]
      },
      {
        "regExp": "(?i).*(name).*(generation|generational|lineage|jr|sr|roman).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name_generational"
        ],
        "negativeExamples": [
          "name_prefix"
        ]
      },
      {
        "regExp": "(?i).*(name).*(suffix|sfx|sufx).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name_sfx"
        ],
        "negativeExamples": [
          "name_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "title"
        ]
      }
    ],
    "positiveContentExamples": [
      "JR",
      "JR.",
      "SR",
      "IV",
      "V",
      "ESQ.",
      "MD",
      "PH.D."
    ],
    "negativeContentExamples": [
      "Jr",
      "MD.",
      "P.H.D",
      "XI",
      "I",
      "SR-",
      "ESQ,",
      "IIII"
    ],
    "positiveHeaderExamples": [
      "customer_name_suffix",
      "legal_name_suffix",
      "person_name_sfx",
      "applicant_name_generational",
      "contact_name_suffix",
      "full_name_suffix",
      "employee_name_suffix",
      "name_sfx"
    ],
    "negativeHeaderExamples": [
      "customer_name_prefix",
      "legal_name",
      "person_suffix",
      "applicant_generation",
      "contact_title",
      "suffix",
      "given_name",
      "name_code"
    ],
    "explanation": "This type identifies short tokens appended to personal names that indicate lineage (e.g., Jr., Sr., II\u2013X), honorific status (e.g., Esq.), or academic/professional credentials (e.g., MD, PhD). It is useful for parsing or normalizing personal names by isolating the suffix component. The list-based approach increases precision by enumerating common suffix forms while the backout pattern defines the general token shape for quality control.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:53:17.876400"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_ZA",
    "description": "A two-letter abbreviation representing one of the nine provinces of South Africa for administrative and postal identification purposes.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "EC",
      "FS",
      "GP",
      "KZ",
      "LP",
      "MP",
      "NC",
      "NW",
      "WC"
    ],
    "backout": "^[A-Z]{2}$",
    "confidenceThreshold": 98,
    "priority": 5720,
    "headerPatterns": [
      {
        "regExp": "(?i).*(south.*africa|za).*(province|prov).*(code|abbr|abbrev).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "south_africa_province_code"
        ],
        "negativeExamples": [
          "province_name"
        ]
      },
      {
        "regExp": "(?i).*(province|prov).*(code|abbr|abbrev).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "prov_abbrev"
        ],
        "negativeExamples": [
          "region_code"
        ]
      },
      {
        "regExp": "(?i).*(za|sa).*(province|prov).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "za_province"
        ],
        "negativeExamples": [
          "za_postal_code"
        ]
      },
      {
        "regExp": "(?i).*(province|prov).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province"
        ],
        "negativeExamples": [
          "country"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "EC",
      "FS",
      "GP",
      "KZ",
      "LP",
      "MP",
      "NC",
      "WC"
    ],
    "negativeContentExamples": [
      "KZN",
      "ZA",
      "ec",
      "GP.",
      "WC1",
      "E-C",
      "G P",
      "N/W"
    ],
    "positiveHeaderExamples": [
      "south_africa_province_code",
      "za_province_abbr",
      "province_code_za",
      "prov_abbrev_sa",
      "province_short_code_za",
      "prov_code",
      "za_province",
      "province"
    ],
    "negativeHeaderExamples": [
      "country_code_za",
      "province_name",
      "postal_code",
      "region_code",
      "state_code_us",
      "airport_code_za",
      "province_id",
      "state_province"
    ],
    "explanation": "This semantic type identifies two-letter abbreviations for South African provinces. It is intended for datasets that store provincial information in compact code form for validation, normalization, filtering, and join operations. The list-based implementation ensures strict matching to the known finite set of province abbreviations while the backout pattern provides a bounded fallback shape for diagnostics.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:53:18.182355"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS4_EN",
    "description": "The fourth line of a street address containing wing designations, entrance specifications, or other specialized location details for large facilities. Typical values include descriptors like Wing C, Entrance 2, Loading Dock 3, or Elevator Lobby 1, which help pinpoint an exact area inside a complex site. This line is intended for granular internal location cues beyond building, unit, or floor information.",
    "pluginType": "regex",
    "regexPattern": "(?i)(\\b(wing|entrance|door|gate|suite|unit|tower|block|bay|pod|building|hall|stair|lift|elevator|dept|department|section|lobby)[ -][A-Z0-9]{1,4}\\b|\\b(loading|receiving)[ -](dock|bay)([ -][0-9]{1,2}\\b)?|\\b(elevator|lift)[ -](bank|lobby)([ -][A-Z0-9]{1,2}\\b)?)",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 92,
    "priority": 5940,
    "headerPatterns": [
      {
        "regExp": "(?i).*street.*address.*4.*en.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "street_address4_en"
        ],
        "negativeExamples": [
          "street_address3_en"
        ]
      },
      {
        "regExp": "(?i).*address.*line.*4.*en.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "address_line4_en"
        ],
        "negativeExamples": [
          "address_line3_en"
        ]
      },
      {
        "regExp": "(?i).*addr.*line.*4.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "addr_line4"
        ],
        "negativeExamples": [
          "addr_line2"
        ]
      },
      {
        "regExp": "(?i).*street.*address.*4.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "street_address4"
        ],
        "negativeExamples": [
          "street_address2"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "address"
        ],
        "negativeExamples": [
          "email"
        ]
      }
    ],
    "positiveContentExamples": [
      "Wing C",
      "Entrance 2",
      "Gate 5",
      "Suite 120",
      "Unit B3",
      "Block 7",
      "Elevator Lobby 3",
      "Loading Dock 2"
    ],
    "negativeContentExamples": [
      "Main Street",
      "Apt 4B",
      "Level 3",
      "North Wing",
      "Building",
      "Gatehouse 5",
      "Entranceway 2",
      "Suite"
    ],
    "positiveHeaderExamples": [
      "street_address4_en",
      "address_line4_en",
      "addr_line4",
      "street_address4",
      "address4_detail",
      "addr_line_4_en",
      "address_line_4",
      "address4"
    ],
    "negativeHeaderExamples": [
      "street_address3_en",
      "address_line3",
      "addr_line2",
      "street_address2",
      "billing_address",
      "email_address",
      "name",
      "postal_code"
    ],
    "explanation": "This semantic type targets the fourth address line used for internal wayfinding details within large sites (e.g., campuses, hospitals, factories) such as wings, entrances, gates, docks, or lobby identifiers. It is designed to complement other address lines by capturing precise sub-location information used for delivery, access control, or visitor routing.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:53:18.799447"
  },
  {
    "resultType": "generated",
    "semanticType": "URI.URL",
    "description": "A Uniform Resource Locator specifying the address and access method for resources on the internet or other networks following RFC 3986 standards.",
    "pluginType": "regex",
    "regexPattern": "\\b(http|https|ftp|ftps|ws|wss)://(([A-Za-z0-9-]+\\.)+[A-Za-z]{2,}|(\\d{1,3}\\.){3}\\d{1,3})(:\\d{2,5})?(/[A-Za-z0-9._~!$&'()*+,;=:@%-]*)*(\\?[A-Za-z0-9._~!$&'()*+,;=:@%/?-]*)?(#[A-Za-z0-9._~!$&'()*+,;=:@%/?-]*)?",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 6040,
    "headerPatterns": [
      {
        "regExp": "(?i).*landing[ _-]*page[ _-]*url.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "landing_page_url"
        ],
        "negativeExamples": [
          "landing_page"
        ]
      },
      {
        "regExp": "(?i).*redirect[ _-]*url.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "redirect_url"
        ],
        "negativeExamples": [
          "redirect_code"
        ]
      },
      {
        "regExp": "(?i).*(website|page)[ _-]*url.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "website_url"
        ],
        "negativeExamples": [
          "page_path"
        ]
      },
      {
        "regExp": "(?i).*\\bhref\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "href"
        ],
        "negativeExamples": [
          "rel"
        ]
      },
      {
        "regExp": "(?i).*url.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "url"
        ],
        "negativeExamples": [
          "uri"
        ]
      }
    ],
    "positiveContentExamples": [
      "https://www.example.com",
      "http://example.org/index.html",
      "https://sub.domain.co.uk/path/to/resource?query=val#section",
      "ftp://ftp.example.com/files/archive.zip",
      "https://192.168.1.10:8080/api/v1/items?sort=asc",
      "wss://socket.example.net/stream",
      "http://example.com?utm_source=ad",
      "https://www.example.com/path-with%20spaces/?a=1&b=two#frag-1"
    ],
    "negativeContentExamples": [
      "www.example.com",
      "http:/example.com",
      "https://",
      "mailto:user@example.com",
      "https://example",
      "wss:/socket.example.com",
      "ftp.example.com/file",
      "https://example..com"
    ],
    "positiveHeaderExamples": [
      "url",
      "page_url",
      "website_url",
      "download_url",
      "landing_page_url",
      "target_url",
      "redirect_url",
      "image_url"
    ],
    "negativeHeaderExamples": [
      "uri",
      "page_path",
      "link_text",
      "hostname",
      "domain",
      "email",
      "file_path",
      "resource_id"
    ],
    "explanation": "This type identifies network-locatable URLs that include a supported scheme, a valid host (domain or IPv4), optional port, path, query, and fragment. It is intended for detecting fields that store full clickable links to web resources, APIs, downloads, or web sockets in datasets.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:53:19.770073"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.SUBURB_AU",
    "description": "The name of a suburban locality within Australian cities and towns, representing residential and commercial areas for postal and administrative identification.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z]('?[[A-Z]])?[a-z]+[A-Za-z']*(-[A-Z]('?[[A-Z]])?[a-z]+[A-Za-z']*)?)(\\s([A-Z]('?[[A-Z]])?[a-z]+[A-Za-z']*(-[A-Z]('?[[A-Z]])?[a-z]+[A-Za-z']*)?)){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 5910,
    "headerPatterns": [
      {
        "regExp": "(?i).*suburb.*au.*name.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "suburb_au_name"
        ],
        "negativeExamples": [
          "suburb_code"
        ]
      },
      {
        "regExp": "(?i).*(au|australia).*suburb.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "australian_suburb"
        ],
        "negativeExamples": [
          "suburb_locality"
        ]
      },
      {
        "regExp": "(?i).*suburb.*(name|nm).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "suburb_name"
        ],
        "negativeExamples": [
          "suburb_type"
        ]
      },
      {
        "regExp": "(?i).*(locality|loc).*(name|nm).*",
        "confidence": 92,
        "mandatory": false,
        "positiveExamples": [
          "locality_name"
        ],
        "negativeExamples": [
          "district_name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Parramatta",
      "St Kilda",
      "O'Connor",
      "Port Macquarie",
      "Alice Springs",
      "Wagga Wagga",
      "McMahons Point",
      "The Entrance North"
    ],
    "negativeContentExamples": [
      "Sydney NSW 2000",
      "Sydney, NSW",
      "Kingsford 2032",
      "Brisbane City QLD",
      "Ballarat VIC 3350",
      "Gungahlin/ACT",
      "NORTH SYDNEY",
      "St. Kilda"
    ],
    "positiveHeaderExamples": [
      "suburb",
      "suburb_name",
      "au_suburb",
      "australian_suburb",
      "suburb_locality",
      "locality_name",
      "suburb_au_name",
      "suburb_town_locality"
    ],
    "negativeHeaderExamples": [
      "state",
      "postcode",
      "city",
      "street_name",
      "lga_name",
      "country",
      "timezone",
      "airport_code"
    ],
    "explanation": "This semantic type targets Australian suburb/locality names as they typically appear in address data, allowing for multi-word names, internal hyphens, and apostrophes (e.g., O'Connor, Tea-Tree Gully). It intentionally excludes state abbreviations, postcodes, commas, and other address components. Use this to identify and validate the suburb/locality portion of Australian addresses for cleansing, deduplication, and geocoding workflows.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:53:20.062067"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS3_EN",
    "description": "The third line of a street address containing building names, floor numbers, unit/suite identifiers, or other sub-premise details commonly used within complexes or multi-building sites. This line is expected to be in English and typically refines location within a property such as tower, block, level, or room.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b((bldg|building|tower|block|unit|suite|apt|apartment|floor|fl|level|lvl|wing|room|rm|dept|department|lot)\\b[ \\-#]*[A-Z0-9]{1,5}([ ,\\/\\-]+[A-Z0-9]{1,8}){0,5})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 92,
    "priority": 5930,
    "headerPatterns": [
      {
        "regExp": "(?i).*street[_ ]?address.*(line[_ ]?3|[_ ]?3).*(en|english).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "street_address3_en"
        ],
        "negativeExamples": [
          "street_address2_en"
        ]
      },
      {
        "regExp": "(?i).*(address[_ ]?line[_ ]?3|address3).*(en|english).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "address_line3_en"
        ],
        "negativeExamples": [
          "address_line3_es"
        ]
      },
      {
        "regExp": "(?i).*(addr[_ ]?line[_ ]?3|addr3|street[_ ]?addr[_ ]?line[_ ]?3).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "addr_line3_en"
        ],
        "negativeExamples": [
          "addr_line2_en"
        ]
      },
      {
        "regExp": "(?i).*(mailing|shipping).*address.*(line[_ ]?3|3).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "mailing_address3_en"
        ],
        "negativeExamples": [
          "mailing_address2_en"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "address"
        ],
        "negativeExamples": [
          "location"
        ]
      }
    ],
    "positiveContentExamples": [
      "Building A",
      "Bldg 5",
      "Floor 3",
      "Level 14",
      "Suite 240",
      "Apt 7C",
      "Unit 12B",
      "Tower 2"
    ],
    "negativeContentExamples": [
      "123 Main St",
      "PO Box 123",
      "Levelheaded 2",
      "Suiteheart 5",
      "Flr 3",
      "Floor No. 3",
      "City Center Tower",
      "Address Line 3"
    ],
    "positiveHeaderExamples": [
      "street_address3_en",
      "address_line3_en",
      "addr3_en",
      "mailing_address3_en",
      "street_addr_line3_en",
      "address3_english",
      "address_line_3_en",
      "addr_line3_en"
    ],
    "negativeHeaderExamples": [
      "street_address2_en",
      "address_line1_en",
      "address3_es",
      "street_address3",
      "addr_line3_fr",
      "billing_address_en",
      "street_name_en",
      "postal_address3_en"
    ],
    "explanation": "This semantic type captures the third line of an English street address, focusing on sub-premise and intra-complex details such as building, tower, block, floor/level, unit/suite, apartment, room, or department identifiers. It is intended to disambiguate precise locations within multi-building properties or large facilities and complements primary address lines without repeating street names or cities.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:53:29.147930"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_NAME_BARE_EN",
    "description": "The base name of a street in English without any type designation or suffix such as Street, Avenue, or Road. Accepts typical English street base names made of 1\u20135 tokens including letters, digits, apostrophes, hyphens, and periods, and may include ordinals (e.g., 7th) or honorifics/initials.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b([A-Z0-9][A-Z0-9'-.]{0,20}(\\s|-)){0,4}(?!street\\b)(?!st\\b)(?!st\\.)(?!avenue\\b)(?!ave\\b)(?!ave\\.)(?!road\\b)(?!rd\\b)(?!rd\\.)(?!boulevard\\b)(?!blvd\\b)(?!blvd\\.)(?!lane\\b)(?!ln\\b)(?!ln\\.)(?!drive\\b)(?!dr\\b)(?!dr\\.)(?!court\\b)(?!ct\\b)(?!ct\\.)(?!terrace\\b)(?!ter\\b)(?!ter\\.)(?!place\\b)(?!pl\\b)(?!pl\\.)(?!way\\b)(?!parkway\\b)(?!pkwy\\b)(?!pkwy\\.)(?!highway\\b)(?!hwy\\b)(?!hwy\\.)(?!alley\\b)(?!aly\\b)(?!aly\\.)(?!circle\\b)(?!cir\\b)(?!cir\\.)(?!square\\b)(?!sq\\b)(?!sq\\.)(?!trail\\b)(?!trl\\b)(?!trl\\.)(?!crescent\\b)(?!cres\\b)(?!cres\\.)(?!row\\b)[A-Z0-9][A-Z0-9'-.]{0,20}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 5990,
    "headerPatterns": [
      {
        "regExp": "(?i).*(street|thoroughfare).*(base|bare).*(name).*(en|english).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "street_name_base_en"
        ],
        "negativeExamples": [
          "street_type"
        ]
      },
      {
        "regExp": "(?i).*(street|thoroughfare).*(base|bare).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "base_street_name"
        ],
        "negativeExamples": [
          "full_street_address"
        ]
      },
      {
        "regExp": "(?i).*(street).*(core|root).*(name).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "street_core_name"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      },
      {
        "regExp": "(?i).*(streetname|street_name).*(bare|base).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "streetname_bare"
        ],
        "negativeExamples": [
          "city_name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Main",
      "Old Mill",
      "King's Cross",
      "Martin Luther King Jr",
      "W 42nd",
      "Saint John",
      "Queen's Park",
      "Oak-Tree"
    ],
    "negativeContentExamples": [
      "Main Street",
      "Elm Rd",
      "Oak Ave.",
      "Old Mill Road",
      "3rd St",
      "Queen's Park Way",
      "Avenue",
      "Road"
    ],
    "positiveHeaderExamples": [
      "street_name_base_en",
      "street_base_name",
      "thoroughfare_base_name",
      "base_street_name",
      "bare_street_name",
      "street_core_name",
      "streetname_bare",
      "street_root_name"
    ],
    "negativeHeaderExamples": [
      "street_type",
      "full_street_address",
      "postal_code",
      "city_name",
      "road_suffix",
      "address_line2",
      "building_name",
      "highway_code"
    ],
    "explanation": "Detects English street base names that exclude trailing street-type designations (e.g., Street, St, Avenue, Ave, Road, Rd). Supports 1\u20135 tokens with letters, digits, apostrophes, hyphens, and periods, and allows ordinals and initials (e.g., 7th, W 42nd, Martin Luther King Jr). Use this to isolate the core street name for normalization, geocoding, and address parsing where the suffix/type is stored separately.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:53:29.637482"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_UNION_NAME_IN",
    "description": "The full name of one of the twenty-eight states or eight union territories of India, representing the complete official designation of Indian administrative divisions.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "ANDHRA PRADESH",
      "ARUNACHAL PRADESH",
      "ASSAM",
      "BIHAR",
      "CHHATTISGARH",
      "GOA",
      "GUJARAT",
      "HARYANA",
      "HIMACHAL PRADESH",
      "JHARKHAND",
      "KARNATAKA",
      "KERALA",
      "MADHYA PRADESH",
      "MAHARASHTRA",
      "ODISHA",
      "RAJASTHAN",
      "TAMIL NADU",
      "ANDAMAN AND NICOBAR ISLANDS",
      "CHANDIGARH",
      "DADRA AND NAGAR HAVELI AND DAMAN AND DIU",
      "DELHI",
      "JAMMU AND KASHMIR",
      "LADAKH",
      "LAKSHADWEEP",
      "PUDUCHERRY"
    ],
    "backout": "^[A-Z][A-Z ]{2,49}$",
    "confidenceThreshold": 95,
    "priority": 5890,
    "headerPatterns": [
      {
        "regExp": "(?i).*india.*state.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "india_state_name"
        ],
        "negativeExamples": [
          "state_name_in"
        ]
      },
      {
        "regExp": "(?i).*india.*union.*territor.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "indian_union_territory_name"
        ],
        "negativeExamples": [
          "state_or_ut_name"
        ]
      },
      {
        "regExp": "(?i).*(state|union.*territor|ut).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_or_ut_name"
        ],
        "negativeExamples": [
          "state_code"
        ]
      },
      {
        "regExp": "(?i).*(prov|province).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province_name_india"
        ],
        "negativeExamples": [
          "province_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "TAMIL NADU",
      "ODISHA",
      "ANDAMAN AND NICOBAR ISLANDS",
      "LADAKH",
      "DELHI",
      "GUJARAT",
      "MAHARASHTRA",
      "PUDUCHERRY"
    ],
    "negativeContentExamples": [
      "ORISSA",
      "BENGAL",
      "DELHI NCR",
      "GOA STATE",
      "JAMMU & KASHMIR",
      "MADHYA PRADEESH",
      "DADRA NAGAR HAVELI DAMAN DIU",
      "ANDAMAN-NICOBAR ISLANDS"
    ],
    "positiveHeaderExamples": [
      "india_state_name",
      "state_or_ut_name",
      "indian_union_territory_name",
      "state_name_in",
      "province_name_india",
      "st_ut_name"
    ],
    "negativeHeaderExamples": [
      "country_name",
      "state_code",
      "city_name",
      "province_code",
      "timezone_name",
      "employee_name"
    ],
    "explanation": "This semantic type identifies full official names of Indian states and union territories. Use it to classify columns containing the complete names of these administrative divisions, not abbreviations or codes. The list provides representative values and a strict fallback pattern ensures values are uppercase alphabetic with spaces only.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:53:31.168400"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_US",
    "description": "The full name of one of the fifty states or the federal district of the United States, using the complete official state or district name. Typical values include multi-word names (e.g., New Hampshire) and the District of Columbia.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(Alabama|Alaska|Arizona|Arkansas|California|Colorado|Connecticut|Delaware|Florida|Georgia|Hawaii|Idaho|Illinois|Indiana|Iowa|Kansas|Kentucky|Louisiana|Maine|Maryland|Massachusetts|Michigan|Minnesota|Mississippi|Missouri|Montana|Nebraska|Nevada|New Hampshire|New Jersey|New Mexico|New York|North Carolina|North Dakota|Ohio|Oklahoma|Oregon|Pennsylvania|Rhode Island|South Carolina|South Dakota|Tennessee|Texas|Utah|Vermont|Virginia|Washington|West Virginia|Wisconsin|Wyoming|District of Columbia)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5850,
    "headerPatterns": [
      {
        "regExp": "(?i).*us[ _-]*state[ _-]*name.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "us_state_name"
        ],
        "negativeExamples": [
          "state_abbrev"
        ]
      },
      {
        "regExp": "(?i).*united[ _-]*states[ _-]*state[ _-]*name.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "united_states_state_name"
        ],
        "negativeExamples": [
          "state_code"
        ]
      },
      {
        "regExp": "(?i).*state[ _-]*full[ _-]*name.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "state_full_name"
        ],
        "negativeExamples": [
          "state_name_code"
        ]
      },
      {
        "regExp": "(?i).*(state|province)[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state name"
        ],
        "negativeExamples": [
          "province_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "California",
      "New York",
      "District of Columbia",
      "north dakota",
      "Rhode Island",
      "Texas",
      "Washington",
      "West Virginia"
    ],
    "negativeContentExamples": [
      "Puerto Rico",
      "District of Colombia",
      "WashingtonDC",
      "NewYork City",
      "RhodeIsland",
      "N. Dakota",
      "Massachussetts",
      "Californias"
    ],
    "positiveHeaderExamples": [
      "us_state_name",
      "united_states_state_name",
      "state_full_name",
      "state name",
      "full_state_name",
      "state_province_name",
      "usa_state_name",
      "state long name"
    ],
    "negativeHeaderExamples": [
      "state_code",
      "state_abbrev",
      "state_abbreviation",
      "province_code",
      "country_name",
      "state_id",
      "city_name",
      "region_name"
    ],
    "explanation": "This semantic type identifies entries that are the full names of U.S. states and the federal district. It is tailored for datasets that store complete state names rather than abbreviations or codes. Typical use cases include address normalization, geospatial aggregation by state, and validation of administrative division fields in U.S.-centric datasets.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:53:34.799047"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS_<LANGUAGE>",
    "description": "A complete single-line street address written in English following United States conventions, including house number, street name and type, optional directional and unit, city, state (2-letter), and 5-digit ZIP with optional +4. The pattern expects comma separators between street segment, city, and state/ZIP to ensure structure and reduce ambiguity.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{1,6}\\s+((N|S|E|W|NE|NW|SE|SW)\\s+)?[A-Za-z0-9.'-]{2,}(\\s+[A-Za-z0-9.'-]{2,}){0,4}\\s+(Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Lane|Ln|Drive|Dr|Court|Ct|Place|Pl|Terrace|Ter|Parkway|Pkwy|Highway|Hwy|Loop|Lp)(\\s+(N|S|E|W|NE|NW|SE|SW))?(,\\s*(Apt|Unit|Suite|Ste|#)\\s*[A-Za-z0-9-]{1,6})?,\\s*[A-Za-z .'-]{2,},\\s*[A-Z]{2}\\s+\\d{5}(-\\d{4})?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5950,
    "headerPatterns": [
      {
        "regExp": "(?i).*mailing.*street.*address.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "mailing_street_address"
        ],
        "negativeExamples": [
          "mailing_address_line1"
        ]
      },
      {
        "regExp": "(?i).*shipping.*street.*address.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "shipping_street_address"
        ],
        "negativeExamples": [
          "shipping_city"
        ]
      },
      {
        "regExp": "(?i).*(billing|service|residential|home|office).*street.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "billing_street_address"
        ],
        "negativeExamples": [
          "billing_postal_code"
        ]
      },
      {
        "regExp": "(?i).*(street|str).*addr.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "street_addr1"
        ],
        "negativeExamples": [
          "physical_state"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "address"
        ],
        "negativeExamples": [
          "email"
        ]
      }
    ],
    "positiveContentExamples": [
      "742 Evergreen Terrace, Springfield, IL 62704",
      "1600 Pennsylvania Ave NW, Washington, DC 20500",
      "1 Infinite Loop, Cupertino, CA 95014",
      "350 Fifth Avenue, New York, NY 10118",
      "500 S Buena Vista St, Burbank, CA 91521",
      "233 S Wacker Dr, Chicago, IL 60606",
      "200 E 15th St, Austin, TX 78701",
      "77 Mass Ave, Cambridge, MA 02139"
    ],
    "negativeContentExamples": [
      "Evergreen Terrace, Springfield, IL 62704",
      "742 Evergreen Terrace Springfield IL 62704",
      "1600 Pennsylvania Avenue, Washington DC 20500",
      "350 Fifth Avenue, New York, New York 10118",
      "221B Baker Street, London NW1 6XE",
      "123 Main, Springfield, IL",
      "500 Buena Vista St., Burbank, CA 91521",
      "1600 Pennsylvania Ave NW Washington, DC 20500"
    ],
    "positiveHeaderExamples": [
      "mailing_street_address",
      "shipping_street_address",
      "billing_street_address",
      "residential_street_address",
      "office_street_addr",
      "home_street_addr1",
      "service_street_address_line",
      "street_address"
    ],
    "negativeHeaderExamples": [
      "mailing_city",
      "shipping_state",
      "postal_code",
      "street_name",
      "address_id",
      "address2",
      "email_address",
      "country"
    ],
    "explanation": "This semantic type captures US English-formatted street addresses that include a house number, street name and type, optional directional or unit, followed by city, state abbreviation, and ZIP code. The regex emphasizes clear token boundaries and required commas to avoid overlapping with general address fragments, person names, or organization names.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:53:39.586378"
  },
  {
    "resultType": "generated",
    "semanticType": "AIRLINE.TEXT_EN",
    "description": "The full commercial name of an airline company as used in business operations and customer-facing communications.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b([A-Z][a-z]+|[A-Z]{2,})((\\s|[-'&.])+([A-Z][a-z]+|[A-Z]{2,}))*((\\s|[-'&.])+(airlines|airways|aviation|jet|jets|express|cargo|lines))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 4210,
    "headerPatterns": [
      {
        "regExp": "(?i).*operating.*airline.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "operating_airline_name"
        ],
        "negativeExamples": [
          "operating_airline_code"
        ]
      },
      {
        "regExp": "(?i).*marketing.*carrier.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "marketing_carrier_name"
        ],
        "negativeExamples": [
          "marketing_carrier_code"
        ]
      },
      {
        "regExp": "(?i).*airline.*company.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "airline_company_name"
        ],
        "negativeExamples": [
          "airline_company_code"
        ]
      },
      {
        "regExp": "(?i).*airline.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "airline_name"
        ],
        "negativeExamples": [
          "airline_code"
        ]
      },
      {
        "regExp": "(?i).*carrier.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "carrier_name"
        ],
        "negativeExamples": [
          "carrier_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Pacific Airways",
      "Skyward Airlines",
      "Northern Jet",
      "Blue Horizon Express",
      "Atlas Air Cargo",
      "Summit Aviation",
      "Liberty Air Lines",
      "Continental Jets"
    ],
    "negativeContentExamples": [
      "Skyward",
      "Air Filters",
      "Blue Horizon Transit",
      "Airline Policy",
      "Jet Fuel",
      "Airways Terminal",
      "Cargo Plane",
      "Northern-Jet-123"
    ],
    "positiveHeaderExamples": [
      "operating_airline_name",
      "marketing_carrier_name",
      "airline_company_name",
      "airline_name",
      "carrier_name",
      "airline full name",
      "official airline name",
      "operating carrier name"
    ],
    "negativeHeaderExamples": [
      "airline_code",
      "carrier_code",
      "airport_name",
      "flight_number",
      "aircraft_type",
      "airport_code",
      "booking_reference",
      "iata_code"
    ],
    "explanation": "This semantic type identifies full commercial airline names in English, typically multi-word names ending with common airline-specific terms such as Airlines, Airways, Aviation, Jet/Jets, Express, Cargo, or Lines. It targets customer-facing and operational naming rather than shorthand codes.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:53:48.928048"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_MARKER_EN",
    "description": "A standardized suffix or type designation used in English street addressing systems (e.g., St, Street, Ave, Avenue, Rd, Road). Values are typically standalone tokens representing the thoroughfare type rather than full street names.",
    "pluginType": "regex",
    "regexPattern": "\\b(avenue|ave|ave\\.|street|st|st\\.|road|rd|rd\\.|boulevard|blvd|blvd\\.|lane|ln|ln\\.|drive|dr|dr\\.|court|ct|ct\\.|circle|cir|cir\\.|place|pl|pl\\.|terrace|ter|ter\\.|parkway|pkwy|pkwy\\.|square|sq|sq\\.|highway|hwy|hwy\\.|way|walk|trail|trl|trl\\.|crescent|cres|cres\\.|mews|grove|grv|grv\\.|alley|aly|aly\\.)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 5970,
    "headerPatterns": [
      {
        "regExp": "(?i).*(street|st).*(suffix|sfx).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "street_suffix"
        ],
        "negativeExamples": [
          "street_name"
        ]
      },
      {
        "regExp": "(?i).*(street|st).*(type|typ).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "street_type"
        ],
        "negativeExamples": [
          "street_number"
        ]
      },
      {
        "regExp": "(?i).*(thoroughfare|road|rd).*type.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "road_type"
        ],
        "negativeExamples": [
          "city"
        ]
      },
      {
        "regExp": "(?i).*(addr|address).*(street|st).*(suffix|sfx|type).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "addr_street_suffix"
        ],
        "negativeExamples": [
          "address_line"
        ]
      },
      {
        "regExp": "(?i).*(st|rd|ave|blvd).*(type|sfx).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "st_sfx"
        ],
        "negativeExamples": [
          "suite_type"
        ]
      },
      {
        "regExp": "(?i).*suffix.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "suffix"
        ],
        "negativeExamples": [
          "prefix"
        ]
      }
    ],
    "positiveContentExamples": [
      "St",
      "ST.",
      "Street",
      "Rd",
      "Road",
      "Ave",
      "Blvd",
      "Drive"
    ],
    "negativeContentExamples": [
      "Ste",
      "Streetname",
      "Roadway",
      "Driver",
      "Av",
      "Boulvard",
      "Courtroom",
      "Trails"
    ],
    "positiveHeaderExamples": [
      "street_suffix",
      "street_type",
      "addr_street_suffix",
      "road_type",
      "thoroughfare_type",
      "street_post_type",
      "st_sfx",
      "suffix"
    ],
    "negativeHeaderExamples": [
      "street_name",
      "street_number",
      "street_direction",
      "suite_type",
      "address_line",
      "city",
      "postal_code",
      "country"
    ],
    "explanation": "This semantic type identifies the standardized street thoroughfare designators used as suffix tokens in English-language addresses (e.g., St, Rd, Ave, Blvd). It is useful for parsing or normalizing addresses where the street type is stored separately from the street name or number, enabling consistent transformations and validation across datasets.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:53:49.666232"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS_EN",
    "description": "A complete street address formatted according to English-language conventions, consisting of a leading house number followed by a street name and a recognized street type, with optional directional prefixes/suffixes and common unit designators.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{1,6}[A-Za-z]?\\s+((N|S|E|W|NE|NW|SE|SW)\\s+)?[A-Za-z0-9]+(\\s+[A-Za-z0-9]+){0,3}\\s+(Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Lane|Ln|Drive|Dr|Court|Ct|Way|Terrace|Ter|Place|Pl|Circle|Cir)(\\s+(N|S|E|W|NE|NW|SE|SW))?(\\s+(Apt|Unit|Suite|Ste|#)\\s*[A-Za-z0-9-]+)?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 5960,
    "headerPatterns": [
      {
        "regExp": "(?i).*street[_ ]address[_ ]en.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "mailing_street_address_en"
        ],
        "negativeExamples": [
          "street_address"
        ]
      },
      {
        "regExp": "(?i).*(shipping|billing|mailing|residential).*street[_ ]address.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "billing_street_address"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      },
      {
        "regExp": "(?i).*(address[_ ]line1|address1|addr1|street[_ ]addr).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "address_line1"
        ],
        "negativeExamples": [
          "address_line2"
        ]
      },
      {
        "regExp": "(?i).*street.*address.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "street_address"
        ],
        "negativeExamples": [
          "street_name"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "address"
        ],
        "negativeExamples": [
          "city"
        ]
      }
    ],
    "positiveContentExamples": [
      "221B Baker Street",
      "1600 Pennsylvania Ave NW",
      "10 Downing St",
      "742 Evergreen Terrace",
      "12A High Road",
      "500 E Main St",
      "89 South Hill Rd",
      "1 King William Street"
    ],
    "negativeContentExamples": [
      "Baker Street",
      "1600 Pennsylvania",
      "742 Evergreen",
      "A12 Baker Street",
      "1600 Ave NW",
      "500 E 5th",
      "Downing Street 10",
      "West 46th Street 55"
    ],
    "positiveHeaderExamples": [
      "mailing_street_address_en",
      "shipping_street_address",
      "residential_street_address",
      "street_address",
      "address_line1",
      "billing_addr1",
      "primary_street_address",
      "addr1"
    ],
    "negativeHeaderExamples": [
      "postal_code",
      "city",
      "country",
      "state_province",
      "po_box",
      "apartment",
      "unit_number",
      "street_name"
    ],
    "explanation": "This type detects single-line English street addresses that begin with a house number and end with a standard street type token (e.g., St, Ave, Rd), optionally including directional prefixes/suffixes and unit designators. It is intended for address line 1 fields that contain the deliverable street portion of a postal address.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:53:52.792428"
  },
  {
    "resultType": "generated",
    "semanticType": "VIN",
    "description": "A unique 17-character alphanumeric identifier assigned to motor vehicles for identification, tracking, and registration. Valid VINs use uppercase letters and digits, excluding the letters I, O, and Q, and are typically presented without spaces or separators.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-HJ-NPR-Z0-9]{17}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 6050,
    "headerPatterns": [
      {
        "regExp": "(?i).*(vehicle|veh).*identification.*(number|no).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "vehicle_identification_number"
        ],
        "negativeExamples": [
          "vehicle_registration_number"
        ]
      },
      {
        "regExp": "(?i).*\\bvin\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "vin"
        ],
        "negativeExamples": [
          "vinyl_code"
        ]
      },
      {
        "regExp": "(?i).*(vehicle|veh).*id.*(number|num|no).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "vehicle_id_number"
        ],
        "negativeExamples": [
          "vehicle_id"
        ]
      },
      {
        "regExp": "(?i).*(auto|car).*vin.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "auto_vin_code"
        ],
        "negativeExamples": [
          "auto_engine_code"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "status"
        ]
      }
    ],
    "positiveContentExamples": [
      "1HGCM82633A004352",
      "JH4DA3350GS009483",
      "WDBUF56X98B123456",
      "2G1WF55KX49382917",
      "3FAHP0HA6AR123456",
      "SALVP2BG0FH123456",
      "5YJSA1DN5DFP12345",
      "ZFAAS00B0E1234567"
    ],
    "negativeContentExamples": [
      "1HGCM82633A00435",
      "1HGCM82633A0043527",
      "1HGCM82633A0I4352",
      "1HGCM82633A00O352",
      "1HGCM82633A00Q352",
      "1hgcm82633a004352",
      "1HGCM82633-A004352",
      "1HGCM82633A00 4352"
    ],
    "positiveHeaderExamples": [
      "vehicle_identification_number",
      "vin",
      "vehicle_id_number",
      "veh_id_num",
      "car_vin",
      "auto_vin_code",
      "veh_identification_no",
      "vehicle_vin_code"
    ],
    "negativeHeaderExamples": [
      "vehicle_registration_number",
      "vinyl_code",
      "vehicle_id",
      "engine_number",
      "vehicle_chassis_number",
      "product_code",
      "customer_code",
      "serial_number"
    ],
    "explanation": "This semantic type detects Vehicle Identification Numbers (VINs), which are 17-character uppercase alphanumeric strings excluding I, O, and Q. It targets clean, delimiter-free VINs commonly used for vehicle records, registrations, service histories, and asset tracking.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:53:58.305226"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_NAME_EN",
    "description": "The complete name of a street in English, including both the base name and the street type (e.g., Street, Ave, Rd). It may optionally include a leading or trailing directional (e.g., N, West) and ordinal numerals in the base name (e.g., 3rd).",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b((NORTH|SOUTH|EAST|WEST|NE|NW|SE|SW|N|S|E|W)[ ]+)?([0-9]+(ST|ND|RD|TH)|[A-Za-z][A-Za-z0-9]*('[A-Za-z]+)?)([- ]([0-9]+(ST|ND|RD|TH)|[A-Za-z][A-Za-z0-9]*('[A-Za-z]+)?)){0,3}[ ]+((HWY|HIGHWAY|RTE|ROUTE)[ ]+[0-9]+[A-Z]?|(ST|STREET|AVE|AVENUE|RD|ROAD|BLVD|BOULEVARD|LN|LANE|DR|DRIVE|CT|COURT|PL|PLACE|TER|TERRACE|WAY|PKWY|PARKWAY|SQ|SQUARE|TRL|TRAIL|CL|CLOSE|CRES|CRESCENT|CIR|CIRCLE|EXPY|EXPRESSWAY|BYP|BYPASS|TPKE|TURNPIKE|ALY|ALLEY))(\\b|[ ]+(NORTH|SOUTH|EAST|WEST|NE|NW|SE|SW|N|S|E|W)\\b)",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 6000,
    "headerPatterns": [
      {
        "regExp": "(?i).*(street.*name.*(en|english)|street_name_en).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "street_name_en"
        ],
        "negativeExamples": [
          "street_name_fr"
        ]
      },
      {
        "regExp": "(?i).*(street|road|thoroughfare).*(full|complete).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "street full name"
        ],
        "negativeExamples": [
          "street number"
        ]
      },
      {
        "regExp": "(?i).*(street|road|avenue|boulevard).*name.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "street name english"
        ],
        "negativeExamples": [
          "city name"
        ]
      },
      {
        "regExp": "(?i).*\\b(st|rd|ave|blvd|ln|dr|ct|pl|ter|cir)\\b.*name.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "st name"
        ],
        "negativeExamples": [
          "state name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "East Main Street",
      "W 3rd Ave",
      "Queen's Road",
      "Old Mill Rd",
      "Maple Blvd",
      "St John's Place",
      "State Route 12",
      "State Highway 101"
    ],
    "negativeContentExamples": [
      "Main",
      "123 Main St",
      "Mainstreet",
      "Elm Av",
      "N Hwy",
      "4th",
      "Main Street, NW",
      "Avenue of the Americas"
    ],
    "positiveHeaderExamples": [
      "street_name_en",
      "street full name",
      "primary street name",
      "street type and name",
      "road name en",
      "thoroughfare name",
      "street name english",
      "en street name"
    ],
    "negativeHeaderExamples": [
      "street_number",
      "address_line1",
      "city_name",
      "route_code",
      "state_name",
      "name",
      "street_type",
      "highway_number"
    ],
    "explanation": "This semantic type identifies English street names that include both a base/toponym and a street type (e.g., Street, Ave, Rd). It supports optional leading or trailing compass directions and ordinal numerals within the base name, while excluding full addresses that include house numbers.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:54:02.077541"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.CANTON_CH",
    "description": "Swiss canton codes used for administrative and postal identification of the 26 federal states within Switzerland. These standardized two-letter abbreviations enable efficient reference to specific cantonal jurisdictions in government and business processes.",
    "pluginType": "regex",
    "regexPattern": "\\b(AG|AI|AR|BE|BL|BS|FR|GE|GL|GR|JU|LU|NE|NW|OW|SG|SH|SO|SZ|TG|TI|UR|VD|VS|ZG|ZH)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 5420,
    "headerPatterns": [
      {
        "regExp": "(?i).*(swiss|ch).*(canton).*(code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "swiss_canton_code"
        ],
        "negativeExamples": [
          "swiss_country_code"
        ]
      },
      {
        "regExp": "(?i).*(cantonal).*(abbrev|abbr|code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cantonal_abbreviation"
        ],
        "negativeExamples": [
          "canton_name"
        ]
      },
      {
        "regExp": "(?i).*(canton).*(code|cd).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "canton_code"
        ],
        "negativeExamples": [
          "country_code"
        ]
      },
      {
        "regExp": "(?i).*(kanton).*(code|kuerzel).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "kanton_code"
        ],
        "negativeExamples": [
          "kanton_name"
        ]
      },
      {
        "regExp": "(?i).*(code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "ZH",
      "GE",
      "VD",
      "TI",
      "BE",
      "SG",
      "FR",
      "VS"
    ],
    "negativeContentExamples": [
      "AA",
      "BB",
      "CH",
      "DE",
      "EU",
      "LL",
      "PP",
      "ZZ"
    ],
    "positiveHeaderExamples": [
      "canton_code",
      "ch_canton_code",
      "swiss_canton_code",
      "cantonal_abbreviation",
      "kanton_code",
      "canton_cd",
      "canton_abbr"
    ],
    "negativeHeaderExamples": [
      "country_code",
      "state_code",
      "province_code",
      "postal_code",
      "canton_name",
      "municipality_code",
      "language_code"
    ],
    "explanation": "This semantic type identifies Swiss canton two-letter codes used across administrative, postal, and business datasets. It matches only the officially recognized 26 abbreviations and is intended for columns explicitly representing canton identifiers rather than full names.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:54:02.866595"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_CO",
    "description": "Colombian municipality names representing the local administrative divisions within Colombia's departmental system. These municipios serve as primary units for local government services, urban planning, and municipal administration throughout Colombian departments.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1\u00e1\u00e9\u00ed\u00f3\u00fa\u00fc\u00f1]{2,}([ -][A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1\u00e1\u00e9\u00ed\u00f3\u00fa\u00fc\u00f1]{1,}){0,5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5560,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\b(colombia|colombian|co)\\b[ _-]*(municipio|municipality|municipalidad)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipio_co"
        ],
        "negativeExamples": [
          "department_name"
        ]
      },
      {
        "regExp": "(?i).*\\b(municipio|municipality|municipalidad)\\b[ _-]*(name|nombre)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipio_nombre"
        ],
        "negativeExamples": [
          "municipio_codigo"
        ]
      },
      {
        "regExp": "(?i).*\\b(municipio|municipality|municipalidad)\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "municipio"
        ],
        "negativeExamples": [
          "provincia"
        ]
      },
      {
        "regExp": "(?i).*\\b(mpio|muni|mun)\\b([ _-]*(name|nombre))?.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "mpio_nombre"
        ],
        "negativeExamples": [
          "depto_nombre"
        ]
      },
      {
        "regExp": "(?i).*\\bname\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Medell\u00edn",
      "Cartagena de Indias",
      "San Jos\u00e9 del Guaviare",
      "Santa Rosa de Cabal",
      "El Carmen de Bol\u00edvar",
      "Villavicencio",
      "Puerto As\u00eds",
      "Santiago de Cali"
    ],
    "negativeContentExamples": [
      "Santa Marta (Magdalena)",
      "Cali - Valle",
      "Bogot\u00e1 D.C.",
      "Villavicencio - Meta",
      "El Carmen de Bol\u00edvar 2",
      "San Jos\u00e9/Guaviare",
      "Medell\u00edn, Antioquia",
      "La Uni\u00f3n#"
    ],
    "positiveHeaderExamples": [
      "municipio",
      "nombre_municipio",
      "municipio_nombre",
      "municipio_co",
      "colombia_municipality",
      "municipality_name_co",
      "mpio_nombre",
      "muni_name"
    ],
    "negativeHeaderExamples": [
      "departamento",
      "department_name",
      "provincia",
      "estado",
      "ciudad",
      "county",
      "municipality_id",
      "municipal_code"
    ],
    "explanation": "This semantic type identifies values that look like Colombian municipality (municipio) names, allowing for Spanish diacritics and common multi-word structures separated by spaces or hyphens. It uses a conservative regex focused on alphabetic tokens and leverages header patterns emphasizing municipio/municipality terminology and Colombia context to distinguish from other geographic types.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:54:12.548785"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_BR",
    "description": "Brazilian municipality names representing the basic administrative units within Brazil's federal system. These munic\u00edpios serve as fundamental territorial divisions for local government, public services, and municipal administration throughout Brazilian states.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff']{3,}|[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff']{2,}([ -][A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff']{2,}){1,5})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5550,
    "headerPatterns": [
      {
        "regExp": "(?i).*municipio.*(br|brasil|brazil).*(name|nome).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality_br_name"
        ],
        "negativeExamples": [
          "city_name"
        ]
      },
      {
        "regExp": "(?i).*(brazil|brasil|br).*(municipality|municipio).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "br_municipality"
        ],
        "negativeExamples": [
          "municipio_nome"
        ]
      },
      {
        "regExp": "(?i).*(municipio|municipality).*(br|brasil|brazil).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "municipio_brasil"
        ],
        "negativeExamples": [
          "state_municipality"
        ]
      },
      {
        "regExp": "(?i).*(munic|mun).*(br|brasil|brazil).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "mun_br"
        ],
        "negativeExamples": [
          "mun_local"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "S\u00e3o Paulo",
      "Rio de Janeiro",
      "Belo Horizonte",
      "Curitiba",
      "Florian\u00f3polis",
      "Jo\u00e3o Pessoa",
      "Porto Alegre",
      "Ji-Paran\u00e1"
    ],
    "negativeContentExamples": [
      "S\u00e3o Paulo - SP",
      "Rio de Janeiro/RJ",
      "Fortaleza, CE",
      "Belo Horizonte 2023",
      "12345",
      "SP",
      "Palmas - TO",
      "S\u00e3o Paulo/SP"
    ],
    "positiveHeaderExamples": [
      "municipio_br",
      "municipio_brasil",
      "brazil_municipality_name",
      "nm_municipio",
      "municipality_br_name",
      "city_municipality_br",
      "municipio_nome",
      "br_municipality"
    ],
    "negativeHeaderExamples": [
      "state_name",
      "uf",
      "province",
      "country",
      "city_code",
      "neighborhood",
      "postal_code",
      "county_name"
    ],
    "explanation": "This semantic type detects Brazilian municipality names as free-text labels containing only alphabetic characters (including diacritics), spaces, hyphens, and apostrophes. It accepts single-word city names with at least three letters and multi-word names with 2\u20136 tokens while rejecting values that include country/state codes, punctuation like slashes/commas, or digits. Typical uses include identifying columns holding Brazilian municipality names for geospatial analytics, normalization, and join preparation.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:54:13.992210"
  },
  {
    "resultType": "generated",
    "semanticType": "TELEPHONE",
    "description": "A numeric sequence used to identify and connect to specific telephone lines for voice communication across various telecommunications systems.",
    "pluginType": "regex",
    "regexPattern": "\\b((\\+?[1-9]\\d{0,2}[ \\-]?)?(\\(\\d{2,4}\\)|\\d{2,4})[ \\-\\.]?\\d{3,4}[ \\-\\.]?\\d{4}|\\d{3}[ \\-\\.]?\\d{4})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 6020,
    "headerPatterns": [
      {
        "regExp": "(?i).*(customer|client|user).*phone.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_phone_number"
        ],
        "negativeExamples": [
          "customer_account_number"
        ]
      },
      {
        "regExp": "(?i).*(primary|main|billing|shipping|contact).*phone.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "primary_phone"
        ],
        "negativeExamples": [
          "primary_email"
        ]
      },
      {
        "regExp": "(?i).*(mobile|cell|cellular).*phone.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mobile_phone"
        ],
        "negativeExamples": [
          "mobile_data_limit"
        ]
      },
      {
        "regExp": "(?i).*telephone.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "user_telephone"
        ],
        "negativeExamples": [
          "teleconference_id"
        ]
      },
      {
        "regExp": "(?i).*phone.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "phone"
        ],
        "negativeExamples": [
          "fax_number"
        ]
      }
    ],
    "positiveContentExamples": [
      "+1 212 555 0139",
      "(212) 555-0139",
      "212-555-0139",
      "212.555.0139",
      "+44 20 7946 0958",
      "555-0139",
      "+49 157 345 6789",
      "020 7946 0958"
    ],
    "negativeContentExamples": [
      "212-555-0139 x123",
      "+1(212)5550139#",
      "123456",
      "212-55-0139",
      "+99 12345 678",
      "020-79460958",
      "1 800 FLOWERS",
      "212 555 013"
    ],
    "positiveHeaderExamples": [
      "customer_phone_number",
      "primary_phone",
      "contact_phone",
      "mobile_phone",
      "user_telephone",
      "billing_contact_phone",
      "office_phone",
      "phone"
    ],
    "negativeHeaderExamples": [
      "customer_account_number",
      "primary_email",
      "contact_fax",
      "mobile_data_limit",
      "teleconference_id",
      "billing_contact_name",
      "office_extension",
      "emergency_contact"
    ],
    "explanation": "This semantic type detects telephone numbers in common international and domestic formats, including optional country codes, area codes with or without parentheses, and separators such as spaces, hyphens, or dots. It also supports 7-digit local numbers with a single separator. It intentionally excludes extensions (e.g., x123), alphanumeric vanity numbers, and numbers with trailing special symbols to reduce ambiguity and false positives.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:54:22.332034"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_NAME_BARE_<LANGUAGE>",
    "description": "The base name of a street without any type designation or suffix, formatted according to specific language conventions. For English, this is one to four tokens composed of capitalized words, ordinals (e.g., 42nd), initials, or apostrophized tokens (e.g., O'Connor), without terms like Street, Ave, Rd, etc.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z][a-z]+|[A-Z][a-z]+'[A-Za-z]+|[A-Z]\\.|[1-9][0-9]{0,3}(st|nd|rd|th))( ([A-Z][a-z]+|[A-Z][a-z]+'[A-Za-z]+|[A-Z]\\.|[1-9][0-9]{0,3}(st|nd|rd|th))){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 5980,
    "headerPatterns": [
      {
        "regExp": "(?i).*(street|road).*name.*(bare|base|core).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "street_name_bare"
        ],
        "negativeExamples": [
          "street_type"
        ]
      },
      {
        "regExp": "(?i).*(bare|base|core).*street.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "base_street_name"
        ],
        "negativeExamples": [
          "full_street_name"
        ]
      },
      {
        "regExp": "(?i).*(street|road).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "streetname_base"
        ],
        "negativeExamples": [
          "street_code"
        ]
      },
      {
        "regExp": "(?i).*st.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "st_name_base"
        ],
        "negativeExamples": [
          "state_name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Elm",
      "Old Mill",
      "King's Cross",
      "O'Connor",
      "Queen Anne",
      "42nd",
      "Fort George",
      "North Point"
    ],
    "negativeContentExamples": [
      "Elm Street",
      "Old Mill Road",
      "King's Cross Station",
      "O'Connor Drive",
      "42nd Ave",
      "Main St",
      "NW 7th Street",
      "South Avenue"
    ],
    "positiveHeaderExamples": [
      "street_name_bare",
      "base_street_name",
      "bare_road_name",
      "street_base_name",
      "road_name_core",
      "streetname_base",
      "st_name_base"
    ],
    "negativeHeaderExamples": [
      "street_type",
      "street_suffix",
      "full_street_name",
      "address_line1",
      "city_name",
      "person_name",
      "route_code"
    ],
    "explanation": "This semantic type identifies the core (bare) portion of English street names, excluding any street type or suffix. It supports normalized schemas where the base name is stored separately from a street type/suffix field and helps validate or split address components cleanly.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:54:25.278867"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COMMUNE_IT",
    "description": "Italian commune names representing the basic administrative divisions within Italy's municipal system. These local government units serve as the primary territorial entities for municipal services and local administration throughout Italian provinces.",
    "pluginType": "regex",
    "regexPattern": "\\b(([A-Z][a-z\u00e0\u00e8\u00e9\u00ec\u00f2\u00f3\u00f9]+('[A-Z][a-z\u00e0\u00e8\u00e9\u00ec\u00f2\u00f3\u00f9]+)?|[A-Z]'[A-Z][a-z\u00e0\u00e8\u00e9\u00ec\u00f2\u00f3\u00f9]+)([ -]([A-Z][a-z\u00e0\u00e8\u00e9\u00ec\u00f2\u00f3\u00f9]+('[A-Z][a-z\u00e0\u00e8\u00e9\u00ec\u00f2\u00f3\u00f9]+)?|[A-Z]'[A-Z][a-z\u00e0\u00e8\u00e9\u00ec\u00f2\u00f3\u00f9]+)){0,4})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 5440,
    "headerPatterns": [
      {
        "regExp": "(?i).*(italian|it).*(comune|municipality).*(name|nome).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "italian_comune_name"
        ],
        "negativeExamples": [
          "municipality_code"
        ]
      },
      {
        "regExp": "(?i).*(comune|municipality).*(name|nome).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality_name"
        ],
        "negativeExamples": [
          "comune_code"
        ]
      },
      {
        "regExp": "(?i).*(comune_italiano|italian_municipality|comune_it|it_comune).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "comune_italiano"
        ],
        "negativeExamples": [
          "region_it"
        ]
      },
      {
        "regExp": "(?i).*(residence|birth|domicile).*(comune).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "residence_comune"
        ],
        "negativeExamples": [
          "province_residence"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Roma",
      "Milano",
      "Napoli",
      "Torino",
      "Firenze",
      "L'Aquila",
      "Reggio Calabria",
      "Quartu Sant'Elena"
    ],
    "negativeContentExamples": [
      "roma",
      "sanremo",
      "l'aquila",
      "reggio calabria",
      "milano-bergamo",
      "torino (to)",
      "napoli2",
      "firenze-centro"
    ],
    "positiveHeaderExamples": [
      "italian_comune_name",
      "comune_name",
      "comune",
      "birth_comune_name",
      "residence_comune",
      "comune_italiano",
      "municipality_name",
      "comune_di_residenza"
    ],
    "negativeHeaderExamples": [
      "comune_code",
      "municipality_code",
      "comune_id",
      "province_name",
      "region_name",
      "city_name",
      "comune_cap",
      "comune_area_km2"
    ],
    "explanation": "This semantic type captures the names of Italian comuni (municipalities), allowing for common Italian orthography including spaces, hyphens, and internal apostrophes (e.g., L'Aquila, Sant'Elena). It is intended for columns containing the commune\u2019s name rather than identifiers or codes. Use when datasets reference municipal-level localities across Italy\u2019s provinces and regions.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:54:35.101303"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.REGION_NAME_FR",
    "description": "The name of one of the administrative regions of France, representing the highest level of territorial subdivision in the French administrative system. Values are the official post-2016 region names and may include diacritics, spaces, hyphens, and apostrophes.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AUVERGNE-RH\u00d4NE-ALPES",
      "BOURGOGNE-FRANCHE-COMT\u00c9",
      "BRETAGNE",
      "CENTRE-VAL DE LOIRE",
      "CORSE",
      "GRAND EST",
      "HAUTS-DE-FRANCE",
      "\u00ceLE-DE-FRANCE",
      "NORMANDIE",
      "NOUVELLE-AQUITAINE",
      "OCCITANIE",
      "PAYS DE LA LOIRE",
      "PROVENCE-ALPES-C\u00d4TE D'AZUR",
      "GUADELOUPE",
      "MARTINIQUE",
      "GUYANE",
      "LA R\u00c9UNION",
      "MAYOTTE"
    ],
    "backout": "^[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff' -]{3,40}$",
    "confidenceThreshold": 97,
    "priority": 5730,
    "headerPatterns": [
      {
        "regExp": "(?i).*france.*region.*name.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "region_name_france"
        ],
        "negativeExamples": [
          "region_code_france"
        ]
      },
      {
        "regExp": "(?i).*fr.*region.*name.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "fr_region_name"
        ],
        "negativeExamples": [
          "fr_region_code"
        ]
      },
      {
        "regExp": "(?i).*(nom|libelle).*region.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "nom_region"
        ],
        "negativeExamples": [
          "nom_departement"
        ]
      },
      {
        "regExp": "(?i).*(reg|rg).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "reg_name"
        ],
        "negativeExamples": [
          "reg_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "\u00ceLE-DE-FRANCE",
      "AUVERGNE-RH\u00d4NE-ALPES",
      "BOURGOGNE-FRANCHE-COMT\u00c9",
      "BRETAGNE",
      "NORMANDIE",
      "NOUVELLE-AQUITAINE",
      "PROVENCE-ALPES-C\u00d4TE D'AZUR",
      "LA R\u00c9UNION"
    ],
    "negativeContentExamples": [
      "ILE-DE-FRANCE",
      "PROVENCE ALPES COTE D'AZUR",
      "GRAND-EST",
      "CENTRE VAL DE LOIRE",
      "GUYANA",
      "NORMANDY",
      "REUNION",
      "MAYOTTE DEPARTMENT"
    ],
    "positiveHeaderExamples": [
      "region_name_fr",
      "french_region_name",
      "nom_region",
      "libelle_region",
      "fr_region_name",
      "region_name_france",
      "nom_de_region",
      "region_name"
    ],
    "negativeHeaderExamples": [
      "region_code_fr",
      "department_name_fr",
      "state_name",
      "country_region_name",
      "commune_name",
      "arrondissement_name",
      "county_name",
      "province_code"
    ],
    "explanation": "This semantic type identifies French administrative region names using a finite, authoritative list of post-2016 regions. It is suitable for columns that store the human-readable region name (label), including diacritics and valid separators. The list plugin ensures high precision, while the anchored backout pattern provides a controlled fallback for shape validation without overgeneralizing.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:54:41.328982"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.DISTRICT_NAME_IN",
    "description": "Indian district names representing the administrative divisions within states and union territories of India. These districts serve as primary units for local government administration, revenue collection, and public service delivery throughout the Indian subcontinent.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z]{2,}([ -][A-Za-z]{2,}|[ -][0-9]{1,3}|'[A-Za-z]{2,}){0,5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 5520,
    "headerPatterns": [
      {
        "regExp": "(?i).*(india|indian).*(district).*(name).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "india_district_name"
        ],
        "negativeExamples": [
          "district_name"
        ]
      },
      {
        "regExp": "(?i).*(state|union[ _-]?territory|ut).*(district).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "state_district"
        ],
        "negativeExamples": [
          "state_name"
        ]
      },
      {
        "regExp": "(?i).*(dist|zila|zilla).*(name).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "zila_name"
        ],
        "negativeExamples": [
          "province_title"
        ]
      },
      {
        "regExp": "(?i).*(district).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "residence_district"
        ],
        "negativeExamples": [
          "state_name"
        ]
      },
      {
        "regExp": "(?i).*(name).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Ahmedabad",
      "North 24 Parganas",
      "South Andaman",
      "Purba Bardhaman",
      "Bengaluru Urban",
      "Dadra and Nagar Haveli",
      "Coimbatore",
      "Ernakulam"
    ],
    "negativeContentExamples": [
      "Maharashtra",
      "Gujarat",
      "24 Parganas",
      "South 24",
      "Dadra Nagar Haveli",
      "Kolkata Municipal Corporation",
      "560001",
      "IN-DL"
    ],
    "positiveHeaderExamples": [
      "district_name",
      "indian_district",
      "india_district_name",
      "district_of_state",
      "residence_district",
      "zila_name",
      "state_district"
    ],
    "negativeHeaderExamples": [
      "state_name",
      "province",
      "city_district_code",
      "country",
      "postal_code",
      "tehsil_name",
      "region_name"
    ],
    "explanation": "This semantic type identifies names of Indian districts across states and union territories. It is useful for normalizing location data, geospatial joins, demographic analysis, and aggregations at the district level in India. The value pattern allows common multi-token district names with spaces, hyphens, apostrophes, and occasional numerals (e.g., 24) while header patterns strongly bias toward columns explicitly labeled as Indian district names.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:54:54.764651"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_NL",
    "description": "Dutch municipality names representing the local administrative divisions within the Netherlands' provincial system. These gemeenten serve as primary units for local government services, urban planning, and municipal administration throughout Dutch provinces.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff\u2019']+([ -][A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff\u2019']+){0,4})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5600,
    "headerPatterns": [
      {
        "regExp": "(?i).*(municipality|gemeente).*(nl|nederland|dutch).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "municipality_nl"
        ],
        "negativeExamples": [
          "municipality_code"
        ]
      },
      {
        "regExp": "(?i).*(nl|nederland|dutch).*(municipality|gemeente).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "nl_gemeente"
        ],
        "negativeExamples": [
          "province_nl"
        ]
      },
      {
        "regExp": "(?i).*(municipality|gemeente).*(name|naam).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality_name"
        ],
        "negativeExamples": [
          "municipality_code"
        ]
      },
      {
        "regExp": "(?i).*(municipality|gemeente).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "gemeente"
        ],
        "negativeExamples": [
          "city"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Amsterdam",
      "Rotterdam",
      "\u2019s-Hertogenbosch",
      "Eijsden-Margraten",
      "S\u00fadwest-Frysl\u00e2n",
      "Noardeast-Frysl\u00e2n",
      "Hoeksche Waard",
      "Hendrik-Ido-Ambacht"
    ],
    "negativeContentExamples": [
      "Amsterdam, NL",
      "Den Haag (ZH)",
      "Hendrik-Ido-Ambacht 2",
      "Noardeast-Frysl\u00e2n.",
      "Rotterdam/Barendrecht",
      "\u2019s-Hertogenbosch-",
      "Groningen & Haren",
      "Utrecht (provincie)"
    ],
    "positiveHeaderExamples": [
      "municipality_nl",
      "nl_gemeente",
      "dutch_municipality",
      "gemeente",
      "municipality_name",
      "gem_name",
      "municipality"
    ],
    "negativeHeaderExamples": [
      "province",
      "country",
      "city_name",
      "postal_code",
      "address",
      "region",
      "state",
      "code"
    ],
    "explanation": "This semantic type targets the names of Dutch municipalities (gemeenten) as free-text labels, accommodating common Dutch orthography including spaces, hyphens, and apostrophes. It is useful for identifying columns that store municipality names for geospatial joins, aggregation, and jurisdictional analyses within the Netherlands. The regex is intentionally constrained to alphabetic characters (with diacritics), spaces, apostrophes, and hyphens, avoiding digits and punctuation that typically denote codes or annotations.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:55:01.030249"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_BR",
    "description": "The full name of one of the twenty-six states or the federal district of Brazil, representing the complete official designation of Brazilian federative units.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(acre|alagoas|amap\u00e1|amazonas|bahia|cear\u00e1|distrito federal|esp\u00edrito santo|goi\u00e1s|maranh\u00e3o|mato grosso do sul|mato grosso|minas gerais|par\u00e1|para\u00edba|paran\u00e1|pernambuco|piau\u00ed|rio de janeiro|rio grande do norte|rio grande do sul|rond\u00f4nia|roraima|santa catarina|s\u00e3o paulo|sergipe|tocantins)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 5820,
    "headerPatterns": [
      {
        "regExp": "(?i).*(brazil|br).*(state|estado|uf).*(full|long).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "brazil state full name"
        ],
        "negativeExamples": [
          "br state code"
        ]
      },
      {
        "regExp": "(?i).*(federative unit|unidade federativa).*(name|nome).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "unidade federativa nome"
        ],
        "negativeExamples": [
          "unidade federativa c\u00f3digo"
        ]
      },
      {
        "regExp": "(?i).*(state|estado).*(name|nome).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state name"
        ],
        "negativeExamples": [
          "state id"
        ]
      },
      {
        "regExp": "(?i).*(br|brazil).*(uf).*(name|nome).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "br uf name"
        ],
        "negativeExamples": [
          "uf code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "description"
        ]
      }
    ],
    "positiveContentExamples": [
      "S\u00e3o Paulo",
      "Rio de Janeiro",
      "Minas Gerais",
      "Distrito Federal",
      "Esp\u00edrito Santo",
      "Mato Grosso do Sul",
      "Rio Grande do Norte",
      "Paran\u00e1"
    ],
    "negativeContentExamples": [
      "SP",
      "Sao Paulo",
      "Rio de Janerio",
      "Minas-Gerais",
      "DistritoFederal",
      "Espirito Santo",
      "Mato G. do Sul",
      "Rondonia"
    ],
    "positiveHeaderExamples": [
      "brazil state full name",
      "unidade federativa nome",
      "federative unit name",
      "state name br",
      "br uf name",
      "estado nome",
      "nome do estado"
    ],
    "negativeHeaderExamples": [
      "state code",
      "uf",
      "country name",
      "province id",
      "br state code",
      "region name",
      "city name"
    ],
    "explanation": "This semantic type identifies cells containing the official full names of Brazilian federative units (the 26 states and the Federal District). It matches the complete, correctly spelled names with appropriate spacing and diacritics, and intentionally excludes abbreviations, codes, partial names, or misspelled/unaccented variants.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:55:44.617402"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_UNION_IN",
    "description": "Two-letter abbreviations for India\u2019s first-level administrative subdivisions (28 states and 8 union territories), suitable for administrative and postal identification. Values are restricted to the standard two-letter forms used for Indian subdivisions.",
    "pluginType": "regex",
    "regexPattern": "\\b(AN|AP|AR|AS|BR|CH|CT|DL|DH|GA|GJ|HR|HP|JH|JK|KA|KL|LD|MH|ML|MN|MP|MZ|NL|OD|PB|PY|RJ|SK|TN|TG|TR|UP|UT|WB|LA)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5880,
    "headerPatterns": [
      {
        "regExp": "(?i).*india.*state.*ut.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "india_state_ut_code"
        ],
        "negativeExamples": [
          "state_code_in"
        ]
      },
      {
        "regExp": "(?i).*in.*state.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "in_state_code"
        ],
        "negativeExamples": [
          "country_state_code"
        ]
      },
      {
        "regExp": "(?i).*state.*territory.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_territory_code"
        ],
        "negativeExamples": [
          "territory_name"
        ]
      },
      {
        "regExp": "(?i).*state.*abbr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "indian_state_abbr"
        ],
        "negativeExamples": [
          "state_name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "AN",
      "DL",
      "KA",
      "MH",
      "TN",
      "TG",
      "OD",
      "LA"
    ],
    "negativeContentExamples": [
      "mh",
      "TS",
      "OR",
      "UK",
      "DN",
      "DD",
      "MH1",
      "ANP"
    ],
    "positiveHeaderExamples": [
      "in_state_code",
      "india_state_ut_code",
      "state_territory_code",
      "state_code_in",
      "indian_state_abbr",
      "state_ut_abbreviation",
      "state_code",
      "state_short_code"
    ],
    "negativeHeaderExamples": [
      "country_code",
      "postal_code",
      "state_name",
      "province_code",
      "timezone_code",
      "airport_code",
      "region",
      "territory_name"
    ],
    "explanation": "This semantic type identifies two-letter Indian state and union territory abbreviations commonly used in administrative and postal datasets. It strictly matches only the recognized two-letter subdivision codes and rejects near-misses such as deprecated or non-standard codes, lowercase variants, or values with attached alphanumeric characters.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:55:48.826598"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_PROVINCE_NA",
    "description": "A standardized abbreviation representing administrative divisions from the United States, Canada, or Mexico for North American geographic identification.",
    "pluginType": "regex",
    "regexPattern": "\\b(AL|AK|AZ|AR|CA|CO|CT|DC|DE|FL|GA|HI|IA|ID|IL|IN|KS|KY|LA|MA|MD|ME|MI|MN|MO|MS|MT|NC|ND|NE|NH|NJ|NM|NV|NY|OH|OK|OR|PA|RI|SC|SD|TN|TX|UT|VA|VT|WA|WI|WV|WY|AB|BC|MB|NB|NL|NS|NT|NU|ON|PE|QC|SK|YT|AGU|BCN|BCS|CAM|CHH|CHP|CMX|COA|COL|DUR|GUA|GRO|HID|JAL|MEX|MIC|MOR|NAY|NLE|OAX|PUE|QUE|ROO|SIN|SLP|SON|TAB|TAM|TLA|VER|YUC|ZAC)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5860,
    "headerPatterns": [
      {
        "regExp": "(?i).*(na|north.?america).*(state|prov|province).*(code|abbr|abbrev).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "na_state_code"
        ],
        "negativeExamples": [
          "state_code"
        ]
      },
      {
        "regExp": "(?i).*(us|usa|canada|ca|mx|mexico).*(state|prov|province).*(code|abbr|abbrev).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "us_state_code"
        ],
        "negativeExamples": [
          "country_code"
        ]
      },
      {
        "regExp": "(?i).*(state|prov|province).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_prov_code"
        ],
        "negativeExamples": [
          "state_name"
        ]
      },
      {
        "regExp": "(?i).*(state|prov|province).*(abbr|abbrev).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province_abbrev"
        ],
        "negativeExamples": [
          "province_id"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "CA",
      "TX",
      "NY",
      "DC",
      "ON",
      "QC",
      "JAL",
      "NLE"
    ],
    "negativeContentExamples": [
      "ca",
      "C-A",
      "NYC",
      "DF",
      "PR",
      "ALB",
      "NSW",
      "QUE."
    ],
    "positiveHeaderExamples": [
      "na_state_code",
      "north_america_province_abbr",
      "us_state_code",
      "ca_province_code",
      "mx_state_abbrev",
      "region_state_code",
      "state_prov_code",
      "subdivision_code"
    ],
    "negativeHeaderExamples": [
      "country_code",
      "state_name",
      "province",
      "us_state",
      "postal_code",
      "timezone_code",
      "airport_code",
      "region_name"
    ],
    "explanation": "This semantic type identifies North American first-level administrative division abbreviations using the canonical two-letter codes for US states and DC, two-letter codes for Canadian provinces and territories, and three-letter ISO-style codes for Mexican states (without an MX- prefix). It enforces uppercase standardized abbreviations to avoid ambiguity and ensures robust discrimination from unrelated codes.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:55:55.724002"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_MX",
    "description": "The full name of one of the thirty-two federal entities of Mexico, representing the complete official designation of Mexican states and federal districts.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(aguascalientes|baja california sur|baja california|campeche|chiapas|chihuahua|ciudad de m\u00e9xico|ciudad de mexico|coahuila de zaragoza|colima|durango|guanajuato|guerrero|hidalgo|jalisco|estado de m\u00e9xico|estado de mexico|michoac\u00e1n de ocampo|michoacan de ocampo|morelos|nayarit|nuevo le\u00f3n|nuevo leon|oaxaca|puebla|quer\u00e9taro|queretaro|quintana roo|san luis potos\u00ed|san luis potosi|sinaloa|sonora|tabasco|tamaulipas|tlaxcala|veracruz de ignacio de la llave|yucat\u00e1n|yucatan|zacatecas)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5840,
    "headerPatterns": [
      {
        "regExp": "(?i).*(mexic|mx).*state.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mx_state_name"
        ],
        "negativeExamples": [
          "mx_state_code"
        ]
      },
      {
        "regExp": "(?i).*(nombre|name).*(estado|entidad).*(mexic|mx).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nombre_estado_mexico"
        ],
        "negativeExamples": [
          "estado_codigo_mexico"
        ]
      },
      {
        "regExp": "(?i).*(mexic|mx).*(state|estado).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "mx_state"
        ],
        "negativeExamples": [
          "us_state"
        ]
      },
      {
        "regExp": "(?i).*(mx).*(st|edo)\\b.*name.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "mx_st_name"
        ],
        "negativeExamples": [
          "mx_state_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Ciudad de M\u00e9xico",
      "Baja California Sur",
      "Coahuila de Zaragoza",
      "Michoac\u00e1n de Ocampo",
      "Nuevo Le\u00f3n",
      "San Luis Potos\u00ed",
      "Veracruz de Ignacio de la Llave",
      "Quer\u00e9taro"
    ],
    "negativeContentExamples": [
      "Mexico",
      "Baja California, Mexico",
      "Nuevo Le\u00f3n MX",
      "San Luis",
      "Veracruz",
      "Coahuila",
      "Michoacan",
      "Distrito Federal"
    ],
    "positiveHeaderExamples": [
      "mx_state_name",
      "mexico_state_name",
      "nombre_estado_mexico",
      "state_full_name_mx",
      "nombre_entidad_mexicana",
      "mx_st_name",
      "state_name_mx"
    ],
    "negativeHeaderExamples": [
      "mx_state_code",
      "us_state_name",
      "province_name_ca",
      "country_name",
      "city_name",
      "state_abbreviation_mx",
      "entidad_codigo_mexico"
    ],
    "explanation": "Identifies cell values that are exact full official names of Mexico's federal entities, including diacritics and multi-word forms. Use this type to standardize and validate Mexican state/federal entity names in address, geography, or government datasets.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:57:43.824118"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS2_EN",
    "description": "Second line of a street address in English capturing sub\u2011premise details such as apartment, suite, unit, floor, room, or department identifiers within a building. Typical tokens include Apt, Suite/Ste, Unit, Floor/Fl, Room/Rm, Building/Bldg with an associated number or alphanumeric designator.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(apt|apartment)\\s+[A-Z]?[0-9]{1,4}[A-Z]?\\b|\\b(suite|ste)\\s+[A-Z]?[0-9]{1,4}[A-Z]?\\b|\\bunit\\s+(#\\s*)?[A-Z0-9-]{1,6}\\b|\\b(#|no\\.|number)\\s*[A-Z0-9-]{1,6}\\b|\\b(floor|fl|level|lvl)\\s*[0-9]{1,2}[A-Z]?\\b|\\b(room|rm)\\s*[0-9]{1,4}[A-Z]?\\b|\\b(building|bldg)\\s+[A-Z0-9]{1,3}\\s*,\\s*(apt|apartment|suite|ste|unit|room|rm|#)\\s*[A-Z0-9-]{1,6}\\b|\\b(dept|department)\\s+[A-Z0-9]{1,4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5920,
    "headerPatterns": [
      {
        "regExp": "(?i).*(shipping|billing)[ _-]*(street)?[ _-]*address[ _-]*(line|ln)[ _-]*2.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "shipping_address_line2"
        ],
        "negativeExamples": [
          "billing_street_address_line1"
        ]
      },
      {
        "regExp": "(?i).*(street|mailing)[ _-]*address[ _-]*(line|ln|addr)[ _-]*2.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "street_address_ln_2"
        ],
        "negativeExamples": [
          "mailing_address_line1"
        ]
      },
      {
        "regExp": "(?i).*address[ _-]*(line|ln|addr)[ _-]*2.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "address_ln_2"
        ],
        "negativeExamples": [
          "address_ln_1"
        ]
      },
      {
        "regExp": "(?i).*(address|addr)[ _-]*2.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "address2"
        ],
        "negativeExamples": [
          "addr_1"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "address"
        ],
        "negativeExamples": [
          "city"
        ]
      }
    ],
    "positiveContentExamples": [
      "Apt 3B",
      "Apartment 12",
      "Suite 210",
      "Ste 5A",
      "Unit #304",
      "#22B",
      "Floor 14",
      "Bldg A, Apt 3"
    ],
    "negativeContentExamples": [
      "Apartment3B",
      "Ste5A",
      "Unit#304",
      "Fl-2",
      "P.O. Box 123",
      "Building A Apt 3",
      "Rm-204",
      "#"
    ],
    "positiveHeaderExamples": [
      "shipping_address_line2",
      "billing_address_line_2",
      "street_address_ln_2",
      "mailing_address_addr_2",
      "address_line_2",
      "address_ln_2",
      "address2",
      "addr_2"
    ],
    "negativeHeaderExamples": [
      "shipping_address_line1",
      "address_line1",
      "addr_1",
      "street_address",
      "postal_address",
      "address3",
      "address_primary",
      "shipping_address"
    ],
    "explanation": "This semantic type detects second-line street address details commonly used to specify sub-premise locations within a building, such as apartments, suites, units, floors, rooms, or departments. The regex focuses on clear English tokens and bounded alphanumeric designators to reduce ambiguity while accommodating common formatting variations. Header patterns prioritize explicit 'address line 2' fields to improve classification in schemas where column names are informative.",
    "description_pattern": "P1",
    "generated_at": "2025-08-10T16:57:54.819002"
  }
]
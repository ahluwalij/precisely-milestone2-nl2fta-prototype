[
  {
    "resultType": "generated",
    "semanticType": "DAY.DIGITS",
    "description": "calendar_day: numeric day within month",
    "pluginType": "regex",
    "regexPattern": "\\b(0?[1-9]|[12][0-9]|3[01])\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 8890,
    "headerPatterns": [
      {
        "regExp": "(?i).*(day[^a-z0-9]+of[^a-z0-9]+month).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Day of Month"
        ],
        "negativeExamples": [
          "Month Day"
        ]
      },
      {
        "regExp": "(?i).*(date[^a-z0-9]*number).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Date Number"
        ],
        "negativeExamples": [
          "Account Number"
        ]
      },
      {
        "regExp": "(?i).*(day[^a-z0-9]*(number|num)).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Day Num"
        ],
        "negativeExamples": [
          "Item Number"
        ]
      },
      {
        "regExp": "(?i).*(calendar[^a-z0-9]*day).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Calendar Day"
        ],
        "negativeExamples": [
          "Calendar Month"
        ]
      },
      {
        "regExp": "(?i).*day.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Day"
        ],
        "negativeExamples": [
          "Year"
        ]
      }
    ],
    "positiveContentExamples": [
      "1",
      "09",
      "12",
      "31",
      "5",
      "23",
      "30",
      "10"
    ],
    "negativeContentExamples": [
      "00",
      "32",
      "3rd",
      "1.0",
      "001",
      "9-",
      "13:00",
      "7/"
    ],
    "positiveHeaderExamples": [
      "Day",
      "Day of Month",
      "Date Number"
    ],
    "negativeHeaderExamples": [
      "Month",
      "Year",
      "Day Name"
    ],
    "explanation": "This semantic type identifies the numeric day within a month, limited to 1\u201331, allowing an optional leading zero (e.g., 01\u201309). It is intended for fields representing the day-of-month component, not full dates or textual day names.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:53:23.664717"
  },
  {
    "resultType": "generated",
    "semanticType": "CONTINENT.CODE_EN",
    "description": "Regional Code: two-letter continental abbreviation",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AF",
      "AN",
      "AS",
      "EU",
      "NA",
      "OC",
      "SA"
    ],
    "backout": "^[A-Z]{2}$",
    "confidenceThreshold": 98,
    "priority": 8680,
    "headerPatterns": [
      {
        "regExp": "(?i).*continent.*(code|abbr|abbrev).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Continent Abbr"
        ],
        "negativeExamples": [
          "Continent Name"
        ]
      },
      {
        "regExp": "(?i).*(region).*\\b(code|abbr|abbrev)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Region Code"
        ],
        "negativeExamples": [
          "Region Name"
        ]
      },
      {
        "regExp": "(?i).*(cont|cnt).*\\b(code|abbr|abbrev)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Cont Code"
        ],
        "negativeExamples": [
          "Continent Name"
        ]
      },
      {
        "regExp": "(?i).*continental.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Continental Code"
        ],
        "negativeExamples": [
          "Continental Shelf"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "AF",
      "AN",
      "AS",
      "EU",
      "NA",
      "OC",
      "SA"
    ],
    "negativeContentExamples": [
      "AU",
      "EU1",
      "E U",
      "EUR",
      "XX",
      "AF-",
      "OC3",
      "SAO"
    ],
    "positiveHeaderExamples": [
      "Continent Code",
      "Continent Abbr",
      "Region Code",
      "Continental Code",
      "Cont Code",
      "Region Abbr",
      "Continent Abbrev"
    ],
    "negativeHeaderExamples": [
      "Continent Name",
      "Country",
      "Location",
      "Continent",
      "Country Code",
      "Region Name",
      "Geo Name"
    ],
    "explanation": "This type captures standardized two-letter abbreviations representing continents, enabling consistent regional grouping and filtering. It is modeled as a finite controlled vocabulary to prevent misclassification and ensure high precision.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:53:29.574030"
  },
  {
    "resultType": "generated",
    "semanticType": "COLOR.HEX",
    "description": "Color Value: hexadecimal RGB representation",
    "pluginType": "regex",
    "regexPattern": "\\b#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 8630,
    "headerPatterns": [
      {
        "regExp": "(?i).*hex.*color.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Hex Color Code"
        ],
        "negativeExamples": [
          "Color Name"
        ]
      },
      {
        "regExp": "(?i).*color.*hex.*value.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Color Hex Value"
        ],
        "negativeExamples": [
          "RGB Values"
        ]
      },
      {
        "regExp": "(?i).*hex.*color.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Hex Color"
        ],
        "negativeExamples": [
          "Brand Color"
        ]
      },
      {
        "regExp": "(?i).*color.*code.*",
        "confidence": 91,
        "mandatory": true,
        "positiveExamples": [
          "Color Code"
        ],
        "negativeExamples": [
          "Hex Value"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Value"
        ]
      }
    ],
    "positiveContentExamples": [
      "#1A2B3C",
      "#FFFFFF",
      "#000000",
      "#abc",
      "#F0F",
      "#a1b2c3",
      "#C0ffee"
    ],
    "negativeContentExamples": [
      "1A2B3C",
      "#1234",
      "#12345",
      "#1234567",
      "#GGGGGG",
      "#12 3456",
      "0xFFFFFF",
      "rgb(255,0,0)"
    ],
    "positiveHeaderExamples": [
      "Color Code",
      "Hex Color",
      "Color Value",
      "Hex Code",
      "Web Color Hex",
      "Color Hex Value",
      "Hexadecimal Color"
    ],
    "negativeHeaderExamples": [
      "Color Name",
      "RGB Values",
      "Brand Color",
      "Pantone Code",
      "RGBA",
      "CMYK",
      "Hue"
    ],
    "explanation": "This semantic type identifies color values expressed as hexadecimal RGB codes commonly used in stylesheets and UI configuration. It matches both 3-digit and 6-digit forms prefixed with '#', using case-insensitive hexadecimal digits.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:53:30.175627"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.EASTING",
    "description": "X Coordinate: eastward distance measurement",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{3,7}(\\.\\d+)?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 8700,
    "headerPatterns": [
      {
        "regExp": "(?i).*easting[ _-]*(coordinate|coord|value).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Easting Value"
        ],
        "negativeExamples": [
          "Latitude"
        ]
      },
      {
        "regExp": "(?i).*\\bx[ _-]*coordinate.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "X Coordinate"
        ],
        "negativeExamples": [
          "Longitude"
        ]
      },
      {
        "regExp": "(?i).*\\beasting\\b.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Easting"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*\\bx[_-]?coord.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "X_Coordinate"
        ],
        "negativeExamples": [
          "X Index"
        ]
      },
      {
        "regExp": "(?i).*coordinate.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "X Coordinate"
        ],
        "negativeExamples": [
          "Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "500000",
      "432123.45",
      "700123.0",
      "12345",
      "2543216",
      "812345",
      "642000"
    ],
    "negativeContentExamples": [
      "-500000",
      "1,234",
      "500000E",
      "E500000",
      "500 000",
      "500000.123.45",
      "12.",
      "90.000W"
    ],
    "positiveHeaderExamples": [
      "Easting",
      "X Coordinate",
      "Easting Value",
      "UTM Easting",
      "X Coord",
      "X_Coordinate",
      "Grid X"
    ],
    "negativeHeaderExamples": [
      "Longitude",
      "Latitude",
      "Address",
      "Postal Code",
      "X Index",
      "Location ID"
    ],
    "explanation": "Identifies numeric easting values representing the X component in projected coordinate systems. Values are positive numeric distances (meters or feet depending on CRS) with optional decimals, excluding signs, thousands separators, or unit suffixes. Useful for GIS datasets where coordinates are provided as separate easting (X) and northing (Y) fields. Header patterns emphasize 'easting' and 'x coordinate' terminology to disambiguate from generic numbers.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:53:33.085900"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.ISIN",
    "description": "Security Identifier: twelve-character international instrument code. Recognizes International Securities Identification Numbers (ISINs) consisting of two letters, followed by nine alphanumeric characters, and a final check digit.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z]{2}[A-Za-z0-9]{9}\\d\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 8580,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bsecurity\\b.*\\bisin\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Security ISIN"
        ],
        "negativeExamples": [
          "Ticker Symbol"
        ]
      },
      {
        "regExp": "(?i).*\\binternational\\b.*\\bsecurity\\b.*\\b(id|ident).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "International Security ID"
        ],
        "negativeExamples": [
          "Company Name"
        ]
      },
      {
        "regExp": "(?i).*\\bisin\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISIN"
        ],
        "negativeExamples": [
          "CUSIP"
        ]
      },
      {
        "regExp": "(?i).*\\bsecurity\\b.*\\b(id|ident).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Security Identification Number"
        ],
        "negativeExamples": [
          "Security Code"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Instrument ISIN Code"
        ],
        "negativeExamples": [
          "Stock Price"
        ]
      }
    ],
    "positiveContentExamples": [
      "US1234567890",
      "GB00B1XHMK64",
      "DE000BAY0017",
      "FR0012345678",
      "XS123ABC4567",
      "CA0A1B2C3D45",
      "JP90ABC12345",
      "NL0000123456"
    ],
    "negativeContentExamples": [
      "US123456789A",
      "US12345678",
      "US12345678901",
      "123456789012",
      "U11234567890",
      "USA234567890",
      "GB00B1XHMK6",
      "DE000BAY001-"
    ],
    "positiveHeaderExamples": [
      "ISIN",
      "Security ISIN",
      "International Security ID",
      "Instrument ISIN Code",
      "ISIN Number",
      "Security Identification Number",
      "International Security Identifier"
    ],
    "negativeHeaderExamples": [
      "Company Name",
      "Ticker Symbol",
      "Stock Price",
      "CUSIP",
      "Security Code",
      "Bond Identifier",
      "Exchange Code"
    ],
    "explanation": "This semantic type identifies values that look like ISINs: two letters, nine alphanumeric characters, and a final check digit, totaling 12 characters. It is intended to classify columns containing international securities identifiers and supports common header name variants while remaining strict about the value format.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:53:33.905986"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.ABA",
    "description": "Bank Routing Number: nine-digit institution identifier. Values are exactly nine digits and typically include a checksum per the ABA/RTN specification.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{9}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 8530,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\brouting\\b.*\\btransit\\b.*\\bnumber\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Routing Transit Number"
        ],
        "negativeExamples": [
          "Account Number"
        ]
      },
      {
        "regExp": "(?i).*\\baba\\b.*\\bnumber\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ABA Number"
        ],
        "negativeExamples": [
          "SWIFT Code"
        ]
      },
      {
        "regExp": "(?i).*\\brouting\\b.*\\bnumber\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Routing Number"
        ],
        "negativeExamples": [
          "Bank Name"
        ]
      },
      {
        "regExp": "(?i).*\\brtn\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "RTN"
        ],
        "negativeExamples": [
          "SWIFT Code"
        ]
      },
      {
        "regExp": "(?i).*\\bnumber\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Number"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "011000015",
      "021000021",
      "121000358",
      "111000025",
      "071000013",
      "063103915",
      "322271627",
      "026009593"
    ],
    "negativeContentExamples": [
      "011000016",
      "021000022",
      "121000359",
      "111000026",
      "071000014",
      "063103916",
      "322271628",
      "02600959"
    ],
    "positiveHeaderExamples": [
      "ABA Number",
      "Routing Number",
      "RTN",
      "Routing Transit Number",
      "Bank Routing Number",
      "ABA RTN",
      "Routing No",
      "Transit Routing Number"
    ],
    "negativeHeaderExamples": [
      "Account Number",
      "Bank Name",
      "SWIFT Code",
      "IBAN",
      "Customer Number",
      "Invoice Number",
      "BIC",
      "Branch Code"
    ],
    "explanation": "This semantic type identifies ABA routing numbers (Routing Transit Numbers) used to route financial transactions between U.S. financial institutions. Values are nine digits and typically adhere to an ABA checksum. Use this to detect and validate fields that contain U.S. bank routing numbers in datasets, especially when paired with corresponding account identifiers.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:53:33.906153"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.LONGITUDE_DMS",
    "description": "Longitude expressed in degrees, minutes, and seconds with an East/West hemisphere indicator. Accepts 0\u2013180 degrees, 0\u201359 minutes, and 0\u201359 seconds with required symbols (\u00b0, ', \") and a trailing E/W indicator.\nThis type targets longitude in DMS format and excludes latitude and decimal-degree longitude representations.",
    "pluginType": "regex",
    "regexPattern": "\\b(180|1[0-7][0-9]|[0-9]{1,2})\\s*\u00b0\\s*([0-5]?[0-9])\\s*'\\s*([0-5]?[0-9])\\s*\"\\s*[EeWw]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 8740,
    "headerPatterns": [
      {
        "regExp": "(?i).*(longitude|long)\\s*(dms|degrees\\s*minutes\\s*seconds|deg\\s*min\\s*sec).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Longitude DMS"
        ],
        "negativeExamples": [
          "Decimal Longitude"
        ]
      },
      {
        "regExp": "(?i).*(longitude|long)\\s*(coord|coords|coordinates).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Longitude Coords"
        ],
        "negativeExamples": [
          "Location"
        ]
      },
      {
        "regExp": "(?i).*long(itude)?\\s*deg.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Long Degrees"
        ],
        "negativeExamples": [
          "Latitude Degrees"
        ]
      },
      {
        "regExp": "(?i).*(lon|lng|long)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lng"
        ],
        "negativeExamples": [
          "lat"
        ]
      },
      {
        "regExp": "(?i).*longitude.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "longitude"
        ],
        "negativeExamples": [
          "latitude"
        ]
      }
    ],
    "positiveContentExamples": [
      "73\u00b059'08\" W",
      "0\u00b00'0\" E",
      "180\u00b000'00\" E",
      "12\u00b0 5' 9\" E",
      "145\u00b030'00\" W",
      "07\u00b009'10\" E",
      "123\u00b045'56\" e",
      "99\u00b059'59\" W"
    ],
    "negativeContentExamples": [
      "181\u00b000'00\" E",
      "180 00 00 E",
      "73\u00b059'08\"",
      "-73\u00b059'08\"",
      "73\u00b060'00\" W",
      "73\u00b059'60\" E",
      "123.765 E",
      "45\u00b0 30' W"
    ],
    "positiveHeaderExamples": [
      "Longitude DMS",
      "Long Degrees",
      "Longitude Coords",
      "Longitude Degrees Minutes Seconds",
      "Long Deg Min Sec",
      "E/W Longitude DMS"
    ],
    "negativeHeaderExamples": [
      "Latitude",
      "Decimal Longitude",
      "Location",
      "Lat DMS",
      "GPS Coordinate",
      "Bearing"
    ],
    "explanation": "This semantic type identifies longitude coordinates written in traditional DMS notation, requiring degree (\u00b0), minute ('), second (\") symbols and a trailing hemisphere letter E or W. It rejects latitude values, decimal-degree formats, and DMS strings missing required symbols or hemisphere.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:53:33.908257"
  },
  {
    "resultType": "generated",
    "semanticType": "CURRENCY_CODE.ISO-4217",
    "description": "Three-letter ISO 4217 currency code representing a monetary unit (e.g., USD, EUR). This identifies standardized currency codes composed of exactly three uppercase Latin letters.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 8870,
    "headerPatterns": [
      {
        "regExp": "(?i).*iso[-_ ]?4217.*currency.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISO 4217 Currency Code"
        ],
        "negativeExamples": [
          "Currency Code"
        ]
      },
      {
        "regExp": "(?i).*currency.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Currency Code"
        ],
        "negativeExamples": [
          "Currency Name"
        ]
      },
      {
        "regExp": "(?i).*(ccy|curr|cur).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CCY Code"
        ],
        "negativeExamples": [
          "Currency Symbol"
        ]
      },
      {
        "regExp": "(?i).*iso.*currency.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISO Currency"
        ],
        "negativeExamples": [
          "Exchange Rate"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Country"
        ]
      }
    ],
    "positiveContentExamples": [
      "USD",
      "EUR",
      "JPY",
      "GBP",
      "AUD",
      "CAD",
      "CHF",
      "CNY"
    ],
    "negativeContentExamples": [
      "US",
      "USDT",
      "EUR1",
      "USD ",
      "U SD",
      "usd",
      "Usd",
      "EURO"
    ],
    "positiveHeaderExamples": [
      "Currency Code",
      "ISO Currency",
      "Currency Symbol",
      "ISO 4217 Currency Code",
      "CCY Code",
      "Currency ISO Code",
      "Currency Code (ISO)"
    ],
    "negativeHeaderExamples": [
      "Currency Name",
      "Exchange Rate",
      "Country",
      "Currency Amount",
      "Postal Code",
      "Country Code"
    ],
    "explanation": "This semantic type targets three-letter ISO 4217 currency codes such as USD, EUR, and JPY. It is useful for validating and standardizing currency identifiers in financial, commerce, and internationalization datasets where a strict three-letter code is expected.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:53:34.728672"
  },
  {
    "resultType": "generated",
    "semanticType": "AIRPORT_CODE.IATA",
    "description": "Airport ID: three-letter destination code",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 8520,
    "headerPatterns": [
      {
        "regExp": "(?i).*iata.*airport.*code.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "IATA Airport Code"
        ],
        "negativeExamples": [
          "Airline Code"
        ]
      },
      {
        "regExp": "(?i).*airport.*code.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Airport Code"
        ],
        "negativeExamples": [
          "Airport Name"
        ]
      },
      {
        "regExp": "(?i).*iata.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IATA Code"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*(departure|arrival|dest).*airport.*code.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Departure Airport Code"
        ],
        "negativeExamples": [
          "Airline"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Location Code"
        ],
        "negativeExamples": [
          "Airport Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "JFK",
      "LAX",
      "CDG",
      "HND",
      "SFO",
      "DXB",
      "FRA",
      "SYD"
    ],
    "negativeContentExamples": [
      "LaX",
      "JFK1",
      "SF0",
      "L-AX",
      "AB",
      "IATA",
      "123",
      "\u00d6SF"
    ],
    "positiveHeaderExamples": [
      "Airport Code",
      "IATA Code",
      "Airport",
      "Destination IATA",
      "IATA Airport Code",
      "Departure Airport Code",
      "Arrival Airport Code",
      "Dest Airport"
    ],
    "negativeHeaderExamples": [
      "Airport Name",
      "City",
      "Airline Code",
      "Airport City",
      "IATA Number",
      "Country Code",
      "Departure Gate",
      "Airline"
    ],
    "explanation": "Three-letter IATA airport codes used to identify specific airports in travel and logistics datasets. Useful for routing, ticketing, and mapping airport-related fields where values are exactly three uppercase letters.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:53:35.851034"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.SEDOL",
    "description": "UK Security Code: seven-character London exchange identifier. The last character is a numeric check digit.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9A-Z]{6}[0-9]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 8600,
    "headerPatterns": [
      {
        "regExp": "(?i).*sedol.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SEDOL Code"
        ],
        "negativeExamples": [
          "UK Security ID"
        ]
      },
      {
        "regExp": "(?i).*sedol.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SEDOL"
        ],
        "negativeExamples": [
          "Stock Price"
        ]
      },
      {
        "regExp": "(?i).*(uk|london).*security.*(id|code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "UK Security ID"
        ],
        "negativeExamples": [
          "Security ID"
        ]
      },
      {
        "regExp": "(?i).*exchange.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "London Exchange ID"
        ],
        "negativeExamples": [
          "Company Name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "UK Security Code"
        ],
        "negativeExamples": [
          "Exchange"
        ]
      }
    ],
    "positiveContentExamples": [
      "B0YBKJ7",
      "0263494",
      "2000019",
      "A1BC2D3",
      "ZZZZZZ0",
      "H1K3LM5",
      "9ABCDE6",
      "M0N9PQ8"
    ],
    "negativeContentExamples": [
      "B0YBKJ",
      "B0YBKJ78",
      "b0ybkj7",
      "B0YB-KJ7",
      "B0Y BKJ7",
      "B0YBKJX",
      "026349A",
      "ABCD12E"
    ],
    "positiveHeaderExamples": [
      "SEDOL",
      "SEDOL Code",
      "UK Security ID",
      "London Exchange ID",
      "UK Security Code",
      "Security ID",
      "SEDOL Identifier"
    ],
    "negativeHeaderExamples": [
      "Company Name",
      "Stock Price",
      "Exchange",
      "ISIN",
      "Ticker Symbol",
      "CUSIP",
      "Country Code"
    ],
    "explanation": "SEDOL is a seven-character security identifier used in the UK market, where the final character is a numeric check digit. This definition captures the canonical shape (six uppercase alphanumeric characters followed by a digit) and uses header cues related to SEDOL, UK security identifiers, and exchange-specific labels. While the regex enforces format and final-digit constraints, full validation should apply the SEDOL check-digit algorithm.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:53:35.878813"
  },
  {
    "resultType": "generated",
    "semanticType": "DAY.ABBR_<LOCALE>",
    "description": "weekday_short: 3-letter locale-specific day abbreviation",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "MON",
      "TUE",
      "WED",
      "THU",
      "FRI",
      "SAT",
      "SUN"
    ],
    "backout": "^[A-Z]{3}$",
    "confidenceThreshold": 97,
    "priority": 8880,
    "headerPatterns": [
      {
        "regExp": "(?i).*weekday.*abbr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Weekday Abbr"
        ],
        "negativeExamples": [
          "Weekday Name"
        ]
      },
      {
        "regExp": "(?i).*day.*abbr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Day Abbr"
        ],
        "negativeExamples": [
          "Day Name"
        ]
      },
      {
        "regExp": "(?i).*dow.*abbr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "DOW Abbr"
        ],
        "negativeExamples": [
          "DOW Name"
        ]
      },
      {
        "regExp": "(?i).*day.*of.*week.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Day of Week"
        ],
        "negativeExamples": [
          "Month"
        ]
      },
      {
        "regExp": "(?i).*day.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Day"
        ],
        "negativeExamples": [
          "Date"
        ]
      }
    ],
    "positiveContentExamples": [
      "MON",
      "TUE",
      "WED",
      "THU",
      "FRI",
      "SAT",
      "SUN"
    ],
    "negativeContentExamples": [
      "MONDAY",
      "FRI.",
      "M-T-W",
      "THUR",
      "SUNN",
      "WED1",
      "TU",
      "SATURDAY"
    ],
    "positiveHeaderExamples": [
      "Day Abbr",
      "Day of Week",
      "Weekday Abbr",
      "DOW Abbr",
      "Weekday Short",
      "Day of Week Abbreviation",
      "Weekday Code",
      "Day Short"
    ],
    "negativeHeaderExamples": [
      "Day Name",
      "Month",
      "Date",
      "Week Number",
      "Month Abbr",
      "Day Count",
      "Calendar Day",
      "ISO Week"
    ],
    "explanation": "Represents 3-letter, locale-specific weekday abbreviations (e.g., MON, TUE) suitable for fields storing compact day-of-week labels. Use when the dataset encodes days as fixed-width short forms rather than full names or numbers. The list is intentionally finite to ensure high precision, with a backout pattern covering the general 3-letter uppercase shape.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:53:37.404206"
  },
  {
    "resultType": "generated",
    "semanticType": "DAY.FULL_<LOCALE>",
    "description": "Full weekday name in English (e.g., Monday, Tuesday). Includes only complete day-of-week names and excludes abbreviations, plurals, or concatenated/modified forms.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "MONDAY",
      "TUESDAY",
      "WEDNESDAY",
      "THURSDAY",
      "FRIDAY",
      "SATURDAY",
      "SUNDAY"
    ],
    "backout": "^[A-Za-z]{2,8}[Dd][Aa][Yy]$",
    "confidenceThreshold": 98,
    "priority": 8900,
    "headerPatterns": [
      {
        "regExp": "(?i).*day.*of.*week.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Day of Week Name"
        ],
        "negativeExamples": [
          "Day Number"
        ]
      },
      {
        "regExp": "(?i).*weekday.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Weekday Name"
        ],
        "negativeExamples": [
          "Weekend Name"
        ]
      },
      {
        "regExp": "(?i).*full.*day.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Full Day Name"
        ],
        "negativeExamples": [
          "Month Name"
        ]
      },
      {
        "regExp": "(?i).*day.*of.*week.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Day of Week"
        ],
        "negativeExamples": [
          "Week of Year"
        ]
      },
      {
        "regExp": "(?i).*weekday.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Weekday"
        ],
        "negativeExamples": [
          "Day Number"
        ]
      }
    ],
    "positiveContentExamples": [
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday",
      "Sunday"
    ],
    "negativeContentExamples": [
      "Mon",
      "Tues",
      "Wed",
      "Thu",
      "Fri",
      "Sat",
      "Sun",
      "Someday"
    ],
    "positiveHeaderExamples": [
      "Day Name",
      "Day of Week",
      "Weekday",
      "Day of Week Name",
      "Weekday Name",
      "Full Day Name"
    ],
    "negativeHeaderExamples": [
      "Day Number",
      "Month",
      "Year",
      "Month Name",
      "Week Number",
      "Date",
      "Day Code",
      "Day Index"
    ],
    "explanation": "This semantic type identifies full English weekday names only. It is useful for columns storing the spelled-out day of week in English, ensuring consistent recognition of complete names while excluding abbreviations, plurals, and related but non-day terms.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:53:39.334352"
  },
  {
    "resultType": "generated",
    "semanticType": "EPOCH.SECONDS",
    "description": "epoch_seconds: standard Unix timestamp in seconds",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{9,10}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 8940,
    "headerPatterns": [
      {
        "regExp": "(?i).*(unix|epoch).*timestamp.*sec.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "unix_timestamp_seconds"
        ],
        "negativeExamples": [
          "unix_timestamp_ms"
        ]
      },
      {
        "regExp": "(?i).*epoch.*time.*sec.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "epoch_time_seconds"
        ],
        "negativeExamples": [
          "epoch_time_ms"
        ]
      },
      {
        "regExp": "(?i).*unix.*timestamp.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Unix Timestamp"
        ],
        "negativeExamples": [
          "Formatted Date"
        ]
      },
      {
        "regExp": "(?i).*epoch.*time.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Epoch Time"
        ],
        "negativeExamples": [
          "Time"
        ]
      },
      {
        "regExp": "(?i).*timestamp.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Timestamp"
        ],
        "negativeExamples": [
          "Date"
        ]
      }
    ],
    "positiveContentExamples": [
      "315532800",
      "631152000",
      "946684800",
      "1000000000",
      "1234567890",
      "1609459200",
      "1700000000",
      "2147483647"
    ],
    "negativeContentExamples": [
      "1609459200000",
      "170000000",
      "17000000000",
      "-1609459200",
      "1609459200.0",
      "01609459200",
      "1,609,459,200",
      "170000000O"
    ],
    "positiveHeaderExamples": [
      "Timestamp",
      "Unix Timestamp",
      "Epoch Time",
      "unix_epoch_seconds",
      "timestamp_sec",
      "event_timestamp_seconds",
      "epoch_time_sec",
      "ts_epoch_seconds"
    ],
    "negativeHeaderExamples": [
      "Date",
      "Time",
      "Formatted Date",
      "Timestamp_ms",
      "Epoch Milliseconds",
      "Created At",
      "Time Zone",
      "Unix Timezone"
    ],
    "explanation": "Identifies Unix epoch timestamps expressed in whole seconds as 9\u201310 digit numeric values. Useful for detecting and parsing numeric timestamp columns that represent seconds since 1970-01-01 UTC, distinct from millisecond-based timestamps.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:53:43.018409"
  },
  {
    "resultType": "generated",
    "semanticType": "COLOR.TEXT_NL",
    "description": "Kleurnaam: beschrijvende tintterminologie",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b((licht|donker|helder|pastel)\\s*-?\\s*)?(zwart|wit|grijs|rood|groen|blauw|geel|oranje|paars|violet|bruin|beige|ivoor|cyaan|magenta|turkoois|turquoise|olijf|olijfgroen|bordeaux|bordeauxrood|kastanje|kastanjebruin|koraal|indigo|lila|mint|zeegroen|hemelsblauw|nachtblauw|kobaltblauw|oudroze|zalm|saffraan|oker|mosgroen)(\\s*-?\\s*(rood|groen|blauw|geel|oranje|paars|bruin|grijs|wit))?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 8660,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bkleurnaam\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Kleurnaam"
        ],
        "negativeExamples": [
          "Kleurcode"
        ]
      },
      {
        "regExp": "(?i).*primaire.*\\bkleur\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Primaire Kleur"
        ],
        "negativeExamples": [
          "Hex Waarde"
        ]
      },
      {
        "regExp": "(?i).*\\bhoofdkleur\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Hoofdkleur"
        ],
        "negativeExamples": [
          "RGB"
        ]
      },
      {
        "regExp": "(?i).*\\bbasiskleur\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Basiskleur"
        ],
        "negativeExamples": [
          "Kleurcode"
        ]
      },
      {
        "regExp": "(?i).*\\bkleur\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Kleur"
        ],
        "negativeExamples": [
          "Kleurcode"
        ]
      }
    ],
    "positiveContentExamples": [
      "rood",
      "lichtblauw",
      "donker groen",
      "zeegroen",
      "kobaltblauw",
      "bordeauxrood",
      "mosgroen",
      "oudroze"
    ],
    "negativeContentExamples": [
      "kleurcode",
      "#00FF00",
      "RGB",
      "RAL5015",
      "blauwachtig",
      "groen-2",
      "lichtblauw hex",
      "CMYK 0,100,100,0"
    ],
    "positiveHeaderExamples": [
      "Kleur",
      "Kleurnaam",
      "Primaire Kleur",
      "Hoofdkleur",
      "Basiskleur",
      "Dominante Kleur",
      "Kleur Omschrijving",
      "Kleur (NL)"
    ],
    "negativeHeaderExamples": [
      "Kleurcode",
      "Hex Waarde",
      "RGB",
      "Hexadecimaal",
      "Kleurwaarde",
      "RAL",
      "Pantone",
      "RGBA"
    ],
    "explanation": "This semantic type recognizes Dutch color names expressed as descriptive text (e.g., lichtblauw, bordeauxrood), including common intensity prefixes (licht, donker) and compound hues with optional hyphens or spaces. It is intended to classify columns containing human-readable color names rather than encoded color values.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:53:43.631999"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.UPC",
    "description": "Product Code: twelve-digit North American barcode",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{12}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 8610,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bupc.*code\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "UPC Code"
        ],
        "negativeExamples": [
          "Product Name"
        ]
      },
      {
        "regExp": "(?i).*\\bproduct.*barcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Product Barcode"
        ],
        "negativeExamples": [
          "Brand"
        ]
      },
      {
        "regExp": "(?i).*\\bupc\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "UPC"
        ],
        "negativeExamples": [
          "SKU"
        ]
      },
      {
        "regExp": "(?i).*\\bbar.?code\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Barcode"
        ],
        "negativeExamples": [
          "EAN"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Price"
        ]
      }
    ],
    "positiveContentExamples": [
      "012345678905",
      "036000291452",
      "041333422145",
      "123456789012",
      "098765432109",
      "065100004327",
      "000123456789",
      "850000123456"
    ],
    "negativeContentExamples": [
      "12345678901",
      "1234567890123",
      "123456 789012",
      "1234-56789012",
      "A23456789012",
      "12345678901X",
      "1234567890",
      "9999999999999"
    ],
    "positiveHeaderExamples": [
      "UPC",
      "Barcode",
      "UPC Code",
      "Product Barcode",
      "Product UPC",
      "UPC Number",
      "UPC-12",
      "Item UPC"
    ],
    "negativeHeaderExamples": [
      "Product Name",
      "Price",
      "Brand",
      "SKU",
      "EAN",
      "GTIN",
      "Serial Number",
      "Order Code"
    ],
    "explanation": "This semantic type identifies 12-digit UPC (UPC-A) product codes commonly used in North America. It expects exactly twelve numeric digits with no separators or letters. Use this type to detect columns storing UPC values for product identification and retail barcode data.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:53:44.862398"
  },
  {
    "resultType": "generated",
    "semanticType": "CONTINENT.TEXT_EN",
    "description": "Continental Region: major landmass designation. Identifies columns containing the English textual name of a continent (e.g., Africa, Europe, North America), including common alternatives such as Oceania/Australia.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AFRICA",
      "ANTARCTICA",
      "ASIA",
      "EUROPE",
      "NORTH AMERICA",
      "SOUTH AMERICA",
      "OCEANIA",
      "AUSTRALIA"
    ],
    "backout": "^[A-Z]+( [A-Z]+)?$",
    "confidenceThreshold": 98,
    "priority": 8690,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bcontinent\\b.*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Continent Name"
        ],
        "negativeExamples": [
          "Continent Code"
        ]
      },
      {
        "regExp": "(?i).*\\bcontinental\\b.*\\bregion\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Continental Region"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*\\bcontinent\\b.*\\b(label|text|desc|english)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Continent Text"
        ],
        "negativeExamples": [
          "Continent Code"
        ]
      },
      {
        "regExp": "(?i).*\\bcont(inent)?\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Continent"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Africa",
      "Asia",
      "Europe",
      "North America",
      "South America",
      "Oceania",
      "Australia",
      "Antarctica"
    ],
    "negativeContentExamples": [
      "Afrika",
      "Northamerica",
      "South-America",
      "Central America",
      "Eurasia",
      "EU",
      "Oceana",
      "Americas"
    ],
    "positiveHeaderExamples": [
      "Continent",
      "Continent Name",
      "Continental Region",
      "Continent Text",
      "Continent Label",
      "continent_name_en",
      "Continent English"
    ],
    "negativeHeaderExamples": [
      "Country",
      "City",
      "Continent Code",
      "Country Name",
      "Region",
      "ISO Continent Code",
      "City Name"
    ],
    "explanation": "This semantic type identifies columns that store the English textual name of a continent. It uses a finite whitelist of standard continent names and accommodates common alternatives like Australia/Oceania and North/South America. Suitable for datasets where geographic aggregation or filtering is performed by continent names rather than codes.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:53:45.465655"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.NORTHING",
    "description": "Y Coordinate: northward distance measurement",
    "pluginType": "regex",
    "regexPattern": "\\b([0-9]{1,3}(,[0-9]{3})+(\\.[0-9]+)?|[0-9]+(\\.[0-9]+)?)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 8750,
    "headerPatterns": [
      {
        "regExp": "(?i).*northing.*(coordinate|coord).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "UTM Northing Coordinate"
        ],
        "negativeExamples": [
          "Y Coordinate"
        ]
      },
      {
        "regExp": "(?i).*northing.*(value|val).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Northing Value"
        ],
        "negativeExamples": [
          "Longitude Value"
        ]
      },
      {
        "regExp": "(?i).*northing.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Northing"
        ],
        "negativeExamples": [
          "Easting"
        ]
      },
      {
        "regExp": "(?i).*y[ _-]?(coordinate|coord).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Y Coordinate"
        ],
        "negativeExamples": [
          "X Coordinate"
        ]
      },
      {
        "regExp": "(?i).*y[ _-]?pos.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Y Position"
        ],
        "negativeExamples": [
          "Y Axis"
        ]
      },
      {
        "regExp": "(?i).*coordinate.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Coordinate"
        ],
        "negativeExamples": [
          "Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "4645123",
      "7,654,321",
      "123456.78",
      "9876543.2",
      "2500",
      "10,000,000",
      "4321987",
      "5555555.55"
    ],
    "negativeContentExamples": [
      "-12345",
      "1,23,456",
      "12.34.56",
      "1 234 567",
      "abc123",
      "1234m",
      "1,234.",
      "3."
    ],
    "positiveHeaderExamples": [
      "Northing",
      "Y Coordinate",
      "Northing Value",
      "UTM Northing",
      "Y (Northing)",
      "Y Position",
      "Y_Coord",
      "Map Y Coordinate"
    ],
    "negativeHeaderExamples": [
      "Latitude",
      "Longitude",
      "Address",
      "Easting",
      "X Coordinate",
      "Postal Code",
      "Geo Hash",
      "Street Name"
    ],
    "explanation": "This semantic type represents the northward component (Y axis) of a planar or projected coordinate system, commonly recorded as a non-negative numeric distance that may include decimals or thousands separators. It is typically paired with an easting (X) value to form a complete position in systems like grid-based or projected maps. Use when the data field specifically contains the Y-direction distance rather than geographic latitude.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:53:46.677299"
  },
  {
    "resultType": "generated",
    "semanticType": "FILENAME",
    "description": "file_identifier: name with extension for file system reference",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z0-9][A-Za-z0-9 _.-]{0,100}\\.[A-Za-z0-9]{1,8}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 8950,
    "headerPatterns": [
      {
        "regExp": "(?i).*original.*file.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Original File Name"
        ],
        "negativeExamples": [
          "Original File Path"
        ]
      },
      {
        "regExp": "(?i).*(stored|source|attachment).*file.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Attachment File Name"
        ],
        "negativeExamples": [
          "Attachment Path"
        ]
      },
      {
        "regExp": "(?i).*(filename|file[ _-]name|fname).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "File Name"
        ],
        "negativeExamples": [
          "File Path"
        ]
      },
      {
        "regExp": "(?i).*document.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Document Name"
        ],
        "negativeExamples": [
          "Document Title"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Title"
        ]
      }
    ],
    "positiveContentExamples": [
      "report_Q3_2023.pdf",
      "photo-IMG_1234.jpg",
      "data_export.csv",
      "backup.tar.gz",
      "project plan v1.docx",
      "README.md",
      "archive_2021-12-31.zip",
      "notes.txt"
    ],
    "negativeContentExamples": [
      "/var/log/system.log",
      "C:\\Temp\\error.log",
      "report_Q3_2023",
      ".env",
      "sales|2023.csv",
      "project:plan.docx",
      "summary.",
      "file_name_with_extension_too_long.verylongext"
    ],
    "positiveHeaderExamples": [
      "Filename",
      "File Name",
      "Document Name",
      "Original File Name",
      "Source Filename",
      "Attachment File Name",
      "Stored File Name",
      "Output Filename"
    ],
    "negativeHeaderExamples": [
      "File Path",
      "Folder",
      "Extension",
      "File",
      "Base Name",
      "Document Title",
      "Directory",
      "File Extension"
    ],
    "explanation": "This semantic type identifies standalone file names that include an extension (the part after the final dot). It excludes full paths, directory indicators, and bare extensions. Typical use cases include classifying columns that store stored or original filenames for documents, images, or other assets.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:53:47.831325"
  },
  {
    "resultType": "generated",
    "semanticType": "COLOR.TEXT_ES",
    "description": "Nombre de Color: terminolog\u00eda descriptiva de tonos en espa\u00f1ol, representada con palabras y frases como \"azul marino\" o \"rojo oscuro\". Se enfoca en descripciones textuales sin c\u00f3digos ni valores num\u00e9ricos.",
    "pluginType": "regex",
    "regexPattern": "\\b((rojo|azul|verde|amarillo|marr[\u00f3o]n|caf\u00e9|negro|blanco|gris|morado|violeta|naranja|rosa|celeste|turquesa|beige|lila|fucsia|magenta|cian|oliva|granate|dorado|plateado|plata|oro|marfil|mostaza|salm[\u00f3o]n|lavanda|coral)([ -][A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1\u00e1\u00e9\u00ed\u00f3\u00fa\u00fc\u00f1]{2,}){0,3}|(claro|oscuro|p[\u00e1a]lido|intenso|pastel|marino|ne[\u00f3o]n|mate|brillante)[ -](rojo|azul|verde|amarillo|marr[\u00f3o]n|caf\u00e9|negro|blanco|gris|morado|violeta|naranja|rosa|celeste|turquesa|beige|lila|fucsia|magenta|cian|oliva|granate|dorado|plateado|plata|oro|marfil|mostaza|salm[\u00f3o]n|lavanda|coral))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 8650,
    "headerPatterns": [
      {
        "regExp": "(?i).*nombre.*del.*color.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Nombre del Color"
        ],
        "negativeExamples": [
          "C\u00f3digo de Color"
        ]
      },
      {
        "regExp": "(?i).*color.*primari[oa].*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Color Primario"
        ],
        "negativeExamples": [
          "Valor Hexadecimal"
        ]
      },
      {
        "regExp": "(?i).*(texto|descripcion|descripci\u00f3n).*del.*color.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Texto del Color"
        ],
        "negativeExamples": [
          "RGB"
        ]
      },
      {
        "regExp": "(?i).*(etiqueta|nombre).*color.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Etiqueta de Color"
        ],
        "negativeExamples": [
          "C\u00f3digo de Color"
        ]
      },
      {
        "regExp": "(?i).*color.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Color"
        ],
        "negativeExamples": [
          "RGB"
        ]
      }
    ],
    "positiveContentExamples": [
      "azul marino",
      "rojo oscuro",
      "verde oliva",
      "gris claro",
      "marr\u00f3n chocolate",
      "amarillo pastel",
      "rosa p\u00e1lido",
      "violeta intenso"
    ],
    "negativeContentExamples": [
      "#FF5733",
      "RGB(34, 45, 200)",
      "azul_oscuro",
      "color: rojo",
      "gris claro 50%",
      "HSL(120,100%,50%)",
      "0xFFA500",
      "c\u00f3digo HEX FFAA00"
    ],
    "positiveHeaderExamples": [
      "Color",
      "Nombre del Color",
      "Color Primario",
      "Texto del Color",
      "Descripci\u00f3n del Color",
      "Etiqueta de Color"
    ],
    "negativeHeaderExamples": [
      "C\u00f3digo de Color",
      "Valor Hexadecimal",
      "RGB",
      "C\u00f3digo HEX",
      "Color RGB",
      "Valor RGB"
    ],
    "explanation": "Este tipo identifica nombres de colores escritos en espa\u00f1ol con t\u00e9rminos descriptivos, como combinaciones de adjetivos y sustantivos (por ejemplo, \"azul marino\", \"rojo oscuro\"). Est\u00e1 dise\u00f1ado para distinguir descripciones textuales de tonos frente a representaciones de c\u00f3digos o valores num\u00e9ricos de color como HEX, RGB o HSL.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:53:50.290233"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.ISO-3166-2",
    "description": "Nation Code: two-letter international identifier. Uppercase A\u2013Z, exactly two letters, representing a country code used in international contexts. This targets two-letter country codes (alpha-2 style) and excludes digits, punctuation, and subdivision formats.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 8780,
    "headerPatterns": [
      {
        "regExp": "(?i).*iso.*3166.*alpha.*2.*country.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISO3166 Alpha-2 Country Code"
        ],
        "negativeExamples": [
          "ISO3166 Alpha-3 Country Code"
        ]
      },
      {
        "regExp": "(?i).*iso.*country.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISO Country Code"
        ],
        "negativeExamples": [
          "ISO Country Name"
        ]
      },
      {
        "regExp": "(?i).*(country|cntry).*(alpha[-_ ]?2|a2).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Country Alpha-2"
        ],
        "negativeExamples": [
          "Country Alpha-3"
        ]
      },
      {
        "regExp": "(?i).*(country|cntry).*(code|cd).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Country Code"
        ],
        "negativeExamples": [
          "Country Name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Country"
        ]
      }
    ],
    "positiveContentExamples": [
      "US",
      "GB",
      "FR",
      "DE",
      "CN",
      "IN",
      "BR",
      "ZA"
    ],
    "negativeContentExamples": [
      "USA",
      "U1",
      "U",
      "US-CA",
      "U.S",
      "en",
      "Uk",
      "FR1"
    ],
    "positiveHeaderExamples": [
      "Country Code",
      "ISO Country",
      "Country",
      "ISO Country Code",
      "ISO3166 Alpha-2",
      "Country ISO Code",
      "ISO2 Country",
      "Country Alpha-2 Code"
    ],
    "negativeHeaderExamples": [
      "Country Name",
      "State",
      "Language",
      "ISO Country Name",
      "Region Code",
      "Postal Code",
      "Nationality",
      "Province"
    ],
    "explanation": "This semantic type detects two-letter uppercase country identifiers suitable for international datasets where fields contain country codes, and headers reference ISO or alpha-2 country code terminology. Use it to validate or profile columns storing standardized country codes. This excludes subdivision codes like US-CA and any values containing digits, punctuation, or lowercase letters.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:53:51.560636"
  },
  {
    "resultType": "generated",
    "semanticType": "CITY",
    "description": "Location Name: municipal area designation",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z][a-z]{1,19}([ \\-][A-Z][a-z]{1,19}){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 8620,
    "headerPatterns": [
      {
        "regExp": "(?i).*city.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "city_name"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      },
      {
        "regExp": "(?i).*(town|municipality).*name.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "municipality name"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(city|town|municipality).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "City"
        ],
        "negativeExamples": [
          "State"
        ]
      },
      {
        "regExp": "(?i).*(cty|muni).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "cty"
        ],
        "negativeExamples": [
          "zip"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 91,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "New York",
      "Los Angeles",
      "Paris",
      "San Francisco",
      "St Louis",
      "Ho Chi Minh City",
      "Winston-Salem",
      "Chicago"
    ],
    "negativeContentExamples": [
      "new york",
      "NEW YORK",
      "Los Angeles, CA",
      "Paris 75001",
      "Area 51",
      "NY",
      "McAllen",
      "San_Jose"
    ],
    "positiveHeaderExamples": [
      "City",
      "Town",
      "Location",
      "City Name",
      "Municipality Name",
      "cty"
    ],
    "negativeHeaderExamples": [
      "Country",
      "State",
      "ZIP Code",
      "County",
      "Province",
      "Geo Code"
    ],
    "explanation": "This semantic type identifies city names in datasets. It targets proper names of municipal areas composed of 1\u20134 capitalized word tokens separated by spaces or hyphens, without numeric or code components. Use it to recognize fields containing town or municipality names rather than broader administrative regions or postal codes.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:53:54.180230"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.ISO-3166-3",
    "description": "Nation Code: three-letter international identifier for countries using an alpha-3 format commonly associated with ISO 3166 standards.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 8790,
    "headerPatterns": [
      {
        "regExp": "(?i).*(country|nation).*(iso[-_ ]?3166[-_ ]?1[-_ ]?alpha[-_ ]?3|iso[-_ ]?3|three[-_ ]?letter).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISO3 Country"
        ],
        "negativeExamples": [
          "Country Name"
        ]
      },
      {
        "regExp": "(?i).*(iso[-_ ]?3).*(code|country).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Country ISO3 Code"
        ],
        "negativeExamples": [
          "Two Letter Code"
        ]
      },
      {
        "regExp": "(?i).*(country).*(code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Country Code"
        ],
        "negativeExamples": [
          "Continent"
        ]
      },
      {
        "regExp": "(?i).*(ctry|cntry).*(code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CTRY Code"
        ],
        "negativeExamples": [
          "Country Name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "USA",
      "CAN",
      "MEX",
      "FRA",
      "DEU",
      "JPN",
      "AUS",
      "BRA"
    ],
    "negativeContentExamples": [
      "US",
      "USAA",
      "U-SA",
      "123",
      "U2A",
      "usa",
      "UsA",
      "FR4"
    ],
    "positiveHeaderExamples": [
      "Country Code",
      "ISO3 Country",
      "Three Letter Country",
      "Country ISO3 Code",
      "ISO3166 Alpha3",
      "CTRY Code",
      "ISO3 Code",
      "Country Alpha3"
    ],
    "negativeHeaderExamples": [
      "Country Name",
      "Two Letter Code",
      "Continent",
      "Region",
      "Language Code",
      "Country Abbrev",
      "Two Letter Country",
      "Country Numeric Code"
    ],
    "explanation": "This semantic type captures three-letter country identifiers in uppercase alpha characters, suitable for ISO-style alpha-3 country codes. It is intended for fields where values are standardized country abbreviations rather than full country names or numeric codes. Use for validating, profiling, and detecting columns that store three-letter country codes in datasets, especially when paired with supportive headers such as 'Country Code' or 'ISO3 Country'.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:53:54.922461"
  },
  {
    "resultType": "generated",
    "semanticType": "COLOR.TEXT_EN",
    "description": "Color Name: descriptive hue terminology. English textual color names including common modifiers (e.g., light, dark) and two-term combinations (e.g., royal blue, blue-green). Designed to capture human-readable color labels rather than coded representations.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b((very|light|dark|pale|bright|deep|neon|soft|vivid|muted|warm|cool|off|royal|sky|forest|steel|midnight|baby|seafoam|slate|dusty|pastel)\\s+)?(black|white|gray|grey|red|blue|green|yellow|orange|purple|violet|indigo|brown|pink|beige|cyan|magenta|maroon|navy|teal|olive|gold|silver|bronze|lavender|lilac|charcoal|cream|ivory|khaki|tan|peach|mint|mustard|burgundy|turquoise|aquamarine|coral|fuchsia|rose)([-\\s]+(black|white|gray|grey|red|blue|green|yellow|orange|purple|violet|indigo|brown|pink|beige|cyan|magenta|maroon|navy|teal|olive|gold|silver|bronze|lavender|lilac|charcoal|cream|ivory|khaki|tan|peach|mint|mustard|burgundy|turquoise|aquamarine|coral|fuchsia|rose))?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 8640,
    "headerPatterns": [
      {
        "regExp": "(?i).*primary.*color.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Primary Color Name"
        ],
        "negativeExamples": [
          "Primary Color Code"
        ]
      },
      {
        "regExp": "(?i).*color.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Color Name"
        ],
        "negativeExamples": [
          "Color Code"
        ]
      },
      {
        "regExp": "(?i).*primary.*color.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Primary Color"
        ],
        "negativeExamples": [
          "Primary Color Code"
        ]
      },
      {
        "regExp": "(?i).*colour.*name.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Colour Name"
        ],
        "negativeExamples": [
          "Colour Code"
        ]
      },
      {
        "regExp": "(?i).*clr.*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "clr_name"
        ],
        "negativeExamples": [
          "clr_code"
        ]
      },
      {
        "regExp": "(?i).*color.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Color"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "red",
      "navy",
      "light gray",
      "sky blue",
      "forest green",
      "rose gold",
      "blue-green",
      "off white"
    ],
    "negativeContentExamples": [
      "#FF0000",
      "FF0000",
      "rgb(0, 128, 0)",
      "lightblue",
      "lt blue",
      "blue/green",
      "bluish green",
      "navy_blue"
    ],
    "positiveHeaderExamples": [
      "Color",
      "Color Name",
      "Primary Color",
      "Base Color",
      "Colour Name",
      "clr_name",
      "Item Color",
      "Product Color"
    ],
    "negativeHeaderExamples": [
      "Color Code",
      "Hex Value",
      "RGB",
      "Colour Code",
      "clr_code",
      "Color Number",
      "Hex Color",
      "CMYK"
    ],
    "explanation": "This semantic type identifies English text color names, including single-word bases (e.g., red, navy), modifier + base combinations (e.g., light gray, royal blue), and dual-base hyphenated or spaced forms (e.g., blue-green, navy blue). It intentionally excludes coded formats such as hex values, RGB/CMYK/PMS specifications, underscores, slashes, and compressed concatenations like lightblue. Use when the dataset stores human-readable color labels rather than programmatic color codes.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:53:55.368995"
  },
  {
    "resultType": "generated",
    "semanticType": "AIRLINE.IATA_CODE",
    "description": "IATA airline carrier code consisting of exactly two uppercase letters A\u2013Z with no digits, spaces, or separators. This identifies an airline/carrier using a strict two-letter format.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 8500,
    "headerPatterns": [
      {
        "regExp": "(?i).*airline.*iata.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Airline IATA Code"
        ],
        "negativeExamples": [
          "Airline Name"
        ]
      },
      {
        "regExp": "(?i).*iata.*airline.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IATA Airline Code"
        ],
        "negativeExamples": [
          "IATA Airport Code"
        ]
      },
      {
        "regExp": "(?i).*carrier.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Carrier Code"
        ],
        "negativeExamples": [
          "Carrier Name"
        ]
      },
      {
        "regExp": "(?i).*airline.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Airline Code"
        ],
        "negativeExamples": [
          "Flight Code"
        ]
      },
      {
        "regExp": "(?i).*carrier.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Carrier"
        ],
        "negativeExamples": [
          "Airline"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IATA Code"
        ],
        "negativeExamples": [
          "Flight Number"
        ]
      }
    ],
    "positiveContentExamples": [
      "AB",
      "CD",
      "EF",
      "GH",
      "JK",
      "LM",
      "NP",
      "QR"
    ],
    "negativeContentExamples": [
      "A3",
      "3A",
      "Aa",
      "aa",
      "AAA",
      "A",
      "A B",
      "A-B"
    ],
    "positiveHeaderExamples": [
      "Airline Code",
      "IATA Code",
      "Carrier",
      "Airline IATA Code",
      "Carrier Code",
      "IATA Airline Code",
      "Airline Carrier Code",
      "Airline Carrier"
    ],
    "negativeHeaderExamples": [
      "Airline Name",
      "Flight Number",
      "Airport Code",
      "Carrier Name",
      "IATA Airport Code",
      "Airline",
      "Booking Code",
      "Flight Code"
    ],
    "explanation": "This semantic type captures two-letter IATA airline carrier codes, enforcing exactly two uppercase alphabetic characters to minimize false positives. It is useful for columns storing standardized airline identifiers where values are strictly two letters without digits or separators.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:53:56.333040"
  },
  {
    "resultType": "generated",
    "semanticType": "CREDIT_CARD_TYPE",
    "description": "card_brand: payment network identification. Represents the brand or network name printed on a payment card (e.g., VISA, MASTERCARD, AMERICAN EXPRESS).",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "VISA",
      "MASTERCARD",
      "AMERICAN EXPRESS",
      "DISCOVER",
      "DINERS CLUB",
      "JCB",
      "UNIONPAY",
      "MAESTRO",
      "MIR",
      "ELO",
      "HIPERCARD",
      "RUPAY",
      "TROY",
      "INTERAC",
      "CARTES BANCAIRES",
      "BANCONTACT"
    ],
    "backout": "^[A-Z][A-Z &-]{2,29}$",
    "confidenceThreshold": 95,
    "priority": 8840,
    "headerPatterns": [
      {
        "regExp": "(?i).*credit.*card.*type.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Credit Card Type"
        ],
        "negativeExamples": [
          "Card Number"
        ]
      },
      {
        "regExp": "(?i).*card.*brand.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Card Brand"
        ],
        "negativeExamples": [
          "Cardholder Name"
        ]
      },
      {
        "regExp": "(?i).*card.*network.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Card Network"
        ],
        "negativeExamples": [
          "Card Number"
        ]
      },
      {
        "regExp": "(?i).*card.*type.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Card Type"
        ],
        "negativeExamples": [
          "Expiration Date"
        ]
      },
      {
        "regExp": "(?i).*cc.*type.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CC Type"
        ],
        "negativeExamples": [
          "Payment Method"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Card Brand Name"
        ],
        "negativeExamples": [
          "Card Number"
        ]
      }
    ],
    "positiveContentExamples": [
      "VISA",
      "MASTERCARD",
      "AMERICAN EXPRESS",
      "DISCOVER",
      "DINERS CLUB",
      "JCB",
      "UNIONPAY",
      "MAESTRO"
    ],
    "negativeContentExamples": [
      "AMEX",
      "MASTER CARD",
      "DISCOVER CARD",
      "UNION PAY",
      "AMERICANEXPRESS",
      "VISA DEBIT",
      "DINERS",
      "J C B"
    ],
    "positiveHeaderExamples": [
      "Card Type",
      "Credit Card Type",
      "Card Brand",
      "CC Type",
      "Card Network",
      "Card Brand Name",
      "Payment Network"
    ],
    "negativeHeaderExamples": [
      "Card Number",
      "Cardholder Name",
      "Expiration Date",
      "Billing Zip",
      "Security Code",
      "Issuer Name",
      "Payment Method",
      "Transaction Type"
    ],
    "explanation": "This semantic type identifies the credit card payment network or brand (e.g., VISA, MASTERCARD, AMERICAN EXPRESS) typically stored as a categorical value in transaction or payment datasets. Use it to normalize or group transactions by card network, validate brand fields, or map to network-specific processing rules.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:53:58.276577"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.LUHN",
    "description": "Digit sequences that conform to the Luhn (mod 10) checksum, typically used for payment card PANs and IMEIs. Matches plain 13\u201319 digit numbers or common grouped formats with spaces or hyphens, and validates with the Luhn algorithm.",
    "pluginType": "regex",
    "regexPattern": "\\b(\\d{13,19}|\\d{4}([ -]\\d{4}){3}|\\d{4}[ -]\\d{6}[ -]\\d{5})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 8590,
    "headerPatterns": [
      {
        "regExp": "(?i).*(credit|debit).*card.*(number|no|num).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Credit Card Number"
        ],
        "negativeExamples": [
          "Card Type"
        ]
      },
      {
        "regExp": "(?i).*card.*(number|no|num).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Card Number"
        ],
        "negativeExamples": [
          "Cardholder Name"
        ]
      },
      {
        "regExp": "(?i).*imei.*(number|no|num).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IMEI Number"
        ],
        "negativeExamples": [
          "IMEI Status"
        ]
      },
      {
        "regExp": "(?i).*(ccn|cc_num|card_no|cardnum).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CCN"
        ],
        "negativeExamples": [
          "CCV"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Number"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "4111111111111111",
      "4012888888881881",
      "5555 5555 5555 4444",
      "378282246310005",
      "6011-1111-1111-1117",
      "3530111333300000",
      "490154203237518",
      "4222222222222"
    ],
    "negativeContentExamples": [
      "4111111111111112",
      "378282246310006",
      "490154203237519",
      "5555 5555 5555 4445",
      "6011-1111-1111-111",
      "3530 1113 3330 000",
      "4222 2222 2222 3",
      "1234-5678-9012-3456"
    ],
    "positiveHeaderExamples": [
      "Credit Card Number",
      "Card Number",
      "IMEI Number",
      "CCN",
      "Card No",
      "Debit Card Number",
      "Credit Card Num",
      "IMEI"
    ],
    "negativeHeaderExamples": [
      "Card Type",
      "Cardholder Name",
      "Expiration Date",
      "Security Code",
      "CVV",
      "IMEI Status",
      "Card Brand",
      "Issuer"
    ],
    "explanation": "This semantic type identifies numeric strings that should pass a Luhn checksum, covering typical payment card PANs and IMEI identifiers. The regex targets plain 13\u201319 digit sequences and common grouped formats (4-4-4-4 and 4-6-5) with optional spaces or hyphens; the final validation relies on the Luhn mod 10 algorithm to avoid false positives from similarly shaped numbers.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:53:58.788219"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE_PAIR.DECIMAL_PAREN",
    "description": "Parenthesized decimal coordinate pair in latitude, longitude order. Accepts optional signs and optional fractional parts, with optional internal whitespace and a single comma separator.",
    "pluginType": "regex",
    "regexPattern": "\\(\\s*[+-]?\\d{1,2}(\\.\\d+)?\\s*,\\s*[+-]?\\d{1,3}(\\.\\d+)?\\s*\\)",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 8770,
    "headerPatterns": [
      {
        "regExp": "(?i).*gps.*position.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "GPS Position"
        ],
        "negativeExamples": [
          "Longitude"
        ]
      },
      {
        "regExp": "(?i).*(location|loc).*coord.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Location Coords"
        ],
        "negativeExamples": [
          "Street Address"
        ]
      },
      {
        "regExp": "(?i).*coord.*pair.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Coord Pair"
        ],
        "negativeExamples": [
          "Latitude"
        ]
      },
      {
        "regExp": "(?i).*geo.*coord.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Geographic Coordinates"
        ],
        "negativeExamples": [
          "Street Address"
        ]
      },
      {
        "regExp": "(?i).*coordinates.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Coordinates"
        ],
        "negativeExamples": [
          "Latitude"
        ]
      }
    ],
    "positiveContentExamples": [
      "(37.7749, -122.4194)",
      "( -23.5505 , -46.6333 )",
      "(+51.5074, -0.1278)",
      "(0.0, 0.0)",
      "(12.345678, 98.765432)",
      "(-89.9999, 179.9999)",
      "(45, 100)",
      "(9.5, -10.25)"
    ],
    "negativeContentExamples": [
      "37.7749, -122.4194",
      "[37.7749, -122.4194]",
      "(37.7749 -122.4194)",
      "(N37.7749, W122.4194)",
      "(123.456, -12.34)",
      "(45\u00b0, -93\u00b0)",
      "( 12.34 , -56.78 ]",
      "12.34, -56.78"
    ],
    "positiveHeaderExamples": [
      "GPS Position",
      "Location Coords",
      "Coordinates",
      "Geo Coordinates",
      "Coordinate Pair",
      "Lat Lon Coordinates",
      "Map Coordinates",
      "GPS Coordinates"
    ],
    "negativeHeaderExamples": [
      "Latitude",
      "Longitude",
      "Street Address",
      "GPS Timestamp",
      "Postal Code",
      "City",
      "Country",
      "Timezone"
    ],
    "explanation": "This semantic type identifies values that are coordinate pairs in decimal degrees, enclosed in parentheses and separated by a single comma, e.g., (lat, lon). It targets datasets where positions are stored as a compact, parenthesized pair rather than separate latitude/longitude columns.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:01.414563"
  },
  {
    "resultType": "generated",
    "semanticType": "CRYPTOCURRENCY.TEXT_EN",
    "description": "Human\u2011readable English names of blockchain\u2011based digital currencies and tokens (e.g., Bitcoin, USD Coin). Focuses on the asset name, not symbols/tickers, codes, or addresses.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z][a-z]{2,20})([ -]([A-Z][a-z]{2,20}|[A-Z]{2,6})){0,3}\\b|\\b([A-Z]{2,6}[ -][A-Z][a-z]{2,20}([ -][A-Z][a-z]{2,20}){0,2})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 8850,
    "headerPatterns": [
      {
        "regExp": "(?i).*(cryptocurrency|crypto)[ _-]*name.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Crypto Name"
        ],
        "negativeExamples": [
          "Crypto Symbol"
        ]
      },
      {
        "regExp": "(?i).*digital[ _-]*currency[ _-]*name.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Digital Currency Name"
        ],
        "negativeExamples": [
          "Currency Code"
        ]
      },
      {
        "regExp": "(?i).*(cryptocurrency|crypto|digital[ _-]*currency).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Cryptocurrency"
        ],
        "negativeExamples": [
          "Wallet Address"
        ]
      },
      {
        "regExp": "(?i).*(coin|token)[ _-]*name.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Token Name"
        ],
        "negativeExamples": [
          "Coin Symbol"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Bitcoin",
      "Ethereum",
      "USD Coin",
      "Binance Coin",
      "Tether",
      "Cardano",
      "Polkadot",
      "Litecoin"
    ],
    "negativeContentExamples": [
      "BTC",
      "ETH",
      "XRP",
      "bitcoin.org",
      "BTC-USD",
      "0x",
      "123Coin",
      "Wallet Address"
    ],
    "positiveHeaderExamples": [
      "Cryptocurrency",
      "Crypto Name",
      "Digital Currency",
      "Cryptocurrency Name",
      "Token Name",
      "Coin Name",
      "Crypto Asset Name",
      "Digital Currency Name"
    ],
    "negativeHeaderExamples": [
      "Crypto Symbol",
      "Price",
      "Wallet Address",
      "Currency Code",
      "Coin Symbol",
      "Transaction Name",
      "Customer Name",
      "Ticker"
    ],
    "explanation": "This semantic type detects human-readable cryptocurrency asset names, typically in Title Case or acronym + Title Case forms (e.g., 'USD Coin', 'Bitcoin'). It avoids matching tickers/symbols, codes, URIs, market pairs, and addresses. Use it for labeling columns that store crypto asset names in English rather than symbols or identifiers.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:01.964442"
  },
  {
    "resultType": "generated",
    "semanticType": "EPOCH.MILLISECONDS",
    "description": "Millisecond-precision Unix timestamp represented as a whole number count of milliseconds since 1970-01-01T00:00:00Z. Values are plain digit strings without signs, separators, or decimals, typically 12\u201313 digits depending on the date range.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{12,13}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 8930,
    "headerPatterns": [
      {
        "regExp": "(?i).*(unix|epoch).*(timestamp|time).*(millis|milliseconds).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Unix Timestamp Millis"
        ],
        "negativeExamples": [
          "Unix Time Seconds"
        ]
      },
      {
        "regExp": "(?i).*(timestamp|time).*(millis|milliseconds).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Time Millis"
        ],
        "negativeExamples": [
          "Formatted Date"
        ]
      },
      {
        "regExp": "(?i).*(epoch|unix).*(time|ts).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Unix Timestamp"
        ],
        "negativeExamples": [
          "Date"
        ]
      },
      {
        "regExp": "(?i).*(ts).*ms.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ts_ms"
        ],
        "negativeExamples": [
          "ts_sec"
        ]
      },
      {
        "regExp": "(?i).*timestamp.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Timestamp"
        ],
        "negativeExamples": [
          "Time"
        ]
      }
    ],
    "positiveContentExamples": [
      "1697049600000",
      "1700000000123",
      "946684800000",
      "1609459200000",
      "1451606400123",
      "1234567890123",
      "1000000000000",
      "0000000000000"
    ],
    "negativeContentExamples": [
      "1697049600",
      "16970496000",
      "16970496000000",
      "1697049600000.0",
      "1,697,049,600,000",
      "1697049600000Z",
      "-1697049600000",
      "2021-03-15T12:30:00Z"
    ],
    "positiveHeaderExamples": [
      "Timestamp",
      "Unix Timestamp",
      "Time Millis",
      "Epoch Millis",
      "Timestamp (ms)",
      "Epoch Time (ms)",
      "Unix Time Milliseconds"
    ],
    "negativeHeaderExamples": [
      "Date",
      "Time",
      "Formatted Date",
      "Unix Time (seconds)",
      "Epoch Seconds",
      "Timestamp Seconds",
      "ISO Timestamp",
      "DateTime"
    ],
    "explanation": "This semantic type detects millisecond-precision Unix timestamps stored as integer-like strings with 12\u201313 digits, avoiding signs, separators, or decimals. It is useful for identifying raw epoch millisecond fields for parsing and conversion into datetime formats.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:04.215841"
  },
  {
    "resultType": "generated",
    "semanticType": "COMPANY_NAME",
    "description": "Registered business or corporate entity name that includes a formal legal designator (e.g., Inc., LLC, Ltd, GmbH, PLC). Intended to capture official company names as they appear in registrations and business records.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z][A-Za-z0-9'&.-]{1,})(\\s+[A-Z][A-Za-z0-9'&.-]{1,}){0,5}\\s+(Company|Co\\.|Corporation|Corp\\.|Incorporated|Inc\\.|Limited|Ltd\\.|LLC|LLP|PLC|GmbH|S\\.A\\.|N\\.V\\.|Pte\\s+Ltd\\.?.*|Group|Holdings|Partners|Studios|Systems|Services|Solutions)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 8670,
    "headerPatterns": [
      {
        "regExp": "(?i).*(legal|registered).*company.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Legal Company Name"
        ],
        "negativeExamples": [
          "Company Address"
        ]
      },
      {
        "regExp": "(?i).*(business|corporate|entity).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Business Name"
        ],
        "negativeExamples": [
          "Business Unit"
        ]
      },
      {
        "regExp": "(?i).*(company|organization|organisation|corporation).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Organization"
        ],
        "negativeExamples": [
          "Industry"
        ]
      },
      {
        "regExp": "(?i).*(corp|co\\.|org).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Corp Name"
        ],
        "negativeExamples": [
          "Org Code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Account Number"
        ]
      }
    ],
    "positiveContentExamples": [
      "Apex Solutions Inc.",
      "Blue Horizon LLC",
      "Northstar Holdings Ltd",
      "Orion Systems GmbH",
      "Meridian Group PLC",
      "Atlas Services N.V.",
      "Pacific Pte Ltd",
      "Global Tech Incorporated"
    ],
    "negativeContentExamples": [
      "Acme",
      "Blue Horizon",
      "Orion Systems",
      "ACME INC",
      "Acme Co",
      "3M Company",
      "Northstar LTd",
      "Acme Solutions Limited Liability Company"
    ],
    "positiveHeaderExamples": [
      "Company Name",
      "Organization",
      "Corporation",
      "Legal Company Name",
      "Registered Business Name",
      "Business Name",
      "Corporate Entity Name",
      "Company"
    ],
    "negativeHeaderExamples": [
      "Stock Symbol",
      "Industry",
      "Employee Count",
      "Contact Name",
      "Invoice Number",
      "Company Address",
      "Website URL",
      "Department"
    ],
    "explanation": "This semantic type identifies official company or business names that end with a recognized legal entity designator, providing a safeguard against misclassifying generic names or descriptions. It is broad but constrained by the requirement for a legal suffix, and header cues further improve precision in real-world datasets.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:08.209857"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.ISBN",
    "description": "Book ISBN: hyphenated thirteen-digit publication identifier. Matches ISBN-13 values with hyphen separators that begin with 978 or 979 and contain five digit groups with a single-digit check digit at the end. Excludes ISBN-10 and unhyphenated ISBN-13 values.",
    "pluginType": "regex",
    "regexPattern": "\\b97[89]-\\d{1,5}-\\d{1,7}-\\d{1,6}-\\d\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 8570,
    "headerPatterns": [
      {
        "regExp": "(?i).*book.*isbn[-_ ]?13.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Book ISBN-13"
        ],
        "negativeExamples": [
          "Book Title"
        ]
      },
      {
        "regExp": "(?i).*isbn[-_ ]?13.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISBN-13"
        ],
        "negativeExamples": [
          "Publication Year"
        ]
      },
      {
        "regExp": "(?i).*book.*isbn.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Book ISBN"
        ],
        "negativeExamples": [
          "Author"
        ]
      },
      {
        "regExp": "(?i).*isbn.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISBN"
        ],
        "negativeExamples": [
          "ISSN"
        ]
      }
    ],
    "positiveContentExamples": [
      "978-1-4028-9462-6",
      "979-10-90636-07-1",
      "978-0-306-40615-7",
      "978-3-16-148410-0",
      "979-12-200-3158-9",
      "978-1-86197-876-9",
      "978-0-545-01022-1",
      "979-8-7654-3210-9"
    ],
    "negativeContentExamples": [
      "9781402894626",
      "0-306-40615-2",
      "977-1-4028-9462-6",
      "978-1-4028-94626",
      "978-1-4028-9462-",
      "978-1-4028-9462-6-1",
      "978 1 4028 9462 6",
      "979-10-90636-071"
    ],
    "positiveHeaderExamples": [
      "ISBN",
      "Book ISBN",
      "ISBN-13",
      "Primary ISBN",
      "ISBN 13",
      "Book ISBN Code",
      "ISBN Number",
      "Product ISBN"
    ],
    "negativeHeaderExamples": [
      "Book Title",
      "Author",
      "Publication Year",
      "ISSN",
      "SKU",
      "Order Number",
      "Library of Congress Number",
      "Edition"
    ],
    "explanation": "This semantic type detects hyphenated ISBN-13 values used to identify books. It expects five digit groups separated by hyphens, beginning with 978 or 979 and ending in a single check digit. Use this to validate and classify ISBN-13 fields in bibliographic and retail datasets; it intentionally excludes ISBN-10 and unhyphenated ISBN-13 formats to reduce ambiguity.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:08.414999"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTIFIER",
    "description": "record_key: unique alphanumeric code for entity identification",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9A-Za-z]{6,20}\\b|\\b[0-9A-Za-z]{2,10}-[0-9A-Za-z]{2,10}\\b|\\b[0-9A-Za-z]{2,8}_[0-9A-Za-z]{1,8}\\b|\\b[0-9A-Za-z]{2,6}-[0-9A-Za-z]{2,6}-[0-9A-Za-z]{2,6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 9060,
    "headerPatterns": [
      {
        "regExp": "(?i).*record.*key.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "record_key"
        ],
        "negativeExamples": [
          "record_count"
        ]
      },
      {
        "regExp": "(?i).*entity.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "entity_id"
        ],
        "negativeExamples": [
          "entity_type"
        ]
      },
      {
        "regExp": "(?i).*unique.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Unique ID"
        ],
        "negativeExamples": [
          "unique_name"
        ]
      },
      {
        "regExp": "(?i).*identifier.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Identifier"
        ],
        "negativeExamples": [
          "identity"
        ]
      },
      {
        "regExp": "(?i).*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ID"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "A1B2C3",
      "ID12345",
      "USR-000123",
      "9ZX-AB12-CD3",
      "CUST_42",
      "INV-2023-0001",
      "ACCT-99",
      "X9Z7K1Q2"
    ],
    "negativeContentExamples": [
      "A1B2",
      "INV 2023 0001",
      "USER#123",
      "123456789012345678901",
      "AB--123",
      "ABC_DEF_GHI",
      "id",
      "AB_1-2"
    ],
    "positiveHeaderExamples": [
      "ID",
      "Identifier",
      "Unique ID",
      "record_key",
      "entity_id",
      "order_id",
      "user_identifier",
      "global_id"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Description",
      "Date",
      "identity",
      "count",
      "status",
      "code",
      "account_number"
    ],
    "explanation": "A broad, generic identifier type representing single-token alphanumeric keys or segmented keys using hyphens or underscores. Typical use cases include database primary keys, record keys, and generic entity IDs where the exact code system is not specified. Due to its breadth, it uses conservative thresholds and header-driven cues to reduce conflicts with more specific types.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:15.274108"
  },
  {
    "resultType": "generated",
    "semanticType": "FILENAME_EXT",
    "description": "File suffix: period-prefixed format indicator. Values are the dot-leading extension tokens like '.pdf' or multi-part like '.tar.gz', not full filenames or MIME types.",
    "pluginType": "regex",
    "regexPattern": "\\b\\.[A-Za-z0-9]{1,10}(\\.[A-Za-z0-9]{1,10})?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 8960,
    "headerPatterns": [
      {
        "regExp": "(?i).*file.*extension.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "File Extension"
        ],
        "negativeExamples": [
          "File Size"
        ]
      },
      {
        "regExp": "(?i).*filename.*extension.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Filename Extension"
        ],
        "negativeExamples": [
          "Filename"
        ]
      },
      {
        "regExp": "(?i).*file.*type.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "File Type"
        ],
        "negativeExamples": [
          "File Path"
        ]
      },
      {
        "regExp": "(?i).*\\bfile\\b.*\\bext\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "File Ext"
        ],
        "negativeExamples": [
          "File Name"
        ]
      },
      {
        "regExp": "(?i).*extension.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Extension"
        ],
        "negativeExamples": [
          "Filename"
        ]
      }
    ],
    "positiveContentExamples": [
      ".pdf",
      ".DOCX",
      ".csv",
      ".jpeg",
      ".png",
      ".7z",
      ".tar.gz",
      ".html"
    ],
    "negativeContentExamples": [
      "pdf",
      "tar.gz",
      ".tar.gz.sig",
      ".mp3-",
      ".7_zip",
      ".docx/",
      ".12345678901",
      " .txt"
    ],
    "positiveHeaderExamples": [
      "File Extension",
      "Extension",
      "File Type",
      "Filename Extension",
      "File Ext",
      "Ext"
    ],
    "negativeHeaderExamples": [
      "Filename",
      "File Size",
      "File Path",
      "Document Type",
      "Content Type",
      "File Name"
    ],
    "explanation": "Detects file extension values that consist solely of a leading dot followed by 1\u201310 alphanumeric characters, optionally with a second dot-delimited segment (e.g., '.tar.gz'). Intended for columns that store the extension only, enabling validation and profiling of file-related attributes without matching full filenames or MIME types.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:16.496105"
  },
  {
    "resultType": "generated",
    "semanticType": "FULL_ADDRESS_EN",
    "description": "mailing_address: complete postal location with standard formatting. Represents a single-field, English-language full postal address containing street number and type, city/locality, region/state, and a postal code (e.g., US ZIP or UK postcode).",
    "pluginType": "regex",
    "regexPattern": "(\\b\\d{1,6}[A-Za-z]?\\s+[A-Za-z0-9.'\\- ]+\\s+(Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Lane|Ln|Drive|Dr|Court|Ct|Way|Terrace|Ter|Place|Pl|Parkway|Pkwy|Square|Sq|Crescent|Cres|Close|Row|Loop)\\b(\\s+(N|S|E|W|NE|NW|SE|SW))?,\\s+[A-Za-z][A-Za-z .'\\-]+,\\s+[A-Z]{2}\\s+\\d{5}(-\\d{4})?\\b)|(\\b\\d{1,6}[A-Za-z]?\\s+[A-Za-z0-9.'\\- ]+\\s+(Street|St|Road|Rd|Avenue|Ave|Lane|Ln|Drive|Dr|Court|Ct|Way|Place|Pl|Park|Parkway|Pkwy|Crescent|Cres|Close|Square|Sq|Loop)\\b,\\s+[A-Za-z][A-Za-z .'\\-]+,\\s*[A-Z]{1,2}\\d[A-Z0-9]?\\s?\\d[A-Z]{2}\\b)",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 8980,
    "headerPatterns": [
      {
        "regExp": "(?i).*full.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Full Address"
        ],
        "negativeExamples": [
          "Street Address"
        ]
      },
      {
        "regExp": "(?i).*mailing.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Mailing Address"
        ],
        "negativeExamples": [
          "Email Address"
        ]
      },
      {
        "regExp": "(?i).*complete.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Complete Address"
        ],
        "negativeExamples": [
          "Address Line 1"
        ]
      },
      {
        "regExp": "(?i).*shipping.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Shipping Address"
        ],
        "negativeExamples": [
          "Billing Name"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "123 Main St, Springfield, IL 62704",
      "742 Evergreen Terrace, Springfield, OR 97403",
      "350 Fifth Avenue, New York, NY 10118",
      "1 Infinite Loop, Cupertino, CA 95014",
      "1600 Pennsylvania Ave NW, Washington, DC 20500",
      "221B Baker Street, London, NW1 6XE",
      "10 Downing Street, London, SW1A 2AA",
      "50 Queen Street, Edinburgh, EH2 3NS"
    ],
    "negativeContentExamples": [
      "123 Main St",
      "Springfield, IL",
      "123 Main St, Springfield, Illinois",
      "Baker Street, London, NW1 6XE",
      "221B Baker Street, NW1 6XE",
      "1600 Pennsylvania Ave NW, DC 20500",
      "New York, NY 10118",
      "350 Fifth Avenue, New York"
    ],
    "positiveHeaderExamples": [
      "Full Address",
      "Mailing Address",
      "Complete Address",
      "Shipping Address",
      "Billing Address",
      "Primary Address",
      "Customer Address",
      "Address"
    ],
    "negativeHeaderExamples": [
      "Street Address",
      "City",
      "ZIP Code",
      "Address Line 1",
      "Address Line 2",
      "Postal Code",
      "State",
      "Country"
    ],
    "explanation": "Detects full, single-field English-language mailing addresses that include a street number and type, a city/locality, a state/region, and a postal code. The pattern emphasizes clear separators (commas), common street types, and recognized postal code shapes (US ZIP and UK postcode), reducing false positives from partial addresses or unrelated text. Suitable for normalizing or validating columns that store complete mailing addresses in one field.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:17.235824"
  },
  {
    "resultType": "generated",
    "semanticType": "AIRLINE.TEXT_EN",
    "description": "Airline Company: full name of commercial carrier",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b((Air [A-Z][A-Za-z&'.-]*( [A-Z][A-Za-z&'.-]*){0,4}|Air-[A-Z][A-Za-z&'.-]*( [A-Z][A-Za-z&'.-]*){0,4})|([A-Z][A-Za-z&'.-]*( [A-Z][A-Za-z&'.-]*){0,3} (Air Lines|Air Line|Airlines|Airline|Airways|Aviation|Air))( (Express|Regional|Cargo))?)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 8510,
    "headerPatterns": [
      {
        "regExp": "(?i).*(airline|carrier).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Airline Name"
        ],
        "negativeExamples": [
          "Airline Code"
        ]
      },
      {
        "regExp": "(?i).*(airline).*company.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Airline Company"
        ],
        "negativeExamples": [
          "Aircraft Type"
        ]
      },
      {
        "regExp": "(?i).*(airline|carrier).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Carrier Name"
        ],
        "negativeExamples": [
          "Flight Number"
        ]
      },
      {
        "regExp": "(?i).*(airl|airln|carr).*(name|nm).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Carrier Nm"
        ],
        "negativeExamples": [
          "Airline Code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "American Airlines",
      "British Airways",
      "Delta Air Lines",
      "United Airlines",
      "Air France",
      "All Nippon Airways",
      "Xiamen Air",
      "Singapore Airlines"
    ],
    "negativeContentExamples": [
      "American Airlnes",
      "United Airway",
      "Airline: United",
      "DeltaAir Lines",
      "Air Cargo Services",
      "International Aviation Group",
      "AirFrance",
      "United Aviations"
    ],
    "positiveHeaderExamples": [
      "Airline Name",
      "Carrier Name",
      "Airline Company",
      "Airline Full Name",
      "Operating Carrier Name",
      "Marketing Airline Name",
      "Airline Legal Name"
    ],
    "negativeHeaderExamples": [
      "Airline Code",
      "Flight Number",
      "Aircraft Type",
      "Carrier ID",
      "Airport Name",
      "Operator Code",
      "Airline IATA",
      "Tail Number"
    ],
    "explanation": "This semantic type identifies full English names of commercial airline companies, such as those ending with tokens like Airlines, Air Lines, Airways, Aviation, or beginning with 'Air ' followed by capitalized words. It is intended for columns that store the textual company name of the operating or marketing carrier rather than codes or numeric identifiers.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:18.552691"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.NHS_UK",
    "description": "UK National Health Service (NHS) patient identifier consisting of exactly 10 digits, commonly formatted either as a continuous 10-digit string or in grouped form as 3 3 4 with single spaces (e.g., 123 456 7890). This type targets numeric-only identifiers and does not include hyphens, letters, or other punctuation.",
    "pluginType": "regex",
    "regexPattern": "\\b(\\d{10}|\\d{3}\\s\\d{3}\\s\\d{4})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 9120,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bnhs\\b.*\\b(number|no|id|identifier)\\b.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "NHS Number"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*(national health service|health service).*\\b(number|id)\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Health Number"
        ],
        "negativeExamples": [
          "Health Insurance Number"
        ]
      },
      {
        "regExp": "(?i).*\\bpatient\\b.*\\bnhs\\b.*\\b(number|id)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Patient NHS Number"
        ],
        "negativeExamples": [
          "Patient ID"
        ]
      },
      {
        "regExp": "(?i).*\\bnumber\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Number"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "943 476 5919",
      "1234567890",
      "987 654 3210",
      "401 023 1234",
      "0001234567",
      "223 456 7890",
      "5555555555",
      "741 852 9630"
    ],
    "negativeContentExamples": [
      "123-456-7890",
      "123 4567 890",
      "123456789",
      "12345678901",
      "A234567890",
      "123 456 789O",
      "123.456.7890",
      "12 3456 7890"
    ],
    "positiveHeaderExamples": [
      "NHS Number",
      "NHS ID",
      "Health Number",
      "NHS Identifier",
      "Patient NHS Number",
      "UK NHS Number",
      "NHS No"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Address",
      "Date of Birth",
      "National ID Number",
      "Patient ID",
      "Medical Record Number",
      "NINO",
      "SSN"
    ],
    "explanation": "This semantic type identifies the UK NHS patient identifier, a 10-digit numeric value that may appear as a continuous string or grouped as 3 3 4 with single spaces. It is intended for classifying columns that contain NHS numbers in healthcare datasets and avoids matching generic health identifiers that are not explicitly NHS-formatted.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:19.497287"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.EAN13",
    "description": "Product Barcode: thirteen-digit global trade item number",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{13}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 8550,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\b(ean|isbn|gtin)[-_ ]?13\\b.*",
        "confidence": 99,
        "mandatory": true,
        "positiveExamples": [
          "ISBN-13"
        ],
        "negativeExamples": [
          "Product Name"
        ]
      },
      {
        "regExp": "(?i).*\\b(barcode|bar[-_ ]?code)\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Barcode"
        ],
        "negativeExamples": [
          "Price"
        ]
      },
      {
        "regExp": "(?i).*\\b(gtin|ean|isbn)\\b.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "EAN"
        ],
        "negativeExamples": [
          "UPC Code"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "4006381333931",
      "9780306406157",
      "5901234123457",
      "8412345678905",
      "0123456789012",
      "7301433014502",
      "6923456789012"
    ],
    "negativeContentExamples": [
      "400638133393",
      "40063813339310",
      "978030640615X",
      "978-0306406157",
      "97 80306406157",
      "EAN13 4006381333931",
      "4006381333931."
    ],
    "positiveHeaderExamples": [
      "EAN13",
      "Barcode",
      "ISBN-13",
      "GTIN-13",
      "Product Barcode",
      "EAN Code",
      "ISBN13 Code"
    ],
    "negativeHeaderExamples": [
      "Product Name",
      "Price",
      "UPC Code",
      "Order ID",
      "SKU",
      "Customer Code",
      "Serial Number"
    ],
    "explanation": "EAN-13 is a 13-digit, check-digit\u2013protected identifier widely used for retail products and books (as ISBN-13). This semantic type targets cells containing exactly 13 numeric digits with no separators. Use this to identify fields holding a GTIN/EAN-13 style barcode value; headers mentioning EAN/ISBN-13 or barcode strengthen detection while a strict 13-digit pattern minimizes false positives.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:19.856618"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.DUNS",
    "description": "business_identifier: 9-digit commercial entity tracking code",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{9}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 9090,
    "headerPatterns": [
      {
        "regExp": "(?i).*d[-_ ]?u[-_ ]?n[-_ ]?s.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "DUNS Number"
        ],
        "negativeExamples": [
          "Registration Number"
        ]
      },
      {
        "regExp": "(?i).*d[-_ ]?u[-_ ]?n[-_ ]?s.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "DUNS ID"
        ],
        "negativeExamples": [
          "Vendor ID"
        ]
      },
      {
        "regExp": "(?i).*\\bd[-_ ]?u[-_ ]?n[-_ ]?s\\b.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "DUNS Code"
        ],
        "negativeExamples": [
          "Company Code"
        ]
      },
      {
        "regExp": "(?i).*\\bd[-_ ]?u[-_ ]?n[-_ ]?s\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "D-U-N-S"
        ],
        "negativeExamples": [
          "Business ID"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "123456789",
      "001234567",
      "730918245",
      "219876543",
      "550123789",
      "345678901",
      "902345678",
      "100000001"
    ],
    "negativeContentExamples": [
      "12345678",
      "1234567890",
      "123-456-789",
      "123 456 789",
      "123456789-0001",
      "01234567A",
      "A12345678",
      "00000000"
    ],
    "positiveHeaderExamples": [
      "DUNS Number",
      "DUNS",
      "D-U-N-S",
      "DUNS ID",
      "DUNS No",
      "DUNS Code",
      "Business Identifier DUNS",
      "DUNS#"
    ],
    "negativeHeaderExamples": [
      "Company Name",
      "Industry",
      "Revenue",
      "Vendor ID",
      "Business ID",
      "Company Code",
      "Tax ID",
      "Registration Number"
    ],
    "explanation": "Identifies DUNS numbers used for uniquely tracking commercial entities. Values must be exactly nine digits with no separators or suffixes, excluding DUNS+4 extensions. Typical use cases include validating and classifying business registry identifiers in vendor master, customer master, and supply chain datasets.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:20.603059"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.CUSIP",
    "description": "Security Code: nine-character financial instrument ID. A CUSIP is a nine-character alphanumeric identifier for financial instruments where characters 1\u20138 are alphanumeric and the 9th character is a check digit in the set 0\u20139 or X. This type validates the code\u2019s structural shape (including the allowed check-digit character) but does not compute or verify the check digit.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9A-Za-z]{8}[0-9Xx]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 8540,
    "headerPatterns": [
      {
        "regExp": "(?i).*cusip.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "CUSIP Code"
        ],
        "negativeExamples": [
          "Company Name"
        ]
      },
      {
        "regExp": "(?i).*cusip.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "CUSIP"
        ],
        "negativeExamples": [
          "Ticker Symbol"
        ]
      },
      {
        "regExp": "(?i).*security.*id.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Security ID"
        ],
        "negativeExamples": [
          "Stock Price"
        ]
      },
      {
        "regExp": "(?i).*sec.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Sec ID"
        ],
        "negativeExamples": [
          "Company Name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Security Code"
        ],
        "negativeExamples": [
          "Stock Price"
        ]
      }
    ],
    "positiveContentExamples": [
      "1A2B3C4D5",
      "AB12CD34X",
      "ZY12XW34X",
      "9Q8W7E6R2",
      "GH45JK67X",
      "T5R6E7W8X",
      "MNBV12345",
      "QW12ER34X"
    ],
    "negativeContentExamples": [
      "AB12CD34Y",
      "1A2B3C4D",
      "1A2B3C4D56",
      "AB12 CD34X",
      "AB12-CD34X",
      "AB12CD34!",
      "ab12cd34y",
      "12345678Z"
    ],
    "positiveHeaderExamples": [
      "CUSIP",
      "Security ID",
      "CUSIP Code",
      "Security Code",
      "CUSIP Identifier",
      "Issuer CUSIP",
      "Instrument CUSIP"
    ],
    "negativeHeaderExamples": [
      "Ticker Symbol",
      "Company Name",
      "Stock Price",
      "Security Name",
      "ISIN",
      "Order ID"
    ],
    "explanation": "Detects CUSIP security codes in data fields using a strict nine-character pattern: eight alphanumeric characters followed by a check digit that is 0\u20139 or X. Useful for validating and classifying financial instrument identifiers in datasets where CUSIP values are present in raw or normalized uppercase/lowercase forms; this pattern checks only format and permissible check-digit characters, not the arithmetic of the check digit.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:22.239680"
  },
  {
    "resultType": "generated",
    "semanticType": "EMAIL",
    "description": "Contact Address: electronic mail identifier",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,24}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 8920,
    "headerPatterns": [
      {
        "regExp": "(?i).*(contact|primary).*email.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Contact Email"
        ],
        "negativeExamples": [
          "Phone Number"
        ]
      },
      {
        "regExp": "(?i).*(user|customer).*email.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Customer Email"
        ],
        "negativeExamples": [
          "Website"
        ]
      },
      {
        "regExp": "(?i).*email.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Email Address"
        ],
        "negativeExamples": [
          "Contact Phone"
        ]
      },
      {
        "regExp": "(?i).*(e[-_ ]?mail).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "E-mail"
        ],
        "negativeExamples": [
          "Name"
        ]
      },
      {
        "regExp": "(?i).*email.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Email"
        ],
        "negativeExamples": [
          "Phone Number"
        ]
      }
    ],
    "positiveContentExamples": [
      "alice.smith@example.com",
      "bob+sales@sub.example.org",
      "user_01@company.co",
      "support@service.io",
      "john-doe@dept.example.co.uk",
      "newsletter@news-site.net",
      "hr@startup.dev",
      "jane@ex-am-ple.com"
    ],
    "negativeContentExamples": [
      "alice.smith.example.com",
      "bob@sub_example.org",
      "user@company",
      "support@.io",
      "john@@example.com",
      "hr@startup.c",
      "jane doe@example.com",
      "name@example.c9"
    ],
    "positiveHeaderExamples": [
      "Email",
      "Email Address",
      "Contact Email",
      "Primary Email",
      "Customer Email",
      "Work Email",
      "E-mail",
      "User Email"
    ],
    "negativeHeaderExamples": [
      "Phone Number",
      "Name",
      "Website",
      "Contact Phone",
      "Username",
      "URL",
      "Mailing Address",
      "Account ID"
    ],
    "explanation": "Identifies strings that represent email addresses, using a concise pattern that matches common local-part characters, an at-sign, a domain with optional subdomains, and a final alphabetic TLD. Suitable for detecting contact email fields across diverse datasets without relying on anchors.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:22.648619"
  },
  {
    "resultType": "generated",
    "semanticType": "FREE_TEXT",
    "description": "text_content: unrestricted narrative or descriptive text suitable for comments, descriptions, and notes fields in datasets.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z]{2,}( [A-Za-z0-9,.'\"-]{2,}){4,}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 99,
    "priority": 8970,
    "headerPatterns": [
      {
        "regExp": "(?i).*(customer|user|client).*(notes|comments|description).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_notes"
        ],
        "negativeExamples": [
          "customer_id"
        ]
      },
      {
        "regExp": "(?i).*(order|ticket|case|issue).*(description|notes|comments).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ticket_description"
        ],
        "negativeExamples": [
          "order_id"
        ]
      },
      {
        "regExp": "(?i).*(description|desc|details|remarks|feedback|narrative|review|message).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Description"
        ],
        "negativeExamples": [
          "Price"
        ]
      },
      {
        "regExp": "(?i).*(comments|comment|notes|note).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Comments"
        ],
        "negativeExamples": [
          "Status"
        ]
      },
      {
        "regExp": "(?i).*text.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Text"
        ],
        "negativeExamples": [
          "Date"
        ]
      }
    ],
    "positiveContentExamples": [
      "The package arrived two days late but items were well packed.",
      "Customer reported intermittent connectivity issues during peak hours.",
      "Please contact the client to confirm preferred delivery window.",
      "Payment was received, order will ship once backordered items arrive.",
      "User requested refund citing quality concerns with the material.",
      "Meeting notes indicate follow-up actions assigned to support team.",
      "This report summarizes quarterly performance trends across regions.",
      "We appreciate prompt response and detailed troubleshooting steps."
    ],
    "negativeContentExamples": [
      "OK",
      "N/A",
      "Pending",
      "See attached",
      "Call back tomorrow",
      "2024-06-15",
      "USD 12.00",
      "Ref AB-12345"
    ],
    "positiveHeaderExamples": [
      "Description",
      "Notes",
      "Comments",
      "Customer Notes",
      "Product Description",
      "Review Comments",
      "Message Text",
      "Free Text"
    ],
    "negativeHeaderExamples": [
      "ID",
      "Date",
      "Price",
      "SKU",
      "Amount",
      "Country Code",
      "Order Number",
      "Phone Number"
    ],
    "explanation": "This semantic type targets long-form, multi-word narrative text commonly found in descriptive fields such as descriptions, notes, and comments. The value pattern favors natural language by requiring multiple tokens of length two or more, reducing false positives from short labels, codes, or numeric identifiers. Header patterns progress from entity-specific notes/descriptions to generic text, ensuring robust detection across varied schemas while keeping broad matches gated by a high confidence threshold and low priority.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:23.570556"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.EIN_US",
    "description": "US Employer Identification Number (EIN): tax_id_number in the format NN-NNNNNNN consisting of a 2-digit prefix, a hyphen, and a 7-digit employer code.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{2}-[0-9]{7}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 9100,
    "headerPatterns": [
      {
        "regExp": "(?i).*(employer.*identification.*number).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Employer Identification Number"
        ],
        "negativeExamples": [
          "Employee Identification Number"
        ]
      },
      {
        "regExp": "(?i).*\\bfein\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "FEIN"
        ],
        "negativeExamples": [
          "FINE"
        ]
      },
      {
        "regExp": "(?i).*\\bein\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "EIN"
        ],
        "negativeExamples": [
          "FIN"
        ]
      },
      {
        "regExp": "(?i).*(tax.*id|employer.*id).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Tax ID"
        ],
        "negativeExamples": [
          "Employee ID"
        ]
      },
      {
        "regExp": "(?i).*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ID"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "12-3456789",
      "01-2345678",
      "98-7654321",
      "00-0000000",
      "27-0001234",
      "45-6789012",
      "83-1029384",
      "39-4938271"
    ],
    "negativeContentExamples": [
      "123456789",
      "12-345678",
      "12-34567890",
      "123-456789",
      "1A-3456789",
      "12-345678A",
      "12/3456789",
      "12\u20133456789"
    ],
    "positiveHeaderExamples": [
      "EIN",
      "Employer ID",
      "Tax ID",
      "FEIN",
      "Employer Identification Number",
      "Federal Tax ID",
      "US EIN",
      "Employer Tax ID"
    ],
    "negativeHeaderExamples": [
      "Company Name",
      "SSN",
      "Employee Count",
      "VAT Number",
      "Invoice ID",
      "Account Number",
      "Zip Code",
      "Employee ID"
    ],
    "explanation": "This type identifies US Employer Identification Numbers (EIN) formatted as two digits, a hyphen, and seven digits. It is intended for classifying columns containing employer tax identifiers and validating the hyphenated EIN pattern in datasets.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:23.876147"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.TEXT_EN",
    "description": "Nation Name: English country designation",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z][A-Za-z]+([ '-][A-Z][A-Za-z]+| [a-z]{2,3}){0,5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 8810,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bcountry\\b.*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Country Name"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*\\bnation\\b.*\\bname\\b.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Nation Name"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*\\bcountry\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Country"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*\\bnation\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Nation"
        ],
        "negativeExamples": [
          "State"
        ]
      },
      {
        "regExp": "(?i).*\\b(ctry|cntry)\\b.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "ctry"
        ],
        "negativeExamples": [
          "country_code"
        ]
      },
      {
        "regExp": "(?i).*\\bname\\b.*",
        "confidence": 85,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "United States of America",
      "United Kingdom",
      "Canada",
      "Australia",
      "New Zealand",
      "South Africa",
      "Timor-Leste",
      "Trinidad and Tobago"
    ],
    "negativeContentExamples": [
      "USA",
      "U.K.",
      "US",
      "GB",
      "EU",
      "CA",
      "UK (GB)",
      "PRC"
    ],
    "positiveHeaderExamples": [
      "Country",
      "Country Name",
      "Nation",
      "Nation Name",
      "Country English Name",
      "Country Name (EN)",
      "Country Full Name"
    ],
    "negativeHeaderExamples": [
      "Country Code",
      "State",
      "City",
      "Nationality",
      "County",
      "Continent",
      "Region",
      "Country_ID"
    ],
    "explanation": "Identifies full country names written in English, including single-word names (e.g., Canada) and multi-word names with connectors like and/of/the or hyphens (e.g., Trinidad and Tobago, Timor-Leste). Useful for datasets where the field stores the human-readable English designation of a sovereign state rather than a code or abbreviation.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:26.130232"
  },
  {
    "resultType": "generated",
    "semanticType": "GUID",
    "description": "A 128-bit universally unique identifier formatted as five hyphen-separated hexadecimal groups in the 8-4-4-4-12 pattern. Hex digits may be upper or lower case and only 0-9 and A-F are allowed; braces or alternate separators are not included.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 99,
    "priority": 9020,
    "headerPatterns": [
      {
        "regExp": "(?i).*universally[\\s_-]*unique[\\s_-]*(id|identifier).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Universally Unique Identifier"
        ],
        "negativeExamples": [
          "GUID"
        ]
      },
      {
        "regExp": "(?i).*(guid|uuid).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "GUID"
        ],
        "negativeExamples": [
          "Unique Identifier"
        ]
      },
      {
        "regExp": "(?i).*unique[\\s_-]*(id|identifier).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Unique ID"
        ],
        "negativeExamples": [
          "UUID"
        ]
      },
      {
        "regExp": "(?i).*\\buid\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "UID"
        ],
        "negativeExamples": [
          "User ID"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "550e8400-e29b-41d4-a716-446655440000",
      "F47AC10B-58CC-4372-A567-0E02B2C3D479",
      "123e4567-e89b-12d3-a456-426614174000",
      "9b2f1d3a-4c5b-4e9e-8f3a-1a2b3c4d5e6f",
      "a3f1c2b4-7d8e-4f9a-b1c2-3d4e5f6a7b8c",
      "00000000-0000-0000-0000-000000000000",
      "3d6f0a1b-2c3d-4e5f-8a9b-0c1d2e3f4a5b",
      "e2d1c0b9-a8f7-4e5d-9c3b-2a1908765432"
    ],
    "negativeContentExamples": [
      "123e4567e89b12d3a456426614174000",
      "123e4567-e89b-12d3-a4567-426614174000",
      "{123e4567-e89b-12d3-a456-426614174000}",
      "123e4567-e89b-12d3-a456-42661417400G",
      "123e4567_e89b_12d3_a456_426614174000",
      "f47ac10b-58cc-4372a567-0e02b2c3d479",
      "550e8400-e29b-41d4-a716-44665544",
      "550e8400e29b-41d4-a716-446655440000"
    ],
    "positiveHeaderExamples": [
      "GUID",
      "UUID",
      "Unique ID",
      "Universally Unique Identifier",
      "Unique Identifier",
      "UID",
      "Code"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Description",
      "Created Date",
      "Account Number",
      "Order ID",
      "Email Address",
      "Hash"
    ],
    "explanation": "This semantic type identifies canonical hyphenated GUID/UUID values using a strict 8-4-4-4-12 hexadecimal pattern with word boundaries. It is useful for detecting unique identifiers across datasets where entities are keyed by system-generated 128-bit values, independent of domain or geography.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:27.459251"
  },
  {
    "resultType": "generated",
    "semanticType": "CURRENCY.TEXT_EN",
    "description": "monetary_unit: English currency designation. Identifies spelled-out currency names in English such as \"Euro\", \"US dollar\", or \"Pound sterling\", excluding codes or symbols.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b((united states|u\\.s\\.|us|new zealand|hong kong|new taiwan|south african|saudi|uae|emirati|brazilian|swiss|mexican|canadian|australian|singapore|japanese|chinese|indian|thai|malaysian|indonesian|philippine|turkish|polish|swedish|norwegian|danish|czech|romanian|moldovan|russian|ukrainian|kazakhstani|azerbaijani|georgian|armenian|peruvian|bolivian|paraguayan|chilean|argentine|colombian|egyptian|lebanese|syrian|moroccan|algerian|tunisian|qatari|kuwaiti|bahraini|omani|iraqi|iranian|pakistani|bangladeshi|sri lankan|nepalese|vietnamese|korean|jamaican|panamanian|nicaraguan|guatemalan)\\s+)?(dollar|euro|yen|yuan|renminbi|pound sterling|pound|franc|lira|ruble|rouble|real|riyal|dirham|dinar|krone|krona|koruna|peso|won|ringgit|baht|forint|zloty|kuna|manat|taka|naira|rand|shekel|kip|riel|leu|lei|som|tugrik|dram|lari|bolivar|boliviano|guarani|quetzal|cordoba|colon|sol|kwanza|metical|cedi|kina|denar|somoni)(s)?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 8860,
    "headerPatterns": [
      {
        "regExp": "(?i).*(currency).*(english|full|long).*(name|text|description).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Currency English Name"
        ],
        "negativeExamples": [
          "Currency Code"
        ]
      },
      {
        "regExp": "(?i).*(currency).*(name|text).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Currency Name"
        ],
        "negativeExamples": [
          "Exchange Rate"
        ]
      },
      {
        "regExp": "(?i).*(currency|monetary).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Currency"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(curr|money).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Money"
        ],
        "negativeExamples": [
          "Amount"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Euro",
      "US dollar",
      "United States dollar",
      "Japanese yen",
      "Pound sterling",
      "Swiss franc",
      "Brazilian real",
      "South African rand"
    ],
    "negativeContentExamples": [
      "USD",
      "100 dollars",
      "US$",
      "Euro (EUR)",
      "Canadian $",
      "British currency",
      "yen rate",
      "currency code"
    ],
    "positiveHeaderExamples": [
      "Currency",
      "Currency Name",
      "Money",
      "Currency English Name",
      "Monetary Unit Name",
      "Currency Description",
      "Currency Text"
    ],
    "negativeHeaderExamples": [
      "Currency Code",
      "Exchange Rate",
      "Country",
      "Amount",
      "ISO Currency",
      "Code",
      "Currency Symbol"
    ],
    "explanation": "This semantic type identifies spelled-out currency names in English (e.g., Euro, US dollar, Pound sterling) typically found in columns labeled Currency or Currency Name. It excludes currency codes, symbols, and mixed format strings, focusing on human-readable monetary unit designations.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:27.751047"
  },
  {
    "resultType": "generated",
    "semanticType": "HASH.SHA1_HEX",
    "description": "hash_digest: 40-character SHA-1 cryptographic fingerprint represented as a contiguous hexadecimal string (0-9, a-f, A-F). Accepts lowercase, uppercase, or mixed case without separators or prefixes.",
    "pluginType": "regex",
    "regexPattern": "\\b[a-fA-F0-9]{40}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 9030,
    "headerPatterns": [
      {
        "regExp": "(?i).*sha[-_ ]?1.*hash.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SHA1 Hash"
        ],
        "negativeExamples": [
          "Hash"
        ]
      },
      {
        "regExp": "(?i).*sha[-_ ]?1.*(checksum|digest).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SHA-1 Checksum"
        ],
        "negativeExamples": [
          "MD5 Checksum"
        ]
      },
      {
        "regExp": "(?i).*sha[-_ ]?1.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "sha1"
        ],
        "negativeExamples": [
          "sha256"
        ]
      },
      {
        "regExp": "(?i).*(checksum|digest).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Checksum"
        ],
        "negativeExamples": [
          "File Size"
        ]
      },
      {
        "regExp": "(?i).*hash.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Hash"
        ],
        "negativeExamples": [
          "Filename"
        ]
      }
    ],
    "positiveContentExamples": [
      "da39a3ee5e6b4b0d3255bfef95601890afd80709",
      "A94A8FE5CCB19BA61C4C0873D391E987982FBBD3",
      "7C211433F02071597741E6FF5A8EA34789ABBF43",
      "5baa61e4c9b93f3f0682250b6cf8331b7ee68fd8",
      "3b5d5c3712955042212316173ccf37be8006fdcf",
      "9a0fc922c2bdc1b9f9add16dd724e5bdf4c90219",
      "f7c3bc1d808e04732adf679965ccc34ca7ae3441",
      "0000000000000000000000000000000000000000"
    ],
    "negativeContentExamples": [
      "da39a3ee5e6b4b0d3255bfef95601890afd8070",
      "da39a3ee5e6b4b0d3255bfef95601890afd807090",
      "A94A8FE5CCB19BA61C4C0873D391E987982FBBG",
      "a94a8fe5-ccb19ba6-1c4c0873-d391e987-982fbbd3",
      "0xA94A8FE5CCB19BA61C4C0873D391E987982Fbbd3",
      "7C211433F02071597741E6FF5A8EA34789ABBF4",
      "OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO",
      "5baa61e4c9b93f3f0682250b6cf8331b7ee68fdz"
    ],
    "positiveHeaderExamples": [
      "SHA1 Hash",
      "Hash",
      "Checksum",
      "SHA-1 Checksum",
      "sha1_digest",
      "file_sha1",
      "sha1"
    ],
    "negativeHeaderExamples": [
      "Filename",
      "File Size",
      "Password",
      "MD5 Hash",
      "SHA256 Checksum",
      "Hashing Algorithm",
      "Encryption Key"
    ],
    "explanation": "This semantic type identifies SHA-1 digests encoded as a 40-character hexadecimal string. It is useful for detecting cryptographic fingerprints used for integrity verification, de-duplication, or linking to content-addressed storage.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:28.350006"
  },
  {
    "resultType": "generated",
    "semanticType": "HONORIFIC_EN",
    "description": "English honorific/title prefixes used as formal address designations that precede personal names (e.g., MR., MS., DR.). Intended for short standardized tokens rather than full titles or roles.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "MR",
      "MR.",
      "MRS",
      "MRS.",
      "MS",
      "MS.",
      "MISS",
      "MX",
      "MX.",
      "DR",
      "DR.",
      "PROF",
      "PROF.",
      "REV",
      "REV.",
      "SIR",
      "DAME",
      "LORD",
      "LADY",
      "HON",
      "HON.",
      "JUDGE",
      "JUSTICE",
      "FR",
      "FR."
    ],
    "backout": "^[A-Z]{2,7}\\.?$",
    "confidenceThreshold": 95,
    "priority": 9050,
    "headerPatterns": [
      {
        "regExp": "(?i).*honorific.*prefix.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Honorific Prefix"
        ],
        "negativeExamples": [
          "Address Prefix"
        ]
      },
      {
        "regExp": "(?i).*(person|name).*title.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Person Title"
        ],
        "negativeExamples": [
          "Job Title"
        ]
      },
      {
        "regExp": "(?i).*(person|name).*prefix.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name Prefix"
        ],
        "negativeExamples": [
          "Phone Prefix"
        ]
      },
      {
        "regExp": "(?i).*honorific.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Honorific"
        ],
        "negativeExamples": [
          "Honor Roll"
        ]
      },
      {
        "regExp": "(?i).*title.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Title"
        ],
        "negativeExamples": [
          "First Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "MR.",
      "MRS",
      "MS.",
      "MISS",
      "MX",
      "DR.",
      "PROF",
      "SIR"
    ],
    "negativeContentExamples": [
      "M.",
      "MRS-",
      "MRS SMITH",
      "DOCTOR",
      "MISS.",
      "SR.",
      "HONORABLE",
      "REV JOHN"
    ],
    "positiveHeaderExamples": [
      "Title",
      "Honorific",
      "Prefix",
      "Honorific Prefix",
      "Name Prefix",
      "Person Title",
      "Formal Title",
      "Name Title"
    ],
    "negativeHeaderExamples": [
      "First Name",
      "Last Name",
      "Full Name",
      "Job Title",
      "Suffix",
      "Middle Name",
      "Preferred Name",
      "Position"
    ],
    "explanation": "This semantic type captures short English honorifics that precede personal names, enabling identification and normalization of title prefixes in person records. It is a finite, standardized set, so a list-based approach with a constrained backout pattern is used to minimize ambiguity and conflicts with job titles or suffixes.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:29.715409"
  },
  {
    "resultType": "generated",
    "semanticType": "GENDER.TEXT_JA",
    "description": "\u6027\u5225_\u65e5\u672c\u8a9e: Japanese language gender identification",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "\u7537",
      "\u7537\u6027",
      "\u5973",
      "\u5973\u6027",
      "\u305d\u306e\u4ed6",
      "\u4e0d\u660e",
      "\u672a\u56de\u7b54",
      "\u7121\u56de\u7b54",
      "\u4e0d\u8a73",
      "\u4e2d\u6027",
      "X",
      "FTM",
      "MTF",
      "\u30ce\u30f3\u30d0\u30a4\u30ca\u30ea\u30fc",
      "\u30c8\u30e9\u30f3\u30b9\u30b8\u30a7\u30f3\u30c0\u30fc",
      "\u30b8\u30a7\u30f3\u30c0\u30fc\u30af\u30a3\u30a2"
    ],
    "backout": "^[\\p{IsHan}\\p{IsHiragana}\\p{IsKatakana}A-Z]{1,12}$",
    "confidenceThreshold": 93,
    "priority": 9000,
    "headerPatterns": [
      {
        "regExp": "(?i).*\u9867\u5ba2.*\u6027\u5225.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u9867\u5ba2\u6027\u5225"
        ],
        "negativeExamples": [
          "\u9867\u5ba2\u5e74\u9f62"
        ]
      },
      {
        "regExp": "(?i).*\u30e6\u30fc\u30b6.*\u6027\u5225.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u30e6\u30fc\u30b6\u30fc\u6027\u5225"
        ],
        "negativeExamples": [
          "\u30e6\u30fc\u30b6\u30fcID"
        ]
      },
      {
        "regExp": "(?i).*\u30b8\u30a7\u30f3\u30c0\u30fc.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u30b8\u30a7\u30f3\u30c0\u30fc"
        ],
        "negativeExamples": [
          "\u30b8\u30a7\u30cd\u30ec\u30fc\u30bf\u30fc"
        ]
      },
      {
        "regExp": "(?i).*\u6027\u5225.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u6027\u5225"
        ],
        "negativeExamples": [
          "\u540d\u524d"
        ]
      },
      {
        "regExp": "(?i).*\u6027.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u6027"
        ],
        "negativeExamples": [
          "\u59d3"
        ]
      }
    ],
    "positiveContentExamples": [
      "\u7537",
      "\u7537\u6027",
      "\u5973",
      "\u5973\u6027",
      "\u305d\u306e\u4ed6",
      "\u4e0d\u660e",
      "\u30ce\u30f3\u30d0\u30a4\u30ca\u30ea\u30fc",
      "\u30c8\u30e9\u30f3\u30b9\u30b8\u30a7\u30f3\u30c0\u30fc"
    ],
    "negativeContentExamples": [
      "\u6027\u5225\u4e0d\u660e",
      "\u7537\u5b50",
      "\u5973\u5b50",
      "X\u30b8\u30a7\u30f3\u30c0\u30fc",
      "\u6027\u5225\u672a\u8a2d\u5b9a",
      "\u7121\u6027",
      "MALE",
      "FEMALE"
    ],
    "positiveHeaderExamples": [
      "\u6027\u5225",
      "\u30b8\u30a7\u30f3\u30c0\u30fc",
      "\u6027",
      "\u9867\u5ba2\u6027\u5225",
      "\u30e6\u30fc\u30b6\u30fc\u6027\u5225",
      "\u6027\u5225\uff08\u65e5\u672c\u8a9e\uff09",
      "\u4f1a\u54e1\u30b8\u30a7\u30f3\u30c0\u30fc",
      "\u793e\u54e1\u6027\u5225"
    ],
    "negativeHeaderExamples": [
      "\u540d\u524d",
      "\u5e74\u9f62",
      "\u56fd\u7c4d",
      "\u59d3",
      "\u6027\u5411",
      "\u6027\u80fd",
      "\u6027\u8cea",
      "\u751f\u5e74\u6708\u65e5"
    ],
    "explanation": "Detects Japanese-language gender values in data, such as \u7537/\u5973/\u7537\u6027/\u5973\u6027, inclusive categories like \u305d\u306e\u4ed6 and \u4e0d\u660e, and contemporary terms like \u30ce\u30f3\u30d0\u30a4\u30ca\u30ea\u30fc and \u30c8\u30e9\u30f3\u30b9\u30b8\u30a7\u30f3\u30c0\u30fc. Use when a column holds Japanese text labels for gender rather than codes or numeric encodings.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:31.306597"
  },
  {
    "resultType": "generated",
    "semanticType": "GENDER.TEXT_ZH",
    "description": "\u6027\u522b_\u4e2d\u6587: Chinese language gender identification",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "\u7537",
      "\u5973",
      "\u7537\u6027",
      "\u5973\u6027",
      "\u7537\u751f",
      "\u5973\u751f",
      "\u5176\u4ed6",
      "\u672a\u77e5",
      "\u4fdd\u5bc6",
      "\u4e0d\u8be6",
      "\u672a\u8bf4\u660e",
      "\u4e2d\u6027"
    ],
    "backout": "^[\\u4E00-\\u9FFF]{1,3}$",
    "confidenceThreshold": 97,
    "priority": 9010,
    "headerPatterns": [
      {
        "regExp": "(?i).*(\u7528\u6237|\u5ba2\u6237|\u4eba\u5458|\u5458\u5de5).*\u6027\u522b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u7528\u6237\u6027\u522b"
        ],
        "negativeExamples": [
          "\u7528\u6237\u59d3\u540d"
        ]
      },
      {
        "regExp": "(?i).*\u6027\u522b.*(\u4e2d\u6587|\u63cf\u8ff0|\u6587\u672c|\u540d\u79f0).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u6027\u522b\u4e2d\u6587"
        ],
        "negativeExamples": [
          "\u6027\u522b\u4ee3\u7801"
        ]
      },
      {
        "regExp": "(?i).*(\u7537\u5973).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u7537\u5973"
        ],
        "negativeExamples": [
          "\u59d3\u540d"
        ]
      },
      {
        "regExp": "(?i).*(\u6027\u522b\u503c|\u6027\u522b\u6807\u8bc6|\u6027\u522b\u5b57\u6bb5).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u6027\u522b\u503c"
        ],
        "negativeExamples": [
          "\u5b57\u6bb5\u540d\u79f0"
        ]
      },
      {
        "regExp": "(?i).*\u6027\u522b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u6027\u522b"
        ],
        "negativeExamples": [
          "\u59d3\u540d"
        ]
      }
    ],
    "positiveContentExamples": [
      "\u7537",
      "\u5973",
      "\u7537\u6027",
      "\u5973\u6027",
      "\u7537\u751f",
      "\u5973\u751f",
      "\u672a\u77e5",
      "\u5176\u4ed6"
    ],
    "negativeContentExamples": [
      "\u7537\u5973",
      "\u6027\u522b",
      "\u7537/\u5973",
      "\u7537\u6216\u5973",
      "\u7537\u6027\u522b",
      "\u5973\u6027\u522b",
      "\u5148\u751f",
      "\u5973\u58eb"
    ],
    "positiveHeaderExamples": [
      "\u6027\u522b",
      "\u6027",
      "\u7537\u5973",
      "\u7528\u6237\u6027\u522b",
      "\u6027\u522b\u4e2d\u6587",
      "\u6027\u522b\u63cf\u8ff0",
      "\u6027\u522b\u503c",
      "\u4eba\u5458\u6027\u522b"
    ],
    "negativeHeaderExamples": [
      "\u59d3\u540d",
      "\u5e74\u9f84",
      "\u56fd\u7c4d",
      "\u6027\u683c",
      "\u5730\u5740",
      "\u51fa\u751f\u65e5\u671f",
      "\u90e8\u95e8",
      "\u7535\u5b50\u90ae\u7bb1"
    ],
    "explanation": "This semantic type identifies gender values written in Chinese, capturing common tokens such as \u7537/\u5973 and their descriptive forms like \u7537\u6027/\u5973\u6027, as well as conventional placeholders like \u672a\u77e5\u3001\u4fdd\u5bc6\u3001\u5176\u4ed6. It is intended for columns labeled with Chinese terms indicating gender.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:33.912320"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.TEXT_DE",
    "description": "L\u00e4ndername: deutsche Nationalbezeichnung",
    "pluginType": "regex",
    "regexPattern": "\\b(Deutschland|\u00d6sterreich|Schweiz|Frankreich|Spanien|Italien|Portugal|Belgien|Niederlande|Polen|Tschechien|Ungarn|D\u00e4nemark|Schweden|Norwegen|Finnland|Irland|Griechenland|T\u00fcrkei|Kanada|Mexiko|Brasilien|Argentinien|Chile|Peru|China|Japan|Indien|Australien|Neuseeland|Marokko|S\u00fcdafrika|Elfenbeink\u00fcste)\\b|\\b([A-Z\u00c4\u00d6\u00dc][A-Za-z\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]{2,})([ \\-](von|und|der|dem|den|des|die|de|di|du|la|le|das))?([ \\-][A-Z\u00c4\u00d6\u00dc][A-Za-z\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]{2,}){1,4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 8800,
    "headerPatterns": [
      {
        "regExp": "(?i).*(l\u00e4ndername|land[\\s_-]*name|staat[\\s_-]*name|l\u00e4nder[\\s_-]*bezeichnung|staats[\\s_-]*bezeichnung).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "L\u00e4ndername"
        ],
        "negativeExamples": [
          "L\u00e4ndercode"
        ]
      },
      {
        "regExp": "(?i).*country[\\s_-]*name.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "country_name"
        ],
        "negativeExamples": [
          "country_code"
        ]
      },
      {
        "regExp": "(?i).*(l\u00e4nder|land|staat|country).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "L\u00e4nder"
        ],
        "negativeExamples": [
          "Stadt"
        ]
      },
      {
        "regExp": "(?i).*(ctry|cntry|cnty).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "ctry"
        ],
        "negativeExamples": [
          "city"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Deutschland",
      "\u00d6sterreich",
      "Schweiz",
      "Vereinigtes K\u00f6nigreich",
      "Vereinigte Staaten von Amerika",
      "Demokratische Republik Kongo",
      "Elfenbeink\u00fcste",
      "Vereinigte Arabische Emirate"
    ],
    "negativeContentExamples": [
      "deutschland",
      "berlin",
      "l\u00e4ndercode DE",
      "sprache deutsch",
      "usa",
      "vereinigte staaten von amerika",
      "frankreich-2023",
      "k\u00f6nigreich gro\u00dfbritannien"
    ],
    "positiveHeaderExamples": [
      "Land",
      "Staat",
      "L\u00e4nder",
      "L\u00e4ndername",
      "Staatsbezeichnung",
      "country_name",
      "Country Name"
    ],
    "negativeHeaderExamples": [
      "L\u00e4ndercode",
      "Stadt",
      "Sprache",
      "Country Code",
      "ISO Code",
      "Region",
      "Kundennummer"
    ],
    "explanation": "Identifies German-language country names written out as full text (e.g., Deutschland, Vereinigtes K\u00f6nigreich, Vereinigte Staaten von Amerika). Useful for columns containing national designations rather than codes or abbreviations, supporting multi-word names with common connectors and German diacritics.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:37.087251"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE_PAIR.DECIMAL",
    "description": "GPS Position: comma-separated latitude-longitude pair",
    "pluginType": "regex",
    "regexPattern": "([+-]?((90(\\.0+)?)|([0-8]?\\d(\\.\\d+)?)))\\s*,\\s*([+-]?((180(\\.0+)?)|(1[0-7]\\d(\\.\\d+)?)|(\\d{1,2}(\\.\\d+)?)))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 8760,
    "headerPatterns": [
      {
        "regExp": "(?i).*gps.*coord.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "GPS Coordinates"
        ],
        "negativeExamples": [
          "Longitude"
        ]
      },
      {
        "regExp": "(?i).*latitude.*longitude.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Latitude Longitude"
        ],
        "negativeExamples": [
          "Latitude"
        ]
      },
      {
        "regExp": "(?i).*coordinate.*pair.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Coordinate Pair"
        ],
        "negativeExamples": [
          "Coordinates"
        ]
      },
      {
        "regExp": "(?i).*lat.*long.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Lat Long"
        ],
        "negativeExamples": [
          "Lat"
        ]
      },
      {
        "regExp": "(?i).*latlng.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "LatLng"
        ],
        "negativeExamples": [
          "GPS Signal"
        ]
      },
      {
        "regExp": "(?i).*coordinate.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Coordinates"
        ],
        "negativeExamples": [
          "Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "37.7749, -122.4194",
      "-33.8688, 151.2093",
      "0, 0",
      "48.8566, 2.3522",
      "-90.0, 0.123",
      "+23.5, -45.5",
      "89.9999, 179.0",
      "-12.345, +170.75"
    ],
    "negativeContentExamples": [
      "91, 0",
      "-90.1, 0",
      "45.0 -93.0",
      "12.34; -45.0",
      "12.34, -180.5",
      "-, 45.0",
      "12.34, 200",
      "+-12.3, 45.6"
    ],
    "positiveHeaderExamples": [
      "Coordinates",
      "Lat Long",
      "GPS Coordinates",
      "Latitude Longitude",
      "Coordinate Pair",
      "LatLng",
      "Geographic Coordinates"
    ],
    "negativeHeaderExamples": [
      "Latitude",
      "Longitude",
      "Address",
      "City",
      "ZIP Code",
      "GPS Time",
      "State"
    ],
    "explanation": "Identifies a decimal latitude-longitude pair separated by a comma, allowing optional leading plus/minus signs and optional fractional parts. Latitude must be within [-90, 90] (90 only with .0+), and longitude within [-180, 180] (180 only with .0+). Typical use cases include parsing GPS positions, geocoding outputs, and map data exports.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:38.389542"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.BSN_NL",
    "description": "Dutch citizen number (Burgerservicenummer, BSN): a 9-digit national identification code.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{9}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 9080,
    "headerPatterns": [
      {
        "regExp": "(?i).*burgerservicenummer.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Burgerservicenummer"
        ],
        "negativeExamples": [
          "Naam"
        ]
      },
      {
        "regExp": "(?i).*citizen[ _-]*number.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Citizen Number"
        ],
        "negativeExamples": [
          "Phone Number"
        ]
      },
      {
        "regExp": "(?i).*national[ _-]*id.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "National ID"
        ],
        "negativeExamples": [
          "Postcode"
        ]
      },
      {
        "regExp": "(?i).*bsn.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "BSN"
        ],
        "negativeExamples": [
          "Adres"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Personal Number"
        ],
        "negativeExamples": [
          "Gebruikersnaam"
        ]
      }
    ],
    "positiveContentExamples": [
      "123456789",
      "001234567",
      "765432109",
      "219876543",
      "834729165",
      "042369718",
      "908172635",
      "570123468"
    ],
    "negativeContentExamples": [
      "12345678",
      "1234567890",
      "123 456 789",
      "123.456.789",
      "12-3456789",
      "12345678A",
      "00123456",
      "00000000"
    ],
    "positiveHeaderExamples": [
      "BSN",
      "Burgerservicenummer",
      "Citizen Number",
      "National ID",
      "Personal Number",
      "NL Citizen Number",
      "Dutch BSN"
    ],
    "negativeHeaderExamples": [
      "Naam",
      "Adres",
      "Telefoon",
      "Customer ID",
      "Postcode",
      "Phone Number",
      "Gebruikersnaam",
      "Passport Number"
    ],
    "explanation": "This type detects Dutch citizen numbers (BSN) as exactly nine consecutive digits with word boundaries. It is intended for columns explicitly labeled as BSN or a closely related national identity concept, with strong reliance on header cues to avoid misclassifying generic 9-digit numbers.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:39.177233"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.SIN_CA",
    "description": "Canadian Social Insurance Number (SIN): a 9-digit national identifier used for employment, taxation, and benefits. Accepts contiguous digits or grouped as 3-3-3 with spaces or hyphens. Does not enforce checksum validation in this pattern, focusing on format recognition.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{3}[ -]?\\d{3}[ -]?\\d{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 9160,
    "headerPatterns": [
      {
        "regExp": "(?i).*social.*insurance.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Social Insurance Number"
        ],
        "negativeExamples": [
          "Insurance Number"
        ]
      },
      {
        "regExp": "(?i).*social.*insurance.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Social Insurance"
        ],
        "negativeExamples": [
          "Insurance Type"
        ]
      },
      {
        "regExp": "(?i).*\\bsin\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SIN"
        ],
        "negativeExamples": [
          "SSN"
        ]
      },
      {
        "regExp": "(?i).*\\binsurance\\b.*\\bnumber\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Insurance Number"
        ],
        "negativeExamples": [
          "Insurance Code"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Number"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "046454286",
      "123 456 789",
      "987-654-321",
      "234567890",
      "321 654 987",
      "741-852-963",
      "159357258",
      "258 147 369"
    ],
    "negativeContentExamples": [
      "123-45-6789",
      "123 4567 89",
      "12345678",
      "1234567890",
      "12-345-6789",
      "123_456_789",
      "SIN 123456789",
      "12345678A"
    ],
    "positiveHeaderExamples": [
      "SIN",
      "Social Insurance Number",
      "SIN Number",
      "Insurance Number",
      "SIN (CA)",
      "Social Ins No",
      "Primary SIN"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Address",
      "Employer",
      "Tax ID",
      "SSN",
      "National ID",
      "Policy Number"
    ],
    "explanation": "This semantic type identifies Canadian Social Insurance Numbers, recognizing 9 digits either contiguous or grouped as 3-3-3 with optional spaces or hyphens. It is intended for columns labeled with SIN-related terms and values resembling a SIN format. The pattern avoids anchors and relies on word boundaries and explicit digit groups to reduce false positives.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:42.823515"
  },
  {
    "resultType": "generated",
    "semanticType": "HASH.SHA256_HEX",
    "description": "secure_hash: 64-character SHA-256 cryptographic digest encoded in hexadecimal (32 bytes represented as 64 hex characters). Suitable for file/content integrity verification and deduplication workflows.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9A-Fa-f]{64}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 9040,
    "headerPatterns": [
      {
        "regExp": "(?i).*sha[-_ ]?256.*(hash|digest).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SHA256 Hash"
        ],
        "negativeExamples": [
          "SHA256 Key"
        ]
      },
      {
        "regExp": "(?i).*sha2[-_ ]?256.*(hash|digest).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SHA2-256 digest"
        ],
        "negativeExamples": [
          "SHA2 Key"
        ]
      },
      {
        "regExp": "(?i).*sha[-_ ]?256.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "sha256"
        ],
        "negativeExamples": [
          "sha-1 hash"
        ]
      },
      {
        "regExp": "(?i).*(file|content).*(hash|digest).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "File Hash"
        ],
        "negativeExamples": [
          "File Size"
        ]
      },
      {
        "regExp": "(?i).*hash.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Hash"
        ],
        "negativeExamples": [
          "Password"
        ]
      }
    ],
    "positiveContentExamples": [
      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "9F86D081884C7D659A2FEAA0C55AD015A3BF4F1B2B0B822CD15D6C15B0F00A08",
      "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789",
      "0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF",
      "a1b2c3d4e5f6a7b8c9d0a1b2c3d4e5f6a7b8c9d0a1b2c3d4e5f6a7b8c9d0a1b2",
      "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
      "0000000000000000000000000000000000000000000000000000000000000000",
      "1a2b3c4d5e6f708192a3b4c5d6e7f8091a2b3c4d5e6f708192a3b4c5d6e7f809"
    ],
    "negativeContentExamples": [
      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855g",
      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b85",
      "0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08",
      "9F86D081884C7D659A2F EAA0C55AD015A3BF4F1B2B0B822CD15D6C15B0F00A08",
      "e3b0c442-98fc-1c14-9afb-f4c8996fb92427ae41e4649b934ca495991b7852b855",
      "uLShWZf+lfw2ZpNQyKug0S6JYyqz3t+u8tQ8n6r0k9s=",
      "d41d8cd98f00b204e9800998ecf8427e",
      "sha256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
    ],
    "positiveHeaderExamples": [
      "SHA256 Hash",
      "Hash",
      "File Hash",
      "sha-256 hash",
      "SHA256 digest",
      "Content Hash",
      "SHA2-256 digest"
    ],
    "negativeHeaderExamples": [
      "Filename",
      "File Size",
      "Password",
      "Checksum",
      "MD5 Hash",
      "SHA1 Hash",
      "Encryption Key"
    ],
    "explanation": "Detects hexadecimal SHA-256 digests: exactly 64 hexadecimal characters bounded by word boundaries, allowing upper or lower case. This is appropriate for columns storing file or content SHA-256 hashes used for integrity checks and deduplication. Header patterns prioritize explicit references to SHA-256 and hash/digest terminology, with a final primitive pattern for 'hash'. The regex intentionally excludes prefixed forms (e.g., 'sha256:'), hyphenated UUID-like strings, non-hex characters, and other hash lengths (e.g., MD5 32, SHA-1 40, SHA-512 128).",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:42.974664"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.NI_UK",
    "description": "UK National Insurance number style identifier: two letters, six digits, and a final letter. Optional single spaces may appear between blocks (e.g., AA 12 34 56 A or AA123456A).",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z]{2}\\s?\\d{2}\\s?\\d{2}\\s?\\d{2}\\s?[A-Za-z]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 9130,
    "headerPatterns": [
      {
        "regExp": "(?i).*national.*insurance.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "National Insurance Number"
        ],
        "negativeExamples": [
          "Insurance Number"
        ]
      },
      {
        "regExp": "(?i).*\\bni\\b.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "NI Number"
        ],
        "negativeExamples": [
          "Invoice Number"
        ]
      },
      {
        "regExp": "(?i).*\\bnino\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "NINO"
        ],
        "negativeExamples": [
          "National ID"
        ]
      },
      {
        "regExp": "(?i).*national.*insurance.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "National Insurance"
        ],
        "negativeExamples": [
          "Insurance"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Number"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "AB123456C",
      "JG 12 34 56 D",
      "ZK123456A",
      "RT 11 22 33 B",
      "HM654321A",
      "XY 98 76 54 C",
      "PL112233A",
      "ab123456c"
    ],
    "negativeContentExamples": [
      "A123456C",
      "ABC123456C",
      "AB12345C",
      "AB123456",
      "AB12-34-56C",
      "AB 12 34 56 CD",
      "123456AB",
      "AB1234567C"
    ],
    "positiveHeaderExamples": [
      "NI Number",
      "National Insurance",
      "NINO",
      "National Insurance Number",
      "NI No",
      "NINO Reference",
      "Employee NI Number",
      "NI#"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Address",
      "Employer",
      "Invoice Number",
      "Insurance Policy Number",
      "National ID",
      "Taxpayer Number",
      "Employee Code"
    ],
    "explanation": "Identifies UK-style National Insurance numbers comprised of two letters, six digits, and a trailing letter. The pattern permits optional single spaces between the two-letter prefix, each two-digit pair, and the final letter to accommodate common display formats. This type is useful for validating and classifying NI number fields in HR, payroll, and compliance datasets.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:43.231304"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.LATITUDE_DMS",
    "description": "Latitude DMS: traditional degree-minute-second coordinates",
    "pluginType": "regex",
    "regexPattern": "\\b([0-8]?\\d|90)\\s*[\u00b0dD]\\s*([0-5]?\\d)\\s*['mM]\\s*([0-5]?\\d(\\.\\d+)?)\\s*([\\\"sS]\\s*)?[NSns]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 8720,
    "headerPatterns": [
      {
        "regExp": "(?i).*latitude.*dms.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Latitude DMS"
        ],
        "negativeExamples": [
          "Decimal Latitude"
        ]
      },
      {
        "regExp": "(?i).*(latitude|lat).*(degree|deg).*(minute|min).*(second|sec).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Lat Degrees Minutes Seconds"
        ],
        "negativeExamples": [
          "Longitude Degrees"
        ]
      },
      {
        "regExp": "(?i).*(latitude|lat).*(coord|coords|coordinate|coordinates).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Latitude Coords"
        ],
        "negativeExamples": [
          "Location"
        ]
      },
      {
        "regExp": "(?i).*lat.*degrees.*",
        "confidence": 91,
        "mandatory": true,
        "positiveExamples": [
          "Lat Degrees"
        ],
        "negativeExamples": [
          "Longitude"
        ]
      },
      {
        "regExp": "(?i).*latitude.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Latitude"
        ],
        "negativeExamples": [
          "Longitude"
        ]
      }
    ],
    "positiveContentExamples": [
      "40\u00b0 26' 46\" N",
      "23\u00b0 27' 30.5\" S",
      "0\u00b0 0' 0\" N",
      "90\u00b0 0' 0\" S",
      "12\u00b034'56\" N",
      "07\u00b0 05' 09\" S",
      "45\u00b059'59.9\" N",
      "40d 26m 46s N"
    ],
    "negativeContentExamples": [
      "40\u00b0 26' N",
      "40.446\u00b0 N",
      "N 40\u00b0 26' 46\"",
      "40\u00b0 60' 00\" N",
      "91\u00b0 00' 00\" N",
      "40\u00b0 26' 46\" E",
      "40 26 46 N",
      "40\u00b026'46\""
    ],
    "positiveHeaderExamples": [
      "Latitude DMS",
      "Lat Degrees",
      "Latitude Coords",
      "Lat Degrees Minutes Seconds",
      "Lat Deg Min Sec",
      "Latitude Coordinate",
      "Latitude Position",
      "Lat Coords"
    ],
    "negativeHeaderExamples": [
      "Longitude",
      "Decimal Latitude",
      "Location",
      "Latitude Decimal Degrees",
      "Lat DD",
      "Coordinate",
      "Geo Location",
      "Long DMS"
    ],
    "explanation": "This semantic type detects latitude values expressed in traditional degree-minute-second (DMS) notation with a trailing hemisphere indicator (N or S). It expects explicit degree and minute symbols (or their letter equivalents), seconds as an integer or decimal, and validates basic numeric ranges for degrees (0\u201390), minutes (0\u201359), and seconds (0\u201359.x).",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:44.972306"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.LATITUDE_DECIMAL",
    "description": "Geographic latitude in decimal degrees representing north\u2013south position on Earth. Values range from -90 to 90, optionally signed and optionally suffixed with N or S.",
    "pluginType": "regex",
    "regexPattern": "\\b[-+]?((([0-8]?\\d(\\.\\d+)?)|90(\\.0+)?))\\b(\\s*[NSns])?",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 8710,
    "headerPatterns": [
      {
        "regExp": "(?i).*(\\blatitude\\b|\\blat\\b).*(\\bdecimal\\b|\\bdd\\b).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Latitude Decimal"
        ],
        "negativeExamples": [
          "Latitude DMS"
        ]
      },
      {
        "regExp": "(?i).*(\\bgeographic\\b|\\bgeo\\b).*\\blatitude\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Geo Latitude"
        ],
        "negativeExamples": [
          "Geo Longitude"
        ]
      },
      {
        "regExp": "(?i).*\\by[ _]?coordinate\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Y Coordinate"
        ],
        "negativeExamples": [
          "X Coordinate"
        ]
      },
      {
        "regExp": "(?i).*\\blat\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Lat"
        ],
        "negativeExamples": [
          "Lng"
        ]
      },
      {
        "regExp": "(?i).*\\bcoordinate\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Coordinate"
        ],
        "negativeExamples": [
          "Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "37.7749",
      "-23.5505",
      "+48.8566",
      "0.0",
      "90",
      "-90.0000",
      "33.9425 N",
      "12"
    ],
    "negativeContentExamples": [
      "122.4194",
      "-91",
      "90.1",
      "45\u00b012'30\"",
      "N 45.0",
      "37.7749, -122.4194",
      "33.9425 E",
      "45,1234"
    ],
    "positiveHeaderExamples": [
      "Latitude",
      "Lat",
      "Y Coordinate",
      "Latitude Decimal",
      "Geo Latitude",
      "Lat DD",
      "Latitude (DD)"
    ],
    "negativeHeaderExamples": [
      "Longitude",
      "Address",
      "City",
      "X Coordinate",
      "Coordinates",
      "Postal Code",
      "Latitude DMS",
      "LatLong"
    ],
    "explanation": "This semantic type identifies decimal latitude values in the range -90 to 90. It supports optional leading sign and optional trailing hemisphere letters N or S, and is intended for single numeric latitude values rather than coordinate pairs or DMS-formatted strings. Header recognition prioritizes explicit latitude and decimal indicators while allowing common shorthand and the Y-axis coordinate convention.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:44.972466"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.PERSONNUMMER_SE",
    "description": "Swedish personal identity number composed of a birth date followed by a 4\u2011digit individual sequence. Accepted formats include YYMMDD-XXXX, YYMMDD+XXXX, YYYYMMDD-XXXX, and contiguous forms without the separator (YYMMDDXXXX or YYYYMMDDXXXX). The date portion is constrained to realistic month/day ranges; the final digit is a checksum but is not validated by this pattern.",
    "pluginType": "regex",
    "regexPattern": "\\b((19|20)\\d\\d(0[1-9]|1[0-2])(0[1-9]|[12]\\d|3[01])[-+]?\\d{4}|\\d\\d(0[1-9]|1[0-2])(0[1-9]|[12]\\d|3[01])[-+]?\\d{4})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 9150,
    "headerPatterns": [
      {
        "regExp": "(?i).*(swedish|se).*(personnummer|personal[ _-]*identity|personal[ _-]*id|id).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Swedish ID"
        ],
        "negativeExamples": [
          "Telefon"
        ]
      },
      {
        "regExp": "(?i).*(personnummer|personal[ _-]*id|identity[ _-]*number|national[ _-]*id).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Personnummer"
        ],
        "negativeExamples": [
          "Adress"
        ]
      },
      {
        "regExp": "(?i).*(pnr|persnr|pid).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "PersNr"
        ],
        "negativeExamples": [
          "Namn"
        ]
      },
      {
        "regExp": "(?i).*(id[ _-]*number|identity[ _-]*no).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "ID Number"
        ],
        "negativeExamples": [
          "Account Number"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Number"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "850709-9805",
      "850709+9805",
      "19850709-9805",
      "198507099805",
      "700101-1234",
      "20000229-1234",
      "990101+5678",
      "20151231-4321"
    ],
    "negativeContentExamples": [
      "850709/9805",
      "19850709 9805",
      "19850132-1234",
      "990020-1234",
      "850709-980X",
      "19850709-980",
      "85070-9805",
      "19850709--9805"
    ],
    "positiveHeaderExamples": [
      "Personnummer",
      "Personal ID",
      "Swedish ID",
      "SE Personnummer",
      "National ID Number",
      "ID Number",
      "PID",
      "PersNr"
    ],
    "negativeHeaderExamples": [
      "Namn",
      "Adress",
      "Telefon",
      "Kundnummer",
      "Order ID",
      "Birth Date",
      "Postal Code",
      "Account Number"
    ],
    "explanation": "This semantic type identifies Swedish personal identity numbers, which consist of a birth date and a 4\u2011digit individual sequence. It supports common representations with or without a separator and ensures valid month/day ranges while remaining format\u2011focused. Typical use cases include validation and classification of identity numbers in customer, citizen, or employee records.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:45.053608"
  },
  {
    "resultType": "generated",
    "semanticType": "GENDER.TEXT_<LANGUAGE>",
    "description": "Free-text gender/sex labels expressed as natural language terms (e.g., male, female, non-binary, intersex), including common short forms (M, F) and identity descriptors (e.g., trans woman, cis male). Intended for columns storing descriptive gender text rather than compact codes or enumerated identifiers.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(male|female|man|woman|m|f|non[- ]?binary|nb|gender[- ]?queer|gender[- ]?fluid|agender|bigender|two[- ]?spirit|intersex|cis (male|female|man|woman)|transgender|trans (male|female|man|woman)|other|prefer not to say|undisclosed|unknown)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 8990,
    "headerPatterns": [
      {
        "regExp": "(?i).*(sex assigned at birth|birth sex|legal sex).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Sex Assigned at Birth"
        ],
        "negativeExamples": [
          "Birth Date"
        ]
      },
      {
        "regExp": "(?i).*gender.*identity.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Gender Identity"
        ],
        "negativeExamples": [
          "Identity Type"
        ]
      },
      {
        "regExp": "(?i).*(customer|user|patient|member|employee).*(gender|sex).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Patient Sex"
        ],
        "negativeExamples": [
          "Employee Status"
        ]
      },
      {
        "regExp": "(?i).*(gndr|sx).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gndr"
        ],
        "negativeExamples": [
          "addr"
        ]
      },
      {
        "regExp": "(?i).*\\bsex\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Sex"
        ],
        "negativeExamples": [
          "Essex County"
        ]
      },
      {
        "regExp": "(?i).*gender.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Gender"
        ],
        "negativeExamples": [
          "Age"
        ]
      }
    ],
    "positiveContentExamples": [
      "Male",
      "Female",
      "M",
      "F",
      "Nonbinary",
      "Genderqueer",
      "Trans woman",
      "Intersex"
    ],
    "negativeContentExamples": [
      "Mail",
      "Femal",
      "Manpower",
      "Trans",
      "Masculine",
      "Femme",
      "MF",
      "Not specified"
    ],
    "positiveHeaderExamples": [
      "Gender",
      "Sex",
      "Gender Identity",
      "Legal Sex",
      "Birth Sex",
      "Patient Gender",
      "User Sex"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Age",
      "Nationality",
      "Identity Number",
      "Essex County",
      "Customer Type",
      "Address"
    ],
    "explanation": "This semantic type detects free-text gender or sex values in datasets, recognizing common labels and identity descriptors as they typically appear in survey or profile fields. It is suitable for columns that store descriptive gender text rather than coded enumerations, and header patterns prioritize clear gender-related titles and common abbreviations.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:47.735755"
  },
  {
    "resultType": "generated",
    "semanticType": "DIRECTION",
    "description": "Compass_bearing: primary navigational orientation covering cardinal and intercardinal directions. Accepts standard abbreviations (e.g., N, SW, ENE) and spelled-out forms with optional space or hyphen (e.g., North, South-West, West North West).",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(N|S|E|W|NE|NW|SE|SW|NNE|ENE|ESE|SSE|SSW|WSW|WNW|NNW|NORTH|SOUTH|EAST|WEST|NORTHEAST|NORTHWEST|SOUTHEAST|SOUTHWEST|NORTH[- ]EAST|NORTH[- ]WEST|SOUTH[- ]EAST|SOUTH[- ]WEST|NORTH[- ]NORTH[- ]EAST|EAST[- ]NORTH[- ]EAST|EAST[- ]SOUTH[- ]EAST|SOUTH[- ]SOUTH[- ]EAST|SOUTH[- ]SOUTH[- ]WEST|WEST[- ]SOUTH[- ]WEST|WEST[- ]NORTH[- ]WEST|NORTH[- ]NORTH[- ]WEST)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 8910,
    "headerPatterns": [
      {
        "regExp": "(?i).*compass.*direction.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Compass Direction"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*cardinal.*direction.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Cardinal Direction"
        ],
        "negativeExamples": [
          "Location"
        ]
      },
      {
        "regExp": "(?i).*nav.*direction.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Navigational Direction"
        ],
        "negativeExamples": [
          "Navigator Name"
        ]
      },
      {
        "regExp": "(?i).*compass.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Compass Bearing"
        ],
        "negativeExamples": [
          "Bearing"
        ]
      },
      {
        "regExp": "(?i).*direction.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Direction"
        ],
        "negativeExamples": [
          "Distance"
        ]
      }
    ],
    "positiveContentExamples": [
      "N",
      "SW",
      "ENE",
      "SSW",
      "North",
      "Southwest",
      "East North East",
      "West North West"
    ],
    "negativeContentExamples": [
      "270\u00b0",
      "045",
      "359.9",
      "Eastbound",
      "Westerly",
      "Northing",
      "NEE",
      "NORT"
    ],
    "positiveHeaderExamples": [
      "Direction",
      "Cardinal Direction",
      "Compass Direction",
      "Navigational Direction",
      "Primary Direction",
      "Travel Direction",
      "Compass Bearing",
      "Heading Direction"
    ],
    "negativeHeaderExamples": [
      "Address",
      "Location",
      "Distance",
      "Bearing",
      "Latitude",
      "Orientation",
      "Navigator Name",
      "Route"
    ],
    "explanation": "Identifies compass directions used for navigation, supporting both abbreviated (N, SE, ENE) and spelled-out forms with optional spaces or hyphens (North, South-West, West North West). It intentionally excludes numeric bearings or degree-based values (e.g., 270\u00b0, 045), as well as directional adjectives like Eastbound or Westerly.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:52.344120"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.LONGITUDE_DECIMAL",
    "description": "Geographic Longitude: east-west decimal position",
    "pluginType": "regex",
    "regexPattern": "\\b[+-]?(180(\\.0+)?|1[0-7]\\d(\\.\\d+)?|[1-9]?\\d(\\.\\d+)?)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 8730,
    "headerPatterns": [
      {
        "regExp": "(?i).*(decimal\\s*longitude|longitude\\s*decimal|longitude\\s*deg|deg\\s*longitude|longitude\\s*degrees).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Longitude Decimal"
        ],
        "negativeExamples": [
          "Latitude Decimal"
        ]
      },
      {
        "regExp": "(?i).*(x\\s*coordinate|x\\s*coord).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "X Coordinate"
        ],
        "negativeExamples": [
          "Y Coordinate"
        ]
      },
      {
        "regExp": "(?i).*\\blongitude\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Longitude"
        ],
        "negativeExamples": [
          "Latitude"
        ]
      },
      {
        "regExp": "(?i).*\\b(lon|lng|long)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Long"
        ],
        "negativeExamples": [
          "Length"
        ]
      },
      {
        "regExp": "(?i).*coordinate.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Coordinate"
        ],
        "negativeExamples": [
          "City"
        ]
      }
    ],
    "positiveContentExamples": [
      "-122.4194",
      "0",
      "73.985656",
      "179.9999",
      "-180",
      "+12.5",
      "100",
      "-0.0001"
    ],
    "negativeContentExamples": [
      "181",
      "-180.1",
      "200",
      "73.9857W",
      "E123.45",
      "12,345",
      "180.",
      "-181"
    ],
    "positiveHeaderExamples": [
      "Longitude",
      "Long",
      "X Coordinate",
      "Longitude Decimal",
      "Geo Long",
      "Lon",
      "Lng",
      "X Coord"
    ],
    "negativeHeaderExamples": [
      "Latitude",
      "Address",
      "City",
      "Y Coordinate",
      "Postal Code",
      "Country",
      "Zip",
      "Timezone"
    ],
    "explanation": "Represents a geographic longitude expressed as a signed decimal degree value within the inclusive range [-180, 180]. Supports optional leading plus/minus and optional fractional part. Useful for identifying east\u2013west positions in geospatial datasets, often paired with latitude to form coordinate pairs.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:52.858019"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.IBAN",
    "description": "International Account: standardized cross-border bank identifier",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2}[0-9]{2}([ ]?[A-Z0-9]){11,30}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 8560,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\binternational\\b.*\\bbank\\b.*\\baccount\\b.*\\bnumber\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "International Bank Account Number"
        ],
        "negativeExamples": [
          "Account Number"
        ]
      },
      {
        "regExp": "(?i).*\\biban\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IBAN"
        ],
        "negativeExamples": [
          "Bank Name"
        ]
      },
      {
        "regExp": "(?i).*\\binternational\\b.*\\baccount\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "International Account"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*\\bbank\\b.*\\baccount\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Bank Account"
        ],
        "negativeExamples": [
          "Account Type"
        ]
      },
      {
        "regExp": "(?i).*\\bintl\\b.*\\bacct\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Intl Acct"
        ],
        "negativeExamples": [
          "Account Name"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IBAN Code"
        ],
        "negativeExamples": [
          "Account Number"
        ]
      }
    ],
    "positiveContentExamples": [
      "DE89370400440532013000",
      "GB29NWBK60161331926819",
      "FR1420041010050500013M02606",
      "NL91ABNA0417164300",
      "ES9121000418450200051332",
      "IT60X0542811101000000123456",
      "BE68539007547034",
      "DE89 3704 0044 0532 0130 00"
    ],
    "negativeContentExamples": [
      "gb29nwbk60161331926819",
      "DE89-3704-0044-0532-0130-00",
      "DE8937040044053201300",
      "AA12########*******",
      "DEXX370400440532013000",
      "12345678901234567890123456789012",
      "FR14 2004 1010 0505 00013/M02606",
      "D3K5000400440116243"
    ],
    "positiveHeaderExamples": [
      "IBAN",
      "Bank Account",
      "International Account",
      "International Bank Account Number",
      "IBAN Number",
      "Bank Account IBAN",
      "Intl Bank Account"
    ],
    "negativeHeaderExamples": [
      "Account Number",
      "Bank Name",
      "Country Code",
      "SWIFT Code",
      "Routing Number",
      "Account Type",
      "Currency Code"
    ],
    "explanation": "Identifies International Bank Account Numbers (IBAN), an alphanumeric financial identifier beginning with a two-letter country code, two check digits, followed by a country-specific BBAN. The regex accepts uppercase contiguous forms and forms with optional single spaces between characters, while disallowing hyphens and other punctuation. Use this type to detect and validate columns containing IBAN-like values for cross-border banking workflows.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:54.059319"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.INDIVIDUAL_NUMBER_JA",
    "description": "resident_id_code: 12-digit Japanese administrative identification number",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{12}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 9110,
    "headerPatterns": [
      {
        "regExp": "(?i).*(\u500b\u4eba\u756a\u53f7|\u30de\u30a4\u30ca\u30f3\u30d0\u30fc).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "\u500b\u4eba\u756a\u53f7"
        ],
        "negativeExamples": [
          "\u96fb\u8a71\u756a\u53f7"
        ]
      },
      {
        "regExp": "(?i).*\\bmy\\b.*\\bnumber\\b.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "My Number"
        ],
        "negativeExamples": [
          "\u4f4f\u6240"
        ]
      },
      {
        "regExp": "(?i).*\\bid\\b.*\\bnumber\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "ID Number"
        ],
        "negativeExamples": [
          "\u6c0f\u540d"
        ]
      },
      {
        "regExp": "(?i).*\\bpersonal\\b.*\\bnumber\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Personal Number"
        ],
        "negativeExamples": [
          "\u9867\u5ba2\u756a\u53f7"
        ]
      },
      {
        "regExp": "(?i).*\\bnumber\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "\u6c0f\u540d"
        ]
      }
    ],
    "positiveContentExamples": [
      "123456789012",
      "000123456789",
      "098765432109",
      "102938475610",
      "556677889900",
      "314159265358",
      "271828182845",
      "202401010001"
    ],
    "negativeContentExamples": [
      "12345678901",
      "1234567890123",
      "1234-5678-9012",
      "123456 789012",
      "\uff11\uff12\uff13\uff14\uff15\uff16\uff17\uff18\uff19\uff10\uff11\uff12",
      "123456789O12",
      "A23456789012",
      "00000000000"
    ],
    "positiveHeaderExamples": [
      "\u30de\u30a4\u30ca\u30f3\u30d0\u30fc",
      "\u500b\u4eba\u756a\u53f7",
      "My Number",
      "Individual Number",
      "Personal Number",
      "ID Number",
      "National ID Number",
      "\u65e5\u672c\u500b\u4eba\u756a\u53f7"
    ],
    "negativeHeaderExamples": [
      "\u6c0f\u540d",
      "\u4f4f\u6240",
      "\u96fb\u8a71\u756a\u53f7",
      "\u9867\u5ba2\u756a\u53f7",
      "\u53e3\u5ea7\u756a\u53f7",
      "Tax ID",
      "\u793e\u54e1\u756a\u53f7",
      "Email"
    ],
    "explanation": "This semantic type detects Japan's Individual Number (My Number), which is a resident identifier represented as exactly 12 ASCII digits with no separators or spaces. It is suited for validation, detection, masking, and compliance workflows where Japanese resident identification numbers must be recognized in datasets.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:54.100112"
  },
  {
    "resultType": "generated",
    "semanticType": "MONTH.FULL_<LOCALE>",
    "description": "Full month name values represented as complete month designations in a specific language/locale (e.g., January, February). Use this type when the field contains the unabbreviated textual name of the month rather than numeric or abbreviated forms.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "JANUARY",
      "FEBRUARY",
      "MARCH",
      "APRIL",
      "MAY",
      "JUNE",
      "JULY",
      "AUGUST",
      "SEPTEMBER",
      "OCTOBER",
      "NOVEMBER",
      "DECEMBER"
    ],
    "backout": "^[A-Za-z]{3,9}$",
    "confidenceThreshold": 98,
    "priority": 9320,
    "headerPatterns": [
      {
        "regExp": "(?i).*full.*month.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Full Month Name"
        ],
        "negativeExamples": [
          "Month Number"
        ]
      },
      {
        "regExp": "(?i).*month.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Month Name"
        ],
        "negativeExamples": [
          "Day"
        ]
      },
      {
        "regExp": "(?i).*full.*month.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Full Month"
        ],
        "negativeExamples": [
          "Season"
        ]
      },
      {
        "regExp": "(?i).*(mnth|mth).*name.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Mth Name"
        ],
        "negativeExamples": [
          "Mth Number"
        ]
      },
      {
        "regExp": "(?i).*month.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Month"
        ],
        "negativeExamples": [
          "Month Number"
        ]
      }
    ],
    "positiveContentExamples": [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "December"
    ],
    "negativeContentExamples": [
      "Jan",
      "September 2022",
      "09",
      "Feb",
      "Febuary",
      "2023-01",
      "Mon",
      "January-"
    ],
    "positiveHeaderExamples": [
      "Month Name",
      "Month",
      "Full Month",
      "Full Month Name",
      "Month Text",
      "Month Label"
    ],
    "negativeHeaderExamples": [
      "Month Number",
      "Day",
      "Season",
      "Month Abbrev",
      "Month Code",
      "Day Name"
    ],
    "explanation": "This semantic type targets fields that store the full textual name of a month in a given locale. It is best used when downstream logic requires a canonical, unabbreviated month string rather than numeric or abbreviated representations. Replace <LOCALE> with the appropriate locale identifier when defining localized variants.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:54.586577"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.NPI_US",
    "description": "10-digit identifier for US healthcare providers (National Provider Identifier). Values are numeric and typically presented as a contiguous 10-digit string.",
    "pluginType": "regex",
    "regexPattern": "\\b[12][0-9]{9}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 9140,
    "headerPatterns": [
      {
        "regExp": "(?i).*npi.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "NPI Number"
        ],
        "negativeExamples": [
          "Provider Name"
        ]
      },
      {
        "regExp": "(?i).*provider.*npi.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Provider NPI"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*provider.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Provider ID"
        ],
        "negativeExamples": [
          "Specialty"
        ]
      },
      {
        "regExp": "(?i).*npi.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "NPI"
        ],
        "negativeExamples": [
          "License Number"
        ]
      },
      {
        "regExp": "(?i).*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ID"
        ],
        "negativeExamples": [
          "Provider Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "1234567893",
      "1987654321",
      "1760482390",
      "2003456789",
      "1215938475",
      "2123456780",
      "1548392017",
      "2049182736"
    ],
    "negativeContentExamples": [
      "0123456789",
      "9987654321",
      "123456789",
      "12345678901",
      "12345 67890",
      "1A34567890",
      "123-4567890",
      "123456789."
    ],
    "positiveHeaderExamples": [
      "NPI",
      "Provider ID",
      "NPI Number",
      "Provider NPI",
      "NPI Identifier",
      "Practitioner NPI"
    ],
    "negativeHeaderExamples": [
      "Provider Name",
      "Specialty",
      "Address",
      "Phone Number",
      "License Number",
      "Tax ID"
    ],
    "explanation": "IDENTITY.NPI_US detects National Provider Identifiers: 10-digit numeric values commonly used to identify US healthcare providers. The value pattern enforces a 10-digit string beginning with 1 or 2 and uses header cues (e.g., NPI, Provider ID) to increase precision. This type is useful for validating and extracting provider identifiers from claims, credentialing, and enrollment datasets. It does not perform check-digit verification; match confidence relies on format and column header context.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:58.795736"
  },
  {
    "resultType": "generated",
    "semanticType": "IMEI",
    "description": "15-digit International Mobile Equipment Identity used to uniquely identify a mobile device. Accepts contiguous 15 digits or common grouped presentations with hyphens or spaces (8-6-1 or 2-6-6-1).",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{15}\\b|\\b\\d{8}[- ]\\d{6}[- ]\\d\\b|\\b\\d{2}[- ]\\d{6}[- ]\\d{6}[- ]\\d\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 9200,
    "headerPatterns": [
      {
        "regExp": "(?i).*device.*imei.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Device IMEI"
        ],
        "negativeExamples": [
          "Phone Number"
        ]
      },
      {
        "regExp": "(?i).*phone.*imei.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Phone IMEI"
        ],
        "negativeExamples": [
          "Model"
        ]
      },
      {
        "regExp": "(?i).*mobile.*equipment.*identity.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Mobile Equipment Identity"
        ],
        "negativeExamples": [
          "Brand"
        ]
      },
      {
        "regExp": "(?i).*imei.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IMEI"
        ],
        "negativeExamples": [
          "Brand"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Device Code"
        ],
        "negativeExamples": [
          "Phone Number"
        ]
      }
    ],
    "positiveContentExamples": [
      "490154203237518",
      "356938035643809",
      "359876100123456",
      "352099001761481",
      "35-209900-176148-1",
      "35209900 176148 1",
      "867933025123456",
      "861234051234567"
    ],
    "negativeContentExamples": [
      "49015420323751",
      "4901542032375189",
      "35-209900-176148",
      "35209900176148A",
      "3520 9900 1761 481",
      "35209900-1761481",
      "35_209900_176148_1",
      "35987610012345O"
    ],
    "positiveHeaderExamples": [
      "IMEI",
      "Device IMEI",
      "Phone IMEI",
      "Mobile Equipment Identity",
      "Device Code",
      "IMEI Number",
      "Handset IMEI",
      "Equipment IMEI"
    ],
    "negativeHeaderExamples": [
      "Phone Number",
      "Model",
      "Brand",
      "Serial Number",
      "IMSI",
      "ICCID",
      "MEID",
      "Device ID"
    ],
    "explanation": "This semantic type identifies IMEI values used to uniquely identify mobile equipment. The regex supports a contiguous 15-digit IMEI and common grouped formats with spaces or hyphens (8-6-1 and 2-6-6-1). It is intended for columns explicitly labeled as IMEI or mobile equipment identity and may be paired with header context to avoid misclassifying arbitrary 15-digit numbers.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:54:58.935652"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.AADHAAR_IN",
    "description": "indian_identity_code: 12-digit government-issued resident identification number",
    "pluginType": "regex",
    "regexPattern": "\\b([0-9]{12}|[0-9]{4} [0-9]{4} [0-9]{4})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 9070,
    "headerPatterns": [
      {
        "regExp": "(?i).*aadhaar.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Aadhaar Number"
        ],
        "negativeExamples": [
          "Phone Number"
        ]
      },
      {
        "regExp": "(?i).*aadhaar.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Aadhaar ID"
        ],
        "negativeExamples": [
          "Customer ID"
        ]
      },
      {
        "regExp": "(?i).*uid.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "UID Number"
        ],
        "negativeExamples": [
          "Employee Number"
        ]
      },
      {
        "regExp": "(?i).*aadhaar.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Aadhaar"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "UID"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "123456789012",
      "987654321098",
      "000112223333",
      "2345 6789 0123",
      "0192 8374 6510",
      "5555 4444 3333",
      "102938475610",
      "7001 2220 3344"
    ],
    "negativeContentExamples": [
      "12345678901",
      "1234567890123",
      "1234-5678-9012",
      "1234 56789012",
      "123456 789012",
      "1234 5678 901",
      "1234  5678 9012",
      "12345678901A"
    ],
    "positiveHeaderExamples": [
      "Aadhaar Number",
      "Aadhaar ID",
      "UID",
      "Aadhaar No",
      "UID Number",
      "Aadhaar",
      "National UID"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Address",
      "Phone Number",
      "Customer ID",
      "Tax ID",
      "Passport Number",
      "User ID",
      "Employee Number"
    ],
    "explanation": "This semantic type detects Indian Aadhaar identifiers as either a contiguous 12-digit number or three groups of four digits separated by single spaces. It is useful for privacy detection, validation, and normalization of resident identification numbers. The pattern deliberately excludes hyphenated, partially masked, or incorrectly grouped numbers to avoid false positives; header patterns provide additional context to raise confidence.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:55:01.477192"
  },
  {
    "resultType": "generated",
    "semanticType": "LANGUAGE.ISO-639-2",
    "description": "Three-letter ISO 639-2 language identifier (extended international language code). Intended for fields storing standardized 3-letter language codes (typically lowercase) such as eng, spa, fra.",
    "pluginType": "regex",
    "regexPattern": "\\b[a-z]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 9270,
    "headerPatterns": [
      {
        "regExp": "(?i).*iso.*639[-_ ]?2.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "ISO 639-2 Code"
        ],
        "negativeExamples": [
          "Two Letter Code"
        ]
      },
      {
        "regExp": "(?i).*iso.*language.*code.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "ISO Language Code"
        ],
        "negativeExamples": [
          "Language Name"
        ]
      },
      {
        "regExp": "(?i).*iso.*language.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "ISO Language"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*lang.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Lang Code"
        ],
        "negativeExamples": [
          "Language Name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Language Code"
        ],
        "negativeExamples": [
          "Language Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "eng",
      "spa",
      "fra",
      "deu",
      "zho",
      "rus",
      "ara",
      "hin"
    ],
    "negativeContentExamples": [
      "en",
      "engl",
      "en_US",
      "ENG",
      "eng1",
      "123",
      "e ng",
      "sp-"
    ],
    "positiveHeaderExamples": [
      "Language Code",
      "ISO Language",
      "Lang Code",
      "ISO 639-2 Code",
      "ISO Language Code",
      "3-letter Language Code",
      "Language Code (ISO 639-2)",
      "Lang ID (ISO-639-2)"
    ],
    "negativeHeaderExamples": [
      "Language Name",
      "Country",
      "Two Letter Code",
      "Locale",
      "Country Code",
      "ISO 639-1 Code",
      "Alpha-2 Code",
      "Dialect"
    ],
    "explanation": "This semantic type identifies fields containing ISO 639-2 three-letter language codes. It uses a strict three-lowercase-letter token pattern to reduce false positives and relies on header cues emphasizing ISO language coding.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:55:05.656100"
  },
  {
    "resultType": "generated",
    "semanticType": "IPADDRESS.IPV6",
    "description": "An IPv6 address consisting of up to eight groups of 1\u20134 hexadecimal digits separated by colons, allowing leading-zero omission and a single zero-compression sequence (::). This definition focuses on canonical IPv6 textual forms and excludes embedded IPv4 dotted-quad representations.",
    "pluginType": "regex",
    "regexPattern": "\\b(([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}|([0-9A-Fa-f]{1,4}:){1,7}:|([0-9A-Fa-f]{1,4}:){1,6}:[0-9A-Fa-f]{1,4}|([0-9A-Fa-f]{1,4}:){1,5}(:[0-9A-Fa-f]{1,4}){1,2}|([0-9A-Fa-f]{1,4}:){1,4}(:[0-9A-Fa-f]{1,4}){1,3}|([0-9A-Fa-f]{1,4}:){1,3}(:[0-9A-Fa-f]{1,4}){1,4}|([0-9A-Fa-f]{1,4}:){1,2}(:[0-9A-Fa-f]{1,4}){1,5}|[0-9A-Fa-f]{1,4}:((:[0-9A-Fa-f]{1,4}){1,6})|:((:[0-9A-Fa-f]{1,4}){1,7}|:))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 9240,
    "headerPatterns": [
      {
        "regExp": "(?i).*ipv6[ _-]*address.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "IPv6 Address"
        ],
        "negativeExamples": [
          "IPv4 Address"
        ]
      },
      {
        "regExp": "(?i).*(internet|inet)[ _-]*protocol[ _-]*v?6.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Internet Protocol v6"
        ],
        "negativeExamples": [
          "Internet Protocol v4"
        ]
      },
      {
        "regExp": "(?i).*ipv6.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IPv6"
        ],
        "negativeExamples": [
          "IPv4 Address"
        ]
      },
      {
        "regExp": "(?i).*ip[ _-]*address.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "IP Address"
        ],
        "negativeExamples": [
          "Domain Name"
        ]
      },
      {
        "regExp": "(?i).*ip.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "IP"
        ],
        "negativeExamples": [
          "MAC Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "2001:0db8:85a3:0000:0000:8a2e:0370:7334",
      "2001:db8::1",
      "fe80::1",
      "::1",
      "2001:db8:0:0:8d3:0:0:0",
      "fd12:3456:789a:1::ff",
      "2001:db8:abcd:12::abcd",
      "2001:0:0:1::1"
    ],
    "negativeContentExamples": [
      "2001:db8:85a3::8a2e::7334",
      "2001:db8:85a3:0000:0000:8a2e:0370:7334:1234",
      "2001:db8:85a3:0:0:8a2e:0370",
      "2001:gb8::1",
      "fe80:::1",
      "2001:db8:85a3:0:0:8a2e:370:7334:",
      "::ffff:192.0.2.128",
      "1200::AB00:1234::2552:7777:1313"
    ],
    "positiveHeaderExamples": [
      "IPv6 Address",
      "IPv6",
      "IP Address",
      "INET6 Address",
      "IPv6 Src",
      "IPv6 Dst",
      "Client IPv6",
      "Server IPv6"
    ],
    "negativeHeaderExamples": [
      "IPv4 Address",
      "Domain Name",
      "MAC Address",
      "URL",
      "Hostname",
      "Email",
      "Subnet Mask",
      "Gateway"
    ],
    "explanation": "Detects IPv6 textual addresses using explicit group counts, hexadecimal ranges, and controlled zero-compression. Suitable for columns storing IPv6 endpoints, client/server addresses, or network metadata, while avoiding matches to IPv4, MAC, hostnames, or URLs.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:55:12.052728"
  },
  {
    "resultType": "generated",
    "semanticType": "LANGUAGE.ISO-639-1",
    "description": "lang_code: 2-letter international language identifier. Represents ISO 639-1 language codes consisting of exactly two alphabetic characters (case-insensitive). Intended for fields that store only the language code token without region/script extensions.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b[a-z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 9260,
    "headerPatterns": [
      {
        "regExp": "(?i).*iso[-_ ]?639[-_ ]?1.*language.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISO 639-1 Language Code"
        ],
        "negativeExamples": [
          "Three Letter Code"
        ]
      },
      {
        "regExp": "(?i).*(iso.*language.*code|language.*iso.*code|iso.*lang.*code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Language ISO Code"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(language.*code|lang.*code|lng.*code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Lang Code"
        ],
        "negativeExamples": [
          "Language Name"
        ]
      },
      {
        "regExp": "(?i).*(iso.*language|language.*iso|iso.*lang).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISO Language"
        ],
        "negativeExamples": [
          "Three Letter Code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Language Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "en",
      "EN",
      "fr",
      "Es",
      "zh",
      "pt",
      "ru",
      "ja"
    ],
    "negativeContentExamples": [
      "eng",
      "enUS",
      "fr1",
      "1de",
      "ja_jp",
      "zhHans",
      "esMX",
      "ruRU"
    ],
    "positiveHeaderExamples": [
      "Language Code",
      "ISO Language",
      "Lang Code",
      "ISO 639-1 Language Code",
      "Language ISO Code",
      "ISO Language Code",
      "ISO6391 Code"
    ],
    "negativeHeaderExamples": [
      "Language Name",
      "Country",
      "Three Letter Code",
      "Locale",
      "ISO 639-2 Code",
      "Script Code",
      "Country Code"
    ],
    "explanation": "This type detects ISO 639-1 language codes, which are two-letter alphabetic identifiers such as en, fr, and zh. It is suited for columns that contain only the language code without region or script extensions. To minimize false positives due to the simple two-letter form, a higher confidence threshold and lower priority relative to more specific language/locale types are used.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:55:12.158066"
  },
  {
    "resultType": "generated",
    "semanticType": "IPADDRESS.IPV4",
    "description": "IPv4 network address consisting of four dot-separated decimal numbers (octets, 0\u2013255) used for device identification on IP networks.",
    "pluginType": "regex",
    "regexPattern": "\\b(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 9230,
    "headerPatterns": [
      {
        "regExp": "(?i).*(client|source|destination|src|dst).*(ipv4).*(address|addr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Source IPv4 Address"
        ],
        "negativeExamples": [
          "IP Address"
        ]
      },
      {
        "regExp": "(?i).*(ipv4).*(address|addr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IPv4 Address"
        ],
        "negativeExamples": [
          "Port Number"
        ]
      },
      {
        "regExp": "(?i).*(client|source|destination|src|dst).*(ip).*(address|addr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Client IP Address"
        ],
        "negativeExamples": [
          "MAC Address"
        ]
      },
      {
        "regExp": "(?i).*(ipv4|v4).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IPv4"
        ],
        "negativeExamples": [
          "Domain Name"
        ]
      },
      {
        "regExp": "(?i).*ip.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IP"
        ],
        "negativeExamples": [
          "Hostname"
        ]
      }
    ],
    "positiveContentExamples": [
      "0.0.0.0",
      "1.2.3.4",
      "10.0.0.1",
      "127.0.0.1",
      "169.254.0.10",
      "192.168.1.1",
      "203.0.113.255",
      "255.255.255.255"
    ],
    "negativeContentExamples": [
      "256.0.0.1",
      "192.168.1",
      "192.168.1.1.1",
      "192.168.01.1",
      "192.168.1.-1",
      "192.168.1.1:80",
      "abc.def.ghi.jkl",
      "2001:0db8:85a3::8a2e:0370:7334"
    ],
    "positiveHeaderExamples": [
      "IP Address",
      "IPv4",
      "IP",
      "Client IPv4 Address",
      "Source IP v4",
      "IPv4 Address",
      "IP Addr",
      "Device IP"
    ],
    "negativeHeaderExamples": [
      "Domain Name",
      "MAC Address",
      "Port Number",
      "Hostname",
      "URL",
      "Email Address",
      "Port",
      "Gateway"
    ],
    "explanation": "This semantic type identifies IPv4 addresses formatted as four decimal octets (0\u2013255) separated by dots. It is useful for classifying network fields representing device addresses in logs, configuration data, and telemetry where IPv4 addressing is expected.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:55:12.303510"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.SSN_CH",
    "description": "Swiss social security number (AHV/AVS): begins with country prefix 756 followed by segmented digit groups in the pattern 756.XXXX.XXXX.XX or 756 XXXX XXXX XX, using dots or spaces as separators.",
    "pluginType": "regex",
    "regexPattern": "\\b756[. ]\\d{4}[. ]\\d{4}[. ]\\d{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 9170,
    "headerPatterns": [
      {
        "regExp": "(?i).*sozialversicherungsnummer.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Sozialversicherungsnummer"
        ],
        "negativeExamples": [
          "AHV Nummer"
        ]
      },
      {
        "regExp": "(?i).*ahv.*nummer.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "AHV Nummer"
        ],
        "negativeExamples": [
          "Adresse"
        ]
      },
      {
        "regExp": "(?i).*(avs|ahv).*no.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "AVS No"
        ],
        "negativeExamples": [
          "Telefon"
        ]
      },
      {
        "regExp": "(?i).*(social.*security|ssn).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SSN"
        ],
        "negativeExamples": [
          "Name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Social security code"
        ],
        "negativeExamples": [
          "Kundennummer"
        ]
      }
    ],
    "positiveContentExamples": [
      "756.1234.5678.97",
      "756 9876 5432 10",
      "756.0000.0000.00",
      "756 3210 9876 54",
      "756.4321.6789.12",
      "756 1111 2222 33",
      "756.2468.1357.99",
      "756 5555 4444 22"
    ],
    "negativeContentExamples": [
      "757.1234.5678.97",
      "756-1234-5678-97",
      "756.1234.5678.9A",
      "756 12345 678 97",
      "756.123.456.78",
      "756 1234 5678 970",
      "756.1234.5678",
      "756/1234/5678/97"
    ],
    "positiveHeaderExamples": [
      "AHV Nummer",
      "SSN",
      "Sozialversicherungsnummer",
      "AHV-Nr",
      "Versichertennummer",
      "AVS No",
      "Social Security Number",
      "Social security code"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Adresse",
      "Telefon",
      "Kundennummer",
      "Steuernummer",
      "Personen-ID",
      "Employee ID",
      "Code"
    ],
    "explanation": "This type detects Swiss AHV/AVS social security numbers formatted with the fixed 3-4-4-2 digit grouping and the numeric Swiss country prefix 756, using dots or spaces as separators. It is useful for identifying and validating Swiss social insurance identifiers in customer, HR, or government datasets while avoiding looser identifiers by enforcing explicit group sizes and allowed separators.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:55:12.789485"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.LAST",
    "description": "family_name: inherited surname identifying family lineage",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z][A-Za-z' -]{1,38}[A-Za-z]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 9350,
    "headerPatterns": [
      {
        "regExp": "(?i).*last.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Last Name"
        ],
        "negativeExamples": [
          "First Name"
        ]
      },
      {
        "regExp": "(?i).*family.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Family Name"
        ],
        "negativeExamples": [
          "Full Name"
        ]
      },
      {
        "regExp": "(?i).*surname.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Surname"
        ],
        "negativeExamples": [
          "Middle Name"
        ]
      },
      {
        "regExp": "(?i).*lname.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "LName"
        ],
        "negativeExamples": [
          "User Name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "Smith",
      "O'Connor",
      "Johnson-Smith",
      "de la Cruz",
      "Van der Meer",
      "McDonald",
      "St Clair",
      "D'Angelo"
    ],
    "negativeContentExamples": [
      "A",
      "O''Connor",
      "Smith-",
      "-Smith",
      "St. Clair",
      "O\u2019Connor",
      "GARCIA3",
      "N/A"
    ],
    "positiveHeaderExamples": [
      "Last Name",
      "Surname",
      "Family Name",
      "LName",
      "LastName",
      "Customer Last Name"
    ],
    "negativeHeaderExamples": [
      "First Name",
      "Full Name",
      "Middle Name",
      "User Name",
      "Given Name",
      "Display Name"
    ],
    "explanation": "Identifies values that look like a single person\u2019s last/family surname, allowing letters with internal spaces, hyphens, and apostrophes, and excluding punctuation such as periods, digits, or trailing/leading separators. Use when a column explicitly stores the family surname rather than full names or given names.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:55:19.939512"
  },
  {
    "resultType": "generated",
    "semanticType": "INDUSTRY_CODE.NAICS",
    "description": "business_category: 6-digit North American industry classification code",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 9210,
    "headerPatterns": [
      {
        "regExp": "(?i).*naics.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "NAICS Code"
        ],
        "negativeExamples": [
          "Industry Code"
        ]
      },
      {
        "regExp": "(?i).*north.*american.*industry.*classification.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "North American Industry Classification Code"
        ],
        "negativeExamples": [
          "Industry Name"
        ]
      },
      {
        "regExp": "(?i).*industry.*classification.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Industry Classification Code"
        ],
        "negativeExamples": [
          "Company Name"
        ]
      },
      {
        "regExp": "(?i).*industry.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Industry Code"
        ],
        "negativeExamples": [
          "Business Type"
        ]
      },
      {
        "regExp": "(?i).*naics.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "NAICS"
        ],
        "negativeExamples": [
          "Industry Name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "541611",
      "311111",
      "236115",
      "423450",
      "722511",
      "517311",
      "325412",
      "812990"
    ],
    "negativeContentExamples": [
      "54161",
      "5416110",
      "54-1611",
      "541 611",
      "5416A1",
      "A541611",
      "541611A",
      "123.456"
    ],
    "positiveHeaderExamples": [
      "NAICS Code",
      "Industry Code",
      "NAICS",
      "Industry Classification Code",
      "NAICS Number",
      "North American Industry Classification Code",
      "Business Classification Code",
      "NAICS Industry Code"
    ],
    "negativeHeaderExamples": [
      "Industry Name",
      "Business Type",
      "Company Name",
      "NAICS Description",
      "Business Category",
      "Industry Sector",
      "Category Name",
      "Department Name"
    ],
    "explanation": "This semantic type identifies NAICS industry codes represented as exactly six digits. It is useful for classifying business records, linking to industry taxonomies, benchmarking, and analytics that rely on standardized North American industry classifications. The value pattern is intentionally strict to reduce collisions with other identifiers that are not explicitly labeled as NAICS.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:55:24.286257"
  },
  {
    "resultType": "generated",
    "semanticType": "PERIOD.QUARTER",
    "description": "Business quarter: a three-month period within a fiscal or calendar year. Typical values include standalone quarters (Q1\u2013Q4) and quarters associated with a year (e.g., 2023 Q1, FY2020 Q3).",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(FY[ ]?(19[0-9]{2}|20[0-9]{2})[ -]?Q[ ]?[1-4]|(19[0-9]{2}|20[0-9]{2})[ -]?Q[ ]?[1-4]|Q[ ]?[1-4][ -]?(19[0-9]{2}|20[0-9]{2})|Q[ ]?[1-4])\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 9430,
    "headerPatterns": [
      {
        "regExp": "(?i).*fiscal.*year.*\\bquarter\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Fiscal Year Quarter"
        ],
        "negativeExamples": [
          "Full Year"
        ]
      },
      {
        "regExp": "(?i).*year.*\\bquarter\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Year Quarter"
        ],
        "negativeExamples": [
          "Half Year"
        ]
      },
      {
        "regExp": "(?i).*(\\bquarterly\\b|\\bqtr\\b).*\\bperiod\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Quarterly Period"
        ],
        "negativeExamples": [
          "Billing Period"
        ]
      },
      {
        "regExp": "(?i).*(\\bqtr\\b|\\bfy\\b.*\\bqtr\\b).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "QTR"
        ],
        "negativeExamples": [
          "Month"
        ]
      },
      {
        "regExp": "(?i).*\\bquarter\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Quarter"
        ],
        "negativeExamples": [
          "Month"
        ]
      }
    ],
    "positiveContentExamples": [
      "Q1",
      "Q4",
      "2023 Q3",
      "2021-Q4",
      "FY2020 Q2",
      "Q3-2019",
      "2018Q1",
      "fy2017 q4"
    ],
    "negativeContentExamples": [
      "Q5",
      "Q0",
      "Quarter 1",
      "2023 QTR1",
      "FY20 Q1",
      "20231 Q1",
      "2023-Q05",
      "Q4 FY2020"
    ],
    "positiveHeaderExamples": [
      "Quarter",
      "Year Quarter",
      "Quarterly Period",
      "Fiscal Year Quarter",
      "Reporting Quarter",
      "QTR",
      "Calendar Quarter"
    ],
    "negativeHeaderExamples": [
      "Half Year",
      "Month",
      "Full Year",
      "Quarterback",
      "Trimester",
      "Year Month",
      "Period Number"
    ],
    "explanation": "Identifies values expressing business quarters, with or without an associated year and optional fiscal-year indicator. Useful for classifying time-based reporting fields such as financial and operational quarters.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:55:25.555136"
  },
  {
    "resultType": "generated",
    "semanticType": "MONTH.ABBR_<LOCALE>",
    "description": "Three-letter locale-specific month abbreviation (e.g., JAN, FEB, MAR). Use this type when a column contains standardized 3-letter month abbreviations for a single locale. Values are constrained to a fixed set of 12 abbreviations for the chosen locale.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "JAN",
      "FEB",
      "MAR",
      "APR",
      "MAY",
      "JUN",
      "JUL",
      "AUG",
      "SEP",
      "OCT",
      "NOV",
      "DEC"
    ],
    "backout": "^[A-Z]{3}$",
    "confidenceThreshold": 97,
    "priority": 9300,
    "headerPatterns": [
      {
        "regExp": "(?i).*(month.*abbr|abbr.*month).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Month Abbr"
        ],
        "negativeExamples": [
          "Month Name"
        ]
      },
      {
        "regExp": "(?i).*(month.*short|short.*month).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Month Short"
        ],
        "negativeExamples": [
          "Year"
        ]
      },
      {
        "regExp": "(?i).*((mth|mnth).*(abbr|short)|(abbr|short).*(mth|mnth)).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mth_abbr"
        ],
        "negativeExamples": [
          "Day"
        ]
      },
      {
        "regExp": "(?i).*(mth|mnth).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Mnth"
        ],
        "negativeExamples": [
          "Week"
        ]
      },
      {
        "regExp": "(?i).*month.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Month"
        ],
        "negativeExamples": [
          "Year"
        ]
      }
    ],
    "positiveContentExamples": [
      "JAN",
      "FEB",
      "MAR",
      "APR",
      "MAY",
      "JUN",
      "JUL",
      "AUG"
    ],
    "negativeContentExamples": [
      "JAN.",
      "JNA",
      "JULY",
      "SEPT",
      "DEC-",
      "MAYE",
      "JNE",
      "Mar"
    ],
    "positiveHeaderExamples": [
      "Month Abbr",
      "Month",
      "Month Short",
      "mth_abbr",
      "mnth_short",
      "month_abbreviation",
      "short_month",
      "Mnth"
    ],
    "negativeHeaderExamples": [
      "Month Name",
      "Day",
      "Year",
      "Week",
      "Date",
      "Quarter",
      "Season",
      "Day Name"
    ],
    "explanation": "This semantic type identifies columns that contain 3-letter month abbreviations for a single locale, from a fixed set of 12 values. It is best used when the dataset consistently uses standardized short month forms (e.g., JAN, FEB) rather than full month names or numeric month values.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:55:29.058937"
  },
  {
    "resultType": "generated",
    "semanticType": "MONTH.DIGITS",
    "description": "Calendar month represented as an integer from 1 to 12.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "10",
      "11",
      "12"
    ],
    "backout": "^[0-9]{1,2}$",
    "confidenceThreshold": 96,
    "priority": 9310,
    "headerPatterns": [
      {
        "regExp": "(?i).*month.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Month Number"
        ],
        "negativeExamples": [
          "Month Name"
        ]
      },
      {
        "regExp": "(?i).*numeric.*month.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Numeric Month"
        ],
        "negativeExamples": [
          "Year"
        ]
      },
      {
        "regExp": "(?i).*month.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Month"
        ],
        "negativeExamples": [
          "Day"
        ]
      },
      {
        "regExp": "(?i).*(mnth|mon|mo).*num.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Mon Num"
        ],
        "negativeExamples": [
          "Month Name"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Number"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "1",
      "2",
      "3",
      "4",
      "6",
      "9",
      "10",
      "12"
    ],
    "negativeContentExamples": [
      "0",
      "13",
      "01",
      "1.0",
      "7th",
      "12/01",
      "2-",
      "3 "
    ],
    "positiveHeaderExamples": [
      "Month",
      "Month Number",
      "Numeric Month",
      "Billing Month Number",
      "Txn Month Num",
      "Mon Num",
      "Mnth_Number"
    ],
    "negativeHeaderExamples": [
      "Month Name",
      "Day",
      "Year",
      "Month Code",
      "Quarter",
      "Week Number",
      "Customer Number"
    ],
    "explanation": "This semantic type identifies month values recorded strictly as the integers 1 through 12. Use it for columns where the month of year is stored as digits rather than names or abbreviations.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:55:33.098381"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.AGE",
    "description": "years_old: numerical age in completed years since birth",
    "pluginType": "regex",
    "regexPattern": "\\b(0|[1-9][0-9]{0,2})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 9450,
    "headerPatterns": [
      {
        "regExp": "(?i).*(person|customer|user).*age.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Person Age"
        ],
        "negativeExamples": [
          "Person Name"
        ]
      },
      {
        "regExp": "(?i).*years.*old.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Years Old"
        ],
        "negativeExamples": [
          "Birth Year"
        ]
      },
      {
        "regExp": "(?i).*age.*years.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Age in Years"
        ],
        "negativeExamples": [
          "Age in Months"
        ]
      },
      {
        "regExp": "(?i).*age.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Age"
        ],
        "negativeExamples": [
          "Date of Birth"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Age Number"
        ],
        "negativeExamples": [
          "Age"
        ]
      }
    ],
    "positiveContentExamples": [
      "0",
      "1",
      "7",
      "12",
      "18",
      "21",
      "45",
      "99"
    ],
    "negativeContentExamples": [
      "03",
      "1000",
      "18 years",
      "17.5",
      "-1",
      "90+",
      "1983",
      "2y"
    ],
    "positiveHeaderExamples": [
      "Age",
      "Person Age",
      "Years Old",
      "Age in Years",
      "Customer Age",
      "User Age",
      "Age Years",
      "Age Number"
    ],
    "negativeHeaderExamples": [
      "Birth Year",
      "Date of Birth",
      "Name",
      "Order Number",
      "Tenure Years",
      "Account Age",
      "Age Group",
      "Months Old"
    ],
    "explanation": "Represents a person's age in completed years as a whole number. Values are restricted to unsigned integers without text qualifiers, symbols, or decimals. Typical use cases include validating and classifying age columns in person-centric datasets and preventing misclassification of dates, birth years, or durations.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:55:34.534231"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_CA",
    "description": "Canadian postal code values in the pattern letter-digit-letter space digit-letter-digit. Matching is case-insensitive and requires a single space separator between the two blocks.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b[A-Z][0-9][A-Z] [0-9][A-Z][0-9]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 9540,
    "headerPatterns": [
      {
        "regExp": "(?i).*canad.*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Canadian Postal Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*canad.*postcode.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Canada Postcode"
        ],
        "negativeExamples": [
          "Postcode"
        ]
      },
      {
        "regExp": "(?i).*canad.*zip.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Canadian ZIP"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      },
      {
        "regExp": "(?i).*post.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "K1A 0B1",
      "M5V 3L9",
      "H2Y 2B5",
      "V6E 1B5",
      "T2P 1J9",
      "B3J 3X8",
      "R3C 4T3",
      "S7K 1P3"
    ],
    "negativeContentExamples": [
      "K1A0B1",
      "K1A-0B1",
      "K1 0B1",
      "K1A 0B",
      "1KA 0B1",
      "KA1 0B1",
      "M5V3L9",
      "K1A 0B1A"
    ],
    "positiveHeaderExamples": [
      "Postal Code",
      "Postcode",
      "Canadian ZIP",
      "CA Postal Code",
      "Canada Postcode",
      "ZIP (Canada)",
      "Recipient Postal Code",
      "Billing Postal Code"
    ],
    "negativeHeaderExamples": [
      "City",
      "Province",
      "Address",
      "ZIP Code",
      "Country",
      "Phone Number",
      "Street",
      "Order Number"
    ],
    "explanation": "This semantic type identifies Canadian postal codes with the exact structure letter-digit-letter space digit-letter-digit. It is useful for validating and standardizing address data fields specific to Canada, supporting case-insensitive input while requiring the space separator.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:55:37.195591"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.SUFFIX",
    "description": "name_extension: generational or honorific designation after surname",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(JR|JR\\.|JUNIOR|SR|SR\\.|SENIOR|II|III|IV|V|VI|VII|VIII|IX|X|ESQ|ESQ\\.|MD|M\\.D\\.|JD|J\\.D\\.|DDS|D\\.D\\.S\\.|DO|D\\.O\\.|DVM|D\\.V\\.M\\.|RN|CPA|CFA|PMP|MBA|PHD|PH\\.D\\.|LLM|LL\\.M\\.|LLB|LL\\.B\\.)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 9390,
    "headerPatterns": [
      {
        "regExp": "(?i).*name.*suffix.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name Suffix"
        ],
        "negativeExamples": [
          "First Name"
        ]
      },
      {
        "regExp": "(?i).*name.*extension.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Name Extension"
        ],
        "negativeExamples": [
          "Name Middle"
        ]
      },
      {
        "regExp": "(?i).*(person|contact|customer).*name.*suffix.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Person Name Suffix"
        ],
        "negativeExamples": [
          "Customer Name"
        ]
      },
      {
        "regExp": "(?i).*(generation|generational).*",
        "confidence": 91,
        "mandatory": true,
        "positiveExamples": [
          "Generation"
        ],
        "negativeExamples": [
          "Gender"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Account Number"
        ]
      }
    ],
    "positiveContentExamples": [
      "Jr.",
      "Sr",
      "II",
      "III",
      "IV",
      "Esq.",
      "PhD",
      "M.D."
    ],
    "negativeContentExamples": [
      "Mr.",
      "Ms.",
      "I",
      "J.D",
      "Junior Developer",
      "MD PhD",
      "SRR",
      "II."
    ],
    "positiveHeaderExamples": [
      "Name Suffix",
      "Suffix",
      "Generation",
      "Name Extension",
      "Person Name Suffix",
      "Customer Name Suffix",
      "Generational Suffix"
    ],
    "negativeHeaderExamples": [
      "First Name",
      "Last Name",
      "Full Name",
      "Name Prefix",
      "Prefix",
      "Title",
      "Middle Name"
    ],
    "explanation": "Identifies suffix tokens appended to a person's surname, such as generational indicators (e.g., Jr, Sr, III) and honorific or professional post-nominals (e.g., Esq., PhD, MD). Useful for parsing person names into components, standardizing contact records, and preserving generational/professional distinctions without conflating them with given or family names.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:55:37.783140"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.VAT_<COUNTRY>",
    "description": "tax_registration: country-specific business value-added tax identifier. Matches typical country-prefixed VAT IDs consisting of a two-letter country code followed by 8\u201312 alphanumeric characters, allowing a single space or hyphen between the prefix and the body.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2}[ -]?[A-Z0-9]{8,12}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 9190,
    "headerPatterns": [
      {
        "regExp": "(?i).*vat.*registration.*number.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "VAT Registration Number"
        ],
        "negativeExamples": [
          "VAT Number"
        ]
      },
      {
        "regExp": "(?i).*vat.*id.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "VAT ID"
        ],
        "negativeExamples": [
          "Tax ID"
        ]
      },
      {
        "regExp": "(?i).*vat.*number.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "VAT Number"
        ],
        "negativeExamples": [
          "Company Name"
        ]
      },
      {
        "regExp": "(?i).*tax.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Tax ID"
        ],
        "negativeExamples": [
          "VAT ID"
        ]
      },
      {
        "regExp": "(?i).*vat.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "VAT"
        ],
        "negativeExamples": [
          "Revenue"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "VAT Code"
        ],
        "negativeExamples": [
          "Customer Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "DE123456789",
      "FR12345678901",
      "GB123456789",
      "IT12345678901",
      "ESX1234567X",
      "BE0123456789",
      "NL123456789B01",
      "PL1234567890"
    ],
    "negativeContentExamples": [
      "de123456789",
      "D123456789",
      "123456789",
      "DE1234567",
      "DE1234567890123",
      "DE_12345678",
      "DE 1234 5678",
      "DE-1234567A#"
    ],
    "positiveHeaderExamples": [
      "VAT Number",
      "Tax ID",
      "VAT ID",
      "VAT Registration Number",
      "VAT Registration ID",
      "VAT Code",
      "Tax Registration ID",
      "VAT"
    ],
    "negativeHeaderExamples": [
      "Company Name",
      "Revenue",
      "Country",
      "Invoice Date",
      "Postal Code",
      "Customer Number",
      "Employer ID",
      "Phone Number"
    ],
    "explanation": "This semantic type identifies country-specific VAT registration identifiers used by businesses for tax purposes. It expects an uppercase two-letter country prefix followed by 8\u201312 alphanumeric characters, with an optional space or hyphen between the prefix and the body. Typical use cases include validating and classifying business VAT IDs in customer master data, invoices, and tax reporting extracts.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:55:39.214702"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_JA",
    "description": "Japan postcode: three digits, hyphen, four digits",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{3}-\\d{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 9600,
    "headerPatterns": [
      {
        "regExp": "(?i).*(japan|jp|jpn).*(postal|post|zip).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Japan Postal Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*\u90f5\u4fbf\u756a\u53f7.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u90f5\u4fbf\u756a\u53f7"
        ],
        "negativeExamples": [
          "\u90fd\u5e02"
        ]
      },
      {
        "regExp": "(?i).*(postal|zip).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*(postcode|pcode|pstcd|postalcode).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "PostalCode"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "001-0010",
      "060-0042",
      "100-0001",
      "150-0002",
      "160-0022",
      "530-0001",
      "812-0011",
      "900-0015"
    ],
    "negativeContentExamples": [
      "1000001",
      "100-001",
      "10-00001",
      "100 -0001",
      "\uff11\uff10\uff10-\uff10\uff10\uff10\uff11",
      "100\u20130001",
      "0011-0010",
      "abc-defg"
    ],
    "positiveHeaderExamples": [
      "\u90f5\u4fbf\u756a\u53f7",
      "Postal Code",
      "ZIP Code",
      "Japan Postal Code",
      "JP Postal Code",
      "JPN Postcode",
      "PostalCode"
    ],
    "negativeHeaderExamples": [
      "\u90fd\u5e02",
      "City",
      "Address",
      "State",
      "Country",
      "Phone",
      "Street"
    ],
    "explanation": "Detects Japanese postal codes in the canonical format of three digits, a hyphen, and four digits (e.g., 100-0001). Useful for validating and standardizing address datasets that include Japan-specific postal information.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:55:39.696283"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_PT",
    "description": "Portugal postal: four digits, hyphen, three digits",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{4}-\\d{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 9630,
    "headerPatterns": [
      {
        "regExp": "(?i).*(pt|portugal).*(postal|post).*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "PT Postal Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*c[o\u00f3]digo.*postal.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "C\u00f3digo Postal"
        ],
        "negativeExamples": [
          "Cidade"
        ]
      },
      {
        "regExp": "(?i).*postal.*code.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "Postcode"
        ]
      },
      {
        "regExp": "(?i).*\\bcp\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CP"
        ],
        "negativeExamples": [
          "CPU"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "City"
        ]
      }
    ],
    "positiveContentExamples": [
      "1000-001",
      "1200-045",
      "1500-250",
      "2780-157",
      "2900-203",
      "4000-123",
      "7300-999",
      "9950-042"
    ],
    "negativeContentExamples": [
      "1000001",
      "1000 001",
      "100-001",
      "1000-01",
      "1000-0012",
      "PT-1000-001",
      "1000--001",
      "12-345"
    ],
    "positiveHeaderExamples": [
      "C\u00f3digo Postal",
      "CP",
      "Postal Code",
      "PT Postal Code",
      "Portugal Postal Code",
      "C\u00f3digo Postal PT",
      "Postcode"
    ],
    "negativeHeaderExamples": [
      "Cidade",
      "City",
      "Address",
      "Postal City",
      "Postal Area",
      "Country Code",
      "Zip"
    ],
    "explanation": "Identifies Portuguese postal codes in the canonical format of four digits, a hyphen, and three digits (e.g., 1234-567). Useful for validating, parsing, and standardizing Portugal-specific addresses and location fields.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:55:39.825866"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.MARITAL_STATUS_EN",
    "description": "relationship_status: legal marriage and partnership designation",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "SINGLE",
      "NEVER MARRIED",
      "MARRIED",
      "SEPARATED",
      "LEGALLY SEPARATED",
      "DIVORCED",
      "WIDOWED",
      "CIVIL UNION",
      "DOMESTIC PARTNERSHIP",
      "COMMON-LAW MARRIAGE",
      "REGISTERED PARTNERSHIP",
      "ANNULLED"
    ],
    "backout": "^[A-Z][A-Z -]{1,39}$",
    "confidenceThreshold": 94,
    "priority": 9480,
    "headerPatterns": [
      {
        "regExp": "(?i).*marital.*status.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Marital Status"
        ],
        "negativeExamples": [
          "Marriage Status"
        ]
      },
      {
        "regExp": "(?i).*marriage.*status.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Marriage Status"
        ],
        "negativeExamples": [
          "Marital Status"
        ]
      },
      {
        "regExp": "(?i).*relationship.*status.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Relationship Status"
        ],
        "negativeExamples": [
          "Relationship Type"
        ]
      },
      {
        "regExp": "(?i).*(marital|marriage|relationship).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Marital"
        ],
        "negativeExamples": [
          "Gender"
        ]
      },
      {
        "regExp": "(?i).*(mrtl|mar|rel).*stat.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "mrtl_status"
        ],
        "negativeExamples": [
          "Status Code"
        ]
      },
      {
        "regExp": "(?i).*status.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "Status"
        ],
        "negativeExamples": [
          "State"
        ]
      }
    ],
    "positiveContentExamples": [
      "Married",
      "Single",
      "Divorced",
      "Widowed",
      "Separated",
      "Civil Union",
      "Domestic Partnership",
      "Common-law marriage"
    ],
    "negativeContentExamples": [
      "In a relationship",
      "Engaged",
      "Cohabiting",
      "Widow",
      "Never-married",
      "Legal separation",
      "Common law",
      "Domestic partner"
    ],
    "positiveHeaderExamples": [
      "Marital Status",
      "Marriage Status",
      "Relationship Status",
      "Customer Marital Status",
      "Employee Marital Status",
      "Marital",
      "Relationship",
      "Household Marital Status"
    ],
    "negativeHeaderExamples": [
      "Age",
      "Gender",
      "Name",
      "Status Code",
      "Marital State",
      "Relationship Type",
      "Country",
      "Customer Name"
    ],
    "explanation": "This semantic type identifies English-language legal marital and partnership statuses for a person, such as married, divorced, or civil union. Use it to standardize and validate fields capturing legally recognized relationship designations rather than general relationship descriptions.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:55:42.463494"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_AU",
    "description": "Australian postcode: 4-digit mail delivery area identifier used for mail routing within Australia.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 9520,
    "headerPatterns": [
      {
        "regExp": "(?i).*(australia|australian|au).*(postcode|postal[ _-]*code).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "AU Postcode"
        ],
        "negativeExamples": [
          "UK Postcode"
        ]
      },
      {
        "regExp": "(?i).*(postcode).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Postcode"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*(postal[ _-]*code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "Postal Area"
        ]
      },
      {
        "regExp": "(?i).*(zip).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "ZIP"
        ],
        "negativeExamples": [
          "Zone"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "2000",
      "3000",
      "4000",
      "5000",
      "6000",
      "7000",
      "0800",
      "2601"
    ],
    "negativeContentExamples": [
      "A2000",
      "2000A",
      "200",
      "20000",
      "2 000",
      "08O0",
      "12-34",
      "99 99"
    ],
    "positiveHeaderExamples": [
      "Postal Code",
      "Postcode",
      "ZIP",
      "AU Postcode",
      "Australian Postal Code",
      "Postcode (AU)",
      "Shipping Postcode",
      "Billing Postal Code"
    ],
    "negativeHeaderExamples": [
      "City",
      "State",
      "Address",
      "Postal Area",
      "Region",
      "Suburb",
      "Street",
      "PO Box"
    ],
    "explanation": "Detects Australian postcodes as standalone 4-digit numeric tokens. The value pattern uses word boundaries to ensure exactly four consecutive digits are recognized, minimizing accidental matches inside longer strings. Header patterns prioritize Australian-specific labels (AU/Australia + postcode) and then general postal/zip code terminology, ending with a primitive 'code' term to support broader naming variations.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:55:44.349849"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.DATE_OF_BIRTH",
    "description": "birth_date: complete calendar date of person's birth",
    "pluginType": "regex",
    "regexPattern": "\\b(\\d{4}[-/]\\d{2}[-/]\\d{2}|\\d{2}[-/]\\d{2}[-/]\\d{4}|\\d{1,2}\\s[A-Za-z]{3,9}\\s\\d{4}|[A-Za-z]{3,9}\\s\\d{1,2},\\s?\\d{4}|\\d{8})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 9470,
    "headerPatterns": [
      {
        "regExp": "(?i).*date[\\s_-]*of[\\s_-]*birth.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Date_of_Birth"
        ],
        "negativeExamples": [
          "Date of Hire"
        ]
      },
      {
        "regExp": "(?i).*birth[\\s_-]*date.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Birth Date"
        ],
        "negativeExamples": [
          "Birth Year"
        ]
      },
      {
        "regExp": "(?i).*person.*(date[\\s_-]*of[\\s_-]*birth|birth[\\s_-]*date).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Person Birth Date"
        ],
        "negativeExamples": [
          "Person Hire Date"
        ]
      },
      {
        "regExp": "(?i).*\\bdob\\b.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "DOB"
        ],
        "negativeExamples": [
          "Job Title"
        ]
      },
      {
        "regExp": "(?i).*date.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Date of Birth"
        ],
        "negativeExamples": [
          "Invoice Number"
        ]
      }
    ],
    "positiveContentExamples": [
      "1985-07-13",
      "1990/05/17",
      "17-05-1990",
      "05/17/1990",
      "17 May 1990",
      "May 17, 1990",
      "20000229",
      "1970-01-01"
    ],
    "negativeContentExamples": [
      "1990-5-17",
      "17/05/90",
      "17-May-1990",
      "1990.05.17",
      "05/17/90",
      "1990-05-17 00:00",
      "May-17-1990",
      "17 May, 90"
    ],
    "positiveHeaderExamples": [
      "Date of Birth",
      "Birth Date",
      "DOB",
      "Birthdate",
      "Date_of_Birth",
      "person_dob",
      "dateOfBirth",
      "Person Birth Date"
    ],
    "negativeHeaderExamples": [
      "Age",
      "Birth Year",
      "Name",
      "Hire Date",
      "Registration Date",
      "Invoice Date",
      "Anniversary Date",
      "Death Date"
    ],
    "explanation": "Represents a person's date of birth in common calendar date formats, including ISO (YYYY-MM-DD), numeric with slashes or hyphens (MM/DD/YYYY or DD-MM-YYYY), month-name formats (e.g., 17 May 1990, May 17, 1990), and compact YYYYMMDD. Content detection focuses on well-formed date tokens without times or extraneous text, while header patterns strongly cue on DOB-related terminology. Use this type to tag and validate columns explicitly containing birth dates for individuals.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:55:52.659747"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.LAST_FIRST",
    "description": "Formal person name with family/surname first followed by a comma and a space, then given name and optional middle names or a middle initial (e.g., \"Smith, John\" or \"McDonald, Erin K.\"). Intended for records where the canonical order is \"Last, First\" with a comma separator.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z][A-Za-z'-]{1,39}( [A-Z][A-Za-z'-]{1,39})*, [A-Z][A-Za-z'-]{1,39}(\\s[A-Z][A-Za-z'-]{1,39}){0,2}(\\s[A-Z]\\.)?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 9360,
    "headerPatterns": [
      {
        "regExp": "(?i).*(last.*first.*name).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Last First Name"
        ],
        "negativeExamples": [
          "Full Name"
        ]
      },
      {
        "regExp": "(?i).*(surname.*given.*name).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Surname Given Name"
        ],
        "negativeExamples": [
          "First Name"
        ]
      },
      {
        "regExp": "(?i).*(last.*first).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "last_first"
        ],
        "negativeExamples": [
          "first_last"
        ]
      },
      {
        "regExp": "(?i).*lname.*fname.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lname_fname"
        ],
        "negativeExamples": [
          "fname_lname"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Email Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "Smith, John",
      "O'Neil, Patrick",
      "Smith-Jones, Anne",
      "De La Cruz, Maria",
      "Van Buren, Martin",
      "D'Amico, Salvatore",
      "Lee, Jae",
      "Brown, Robert James",
      "McDonald, Erin K.",
      "SMITH, JOHN"
    ],
    "negativeContentExamples": [
      "John Smith",
      "Smith,John",
      "Smith , John",
      "O'Neil, P.",
      "D'Amico, S",
      "Smith, John Jr",
      "Chen, Ming 2",
      "St. John, Mary"
    ],
    "positiveHeaderExamples": [
      "Full Name",
      "Name",
      "Last First Name",
      "Surname Given Name",
      "last_first",
      "lname_fname",
      "Last, First",
      "Family Name, Given Name"
    ],
    "negativeHeaderExamples": [
      "First Name",
      "Last Name",
      "Email Address",
      "First Last Name",
      "fname_lname",
      "Given Surname",
      "User Email",
      "Account Name"
    ],
    "explanation": "This semantic type captures person names formatted as 'Last, First' with a required comma and space after the surname. It supports multi-token surnames (e.g., 'De La Cruz'), hyphens and apostrophes, optional middle names, and an optional middle initial after the given name. Use it to classify columns or fields where names are stored in the formal 'family name, given name' order.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:55:56.452947"
  },
  {
    "resultType": "generated",
    "semanticType": "PERIOD.YEAR_RANGE",
    "description": "A pair of four-digit years representing the beginning and ending years of a duration period. Accepts common separators such as hyphen, en dash, em dash, slash, or the word 'to' with spaces.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(1\\d{3}|20\\d{2}|21\\d{2})\\b(\\s*(-|/|\\u2013|\\u2014)\\s*|\\s+to\\s+)\\b(1\\d{3}|20\\d{2}|21\\d{2})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 9440,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\byear[ _-]*range\\b.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Year Range"
        ],
        "negativeExamples": [
          "Year"
        ]
      },
      {
        "regExp": "(?i).*\\bdate[ _-]*range\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Date Range"
        ],
        "negativeExamples": [
          "Single Date"
        ]
      },
      {
        "regExp": "(?i).*\\b(time[ _-]*span|duration|period)\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Time Span"
        ],
        "negativeExamples": [
          "Month"
        ]
      },
      {
        "regExp": "(?i).*\\b(yrs?|yr)[ _-]*range\\b.*",
        "confidence": 91,
        "mandatory": true,
        "positiveExamples": [
          "yr range"
        ],
        "negativeExamples": [
          "yr"
        ]
      },
      {
        "regExp": "(?i).*\\brange\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Range"
        ],
        "negativeExamples": [
          "Year"
        ]
      }
    ],
    "positiveContentExamples": [
      "1998-2003",
      "1999\u20132005",
      "2010 / 2015",
      "2001 to 2004",
      "1875\u20131900",
      "2021-2022",
      "2100\u20142110",
      "2000 - 2001"
    ],
    "negativeContentExamples": [
      "2008",
      "2010-12",
      "FY2010-2012",
      "2010\u2013",
      "1999/05/2007",
      "May 2010 - June 2012",
      "2010to2012",
      "2010\u20132012Q"
    ],
    "positiveHeaderExamples": [
      "Year Range",
      "Years",
      "Date Range",
      "Time Span",
      "Duration",
      "Period",
      "yr range",
      "Range"
    ],
    "negativeHeaderExamples": [
      "Year",
      "Month",
      "Single Date",
      "Start Year",
      "End Year",
      "Age Range",
      "Date",
      "Quarter"
    ],
    "explanation": "Identifies values that express a period as two four-digit calendar years with a clear separator, such as 1999\u20132005 or 2001 to 2004. Useful for classifying columns storing durations or spans expressed strictly in years (not months or full dates).",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:55:57.678834"
  },
  {
    "resultType": "generated",
    "semanticType": "JOB_TITLE_EN",
    "description": "position_title: professional role or occupation designation. Identifies English-language job/position titles such as Senior Software Engineer, Marketing Manager, Vice President, and similar role designations in HR and staffing data.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(senior|sr|junior|jr|lead|head|principal|chief|vice|vp|assistant|associate)\\b(\\s[ A-Za-z&/\\.\\-']+){0,5}\\s\\b(manager|engineer|developer|director|analyst|specialist|consultant|coordinator|administrator|officer|scientist|technician|architect|designer|recruiter|supervisor|accountant|auditor|president|nurse|teacher|driver|chef|cook|tester|vp|ceo|cfo|cio|cto|cmo|coo)\\b|\\b([A-Za-z&/\\.\\-']+\\s){1,3}\\b(manager|engineer|developer|director|analyst|specialist|consultant|coordinator|administrator|officer|scientist|technician|architect|designer|recruiter|supervisor|accountant|auditor|president|nurse|teacher|driver|chef|cook|tester|vp|ceo|cfo|cio|cto|cmo|coo)\\b|\\b(manager|engineer|developer|director|analyst|specialist|consultant|coordinator|administrator|officer|scientist|technician|architect|designer|recruiter|supervisor|accountant|auditor|president|nurse|teacher|driver|chef|cook|tester|vp|ceo|cfo|cio|cto|cmo|coo)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 9250,
    "headerPatterns": [
      {
        "regExp": "(?i).*(job|employee).*title.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Job Title"
        ],
        "negativeExamples": [
          "Company"
        ]
      },
      {
        "regExp": "(?i).*position.*title.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Position Title"
        ],
        "negativeExamples": [
          "Name"
        ]
      },
      {
        "regExp": "(?i).*occupation.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Occupation"
        ],
        "negativeExamples": [
          "Salary"
        ]
      },
      {
        "regExp": "(?i).*(job|position|occupation).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Position"
        ],
        "negativeExamples": [
          "Company"
        ]
      },
      {
        "regExp": "(?i).*title.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Title"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "Senior Software Engineer",
      "Marketing Manager",
      "Chief Financial Officer",
      "Vice President Finance",
      "VP Sales",
      "Data Scientist",
      "Product Manager II",
      "Junior QA Tester"
    ],
    "negativeContentExamples": [
      "Product Management",
      "Engineering",
      "Senior Level",
      "Management",
      "Sales Department",
      "Customer Support",
      "Business Analysis",
      "Analytics"
    ],
    "positiveHeaderExamples": [
      "Job Title",
      "Position",
      "Occupation",
      "Position Title",
      "Employee Title",
      "Role",
      "Job Role",
      "Position Name"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Company",
      "Salary",
      "Department",
      "Location",
      "Email",
      "Employee ID",
      "Hire Date"
    ],
    "explanation": "This semantic type targets English job and position titles found in HRIS, ATS, and workforce datasets. The regex relies on common role nouns (e.g., manager, engineer, director, analyst) optionally preceded by seniority/level tokens (e.g., senior, junior, lead, vice, VP) and allows typical punctuation and separators used in titles. Header patterns cover specific forms like job title and position title through to the primitive title term to improve column-level identification while avoiding overly broad matches.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:55:59.765903"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_MX",
    "description": "Mexico ZIP: five numeric digits",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 9610,
    "headerPatterns": [
      {
        "regExp": "(?i).*(c[o\u00f3]digo\\s*postal).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "C\u00f3digo Postal"
        ],
        "negativeExamples": [
          "Ciudad"
        ]
      },
      {
        "regExp": "(?i).*(mx|mexico).*(postal\\s*code|c[o\u00f3]digo\\s*postal).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "MX Postal Code"
        ],
        "negativeExamples": [
          "Postal Address"
        ]
      },
      {
        "regExp": "(?i).*(postal\\s*code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*\\bcp\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CP"
        ],
        "negativeExamples": [
          "CPU"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "01000",
      "02860",
      "11320",
      "64000",
      "77000",
      "97000",
      "99950",
      "00001"
    ],
    "negativeContentExamples": [
      "1234",
      "123456",
      "A12345",
      "12345A",
      "12 345",
      "123-45",
      "CP12345",
      "XX12345YY"
    ],
    "positiveHeaderExamples": [
      "C\u00f3digo Postal",
      "CP",
      "Postal Code",
      "MX Postal Code",
      "Codigo Postal",
      "Postal ZIP",
      "PostalCode",
      "C\u00f3digo Postal MX"
    ],
    "negativeHeaderExamples": [
      "Ciudad",
      "City",
      "Address",
      "State",
      "Province",
      "Country",
      "Street",
      "Customer Name"
    ],
    "explanation": "Identifies Mexican postal codes consisting of exactly five digits. The regex uses word boundaries to ensure the five-digit token is isolated and avoids matching alphanumeric or hyphenated sequences. Suitable for detecting standardized ZIP fields in address datasets, shipping records, or location tables where Mexico-specific postal codes are expected.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:01.057501"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.TEXT_NL",
    "description": "Landnaam: nationale aanduiding in Nederlandse taal. Volledige landnamen in het Nederlands, inclusief eventuele spaties en koppeltekens, met ondersteuning voor diacritische tekens. Codes, afkortingen en waarden met cijfers of symbolen worden uitgesloten.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z][a-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]{1,}([ -][A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]{2,}){0,5})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 8830,
    "headerPatterns": [
      {
        "regExp": "(?i).*landnaam.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Landnaam"
        ],
        "negativeExamples": [
          "Landcode"
        ]
      },
      {
        "regExp": "(?i).*land.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Land"
        ],
        "negativeExamples": [
          "Stad"
        ]
      },
      {
        "regExp": "(?i).*natie.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Natie"
        ],
        "negativeExamples": [
          "Provincie"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Nederland",
      "Belgi\u00eb",
      "Duitsland",
      "Frankrijk",
      "Verenigd Koninkrijk",
      "Verenigde Staten",
      "Zuid-Afrika",
      "Nieuw-Zeeland"
    ],
    "negativeContentExamples": [
      "nl",
      "de",
      "usa",
      "nederland 123",
      "zuid - afrika",
      "sao tome & principe",
      "nederland-",
      "belgie"
    ],
    "positiveHeaderExamples": [
      "Land",
      "Landnaam",
      "Natie",
      "Land (NL)",
      "Naam van land",
      "Nationale landnaam"
    ],
    "negativeHeaderExamples": [
      "Landcode",
      "Provincie",
      "Stad",
      "ISO landcode",
      "Nationality",
      "Country"
    ],
    "explanation": "This semantic type identifies full country names written in Dutch, allowing for multi-word names and hyphenated forms with diacritics. It intentionally excludes country codes, abbreviations, numeric suffixes, and values containing symbols. Typical use cases include validating Dutch-localized country fields in CRM, forms, surveys, or address datasets.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:02.695035"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_DE",
    "description": "German PLZ: 5-digit regional mail sorting code used within Germany for addressing and logistics. Values are exactly five digits with no separators or suffixes.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 9560,
    "headerPatterns": [
      {
        "regExp": "(?i).*(de|german).*(postleitzahl|plz|postal[ _-]*code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "German Postal Code"
        ],
        "negativeExamples": [
          "City_DE"
        ]
      },
      {
        "regExp": "(?i).*(postleitzahl|plz)[ _-]*(de|ger|deu).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "PLZ_DE"
        ],
        "negativeExamples": [
          "PLZ_code"
        ]
      },
      {
        "regExp": "(?i).*(postal|mail)[ _-]*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "Address Code"
        ]
      },
      {
        "regExp": "(?i).*(postleitzahl|plz).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postleitzahl"
        ],
        "negativeExamples": [
          "Postal"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "City"
        ]
      }
    ],
    "positiveContentExamples": [
      "10115",
      "20095",
      "28195",
      "50667",
      "65183",
      "80331",
      "04229",
      "99084"
    ],
    "negativeContentExamples": [
      "1011",
      "101150",
      "D-10115",
      "10 115",
      "10115-1234",
      "10115B",
      "101_15",
      "101.15"
    ],
    "positiveHeaderExamples": [
      "Postleitzahl",
      "PLZ",
      "Postal Code",
      "DE Postleitzahl",
      "German Postal Code",
      "PLZ_DE",
      "de_postal_code",
      "postleitzahl_de"
    ],
    "negativeHeaderExamples": [
      "Stadt",
      "City",
      "Address",
      "Province",
      "Street Name",
      "Country",
      "Zip Code",
      "Region"
    ],
    "explanation": "Identifies German postal codes (PLZ) in datasets. Matches precisely five-digit numeric strings with word boundaries to avoid partial matches. Useful for validating and extracting German addressing fields and for geocoding or logistics applications.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:06.714119"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_FR",
    "description": "French mail code: five digit sequence",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 9580,
    "headerPatterns": [
      {
        "regExp": "(?i).*(france|fr).*(postal|postale).*(code|cp).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "FR Postal Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*code[ _-]*postal.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code Postal"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*postal[ _-]*code.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "Area Code"
        ]
      },
      {
        "regExp": "(?i).*\\bcp\\b.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "CP"
        ],
        "negativeExamples": [
          "CPI"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "City"
        ]
      }
    ],
    "positiveContentExamples": [
      "01000",
      "13008",
      "29200",
      "31000",
      "44100",
      "59000",
      "75001",
      "97400"
    ],
    "negativeContentExamples": [
      "7501",
      "075001",
      "75 001",
      "75001A",
      "A75001",
      "750 01",
      "75O01",
      "FR75001"
    ],
    "positiveHeaderExamples": [
      "Code Postal",
      "CP",
      "Postal Code",
      "FR Postal Code",
      "Code postal FR",
      "Code Postal France",
      "CP (Code Postal)"
    ],
    "negativeHeaderExamples": [
      "Ville",
      "City",
      "Address",
      "Area Code",
      "Country Code",
      "ZIP",
      "Region"
    ],
    "explanation": "This semantic type identifies French postal codes as a contiguous five-digit numeric token. It is suitable for classifying columns that contain French postal codes and headers that indicate French postal context (e.g., Code Postal, CP). The regex is constrained with word boundaries to avoid matching embedded digits and header patterns follow a top-down approach from FR-specific variants to the primitive term code.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:06.816809"
  },
  {
    "resultType": "generated",
    "semanticType": "SPATIAL.GEOJSON",
    "description": "GeoJSON-formatted spatial geometry objects and collections represented as JSON text, such as Point, LineString, Polygon, Feature, and FeatureCollection structures. Intended to identify fields containing GeoJSON payloads rather than simple coordinate pairs or non-spatial JSON.",
    "pluginType": "regex",
    "regexPattern": "(?i)(\\b\\{\\s*\"(type)\"\\s*:\\s*\"(Point|LineString|Polygon|MultiPoint|MultiLineString|MultiPolygon)\"\\s*,\\s*\"(coordinates)\"\\s*:\\s*\\[|\\b\\{\\s*\"(type)\"\\s*:\\s*\"(Feature)\"\\s*,\\s*\"(geometry)\"\\s*:\\s*\\{|\\b\\{\\s*\"(type)\"\\s*:\\s*\"(FeatureCollection)\"\\s*,\\s*\"(features)\"\\s*:\\s*\\[|\\b\\{\\s*\"(type)\"\\s*:\\s*\"(GeometryCollection)\"\\s*,\\s*\"(geometries)\"\\s*:\\s*\\[)",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 9690,
    "headerPatterns": [
      {
        "regExp": "(?i).*(geojson).*(geometry|geom|feature|featurecollection|geometrycollection).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "geojson_geometry"
        ],
        "negativeExamples": [
          "Geographic Data"
        ]
      },
      {
        "regExp": "(?i).*(featurecollection|geometrycollection).*(geojson).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "featurecollection_geojson"
        ],
        "negativeExamples": [
          "Location Name"
        ]
      },
      {
        "regExp": "(?i).*(spatial|geographic).*(data).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Spatial Data"
        ],
        "negativeExamples": [
          "Coordinates"
        ]
      },
      {
        "regExp": "(?i).*(geom|geometry).*(json).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "geometry_json"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*geojson.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "GeoJSON"
        ],
        "negativeExamples": [
          "json"
        ]
      }
    ],
    "positiveContentExamples": [
      "{\"type\":\"Point\",\"coordinates\":[-120.2,38.5]}",
      "{\"type\":\"LineString\",\"coordinates\":[[30,10],[10,30],[40,40]]}",
      "{\"type\":\"Polygon\",\"coordinates\":[[[30,10],[40,40],[20,40],[10,20],[30,10]]]}",
      "{\"type\":\"Feature\",\"geometry\":{\"type\":\"Point\",\"coordinates\":[102.0,0.5]},\"properties\":{\"name\":\"A\"}}",
      "{\"type\":\"FeatureCollection\",\"features\":[{\"type\":\"Feature\",\"geometry\":{\"type\":\"Point\",\"coordinates\":[102.0,0.5]},\"properties\":{}}]}",
      "{\"type\":\"MultiPolygon\",\"coordinates\":[[[[0,0],[1,0],[1,1],[0,1],[0,0]]]]}",
      "{\"type\":\"GeometryCollection\",\"geometries\":[{\"type\":\"Point\",\"coordinates\":[100.0,0.0]},{\"type\":\"LineString\",\"coordinates\":[[101.0,0.0],[102.0,1.0]]}]}",
      "{\"type\":\"MultiPoint\",\"coordinates\":[[10,40],[40,30],[20,20],[30,10]]}"
    ],
    "negativeContentExamples": [
      "{\"type\":\"Point\",\"coord\":[-120.2,38.5]}",
      "{\"type\":\"point\",\"coords\":[-120.2,38.5]}",
      "{\"coordinates\":[-120.2,38.5]}",
      "{\"type\":\"Feature\",\"geometry\":null,\"properties\":{}}",
      "[102.0,0.5]",
      "POINT (30 10)",
      "{\"type\":\"Location\",\"coordinates\":[10,20]}",
      "{\"type\":\"FeatureCollection\",\"items\":[{\"type\":\"Feature\"}]}"
    ],
    "positiveHeaderExamples": [
      "GeoJSON",
      "Spatial Data",
      "Geographic Data",
      "geojson_geometry",
      "featurecollection_geojson",
      "geometry_json",
      "spatial_geojson"
    ],
    "negativeHeaderExamples": [
      "Coordinates",
      "Address",
      "Location Name",
      "json",
      "Geometry WKT",
      "Geo Data",
      "Geolocation"
    ],
    "explanation": "This semantic type identifies strings that contain GeoJSON structures such as geometry objects (Point, LineString, Polygon, Multi-*) and containers (Feature, FeatureCollection, GeometryCollection). It is useful for detecting spatial JSON payloads for mapping, spatial indexing, and downstream GIS processing.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:07.330267"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_IN",
    "description": "India PIN: six digit postal identifier. Six consecutive digits where the first digit is 1\u20139, optionally written with a single space or hyphen between the third and fourth digits (e.g., 560001, 560 001, 560-001).",
    "pluginType": "regex",
    "regexPattern": "\\b[1-9][0-9]{2}[ -]?[0-9]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 9590,
    "headerPatterns": [
      {
        "regExp": "(?i).*(india|indian).*(pin|postal).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "India Postal Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*pin.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "PIN Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "Area Code"
        ]
      },
      {
        "regExp": "(?i).*(pincode|postcode|zip|pin).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ZIP"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "110001",
      "560001",
      "400 001",
      "500-001",
      "700084",
      "682 001",
      "751001",
      "803101"
    ],
    "negativeContentExamples": [
      "000001",
      "11001",
      "5600 01",
      "560-01",
      "5600011",
      "A60001",
      "560_001",
      "560  001"
    ],
    "positiveHeaderExamples": [
      "PIN Code",
      "Postal Code",
      "ZIP",
      "India Postal Code",
      "Indian PIN",
      "Pincode",
      "Postcode",
      "Delivery PIN Code"
    ],
    "negativeHeaderExamples": [
      "City",
      "State",
      "Address",
      "ZIP+4",
      "Area Code",
      "Country Code",
      "Postal City",
      "Post Office Name"
    ],
    "explanation": "This semantic type identifies Indian Postal Index Numbers (PIN codes), which are six-digit numeric postal codes used across India. It matches tightly formatted six-digit values with an optional single space or hyphen delimiter after the third digit. Typical use cases include validating and extracting Indian postal codes from customer addresses, shipping records, and geospatial datasets.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:09.466260"
  },
  {
    "resultType": "generated",
    "semanticType": "SSN",
    "description": "Social Security Number formatted as three digits, hyphen, two digits, hyphen, four digits. Intended for detecting US-style personal Social Security identifiers in structured text fields.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{3}-\\d{2}-\\d{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 9710,
    "headerPatterns": [
      {
        "regExp": "(?i).*social.*security.*number.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Social Security Number"
        ],
        "negativeExamples": [
          "Social Insurance Number"
        ]
      },
      {
        "regExp": "(?i).*social.*security.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Social Security"
        ],
        "negativeExamples": [
          "Security Question"
        ]
      },
      {
        "regExp": "(?i).*ssn.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "SSN"
        ],
        "negativeExamples": [
          "SSID"
        ]
      },
      {
        "regExp": "(?i).*soc.*sec.*no.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Soc Sec No"
        ],
        "negativeExamples": [
          "Sec No"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Number"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "123-45-6789",
      "001-01-0001",
      "219-09-1234",
      "555-12-3456",
      "842-67-9031",
      "730-54-8820",
      "406-28-1193",
      "987-65-4320"
    ],
    "negativeContentExamples": [
      "123456789",
      "123-456-789",
      "12-345-6789",
      "123-45-678",
      "123-45-67890",
      "123.45.6789",
      "12a-45-6789",
      "123-4a-6789"
    ],
    "positiveHeaderExamples": [
      "SSN",
      "Social Security Number",
      "Social Security",
      "Employee SSN",
      "Customer Social Security Number",
      "Soc Sec No",
      "SSN Number"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Date of Birth",
      "Tax ID",
      "Social Insurance Number",
      "Security Question",
      "SSID",
      "Number",
      "SSO"
    ],
    "explanation": "This semantic type identifies US Social Security Numbers represented as three digits, a hyphen, two digits, a hyphen, and four digits. It is useful for redaction, validation, and privacy compliance checks in datasets containing personal identifiers.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:10.787999"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.MIDDLE_INITIAL",
    "description": "Single-letter abbreviation of a person's middle name, optionally followed by a period. Accepts only one A\u2013Z letter (case-insensitive), with an optional trailing dot; no digits, spaces within, or diacritics.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z]\\b\\.?",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 9380,
    "headerPatterns": [
      {
        "regExp": "(?i).*middle[\\s_-]*initial.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Middle Initial"
        ],
        "negativeExamples": [
          "Middle Name"
        ]
      },
      {
        "regExp": "(?i).*(person|user|employee|contact)[\\s_-]*middle[\\s_-]*initial.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Person Middle Initial"
        ],
        "negativeExamples": [
          "Employee Initials"
        ]
      },
      {
        "regExp": "(?i).*\\binitial\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Initial"
        ],
        "negativeExamples": [
          "Initials"
        ]
      },
      {
        "regExp": "(?i).*\\bmiddle\\b.*",
        "confidence": 91,
        "mandatory": true,
        "positiveExamples": [
          "Middle"
        ],
        "negativeExamples": [
          "First Name"
        ]
      },
      {
        "regExp": "(?i).*\\bmi\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "MI"
        ],
        "negativeExamples": [
          "Min"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Initial"
        ]
      }
    ],
    "positiveContentExamples": [
      "A",
      "J.",
      "m",
      "Z",
      "Q.",
      "b.",
      "x",
      "H."
    ],
    "negativeContentExamples": [
      "AB",
      "A B",
      "A..",
      "1",
      "A-",
      ".A",
      "\u00c5",
      "J.D"
    ],
    "positiveHeaderExamples": [
      "Middle Initial",
      "Middle",
      "Initial",
      "MI",
      "Person Middle Initial",
      "M. Initial"
    ],
    "negativeHeaderExamples": [
      "First Name",
      "Middle Name",
      "Full Name",
      "Initials",
      "Suffix",
      "Title",
      "Middle Index",
      "Initial Date"
    ],
    "explanation": "This semantic type identifies a single-letter middle initial, optionally followed by a period, commonly used in personal name datasets where only the initial of the middle name is stored. It is constrained to one ASCII alphabetic character with an optional trailing dot to avoid confusion with multi-letter initials or codes.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:10.822612"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_SE",
    "description": "Sweden postcode formatted as three digits, space, two digits (e.g., 123 45). Intended for datasets where postcodes are stored strictly with a single space separator.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{3} \\d{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 9640,
    "headerPatterns": [
      {
        "regExp": "(?i).*(sweden|swedish|se).*(postal|post).*(code|nummer|nr).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "SE Postal Code"
        ],
        "negativeExamples": [
          "City Code"
        ]
      },
      {
        "regExp": "(?i).*(postal|post).*(code|nummer).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "Postal Address"
        ]
      },
      {
        "regExp": "(?i).*(address|billing|shipping|mailing).*(postal|post|zip).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Billing ZIP"
        ],
        "negativeExamples": [
          "Shipping City"
        ]
      },
      {
        "regExp": "(?i).*(postcode|postnr|zip).*",
        "confidence": 91,
        "mandatory": true,
        "positiveExamples": [
          "ZIP"
        ],
        "negativeExamples": [
          "Zone"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "City"
        ]
      }
    ],
    "positiveContentExamples": [
      "114 55",
      "752 36",
      "001 23",
      "405 30",
      "226 57",
      "984 99",
      "105 10",
      "602 23"
    ],
    "negativeContentExamples": [
      "11455",
      "114-55",
      "114  55",
      "SE 114 55",
      "114 5",
      "11 455",
      "0114 55",
      "114 550"
    ],
    "positiveHeaderExamples": [
      "Postnummer",
      "Postal Code",
      "ZIP",
      "SE Postal Code",
      "Postnr",
      "Billing ZIP",
      "Shipping Postnummer",
      "Customer Postcode"
    ],
    "negativeHeaderExamples": [
      "Stad",
      "City",
      "Address",
      "Country",
      "Region",
      "Postal Address",
      "Area",
      "Street Name"
    ],
    "explanation": "This semantic type identifies Swedish postal codes in the strict NNN NN format with a single space separator. It is useful for validating and standardizing address data fields where Swedish postcodes are expected without country prefixes or hyphens.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:11.647279"
  },
  {
    "resultType": "generated",
    "semanticType": "MACADDRESS",
    "description": "Identifies Media Access Control (MAC) addresses used for network interface hardware identifiers. Matches six pairs of hexadecimal digits separated by colons or hyphens (e.g., 00:1A:2B:3C:4D:5E or 00-1A-2B-3C-4D-5E), or three groups of four hexadecimal digits separated by dots (e.g., 001A.2B3C.4D5E).",
    "pluginType": "regex",
    "regexPattern": "\\b([0-9A-Fa-f]{2}([:-][0-9A-Fa-f]{2}){5}|[0-9A-Fa-f]{4}(\\.[0-9A-Fa-f]{4}){2})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 9290,
    "headerPatterns": [
      {
        "regExp": "(?i).*(mac).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "MAC Address"
        ],
        "negativeExamples": [
          "IP Address"
        ]
      },
      {
        "regExp": "(?i).*(hardware).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Hardware Address"
        ],
        "negativeExamples": [
          "Device Name"
        ]
      },
      {
        "regExp": "(?i).*(network).*mac.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Network MAC"
        ],
        "negativeExamples": [
          "Network Name"
        ]
      },
      {
        "regExp": "(?i).*(device|interface).*mac.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Device MAC"
        ],
        "negativeExamples": [
          "Interface Name"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "00:1A:2B:3C:4D:5E",
      "00-1a-2b-3c-4d-5e",
      "AA:BB:CC:DD:EE:FF",
      "aa-bb-cc-dd-ee-ff",
      "001A.2B3C.4D5E",
      "a1:b2:c3:d4:e5:f6",
      "0A-1B-2C-3D-4E-5F",
      "0a1b.2c3d.4e5f"
    ],
    "negativeContentExamples": [
      "00:1A:2B:3C:4D",
      "00:1A:2B:3C:4D:5E:6F",
      "001A2B3C4D5E",
      "00:1G:2B:3C:4D:5E",
      "001A.2B3C.4D5",
      "001A-2B3C-4D5E",
      "AABB:CCDD:EEFF",
      "00-1A-2B-3C-4D-5E-"
    ],
    "positiveHeaderExamples": [
      "MAC Address",
      "Hardware Address",
      "Network MAC",
      "Device MAC",
      "Ethernet MAC",
      "Physical Address",
      "HWADDR"
    ],
    "negativeHeaderExamples": [
      "IP Address",
      "Device Name",
      "Network Name",
      "Email Address",
      "Postal Address",
      "Device ID"
    ],
    "explanation": "This semantic type detects MAC address values that uniquely identify network interfaces at the data link layer. It supports common notations with colon- or hyphen-separated byte pairs and the dotted-quad format often found in network devices. Typical use cases include parsing ARP tables, inventorying network interfaces, and standardizing device identifiers in logs.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:12.011697"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_CO",
    "description": "Six-digit Colombian postal code used as a departmental mail delivery identifier. Values are exactly six digits with no separators or letters.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 9550,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\b(colombia|co)\\b.*\\bpostal\\b.*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CO Postal Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*\\bc[o\u00f3]digo\\b.*\\bpostal\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "C\u00f3digo Postal"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*\\bpostal\\b.*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*\\b(zip|cp)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ZIP"
        ],
        "negativeExamples": [
          "Ciudad"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "State"
        ]
      }
    ],
    "positiveContentExamples": [
      "050001",
      "110111",
      "080001",
      "130001",
      "170001",
      "680006",
      "760001",
      "081007"
    ],
    "negativeContentExamples": [
      "11011",
      "1101110",
      "110-111",
      "110 111",
      "A10111",
      "050001CO",
      "050O01",
      "0050011"
    ],
    "positiveHeaderExamples": [
      "C\u00f3digo Postal",
      "Postal Code",
      "ZIP",
      "CO Postal Code",
      "CP",
      "ZIP Code",
      "Colombia ZIP",
      "C\u00f3digo Postal CO"
    ],
    "negativeHeaderExamples": [
      "Ciudad",
      "City",
      "Address",
      "State",
      "Country",
      "Area Code",
      "Postal City",
      "Location"
    ],
    "explanation": "This semantic type identifies Colombian postal codes, which are exactly six digits with no spaces, hyphens, or letters. It is useful for locating, validating, and standardizing Colombian mailing addresses where a precise six-digit postal code is expected.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:12.422925"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.CANTON_CH",
    "description": "Swiss region: two letter canton abbreviation. Values are the official two-letter uppercase abbreviations for the 26 Swiss cantons (e.g., ZH, BE, VD).",
    "pluginType": "regex",
    "regexPattern": "\\b(AG|AI|AR|BE|BL|BS|FR|GE|GL|GR|JU|LU|NE|NW|OW|SG|SH|SO|SZ|TG|TI|UR|VD|VS|ZG|ZH)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 9720,
    "headerPatterns": [
      {
        "regExp": "(?i).*(canton|kanton)[ _-]*(code|abbr|abbrev).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Canton Code"
        ],
        "negativeExamples": [
          "Canton Name"
        ]
      },
      {
        "regExp": "(?i).*(swiss|ch)[ _-]*(canton|kanton).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Swiss Canton"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(canton|kanton).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Kanton"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "ZH",
      "BE",
      "VD",
      "VS",
      "TI",
      "GE",
      "GR",
      "LU"
    ],
    "negativeContentExamples": [
      "ny",
      "ZRH",
      "ZH1",
      "CH",
      "BL-",
      "B E",
      "AG.",
      "LUZ"
    ],
    "positiveHeaderExamples": [
      "Canton Code",
      "Kanton",
      "Canton",
      "CH Canton Code",
      "Swiss Canton Abbrev",
      "Kanton Code",
      "Canton Abbreviation",
      "Canton Short Code"
    ],
    "negativeHeaderExamples": [
      "Canton Name",
      "Country",
      "City",
      "Province Code",
      "County",
      "Postal Code",
      "State",
      "Region Name"
    ],
    "explanation": "This semantic type detects Swiss canton abbreviations, limited to the official two-letter uppercase codes for Switzerland's 26 cantons. It is suitable for columns storing region codes in Swiss datasets and helps differentiate canton code fields from general region names or non-Swiss codes.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:12.834680"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.RACE_EN",
    "description": "English-language descriptive racial or ethnic group labels for a person, expressed as full words or phrases. Supports single or compound designations joined by separators such as and, or, /, &, or hyphen, and recognizes common pan-ethnic terms.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(american indian|alaska native|native american|indigenous|black|african american|african|white|caucasian|asian|east asian|south asian|southeast asian|native hawaiian|other pacific islander|pacific islander|middle eastern|north african|mena|hispanic|latino|latina|latinx|caribbean|west indian|two or more races|multiracial|multi[- ]?racial|biracial|bi[- ]?racial|mixed race|mixed)(([ /,&-]+| or | and )(american indian|alaska native|native american|indigenous|black|african american|african|white|caucasian|asian|east asian|south asian|southeast asian|native hawaiian|other pacific islander|pacific islander|middle eastern|north african|mena|hispanic|latino|latina|latinx|caribbean|west indian))?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 9500,
    "headerPatterns": [
      {
        "regExp": "(?i).*(race[/ -]?ethnicity|ethnicity[/ -]?race).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Race/Ethnicity"
        ],
        "negativeExamples": [
          "Race Code"
        ]
      },
      {
        "regExp": "(?i).*(racial.*group|racial.*category|race.*category).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Racial Group"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(ethnic.*group|ethnicity).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Ethnic Group"
        ],
        "negativeExamples": [
          "Nationality"
        ]
      },
      {
        "regExp": "(?i).*race.*desc.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Race Description"
        ],
        "negativeExamples": [
          "Race Code"
        ]
      },
      {
        "regExp": "(?i).*race.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Race"
        ],
        "negativeExamples": [
          "Gender"
        ]
      }
    ],
    "positiveContentExamples": [
      "White",
      "Black or African American",
      "Hispanic or Latino",
      "American Indian or Alaska Native",
      "Native Hawaiian or Other Pacific Islander",
      "Middle Eastern/North African",
      "South Asian",
      "Multiracial"
    ],
    "negativeContentExamples": [
      "W",
      "AS",
      "AI/AN",
      "African-American",
      "White/Black/Asian",
      "AsianIndian",
      "Pacific-Islander",
      "American"
    ],
    "positiveHeaderExamples": [
      "Race",
      "Ethnicity",
      "Racial Group",
      "Race Description",
      "Ethnic Group",
      "Racial Category",
      "Race/Ethnicity",
      "Person Race"
    ],
    "negativeHeaderExamples": [
      "Race Code",
      "Nationality",
      "Country",
      "Postal Code",
      "Language",
      "Gender",
      "Country of Origin",
      "State"
    ],
    "explanation": "This semantic type detects English-language racial and ethnic group designations in person-related datasets, including single labels (e.g., White, Asian) and compound categories (e.g., Black or African American, Native Hawaiian or Other Pacific Islander). It is designed to avoid coded abbreviations and nationality/country terms, focusing on descriptive group names.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:13.984829"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.TEXT_ES",
    "description": "nombre_pa\u00eds: designaci\u00f3n nacional en idioma espa\u00f1ol",
    "pluginType": "regex",
    "regexPattern": "\\b(?!Pa[i\u00ed]s\\b)(?!Naci[o\u00f3]n\\b)(?!Estado\\b)(?!Ciudad\\b)(?!Provincia\\b)(?!Departamento\\b)(?!Uni[o\u00f3]n\\b)(?!Am[e\u00e9]rica\\b)[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1][A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1]+([ -][A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1]+){0,4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 8820,
    "headerPatterns": [
      {
        "regExp": "(?i).*nombre.*pa[i\u00ed]s.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Nombre del Pa\u00eds"
        ],
        "negativeExamples": [
          "C\u00f3digo del Pa\u00eds"
        ]
      },
      {
        "regExp": "(?i).*\\bpa[i\u00ed]s\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Pa\u00eds"
        ],
        "negativeExamples": [
          "Estado"
        ]
      },
      {
        "regExp": "(?i).*\\bnaci[o\u00f3]n\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Naci\u00f3n"
        ],
        "negativeExamples": [
          "Ciudad"
        ]
      },
      {
        "regExp": "(?i).*(nom|nbre).*\\bpa[i\u00ed]s\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Nombre de Pa\u00eds"
        ],
        "negativeExamples": [
          "C\u00f3digo ISO del Pa\u00eds"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Espa\u00f1a",
      "M\u00e9xico",
      "Estados Unidos",
      "Reino Unido",
      "Costa Rica",
      "Rep\u00fablica Dominicana",
      "Emiratos \u00c1rabes Unidos",
      "Guinea-Bis\u00e1u"
    ],
    "negativeContentExamples": [
      "Estado de M\u00e9xico",
      "Ciudad de M\u00e9xico",
      "Uni\u00f3n Europea",
      "Am\u00e9rica del Sur",
      "Espa\u00f1a 2024",
      "MX",
      "Pa\u00eds",
      "Provincia de Sevilla"
    ],
    "positiveHeaderExamples": [
      "Pa\u00eds",
      "Nombre del Pa\u00eds",
      "Naci\u00f3n",
      "Nombre de Pa\u00eds",
      "Nombre Pa\u00eds",
      "Pa\u00eds de Residencia",
      "Pa\u00eds de Nacimiento",
      "Pa\u00eds Origen"
    ],
    "negativeHeaderExamples": [
      "C\u00f3digo del Pa\u00eds",
      "Estado",
      "Ciudad",
      "C\u00f3digo ISO del Pa\u00eds",
      "Provincia",
      "Departamento",
      "Nacionalidad",
      "Continente"
    ],
    "explanation": "This semantic type identifies country names written in Spanish, allowing for multi-word names, hyphens, and Spanish diacritics. It excludes generic terms and administrative subdivisions and is intended for columns where the header indicates a country name in Spanish such as 'Pa\u00eds' or 'Nombre del Pa\u00eds'. The header pattern hierarchy ensures strong alignment with columns specifically labeled as country names, while the regex pattern focuses on natural-language country names rather than codes.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:15.498714"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.ZIP5_US",
    "description": "US ZIP: five digit postal code",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 9680,
    "headerPatterns": [
      {
        "regExp": "(?i).*zip[_ ]?code[_ ]?5.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Zip Code 5"
        ],
        "negativeExamples": [
          "ZIP+4"
        ]
      },
      {
        "regExp": "(?i).*us.*zip.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "US ZIP Code"
        ],
        "negativeExamples": [
          "Postal Code CA"
        ]
      },
      {
        "regExp": "(?i).*zip.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ZIP Code"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "State"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Area"
        ]
      }
    ],
    "positiveContentExamples": [
      "00501",
      "02139",
      "10001",
      "30301",
      "60614",
      "75201",
      "85001",
      "94105"
    ],
    "negativeContentExamples": [
      "1234",
      "123456",
      "12345-6789",
      "12345 6789",
      "1234A",
      "ABCDE",
      "94105-123",
      "12 345"
    ],
    "positiveHeaderExamples": [
      "ZIP Code",
      "ZIP",
      "Postal Code",
      "ZIP5",
      "US ZIP Code",
      "Zip Code 5"
    ],
    "negativeHeaderExamples": [
      "City",
      "State",
      "ZIP+4",
      "Postcode",
      "Area Code",
      "State Code"
    ],
    "explanation": "Identifies US 5-digit ZIP Codes consisting strictly of five numeric digits, including those with leading zeros. Useful for validating and classifying US postal codes without ZIP+4 extensions, ensuring fields contain only five digits.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:15.677506"
  },
  {
    "resultType": "generated",
    "semanticType": "NATIONALITY_EN",
    "description": "citizenship_status: legal relationship to nation-state in English terms. Identifies nationality/demonym values expressed in English (e.g., American, Saudi Arabian), typically 1\u20133 tokens possibly including hyphens, with common demonym suffixes.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b([a-z]{2,}[-\\s]){0,2}[a-z]{2,}(ian|ean|an|ish|ese|i|ch)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 9400,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\b(citizenship|nationality)[_\\s-]*status\\b.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "citizenship_status"
        ],
        "negativeExamples": [
          "citizenship_id"
        ]
      },
      {
        "regExp": "(?i).*\\bnational[_\\s-]*origin\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "national_origin"
        ],
        "negativeExamples": [
          "origin_country"
        ]
      },
      {
        "regExp": "(?i).*\\b(customer|applicant|employee)[_\\s-]*(nationality|citizenship)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "applicant_nationality"
        ],
        "negativeExamples": [
          "customer_country"
        ]
      },
      {
        "regExp": "(?i).*\\b(citizenship|nationality)\\b.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Citizenship"
        ],
        "negativeExamples": [
          "Ethnicity"
        ]
      },
      {
        "regExp": "(?i).*\\bnationality\\b.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Nationality"
        ],
        "negativeExamples": [
          "Country"
        ]
      }
    ],
    "positiveContentExamples": [
      "American",
      "British",
      "French",
      "German",
      "Italian",
      "Chinese",
      "Saudi Arabian",
      "Bangladeshi"
    ],
    "negativeContentExamples": [
      "United States",
      "South Korea",
      "France",
      "Germany",
      "US",
      "EU",
      "Permanent Resident",
      "Arabic"
    ],
    "positiveHeaderExamples": [
      "Nationality",
      "Citizenship",
      "Origin",
      "Citizenship Status",
      "National Origin",
      "Employee Nationality",
      "Customer Citizenship"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Ethnicity",
      "Language",
      "Country of Residence",
      "Place of Birth",
      "Passport Number",
      "Resident Status"
    ],
    "explanation": "This semantic type targets English demonyms/nationalities indicating a person's legal or national affiliation, often used for citizenship or nationality fields. The regex accepts 1\u20133 tokens (allowing spaces or hyphens) where the final token ends with common English nationality suffixes such as -ian, -ean, -an, -ish, -ese, -i, or -ch, covering forms like American, Saudi Arabian, and French while excluding bare country names or unrelated terms.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:15.690200"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_UK",
    "description": "UK postcode: area code, space, local identifier. Matches formats like A9 9AA, A9A 9AA, A99 9AA, AA9 9AA, AA9A 9AA, AA99 9AA, and the special case GIR 0AA, requiring a single space between outward and inward parts.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(GIR 0AA|[A-Z]{1,2}[0-9][0-9A-Z]? [0-9][A-Z]{2})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 9650,
    "headerPatterns": [
      {
        "regExp": "(?i).*(shipping|billing|customer).*(uk|united.?kingdom).*post.?code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Shipping UK Post Code"
        ],
        "negativeExamples": [
          "Shipping Address"
        ]
      },
      {
        "regExp": "(?i).*(uk|united.?kingdom).*(post.?code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "UK Postcode"
        ],
        "negativeExamples": [
          "US Zip Code"
        ]
      },
      {
        "regExp": "(?i).*(uk|united.?kingdom).*zip.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "UK ZIP"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      },
      {
        "regExp": "(?i).*post.?code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postcode"
        ],
        "negativeExamples": [
          "Postal Area"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Post Code"
        ],
        "negativeExamples": [
          "City"
        ]
      }
    ],
    "positiveContentExamples": [
      "EC1A 1BB",
      "W1A 0AX",
      "M1 1AE",
      "B33 8TH",
      "CR2 6XH",
      "DN55 1PT",
      "GIR 0AA",
      "SW1A 2AA"
    ],
    "negativeContentExamples": [
      "EC1A1BB",
      "W1A-0AX",
      "M1 1A",
      "B338TH",
      "CR26XH",
      "DN55 1P",
      "GIR0AA",
      "SW1A 22A"
    ],
    "positiveHeaderExamples": [
      "Postcode",
      "Post Code",
      "UK ZIP",
      "Shipping UK Post Code",
      "Billing Postcode",
      "Recipient UK Zip",
      "Customer Post Code",
      "Delivery Postcode"
    ],
    "negativeHeaderExamples": [
      "City",
      "County",
      "Address",
      "Zip4",
      "Postal Area",
      "Country Code",
      "State/Province",
      "Street Code"
    ],
    "explanation": "Identifies UK postcodes that include an outward code and an inward code separated by a single space, including the special case GIR 0AA. Useful for validating and standardizing UK address data where the presence of the space is required.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:16.347452"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.ZIP5_PLUS4_US",
    "description": "US extended ZIP: five digits, hyphen, four digits",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{5}-\\d{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 9670,
    "headerPatterns": [
      {
        "regExp": "(?i).*zip\\+4.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ZIP+4"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      },
      {
        "regExp": "(?i).*extended.*zip.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Extended ZIP"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*zip.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ZIP Code"
        ],
        "negativeExamples": [
          "State"
        ]
      },
      {
        "regExp": "(?i).*zipcode.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "zipcode"
        ],
        "negativeExamples": [
          "ZIP"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "02139-4307",
      "10001-0001",
      "30301-1234",
      "33131-6543",
      "73301-0001",
      "20500-0001",
      "85260-7890",
      "96815-1234"
    ],
    "negativeContentExamples": [
      "02139",
      "02139 4307",
      "021394307",
      "2139-4307",
      "02139-430",
      "02139\u20134307",
      "02139-43O7",
      "02139 -4307"
    ],
    "positiveHeaderExamples": [
      "ZIP+4",
      "ZIP Code",
      "Extended ZIP",
      "ZIP4",
      "Postal code",
      "US ZIP+4",
      "Zip+4 Code",
      "zipcode"
    ],
    "negativeHeaderExamples": [
      "City",
      "State",
      "ZIP Code",
      "ZIP",
      "Area Code",
      "Postcode",
      "Country",
      "Address Line"
    ],
    "explanation": "Identifies US ZIP+4 postal codes formatted as five digits, a hyphen, and four digits. Use when the dataset specifically stores extended ZIP codes rather than the basic 5-digit ZIP.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:17.029773"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_BG",
    "description": "bulgarian_postcode: 4-digit regional mail sorting identifier. Accepts exactly four digits without a leading zero, representing Bulgarian postal codes.",
    "pluginType": "regex",
    "regexPattern": "\\b[1-9][0-9]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 9530,
    "headerPatterns": [
      {
        "regExp": "(?i).*(bulgarian|bg).*(postal|post).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "BG postal code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*\u043f\u043e\u0449\u0435\u043d\u0441\u043a\u0438.*\u043a\u043e\u0434.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u041f\u043e\u0449\u0435\u043d\u0441\u043a\u0438 \u043a\u043e\u0434"
        ],
        "negativeExamples": [
          "\u0413\u0440\u0430\u0434"
        ]
      },
      {
        "regExp": "(?i).*post[ _-]?code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postcode"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*postal[ _-]?code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*(postcode|zip|pcode).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ZIP"
        ],
        "negativeExamples": [
          "Region"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Country"
        ]
      }
    ],
    "positiveContentExamples": [
      "1000",
      "1421",
      "1784",
      "2100",
      "4003",
      "5300",
      "7001",
      "8132"
    ],
    "negativeContentExamples": [
      "0100",
      "0999",
      "100",
      "10000",
      "12-34",
      "BG-1000",
      "100A",
      "1 000"
    ],
    "positiveHeaderExamples": [
      "\u041f\u043e\u0449\u0435\u043d\u0441\u043a\u0438 \u043a\u043e\u0434",
      "Postal Code",
      "Code",
      "Postcode",
      "ZIP",
      "Bulgarian postal code",
      "BG postal code",
      "\u041f\u043e\u0449\u0435\u043d\u0441\u043a\u0438 \u043a\u043e\u0434 BG"
    ],
    "negativeHeaderExamples": [
      "\u0413\u0440\u0430\u0434",
      "City",
      "Address",
      "Street",
      "Municipality",
      "Province",
      "Country",
      "Region"
    ],
    "explanation": "This semantic type identifies Bulgarian postal codes, which are strictly four-digit numbers from 1000 to 9999 with no leading zeros. It is intended for columns labeled as postal/postcode indicators, including Bulgarian Cyrillic headers, and validates content using a tight numeric pattern to avoid false positives.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:18.878242"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_FIPS_US",
    "description": "US county code: five digit FIPS identifier where the first two digits identify the state (01\u201356) and the last three digits identify the county (001\u2013999). This detects standalone 5-digit county FIPS codes within text using token boundaries.",
    "pluginType": "regex",
    "regexPattern": "\\b(0[1-9]|[1-4][0-9]|5[0-6])(00[1-9]|0[1-9][0-9]|[1-9][0-9]{2})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 9750,
    "headerPatterns": [
      {
        "regExp": "(?i).*county.*fips.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "County FIPS Code"
        ],
        "negativeExamples": [
          "County Code"
        ]
      },
      {
        "regExp": "(?i).*(county|cnty).*fips.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "County FIPS"
        ],
        "negativeExamples": [
          "FIPS Code"
        ]
      },
      {
        "regExp": "(?i).*fips.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "FIPS Code"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      },
      {
        "regExp": "(?i).*(county|cnty).*code.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "County Code"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "01001",
      "06037",
      "17031",
      "36061",
      "53033",
      "48201",
      "09003",
      "12086"
    ],
    "negativeContentExamples": [
      "00001",
      "01000",
      "57001",
      "060370",
      "06-037",
      "36061A",
      "0900",
      "1234A"
    ],
    "positiveHeaderExamples": [
      "County FIPS",
      "FIPS Code",
      "County Code",
      "County FIPS Code",
      "FIPS County Code",
      "County FIPS ID",
      "County FIPS No"
    ],
    "negativeHeaderExamples": [
      "County Name",
      "State",
      "City",
      "ZIP Code",
      "Country Code",
      "FIPS State Code",
      "Region Code"
    ],
    "explanation": "Identifies five-digit US county FIPS codes, enforcing valid state prefixes (01\u201356) and county suffixes (001\u2013999). Useful for detecting or validating columns that store county-level FIPS identifiers, especially when headers reference FIPS or county code.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:20.446290"
  },
  {
    "resultType": "generated",
    "semanticType": "PERIOD.HALF",
    "description": "year_half: six-month period designation within annual cycle",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(h[12]|hy[12]|[12]h)\\b|\\b(1st|2nd)\\s+half\\b|\\b(first|second)\\s+half\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 9420,
    "headerPatterns": [
      {
        "regExp": "(?i).*(year[-_ ]?half|half[-_ ]?year).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Year Half"
        ],
        "negativeExamples": [
          "Full Year"
        ]
      },
      {
        "regExp": "(?i).*half[-_ ]?year.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Half Year"
        ],
        "negativeExamples": [
          "Quarter"
        ]
      },
      {
        "regExp": "(?i).*yr[-_ ]?half.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Yr Half"
        ],
        "negativeExamples": [
          "Year Half"
        ]
      },
      {
        "regExp": "(?i).*(\\bh[12]\\b|\\bhy[12]\\b|\\b[12]h\\b).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "H1/H2"
        ],
        "negativeExamples": [
          "Q1"
        ]
      },
      {
        "regExp": "(?i).*half.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Half"
        ],
        "negativeExamples": [
          "Quarter"
        ]
      }
    ],
    "positiveContentExamples": [
      "H1",
      "H2",
      "HY1",
      "HY2",
      "1H",
      "2H",
      "First Half",
      "2nd Half"
    ],
    "negativeContentExamples": [
      "Q1",
      "H3",
      "3H",
      "HY3",
      "2ndHalf",
      "H 1",
      "Half 2",
      "First Quarter"
    ],
    "positiveHeaderExamples": [
      "Half Year",
      "Half",
      "Year Half",
      "Yr Half",
      "Half Period",
      "H1/H2",
      "Half of Year"
    ],
    "negativeHeaderExamples": [
      "Quarter",
      "Month",
      "Full Year",
      "Fiscal Year",
      "Quarter Number",
      "Month Name",
      "Year",
      "Semester"
    ],
    "explanation": "Identifies half-year period indicators, such as H1/H2, HY1/HY2, 1H/2H, and textual forms like First Half or Second Half. Useful for fields that segment a year into two six-month spans aligned to H1 and H2 without implying specific months.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:21.771477"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.AGE_RANGE",
    "description": "Age bracket indicating a span of years for demographic categorization. Typical formats include bounded ranges (e.g., 18-24, 45 to 54), upper-bound labels (Under 18), and open-ended upper ranges (65+ or 65 and over).",
    "pluginType": "regex",
    "regexPattern": "\\b((under|less than)\\s*[0-9]{1,2}|[0-9]{1,2}\\s*[-\u2013]\\s*[0-9]{1,2}|[0-9]{1,2}\\s*to\\s*[0-9]{1,2}|[0-9]{1,2}\\b\\s*\\+|[0-9]{1,2}\\s*(and over|and older|or older|and above|and up)|[0-9]{1,2}\\s*(and under|or younger|and younger))(\\s*(years|yrs|yo|y))?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 92,
    "priority": 9460,
    "headerPatterns": [
      {
        "regExp": "(?i).*(age[_\\s-]*(range|group|bracket)).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Age Range"
        ],
        "negativeExamples": [
          "Age"
        ]
      },
      {
        "regExp": "(?i).*(age[_\\s-]*(band|cohort)).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Age Band"
        ],
        "negativeExamples": [
          "Band"
        ]
      },
      {
        "regExp": "(?i).*(demograph.*age.*(range|group)).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Demographic Age Group"
        ],
        "negativeExamples": [
          "Demographic Group"
        ]
      },
      {
        "regExp": "(?i).*(age[_\\s-]*(grp|rng|brkt)).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Age grp"
        ],
        "negativeExamples": [
          "Grp"
        ]
      },
      {
        "regExp": "(?i).*range.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Range"
        ],
        "negativeExamples": [
          "Value"
        ]
      }
    ],
    "positiveContentExamples": [
      "18-24",
      "25\u201334",
      "35 - 44",
      "45 to 54",
      "65+",
      "Under 18",
      "18 and over",
      "13 to 17 yrs"
    ],
    "negativeContentExamples": [
      "18",
      "65 years",
      "2010-2012",
      ">=65",
      "65 and below",
      "under-18",
      "18 & over",
      "100+"
    ],
    "positiveHeaderExamples": [
      "Age Range",
      "Age Group",
      "Age Bracket",
      "Age Band",
      "Age Cohort",
      "Demographic Age Group",
      "Age rng",
      "Age grp"
    ],
    "negativeHeaderExamples": [
      "Age",
      "Birth Year",
      "Name",
      "Range Start",
      "Cohort",
      "Ageing",
      "Group Size",
      "Date Range"
    ],
    "explanation": "This semantic type identifies age brackets commonly used in demographic analysis, including closed ranges (e.g., 18-24, 45 to 54), open-ended upper ranges (e.g., 65+, 70 and over), and upper-bound labels (e.g., Under 18). It is useful for categorizing individuals into standardized age cohorts for reporting, segmentation, or compliance.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:26.126965"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_ES",
    "description": "Spanish postal code (C\u00f3digo Postal): exactly five digits with no separators or letters. Values consist solely of five consecutive numeric characters.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 9570,
    "headerPatterns": [
      {
        "regExp": "(?i).*(c[o\u00f3]digo\\s*postal|postal\\s*code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "C\u00f3digo Postal"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*(post\\s*code|postcode).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postcode"
        ],
        "negativeExamples": [
          "Post Office"
        ]
      },
      {
        "regExp": "(?i).*\\bpostal\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*\\bcp\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CP"
        ],
        "negativeExamples": [
          "CPU"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "28013",
      "08001",
      "46002",
      "20001",
      "01004",
      "07003",
      "41001",
      "03002"
    ],
    "negativeContentExamples": [
      "2801",
      "280134",
      "28-013",
      "2801A",
      "A8013",
      "28 013",
      "28O13",
      "280_13"
    ],
    "positiveHeaderExamples": [
      "C\u00f3digo Postal",
      "CP",
      "Postal Code",
      "Postcode",
      "Codigo Postal",
      "Spanish Postal Code",
      "CP Espa\u00f1a",
      "C\u00f3digo Postal (ES)"
    ],
    "negativeHeaderExamples": [
      "Ciudad",
      "City",
      "Address",
      "Province Code",
      "ZIP+4",
      "Country",
      "Street",
      "County"
    ],
    "explanation": "This semantic type detects Spanish postal codes (C\u00f3digo Postal), which are exactly five digits without spaces, hyphens, or letters. Use it to classify and validate columns that store Spain ZIP/postal codes in datasets with Spanish addresses or location data.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:28.915241"
  },
  {
    "resultType": "generated",
    "semanticType": "SPATIAL.WKT",
    "description": "Spatial geometry represented in Well-Known Text (WKT) format, a text-based encoding of vector geometries such as POINT, LINESTRING, POLYGON, MULTIPOINT, MULTILINESTRING, MULTIPOLYGON, and GEOMETRYCOLLECTION. Supports optional dimensional flags (Z/M/ZM) and optional SRID=####; prefixes.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(SRID=\\d{1,6};\\s*)?(POINT|LINESTRING|POLYGON|MULTIPOINT|MULTILINESTRING|MULTIPOLYGON|GEOMETRYCOLLECTION)\\s*(Z|M|ZM)?\\s*\\(\\s*[0-9+\\-.,\\s()]+\\)",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 9700,
    "headerPatterns": [
      {
        "regExp": "(?i).*(well\\s*known\\s*text|\\bwkt\\b).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Well Known Text"
        ],
        "negativeExamples": [
          "WKID"
        ]
      },
      {
        "regExp": "(?i).*(geom(etry)?[_\\s-]*wkt).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "geometry_wkt"
        ],
        "negativeExamples": [
          "geometry_type"
        ]
      },
      {
        "regExp": "(?i).*(spatial[_\\s-]*geometry).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Spatial Geometry"
        ],
        "negativeExamples": [
          "GeoJSON"
        ]
      },
      {
        "regExp": "(?i).*(geometry\\s*text).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "geometry text"
        ],
        "negativeExamples": [
          "Coordinates"
        ]
      },
      {
        "regExp": "(?i).*geometry.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "geometry"
        ],
        "negativeExamples": [
          "geography"
        ]
      }
    ],
    "positiveContentExamples": [
      "POINT (30 10)",
      "POINT Z (30 10 5)",
      "SRID=4326; POINT (30 10)",
      "LINESTRING (30 10, 10 30, 40 40)",
      "POLYGON ((30 10, 40 40, 20 40, 10 20, 30 10))",
      "MULTIPOINT ((10 40), (40 30), (20 20))",
      "MULTILINESTRING ((10 10, 20 20), (15 15, 30 15))",
      "MULTIPOLYGON (((30 20, 45 40, 10 40, 30 20)), ((15 5, 40 10, 10 20, 5 10, 15 5)))"
    ],
    "negativeContentExamples": [
      "POINT 30 10",
      "LINESTRING (30,10 40,40)",
      "POLYGON (30 10, 40 40, 20 40, 10 20, 30 10)",
      "SRID=abc; POINT (30 10)",
      "GeoJSON: {\"type\":\"Point\",\"coordinates\":[30,10]}",
      "MULTIPOINT (10, 40)",
      "SRID=4326 POINT (30 10)",
      "Coordinates: 30,10"
    ],
    "positiveHeaderExamples": [
      "WKT",
      "Well Known Text",
      "Spatial Geometry",
      "geometry_wkt",
      "geom wkt",
      "geometry text"
    ],
    "negativeHeaderExamples": [
      "GeoJSON",
      "Coordinates",
      "Address",
      "WKID",
      "geometry_type",
      "spatial_ref"
    ],
    "explanation": "This semantic type detects Well-Known Text (WKT) spatial geometries. It recognizes standard geometry keywords (POINT, LINESTRING, POLYGON, MULTI*, GEOMETRYCOLLECTION), optional dimensional flags (Z/M/ZM), and an optional SRID=####; prefix, followed by coordinate tuples within parentheses. Use it to classify columns that store vector geometry in WKT form across diverse spatial datasets.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:33.147324"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_UY",
    "description": "Uruguay postal code: five consecutive digits with no separators, prefixes, or suffixes. Matches a standalone 5-digit token bounded by non-word characters or string boundaries.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 9660,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\b(uruguay|uy)\\b.*\\b(c[\u00f3o]digo\\s*postal|postal\\s*code|zip\\s*code|cp)\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "UY Postal Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*\\bc[\u00f3o]digo\\s*postal\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "C\u00f3digo Postal"
        ],
        "negativeExamples": [
          "C\u00f3digo"
        ]
      },
      {
        "regExp": "(?i).*\\bpostal\\s*code\\b.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*\\b(cp|zip|postcode)\\b.*",
        "confidence": 91,
        "mandatory": true,
        "positiveExamples": [
          "CP"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "City"
        ]
      }
    ],
    "positiveContentExamples": [
      "11000",
      "11200",
      "11400",
      "12001",
      "12900",
      "20350",
      "45002",
      "70000"
    ],
    "negativeContentExamples": [
      "1100",
      "110000",
      "11 000",
      "11-000",
      "A11000",
      "11000A",
      "123 45",
      "7 0000"
    ],
    "positiveHeaderExamples": [
      "C\u00f3digo Postal",
      "CP",
      "Postal Code",
      "C\u00f3digo Postal UY",
      "UY Postal Code",
      "CP UY",
      "ZIP Uruguay",
      "Uruguay Postal Code"
    ],
    "negativeHeaderExamples": [
      "Ciudad",
      "City",
      "Address",
      "Departamento",
      "Provincia",
      "Pa\u00eds",
      "Region",
      "Street"
    ],
    "explanation": "This semantic type identifies Uruguay postal codes as a standalone 5-digit numeric token. The regex uses word boundaries to avoid matching embedded digits within larger strings. Header patterns prioritize country-specific cues (Uruguay/UY) and common postal terminology and abbreviations, falling back to a primitive 'code' term only as a last resort to minimize false positives.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:34.030126"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_HU",
    "description": "Hungarian region: county administrative name. Identifies the official names of Hungary\u2019s 19 counties, including correct accents and hyphenation.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "B\u00c1CS-KISKUN",
      "BARANYA",
      "B\u00c9K\u00c9S",
      "BORSOD-ABA\u00daJ-ZEMPL\u00c9N",
      "CSONGR\u00c1D-CSAN\u00c1D",
      "FEJ\u00c9R",
      "GY\u0150R-MOSON-SOPRON",
      "HAJD\u00da-BIHAR",
      "HEVES",
      "J\u00c1SZ-NAGYKUN-SZOLNOK",
      "KOM\u00c1ROM-ESZTERGOM",
      "N\u00d3GR\u00c1D",
      "PEST",
      "SOMOGY",
      "SZABOLCS-SZATM\u00c1R-BEREG",
      "TOLNA",
      "VAS",
      "VESZPR\u00c9M",
      "ZALA"
    ],
    "backout": "^[A-Z\u00c1\u00c9\u00cd\u00d3\u00d6\u0150\u00da\u00dc\u0170\\- ]{3,30}$",
    "confidenceThreshold": 98,
    "priority": 9760,
    "headerPatterns": [
      {
        "regExp": "(?i).*(hungarian|hu).*(county|megye).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Hungarian County"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(megye).*(name|n\u00e9v).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Megye N\u00e9v"
        ],
        "negativeExamples": [
          "City Name"
        ]
      },
      {
        "regExp": "(?i).*(county)[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "County Name"
        ],
        "negativeExamples": [
          "Province"
        ]
      },
      {
        "regExp": "(?i).*hu[ _-]*county.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "HU County Name"
        ],
        "negativeExamples": [
          "State"
        ]
      },
      {
        "regExp": "(?i).*county.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "County"
        ],
        "negativeExamples": [
          "Region"
        ]
      }
    ],
    "positiveContentExamples": [
      "B\u00c1CS-KISKUN",
      "BARANYA",
      "B\u00c9K\u00c9S",
      "BORSOD-ABA\u00daJ-ZEMPL\u00c9N",
      "CSONGR\u00c1D-CSAN\u00c1D",
      "FEJ\u00c9R",
      "GY\u0150R-MOSON-SOPRON",
      "HAJD\u00da-BIHAR"
    ],
    "negativeContentExamples": [
      "BUDAPEST",
      "FEJER",
      "GYOR-MOSON-SOPRON",
      "BORSOD ABA\u00daJ ZEMPL\u00c9N",
      "CSONGRAD-CSANAD",
      "J\u00c1SZ-NAGYKUN",
      "SZABOLCS SZATM\u00c1R BEREG",
      "COUNTY OF HUNGARY"
    ],
    "positiveHeaderExamples": [
      "Megye",
      "County",
      "Hungarian County",
      "County Name",
      "Megye N\u00e9v",
      "County (HU)",
      "HU County Name",
      "County of Hungary"
    ],
    "negativeHeaderExamples": [
      "Country",
      "City",
      "Region",
      "Province",
      "State",
      "Municipality",
      "Country Code",
      "City Name"
    ],
    "explanation": "This semantic type represents the official county-level administrative divisions of Hungary. It uses a finite list of 19 county names with correct accents and hyphenation for precise identification. The backout pattern safely bounds the expected character set and length to prevent over-broad matches, while header patterns range from explicit mentions of Hungarian counties to the primitive term 'county'.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:35.668552"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.SSN_FR",
    "description": "French INSEE/NIR personal social security identifier encoded as 15 numeric digits, optionally separated by spaces. Structure: sex (1/2/7/8), year (2 digits), month (01\u201312 or 20\u201399 for special cases), department (2 digits), commune (3 digits), order number (3 digits), and key (2 digits). This pattern validates overall shape and token boundaries only and does not compute or verify the checksum.",
    "pluginType": "regex",
    "regexPattern": "\\b[1278]\\s*[0-9]{2}\\s*(0[1-9]|1[0-2]|[2-9][0-9])\\s*[0-9]{2}\\s*[0-9]{3}\\s*[0-9]{3}\\s*[0-9]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 9180,
    "headerPatterns": [
      {
        "regExp": "(?i).*(num[e\u00e9]ro|no)\\s*.*insee.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Num\u00e9ro INSEE"
        ],
        "negativeExamples": [
          "Adresse"
        ]
      },
      {
        "regExp": "(?i).*(securite|s\u00e9curit\u00e9)\\s*sociale.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "S\u00e9curit\u00e9 Sociale"
        ],
        "negativeExamples": [
          "Nom"
        ]
      },
      {
        "regExp": "(?i).*(nir|nss|no\\s*secu).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "NIR"
        ],
        "negativeExamples": [
          "INSEE"
        ]
      },
      {
        "regExp": "(?i).*insee.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "INSEE"
        ],
        "negativeExamples": [
          "Date de Naissance"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Nom"
        ]
      }
    ],
    "positiveContentExamples": [
      "1 84 12 75 123 456 78",
      "2 99 01 13 001 245 12",
      "1 75 20 99 999 999 12",
      "184127512345678",
      "2 03 12 01 123 004 56",
      "7 90 20 97 321 654 32",
      "8 65 99 76 000 111 09",
      "278129912345678"
    ],
    "negativeContentExamples": [
      "3 84 12 75 123 456 78",
      "2 99 13 13 001 245 12",
      "1 00 00 75 123 456 78",
      "1-84-12-75-123-456-78",
      "18412751234567",
      "2841299123456789",
      "2 90 19 97 321 654 32",
      "1 84 AB 75 123 456 78"
    ],
    "positiveHeaderExamples": [
      "Num\u00e9ro INSEE",
      "S\u00e9curit\u00e9 Sociale",
      "INSEE",
      "NIR",
      "Numero INSEE",
      "No Secu",
      "Identifiant INSEE",
      "Code INSEE"
    ],
    "negativeHeaderExamples": [
      "Nom",
      "Adresse",
      "Date de Naissance",
      "Code Postal",
      "Identifiant Client",
      "Num\u00e9ro Fiscal",
      "IBAN",
      "Email"
    ],
    "explanation": "This semantic type detects French INSEE/NIR personal social security numbers by enforcing a 15-digit numeric structure with optional spaces and specific token boundaries. It targets fields labeled with INSEE or social security terminology and is suitable for data quality checks, masking, and PII detection. The pattern intentionally avoids checksum validation and region-specific exceptions, focusing on stable, format-based recognition to reduce false positives.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:38.522499"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_NL",
    "description": "Netherlands postcode: four digits, space, two letters",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b[1-9][0-9]{3} [A-Z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 9620,
    "headerPatterns": [
      {
        "regExp": "(?i).*(nl|netherlands).*(postal code|postcode).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "NL Postal Code"
        ],
        "negativeExamples": [
          "US Postal Code"
        ]
      },
      {
        "regExp": "(?i).*(postal code|postcode).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "Area Code"
        ]
      },
      {
        "regExp": "(?i).*(zip code|zipcode|zip).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ZIP"
        ],
        "negativeExamples": [
          "Postal Area"
        ]
      },
      {
        "regExp": "(?i).*(pcode|p code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "PCode"
        ],
        "negativeExamples": [
          "Product Code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "1011 AB",
      "2511 BV",
      "3012 EA",
      "5611 BR",
      "9712 CP",
      "5038 ED",
      "1181 ZZ"
    ],
    "negativeContentExamples": [
      "1234AB",
      "0123 AB",
      "123 AB",
      "12345 AB",
      "1234 ABC",
      "1234 A",
      "1234 A1",
      "1234-AA"
    ],
    "positiveHeaderExamples": [
      "Postcode",
      "Postal Code",
      "ZIP",
      "NL Postal Code",
      "Netherlands Postcode",
      "Zip Code",
      "PCode"
    ],
    "negativeHeaderExamples": [
      "Stad",
      "City",
      "Address",
      "Area Code",
      "Country Code",
      "State Code",
      "ZIP Distance"
    ],
    "explanation": "This semantic type recognizes Dutch postal codes, which consist of exactly four digits followed by a single space and two letters (e.g., 1011 AB). It is useful for validating and classifying address data fields specific to the Netherlands where precise postal code formatting is required.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:39.729237"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.YEAR_OF_BIRTH",
    "description": "Four-digit calendar year of a person's birth, represented as a standalone 4-digit integer. Values are constrained to a plausible human birth year range (1800\u20132029) and exclude annotated or partial date strings.",
    "pluginType": "regex",
    "regexPattern": "\\b(18[0-9]{2}|19[0-9]{2}|200[0-9]|201[0-9]|202[0-9])\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 9510,
    "headerPatterns": [
      {
        "regExp": "(?i).*year.*of.*birth.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Year of Birth"
        ],
        "negativeExamples": [
          "Date of Birth"
        ]
      },
      {
        "regExp": "(?i).*birth.*year.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Birth Year"
        ],
        "negativeExamples": [
          "Current Year"
        ]
      },
      {
        "regExp": "(?i).*year.*born.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Year Born"
        ],
        "negativeExamples": [
          "Age"
        ]
      },
      {
        "regExp": "(?i).*yob.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "YOB"
        ],
        "negativeExamples": [
          "DOB"
        ]
      },
      {
        "regExp": "(?i).*year.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Year"
        ],
        "negativeExamples": [
          "Birthdate"
        ]
      }
    ],
    "positiveContentExamples": [
      "1890",
      "1905",
      "1954",
      "1976",
      "1988",
      "2001",
      "2010",
      "2022"
    ],
    "negativeContentExamples": [
      "85",
      "198",
      "01985",
      "c1985",
      "1985AD",
      "2035",
      "1750",
      "9999"
    ],
    "positiveHeaderExamples": [
      "Birth Year",
      "Year Born",
      "Year of Birth",
      "YOB",
      "Birth Yr",
      "Yr of Birth",
      "Born Year"
    ],
    "negativeHeaderExamples": [
      "Age",
      "Date of Birth",
      "Current Year",
      "Birthdate",
      "DOB",
      "Year Started",
      "Graduation Year",
      "Fiscal Year"
    ],
    "explanation": "Identifies columns containing a person's birth year as a standalone four-digit integer. Useful for demographic analysis, age derivation, and temporal cohorting when only the year component is provided. The pattern is range-bounded to reduce false positives and excludes strings that include additional date parts or annotations.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:39.769280"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_UK",
    "description": "UK territory: historic county designation",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z][a-z]+(shire|sex|land|lands)|Kent|Durham|Essex|Sussex|Anglesey|Glamorgan|Yorkshire|Middlesex|Cumberland|Westmorland|Rutland|Aberdeenshire)\\b(\\sand\\s[A-Z][a-z]+(shire|sex|land|lands))?",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 9780,
    "headerPatterns": [
      {
        "regExp": "(?i).*(uk|british).*(historic).*(county).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "British Historic County"
        ],
        "negativeExamples": [
          "UK county code"
        ]
      },
      {
        "regExp": "(?i).*(uk|british).*(county).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "UK County Name"
        ],
        "negativeExamples": [
          "Country Name"
        ]
      },
      {
        "regExp": "(?i).*(county).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "County Name"
        ],
        "negativeExamples": [
          "Country Name"
        ]
      },
      {
        "regExp": "(?i).*(uk|british).*(county).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "UK County"
        ],
        "negativeExamples": [
          "City County"
        ]
      },
      {
        "regExp": "(?i).*county.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "County"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Region"
        ]
      }
    ],
    "positiveContentExamples": [
      "Yorkshire",
      "Middlesex",
      "Westmorland",
      "Cumberland",
      "Rutland",
      "Glamorgan",
      "Anglesey",
      "Aberdeenshire"
    ],
    "negativeContentExamples": [
      "York",
      "Greater London",
      "Aberdeen",
      "Essex County",
      "County of Durham",
      "West Morland",
      "Anglesey Island",
      "Rutledge"
    ],
    "positiveHeaderExamples": [
      "County",
      "UK County",
      "County Name",
      "British Historic County",
      "UK County Name",
      "Historic County",
      "County (UK)"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Region",
      "City",
      "Province",
      "State",
      "County Code",
      "County ID"
    ],
    "explanation": "Identifies values that are names of historic counties within the United Kingdom (England, Scotland, Wales, and Northern Ireland). This focuses on county names (typically single or compound capitalized words, often ending with -shire, -land, or -sex, plus common non-suffix forms) rather than administrative codes.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:43.449485"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_CA",
    "description": "Canadian region: two letter province abbreviation",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AB",
      "BC",
      "MB",
      "NB",
      "NL",
      "NS",
      "ON",
      "PE",
      "QC",
      "SK"
    ],
    "backout": "^[A-Z]{2}$",
    "confidenceThreshold": 98,
    "priority": 9920,
    "headerPatterns": [
      {
        "regExp": "(?i).*(canadian|canada|ca).*province.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "CA Province Code"
        ],
        "negativeExamples": [
          "Canadian Province"
        ]
      },
      {
        "regExp": "(?i).*province.*code.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Province Code"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      },
      {
        "regExp": "(?i).*(prov).*code.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Prov Code"
        ],
        "negativeExamples": [
          "Prov Name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "AB",
      "BC",
      "MB",
      "NB",
      "NL",
      "NS",
      "ON",
      "QC"
    ],
    "negativeContentExamples": [
      "NT",
      "NU",
      "YT",
      "NF",
      "PQ",
      "PEI",
      "qc",
      "QZ"
    ],
    "positiveHeaderExamples": [
      "Province Code",
      "Canadian Province",
      "Province",
      "CA Province Code",
      "Province Abbreviation",
      "Province 2-Letter Code",
      "Prov Code"
    ],
    "negativeHeaderExamples": [
      "Province Name",
      "Country",
      "Territory",
      "State Code",
      "Country Code",
      "Territory Code",
      "Canadian Province Name"
    ],
    "explanation": "This semantic type identifies two-letter abbreviations for Canadian provinces only. It uses a closed list of valid province codes and a strict backout pattern matching two uppercase letters. Territories (NT, NU, YT) and deprecated or malformed codes are intentionally excluded to avoid false positives in Canadian region fields keyed to provinces.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:44.066754"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_IE",
    "description": "Irish region: traditional county name",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b((county|co|co\\.)\\s+)?(carlow|cavan|clare|cork|donegal|dublin|galway|kerry|kildare|kilkenny|laois|leitrim|limerick|longford|louth|mayo|meath|monaghan|offaly|roscommon|sligo|tipperary|waterford|westmeath|wexford|wicklow)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 9770,
    "headerPatterns": [
      {
        "regExp": "(?i).*(irish).*(county).*(name).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Irish County Name"
        ],
        "negativeExamples": [
          "Country Name"
        ]
      },
      {
        "regExp": "(?i).*(ireland|ie).*(county).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "IE County"
        ],
        "negativeExamples": [
          "IE Country"
        ]
      },
      {
        "regExp": "(?i).*\\bco\\.?\\b.*name.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Co Name"
        ],
        "negativeExamples": [
          "Company Name"
        ]
      },
      {
        "regExp": "(?i).*(irish).*(county).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Irish County"
        ],
        "negativeExamples": [
          "Irish Country"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Cork",
      "County Kerry",
      "Co. Dublin",
      "Co Louth",
      "Tipperary",
      "Westmeath",
      "County Wexford",
      "Laois"
    ],
    "negativeContentExamples": [
      "County Derry",
      "Derry",
      "Antrim",
      "Wexford County",
      "Offally",
      "Meade",
      "Kil Kenny",
      "Tipperarry"
    ],
    "positiveHeaderExamples": [
      "County",
      "Irish County",
      "County Name",
      "Irish County Name",
      "IE County",
      "County (Ireland)",
      "Co Name"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Province",
      "City",
      "County Code",
      "Company",
      "State",
      "Region",
      "Parish"
    ],
    "explanation": "This semantic type recognizes traditional county names of the Republic of Ireland, optionally prefixed by 'County', 'Co', or 'Co.'. It is intended for columns storing Irish county names as geographic administrative units rather than codes. Typical uses include normalizing regional dimensions, validating location fields, and enriching address data where counties are captured as free text.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:51.951288"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_CO",
    "description": "Colombian locality: municipal administrative division. Represents the name of a municipality in Colombia written in Spanish or English, typically composed of alphabetic words with spaces, hyphens, or apostrophes.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1\u00e1\u00e9\u00ed\u00f3\u00fa\u00fc\u00f1]{2,}([ '-][A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1\u00e1\u00e9\u00ed\u00f3\u00fa\u00fc\u00f1]{2,}){0,5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 9860,
    "headerPatterns": [
      {
        "regExp": "(?i).*(municipality|municipio).*(colombia|\\bco\\b).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Colombian Municipality"
        ],
        "negativeExamples": [
          "Municipality Code"
        ]
      },
      {
        "regExp": "(?i).*(colombia|\\bco\\b).*(municipality|municipio).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Municipio CO"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(mpio|muni).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mpio"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*(municipality|municipio).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Municipality Name"
        ],
        "negativeExamples": [
          "Department Name"
        ]
      },
      {
        "regExp": "(?i).*municipality.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Municipality"
        ],
        "negativeExamples": [
          "Department"
        ]
      }
    ],
    "positiveContentExamples": [
      "Medell\u00edn",
      "Cartagena de Indias",
      "Santa Marta",
      "Tumaco",
      "El Carmen de Bol\u00edvar",
      "Villavicencio",
      "Soacha",
      "San Jos\u00e9 del Guaviare"
    ],
    "negativeContentExamples": [
      "Bogot\u00e1 D.C.",
      "Cali, Colombia",
      "San Andr\u00e9s & Providencia",
      "Cundinamarca (Dept.)",
      "Cartagena de Indias 170",
      "Municipality: Medell\u00edn",
      "Villavicencio-",
      "Puerto As\u00eds/Nari\u00f1o"
    ],
    "positiveHeaderExamples": [
      "Municipio",
      "Municipality",
      "Colombian Municipality",
      "Municipality CO",
      "Municipio Colombia",
      "mpio",
      "Municipality Name"
    ],
    "negativeHeaderExamples": [
      "Department",
      "Country",
      "City",
      "Province",
      "State",
      "Locality",
      "Continent",
      "Postal Code"
    ],
    "explanation": "This semantic type captures the textual name of a Colombian municipality, accommodating typical diacritics and multi-word forms seen in Spanish place names. Use it to classify columns containing municipality names in datasets scoped to Colombia; header patterns help disambiguate from generic place names by looking for Colombia context or common abbreviations like mpio.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:52.130720"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_IE",
    "description": "Irish territory: traditional historic province. Represents one of the four traditional provinces on the island of Ireland.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "LEINSTER",
      "MUNSTER",
      "CONNACHT",
      "ULSTER"
    ],
    "backout": "^[A-Z]{6,8}$",
    "confidenceThreshold": 98,
    "priority": 9970,
    "headerPatterns": [
      {
        "regExp": "(?i).*irish.*province.*name.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Irish Province Name"
        ],
        "negativeExamples": [
          "Irish Province Code"
        ]
      },
      {
        "regExp": "(?i).*province.*name.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Province Name"
        ],
        "negativeExamples": [
          "Province Number"
        ]
      },
      {
        "regExp": "(?i).*irish.*province.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Irish Province"
        ],
        "negativeExamples": [
          "Province Code"
        ]
      },
      {
        "regExp": "(?i).*\\bprov\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "prov_name"
        ],
        "negativeExamples": [
          "provider"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Leinster",
      "Munster",
      "Connacht",
      "Ulster",
      "LEINSTER",
      "MUNSTER"
    ],
    "negativeContentExamples": [
      "Connaught",
      "Northern Ireland",
      "County Cork",
      "Leinster Province",
      "Province of Ulster",
      "Munster, Ireland",
      "Leinster (IE)",
      "Ulster County"
    ],
    "positiveHeaderExamples": [
      "Province",
      "Irish Province",
      "Province Name",
      "Irish Province Name",
      "Province (Ireland)",
      "Traditional Province",
      "Historic Province",
      "Province of Ireland"
    ],
    "negativeHeaderExamples": [
      "County",
      "Country",
      "Region",
      "State",
      "Province Code",
      "Province Number",
      "Prefecture",
      "Territory"
    ],
    "explanation": "This semantic type identifies values that are one of the four traditional provinces of the island of Ireland. It is intended for columns holding province names (not codes), enabling precise classification for Irish administrative-historic geography.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:52.602347"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COMMUNE_IT",
    "description": "Italian municipality: commune name",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]{1,3}\\.\\s)?([A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]+('[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]+)?)([ -][A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]+('[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]+)?)*\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 9740,
    "headerPatterns": [
      {
        "regExp": "(?i).*(italian|italia|it).*(comune|commune|municipality).*(name|nome).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Italian municipality name"
        ],
        "negativeExamples": [
          "Italian municipality code"
        ]
      },
      {
        "regExp": "(?i).*(comune|commune|municipality).*(name|nome).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Comune name"
        ],
        "negativeExamples": [
          "Province name"
        ]
      },
      {
        "regExp": "(?i).*(comune|commune|municipality|municipio).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Municipality"
        ],
        "negativeExamples": [
          "Region"
        ]
      },
      {
        "regExp": "(?i).*\\b(mun\\.|muni|com\\.)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mun. name"
        ],
        "negativeExamples": [
          "community type"
        ]
      },
      {
        "regExp": "(?i).*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Roma",
      "Milano",
      "L'Aquila",
      "Reggio nell'Emilia",
      "Sant'Angelo in Vado",
      "Citt\u00e0 di Castello",
      "San Don\u00e0 di Piave",
      "S. Giovanni Valdarno"
    ],
    "negativeContentExamples": [
      "L'Aquila 67100",
      "San Don\u00e0 di Piave (VE)",
      "Sant' Angelo Lodigiano",
      "S.. Giovanni",
      "Roma/",
      "3Roma",
      "L'Aquila-",
      "Citt\u00e0 di Castello."
    ],
    "positiveHeaderExamples": [
      "Comune",
      "Commune",
      "Municipality",
      "Municipality name",
      "Comune nome",
      "Italian municipality name",
      "Municipio",
      "Comune di residenza"
    ],
    "negativeHeaderExamples": [
      "Province",
      "Region",
      "Country",
      "City code",
      "Postal code",
      "Province name",
      "Area",
      "County"
    ],
    "explanation": "Detects Italian municipality (comune) names as they would appear in datasets, including common particles and abbreviations, diacritics, internal apostrophes, and occasional abbreviated saints' forms (e.g., \"S.\"). Use when the column contains the proper name of a comune rather than codes or higher-level administrative units.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:53.341466"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_CODE_BR",
    "description": "Brazilian municipal code: seven digit IBGE identifier",
    "pluginType": "regex",
    "regexPattern": "\\b[1-9]\\d{6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 9870,
    "headerPatterns": [
      {
        "regExp": "(?i).*(municipality.*code|code.*municipality|munic[i\u00ed]pio.*c[o\u00f3]digo|c[o\u00f3]digo.*munic[i\u00ed]pio).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "C\u00f3digo do Munic\u00edpio"
        ],
        "negativeExamples": [
          "Municipality Name"
        ]
      },
      {
        "regExp": "(?i).*(ibge.*code|code.*ibge).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "IBGE Code"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(cod[_ ]?mun|mun[_ ]?cod|mun[_ ]?code).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "cod_mun"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*ibge.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "codigo_ibge"
        ],
        "negativeExamples": [
          "State"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Municipality Code"
        ],
        "negativeExamples": [
          "Region"
        ]
      }
    ],
    "positiveContentExamples": [
      "1100015",
      "1200401",
      "1501402",
      "2607901",
      "2927408",
      "3106200",
      "3550308",
      "4314902"
    ],
    "negativeContentExamples": [
      "123456",
      "12345678",
      "0123456",
      "12A4567",
      "123-4567",
      "3550308a",
      "a3550308",
      "0000000"
    ],
    "positiveHeaderExamples": [
      "C\u00f3digo do Munic\u00edpio",
      "Municipality Code",
      "IBGE Code",
      "cod_mun",
      "codigo_ibge",
      "municipality_id",
      "mun_code"
    ],
    "negativeHeaderExamples": [
      "Municipality Name",
      "State",
      "Country",
      "Postal Code",
      "State Code",
      "Region",
      "City Name"
    ],
    "explanation": "This semantic type captures Brazilian IBGE municipality identifiers, which are strictly seven-digit numeric codes used to uniquely identify municipalities. It is useful for validating and standardizing municipality references in Brazilian datasets, ensuring only correctly structured 7-digit codes are classified.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:53.576395"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_EC",
    "description": "Ecuadorian region: provincial administrative division",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AZUAY",
      "BOL\u00cdVAR",
      "CA\u00d1AR",
      "CARCHI",
      "CHIMBORAZO",
      "COTOPAXI",
      "EL ORO",
      "ESMERALDAS",
      "GAL\u00c1PAGOS",
      "GUAYAS",
      "IMBABURA",
      "LOJA",
      "LOS R\u00cdOS",
      "MANAB\u00cd",
      "MORONA SANTIAGO",
      "NAPO",
      "ORELLANA",
      "PASTAZA",
      "PICHINCHA",
      "SANTA ELENA",
      "SANTO DOMINGO DE LOS TS\u00c1CHILAS",
      "SUCUMB\u00cdOS",
      "TUNGURAHUA",
      "ZAMORA CHINCHIPE"
    ],
    "backout": "^[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1 ]{4,40}$",
    "confidenceThreshold": 98,
    "priority": 9950,
    "headerPatterns": [
      {
        "regExp": "(?i).*ecuador.*province.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Ecuador Province Name"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*ecuador.*provincia.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Provincia de Ecuador"
        ],
        "negativeExamples": [
          "Region"
        ]
      },
      {
        "regExp": "(?i).*province.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Province Name"
        ],
        "negativeExamples": [
          "Province Code"
        ]
      },
      {
        "regExp": "(?i).*provincia.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Provincia"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*\\bprov\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Prov"
        ],
        "negativeExamples": [
          "Provider"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "PICHINCHA",
      "GUAYAS",
      "AZUAY",
      "LOS R\u00cdOS",
      "SANTO DOMINGO DE LOS TS\u00c1CHILAS",
      "GAL\u00c1PAGOS",
      "MANAB\u00cd",
      "ZAMORA CHINCHIPE"
    ],
    "negativeContentExamples": [
      "BOLIVAR",
      "LOS RIOS",
      "SANTO DOMINGO",
      "GALAPAGOS",
      "EL ORO PROVINCE",
      "QUITO",
      "GUAYAQUIL",
      "AZUAI"
    ],
    "positiveHeaderExamples": [
      "Provincia",
      "Province",
      "Ecuadorian Province",
      "Province Name",
      "Ecuador Province Name",
      "Provincia de Ecuador",
      "Prov"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Region",
      "City",
      "Province Code",
      "Provider",
      "State",
      "Country Name"
    ],
    "explanation": "This semantic type identifies Ecuadorian first-order administrative divisions (provinces) by name. It is implemented as a finite, authoritative list of 24 province names, preserving diacritics, to ensure high-precision matching in address and geographic datasets.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:58.224449"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_BR",
    "description": "Brazilian locality: municipal administrative unit",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]+('[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]+)?(-[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]+)*( [A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]+('[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]+)?(-[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]+)*)*\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 9850,
    "headerPatterns": [
      {
        "regExp": "(?i).*brazilian.*municipality.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Brazilian Municipality"
        ],
        "negativeExamples": [
          "Municipality Code"
        ]
      },
      {
        "regExp": "(?i).*munic\u00edpio.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Munic\u00edpio"
        ],
        "negativeExamples": [
          "State"
        ]
      },
      {
        "regExp": "(?i).*municipality.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Municipality"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*\\bmunic\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "munic"
        ],
        "negativeExamples": [
          "num"
        ]
      },
      {
        "regExp": "(?i).*\\bmun\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "mun"
        ],
        "negativeExamples": [
          "man"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality name"
        ],
        "negativeExamples": [
          "municipality code"
        ]
      }
    ],
    "positiveContentExamples": [
      "S\u00e3o Paulo",
      "Rio de Janeiro",
      "Belo Horizonte",
      "Curitiba",
      "Ji-Paran\u00e1",
      "Sant'Ana do Livramento",
      "Olho d'\u00c1gua das Flores",
      "Balne\u00e1rio Cambori\u00fa"
    ],
    "negativeContentExamples": [
      "S\u00e3o Paulo - SP",
      "Rio de Janeiro/RJ",
      "Uberl\u00e2ndia, MG",
      "Bel\u00e9m (PA)",
      "S\u00e3o Jo\u00e3o 2",
      "12345",
      "www.saopaulo.sp.gov.br",
      "Porto Alegre - RS"
    ],
    "positiveHeaderExamples": [
      "Munic\u00edpio",
      "Municipality",
      "Brazilian Municipality",
      "Municipality Name",
      "Nome do Munic\u00edpio",
      "BR Municipality",
      "Munic\u00edpio BR"
    ],
    "negativeHeaderExamples": [
      "State",
      "Country",
      "Municipality Code",
      "City",
      "Province",
      "Locality Code",
      "County"
    ],
    "explanation": "This semantic type represents the name of a Brazilian municipality (munic\u00edpio), the primary local administrative unit in Brazil. It captures human-readable municipality names that may include diacritics, internal hyphens, and apostrophes, and may consist of one or multiple words. Use it to classify columns containing municipality names rather than codes or abbreviations. The pattern intentionally excludes values that contain punctuation like slashes, commas, or parentheses typically used to append state abbreviations (e.g., /RJ, , MG) to reduce false positives.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:56:59.493486"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_FIPS_US",
    "description": "Two-digit U.S. state-level FIPS code identifying a state or the District of Columbia. Values are numeric with a leading zero where applicable and constrained to the range 01\u201356 inclusive. This type targets state-level FIPS only and excludes county-level FIPS and other FIPS code systems.",
    "pluginType": "regex",
    "regexPattern": "\\b(0[1-9]|[1-4][0-9]|5[0-6])\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 10090,
    "headerPatterns": [
      {
        "regExp": "(?i).*state.*fips.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State FIPS Code"
        ],
        "negativeExamples": [
          "County FIPS Code"
        ]
      },
      {
        "regExp": "(?i).*(us|usa).*state.*fips.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "US State FIPS"
        ],
        "negativeExamples": [
          "State Name"
        ]
      },
      {
        "regExp": "(?i).*fips.*state.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "FIPS State Code"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*\\bst\\b.*fips.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ST FIPS"
        ],
        "negativeExamples": [
          "County FIPS"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "FIPS Code"
        ],
        "negativeExamples": [
          "FIPS County"
        ]
      }
    ],
    "positiveContentExamples": [
      "01",
      "02",
      "04",
      "06",
      "11",
      "36",
      "48",
      "56"
    ],
    "negativeContentExamples": [
      "00",
      "57",
      "60",
      "3",
      "056",
      "11A",
      "A1",
      "5 6"
    ],
    "positiveHeaderExamples": [
      "State FIPS",
      "FIPS Code",
      "State Code",
      "US State FIPS",
      "FIPS State Code",
      "State FIPS Code",
      "US FIPS State",
      "ST FIPS"
    ],
    "negativeHeaderExamples": [
      "State Name",
      "Country",
      "County FIPS",
      "FIPS County Code",
      "Province Code",
      "Zip Code",
      "ISO State Code",
      "Area Code"
    ],
    "explanation": "This semantic type detects two-digit U.S. state-level FIPS codes (01\u201356), commonly used to identify states and the District of Columbia in national datasets. It is appropriate when fields are strictly two-digit numerics with preserved leading zeros and are labeled to indicate FIPS at the state level. It deliberately excludes county FIPS codes (which are three digits and typically combined with state FIPS) and other coding systems such as ISO subdivision codes.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:01.679130"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.DISTRICT_NAME_PT",
    "description": "Portuguese territory: district administrative unit. Represents the official names of mainland Portuguese districts as standalone values.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AVEIRO",
      "BEJA",
      "BRAGA",
      "BRAGAN\u00c7A",
      "CASTELO BRANCO",
      "COIMBRA",
      "\u00c9VORA",
      "FARO",
      "GUARDA",
      "LEIRIA",
      "LISBOA",
      "PORTALEGRE",
      "PORTO",
      "SANTAR\u00c9M",
      "SET\u00daBAL",
      "VIANA DO CASTELO",
      "VILA REAL",
      "VISEU"
    ],
    "backout": "^[A-Z\u00c1\u00c2\u00c3\u00c0\u00c9\u00ca\u00cd\u00d3\u00d4\u00d5\u00da\u00dc\u00c7]+( [A-Z\u00c1\u00c2\u00c3\u00c0\u00c9\u00ca\u00cd\u00d3\u00d4\u00d5\u00da\u00dc\u00c7]+){0,3}$",
    "confidenceThreshold": 98,
    "priority": 9830,
    "headerPatterns": [
      {
        "regExp": "(?i).*portuguese.*district.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Portuguese District"
        ],
        "negativeExamples": [
          "District"
        ]
      },
      {
        "regExp": "(?i).*distrito.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Distrito"
        ],
        "negativeExamples": [
          "Region"
        ]
      },
      {
        "regExp": "(?i).*district.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "District"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*\\bdist\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "dist"
        ],
        "negativeExamples": [
          "distance"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "district name"
        ],
        "negativeExamples": [
          "district code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Lisboa",
      "Porto",
      "Set\u00fabal",
      "\u00c9vora",
      "Santar\u00e9m",
      "Viana do Castelo",
      "Castelo Branco",
      "Vila Real"
    ],
    "negativeContentExamples": [
      "Lisbon",
      "Setubal",
      "Azores",
      "Madeira",
      "Distrito de Lisboa",
      "Viana do Castello",
      "Castelo Branco, PT",
      "Porto City"
    ],
    "positiveHeaderExamples": [
      "Distrito",
      "District",
      "Portuguese District",
      "district name",
      "district_name",
      "dist",
      "distrito",
      "distrito nome"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Region",
      "City",
      "district code",
      "province",
      "municipality",
      "county",
      "postcode"
    ],
    "explanation": "This semantic type identifies the official names of Portuguese mainland districts as standalone values, suitable for labeling or grouping records by district. It is implemented as a finite list to ensure precise classification and to avoid confusion with regions, municipalities, or codes.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:03.286427"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_ZA",
    "description": "sa_province_code: two-letter South African provincial designation",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "EC",
      "FS",
      "GP",
      "KZ",
      "LP",
      "MP",
      "NC",
      "NW",
      "WC"
    ],
    "backout": "^[A-Z]{2}$",
    "confidenceThreshold": 96,
    "priority": 10020,
    "headerPatterns": [
      {
        "regExp": "(?i).*sa.*province.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SA Province Code"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      },
      {
        "regExp": "(?i).*za.*province.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ZA Province Code"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*province.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Province Code"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      },
      {
        "regExp": "(?i).*sa.*province.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SA Province"
        ],
        "negativeExamples": [
          "District"
        ]
      },
      {
        "regExp": "(?i).*\\bprov.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Prov Code"
        ],
        "negativeExamples": [
          "Province"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "EC",
      "FS",
      "GP",
      "KZ",
      "LP",
      "MP",
      "NW",
      "WC"
    ],
    "negativeContentExamples": [
      "KZN",
      "ZN",
      "EC-",
      "GP1",
      "E C",
      "K Z",
      "WC/",
      "ZA"
    ],
    "positiveHeaderExamples": [
      "Province Code",
      "SA Province",
      "Province",
      "SA Province Code",
      "ZA Province Code",
      "Prov Code",
      "Province Abbrev",
      "Province Identifier"
    ],
    "negativeHeaderExamples": [
      "Province Name",
      "Country",
      "District",
      "Postal Code",
      "Region",
      "State Code",
      "County",
      "Territory"
    ],
    "explanation": "This semantic type identifies two-letter abbreviations used for South African provinces. It is a finite, closed set appropriate for validation and standardization of province codes in ZA-focused datasets.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:04.238452"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.REGION_NAME_IT",
    "description": "regione_italiana: Italian constitutional regional designation. Identifies values that are the official names of Italy's 20 first-level administrative regions in Italian, using uppercase with spaces, hyphens, and apostrophes as appropriate.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "ABRUZZO",
      "BASILICATA",
      "CALABRIA",
      "CAMPANIA",
      "EMILIA-ROMAGNA",
      "FRIULI-VENEZIA GIULIA",
      "LAZIO",
      "LIGURIA",
      "LOMBARDIA",
      "MARCHE",
      "MOLISE",
      "PIEMONTE",
      "PUGLIA",
      "SARDEGNA",
      "SICILIA",
      "TOSCANA",
      "TRENTINO-ALTO ADIGE",
      "UMBRIA",
      "VALLE D'AOSTA",
      "VENETO"
    ],
    "backout": "^[A-Z][A-Z '\\-]{3,24}$",
    "confidenceThreshold": 98,
    "priority": 10040,
    "headerPatterns": [
      {
        "regExp": "(?i).*(regione italiana|italian region).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Italian Region"
        ],
        "negativeExamples": [
          "Region"
        ]
      },
      {
        "regExp": "(?i).*(region|regione).*(name|nome).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Region Name"
        ],
        "negativeExamples": [
          "Region Code"
        ]
      },
      {
        "regExp": "(?i).*(rgn|reg)[ _-]*(name|nm).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Rgn Name"
        ],
        "negativeExamples": [
          "Reg Code"
        ]
      },
      {
        "regExp": "(?i).*(administrative|admin).*(region|regione).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Administrative Region"
        ],
        "negativeExamples": [
          "Administrative Area"
        ]
      },
      {
        "regExp": "(?i).*region.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Region"
        ],
        "negativeExamples": [
          "Province"
        ]
      }
    ],
    "positiveContentExamples": [
      "LOMBARDIA",
      "PIEMONTE",
      "FRIULI-VENEZIA GIULIA",
      "EMILIA-ROMAGNA",
      "VALLE D'AOSTA",
      "TRENTINO-ALTO ADIGE",
      "SARDEGNA",
      "TOSCANA"
    ],
    "negativeContentExamples": [
      "LOMBARDY",
      "PIEDMONT",
      "FRIULI VENEZIA GIULIA",
      "EMILIA ROMAGNA",
      "VALLE D AOSTA",
      "CALABRIA REGION",
      "REGIONE LAZIO",
      "SUDTIROL"
    ],
    "positiveHeaderExamples": [
      "Regione",
      "Region",
      "Italian Region",
      "Region Name",
      "Regione Italiana",
      "Rgn Name",
      "Administrative Region",
      "Nome Regione"
    ],
    "negativeHeaderExamples": [
      "Province",
      "Country",
      "City",
      "State",
      "Region Code",
      "County",
      "Area",
      "Timezone"
    ],
    "explanation": "This semantic type captures the official names of Italian regions and is best used for columns containing region names rather than codes or broader geographic labels. It relies on a finite, enumerated list of the 20 regions to provide high precision classification, with a backout pattern that reflects the shape of valid values.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:04.440572"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_NL",
    "description": "Netherlands territory: provincial administrative division. Represents the official Dutch provincial names (including common Dutch/Frisian variants) for the 12 provinces of the Netherlands. Excludes municipalities, cities, regions, or country names.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "DRENTHE",
      "FLEVOLAND",
      "FRIESLAND",
      "FRYSLAN",
      "GELDERLAND",
      "GRONINGEN",
      "LIMBURG",
      "NOORD-BRABANT",
      "NOORD BRABANT",
      "NOORD-HOLLAND",
      "NOORD HOLLAND",
      "OVERIJSSEL",
      "UTRECHT",
      "ZEELAND",
      "ZUID-HOLLAND",
      "ZUID HOLLAND"
    ],
    "backout": "^[A-Z][A-Z -]{2,20}$",
    "confidenceThreshold": 96,
    "priority": 9990,
    "headerPatterns": [
      {
        "regExp": "(?i).*dutch.*province.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Dutch Province Name"
        ],
        "negativeExamples": [
          "Province Code"
        ]
      },
      {
        "regExp": "(?i).*(netherlands|nl).*province.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "NL Province"
        ],
        "negativeExamples": [
          "Country Province"
        ]
      },
      {
        "regExp": "(?i).*provincie.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Provincie"
        ],
        "negativeExamples": [
          "Municipality"
        ]
      },
      {
        "regExp": "(?i).*province.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Province"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Noord-Brabant",
      "Noord Holland",
      "Zuid-Holland",
      "Drenthe",
      "Fryslan",
      "Friesland",
      "Utrecht",
      "Overijssel"
    ],
    "negativeContentExamples": [
      "NoordHolland",
      "South Holland",
      "Frysl\u00e2n",
      "Zeeland, Netherlands",
      "Gelderland-",
      "Utrecht City",
      "Overijssel.",
      "Province of Groningen"
    ],
    "positiveHeaderExamples": [
      "Provincie",
      "Province",
      "Dutch Province",
      "NL Province",
      "Province Name",
      "Dutch Province Name",
      "Netherlands Province",
      "Provincie Naam"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Municipality",
      "City",
      "Region",
      "State",
      "Province Code",
      "County",
      "City Name"
    ],
    "explanation": "This semantic type identifies the names of the 12 Dutch provinces, recognizing common Dutch and Frisian variants and hyphen/space variations for Noord-Holland, Zuid-Holland, and Noord-Brabant. It is useful for validating and standardizing province-level administrative data in Netherlands-focused datasets, and to distinguish province names from other geographic or administrative levels.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:04.750676"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.MIDDLE",
    "description": "Middle given name: the secondary personal name occurring between a person's first (given) name and family (last) name. Typical values are a single initial (with or without a period) or a single short given name, sometimes hyphenated.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z][a-z]{1,19}-[A-Z][a-z]{1,19}|[A-Z][a-z]{1,19}|[A-Z](\\.)?)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 9370,
    "headerPatterns": [
      {
        "regExp": "(?i).*(middle[_\\s-]*name|m[_\\s-]*name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Middle Name"
        ],
        "negativeExamples": [
          "Full Name"
        ]
      },
      {
        "regExp": "(?i).*\\bmiddle\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Middle"
        ],
        "negativeExamples": [
          "Center"
        ]
      },
      {
        "regExp": "(?i).*(middle[_\\s-]*initial|m[_\\s-]*initial|mi\\b).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Middle Initial"
        ],
        "negativeExamples": [
          "First Initial"
        ]
      },
      {
        "regExp": "(?i).*(second[_\\s-]*name|second[_\\s-]*given).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Second Name"
        ],
        "negativeExamples": [
          "Second Email"
        ]
      },
      {
        "regExp": "(?i).*(middle[_\\s-]*given|given[_\\s-]*middle).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Middle Given Name"
        ],
        "negativeExamples": [
          "Given Name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "A.",
      "B",
      "Anne",
      "Marie",
      "Lee",
      "J.",
      "Jo-Anne",
      "Paul"
    ],
    "negativeContentExamples": [
      "JR",
      "Anne Marie",
      "A B",
      "J D",
      "O'Neil",
      "A..",
      "M-",
      "-Ann"
    ],
    "positiveHeaderExamples": [
      "Middle Name",
      "Second Name",
      "Middle",
      "Middle Initial",
      "M Name",
      "Middle Given Name",
      "Middlename"
    ],
    "negativeHeaderExamples": [
      "First Name",
      "Last Name",
      "Full Name",
      "Given Name",
      "Preferred Name",
      "Legal Name",
      "Display Name"
    ],
    "explanation": "This type targets single-token middle names or initials commonly stored separately from first and last names. It is optimized to recognize single initials (with or without a period), simple given names, and hyphenated single-token names while avoiding multi-word full names.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:05.746230"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.DEPARTMENT_CO",
    "description": "Colombian region: departmental administrative unit",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(AMAZONAS|ANTIOQUIA|ARAUCA|ATL\u00c1NTICO|BOL\u00cdVAR|BOYAC\u00c1|CALDAS|CAQUET\u00c1|CASANARE|CAUCA|CESAR|CHOC\u00d3|C\u00d3RDOBA|CUNDINAMARCA|GUAIN\u00cdA|GUAVIARE|HUILA|LA GUAJIRA|MAGDALENA|META|NARI\u00d1O|NORTE DE SANTANDER|PUTUMAYO|QUIND\u00cdO|RISARALDA|SAN ANDR\u00c9S Y PROVIDENCIA|SANTANDER|SUCRE|TOLIMA|VALLE DEL CAUCA|VAUP\u00c9S|VICHADA)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 9800,
    "headerPatterns": [
      {
        "regExp": "(?i).*(colombia|colombian|co\\b).*(departamento|department|dept|depto).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Colombian Department"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(departamento).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Departamento"
        ],
        "negativeExamples": [
          "Municipality"
        ]
      },
      {
        "regExp": "(?i).*(dept|depto|dpto).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Dept"
        ],
        "negativeExamples": [
          "Province"
        ]
      },
      {
        "regExp": "(?i).*(regional.*department|administrative.*department|territorial.*department).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Regional Department"
        ],
        "negativeExamples": [
          "Department Code"
        ]
      },
      {
        "regExp": "(?i).*department.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Department"
        ],
        "negativeExamples": [
          "City"
        ]
      }
    ],
    "positiveContentExamples": [
      "Antioquia",
      "Atl\u00e1ntico",
      "Bol\u00edvar",
      "Boyac\u00e1",
      "Cundinamarca",
      "Nari\u00f1o",
      "Valle del Cauca",
      "Norte de Santander"
    ],
    "negativeContentExamples": [
      "Atlantico",
      "Cordoba",
      "Bogot\u00e1 D.C.",
      "La-Guajira",
      "Norte Santander",
      "San Andres y Providencia",
      "Valle de Cauca",
      "Choco"
    ],
    "positiveHeaderExamples": [
      "Departamento",
      "Department",
      "Colombian Department",
      "Dept",
      "Departamento Administrativo",
      "CO Department",
      "Regional Department"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Municipality",
      "City",
      "Province",
      "State",
      "Region",
      "County"
    ],
    "explanation": "This semantic type identifies the name of a first-level administrative division in Colombia (departamento). It is intended for columns that contain department names such as Antioquia, Cundinamarca, or Valle del Cauca. The value pattern enumerates the official department names with support for Spanish diacritics and multi-word forms.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:05.900326"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_CA",
    "description": "Full official Canadian province name (not abbreviations or codes). Accepts only the ten provinces in their full names.\nThis type excludes Canadian territories; values like Yukon, Nunavut, and Northwest Territories are not included.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "ALBERTA",
      "BRITISH COLUMBIA",
      "MANITOBA",
      "NEW BRUNSWICK",
      "NEWFOUNDLAND AND LABRADOR",
      "NOVA SCOTIA",
      "ONTARIO",
      "PRINCE EDWARD ISLAND",
      "QUEBEC",
      "SASKATCHEWAN"
    ],
    "backout": "^[A-Z ]{4,30}$",
    "confidenceThreshold": 99,
    "priority": 9940,
    "headerPatterns": [
      {
        "regExp": "(?i).*canadian.*province.*name.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Canadian Province Name"
        ],
        "negativeExamples": [
          "Canadian Province Code"
        ]
      },
      {
        "regExp": "(?i).*province.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Province Name"
        ],
        "negativeExamples": [
          "Province Code"
        ]
      },
      {
        "regExp": "(?i).*\\bprov\\b.*name.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Prov Name"
        ],
        "negativeExamples": [
          "Provider Name"
        ]
      },
      {
        "regExp": "(?i).*(ca|canada).*province.*",
        "confidence": 91,
        "mandatory": true,
        "positiveExamples": [
          "CA Province"
        ],
        "negativeExamples": [
          "Province Abbreviation"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "ALBERTA",
      "BRITISH COLUMBIA",
      "MANITOBA",
      "NEW BRUNSWICK",
      "NEWFOUNDLAND AND LABRADOR",
      "NOVA SCOTIA",
      "ONTARIO",
      "PRINCE EDWARD ISLAND"
    ],
    "negativeContentExamples": [
      "QUEBEC CITY",
      "SASKATCHEWAN PROVINCE",
      "YUKON",
      "NORTHWEST TERRITORIES",
      "NUNAVUT",
      "QC",
      "BRITISH COLUMBIA, CANADA",
      "ONTARIO (CA)"
    ],
    "positiveHeaderExamples": [
      "Province",
      "Province Name",
      "Canadian Province",
      "CA Province Name",
      "Provincial Name",
      "Province Full Name",
      "Province (Canada)"
    ],
    "negativeHeaderExamples": [
      "Province Code",
      "Country",
      "Territory",
      "State",
      "Region",
      "CA Province Code",
      "Province Abbreviation",
      "Territory Name"
    ],
    "explanation": "This semantic type identifies full Canadian province names as values, suitable for normalizing location attributes, validating province fields, or joining against reference tables. It focuses on exact full names to minimize ambiguity and excludes abbreviations and any Canadian territories.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:06.068416"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_MX",
    "description": "Mexican locality: municipal administrative division",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc]+)([ -]([A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc]+|de|del|la|las|los|y|el)){0,5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 92,
    "priority": 9890,
    "headerPatterns": [
      {
        "regExp": "(?i).*(mexic|mx).*municip.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Mexican Municipality"
        ],
        "negativeExamples": [
          "State"
        ]
      },
      {
        "regExp": "(?i).*(municipality|municipio|munic\u00edpio).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Municipality"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*\\b(mpio|muni|mun)\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Mpio"
        ],
        "negativeExamples": [
          "Province"
        ]
      },
      {
        "regExp": "(?i).*municip.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Municipio"
        ],
        "negativeExamples": [
          "Country"
        ]
      }
    ],
    "positiveContentExamples": [
      "Benito Ju\u00e1rez",
      "San Pedro Garza Garc\u00eda",
      "Santiago Ixcuintla",
      "Coatzacoalcos",
      "L\u00e1zaro C\u00e1rdenas",
      "General Escobedo",
      "Ecatepec de Morelos",
      "Guadalajara"
    ],
    "negativeContentExamples": [
      "benito ju\u00e1rez",
      "san pedro garza garcia",
      "santiago ixcuintla",
      "general escobedo",
      "ecatepec de morelos",
      "ALCALDIA BENITO JUAREZ",
      "PUERTO VALLARTA, JALISCO",
      "leon"
    ],
    "positiveHeaderExamples": [
      "Municipality",
      "Municipio",
      "Munic\u00edpio",
      "Mexican Municipality",
      "Municipality Name",
      "Mpio",
      "MX Municipality",
      "Municipality_ID"
    ],
    "negativeHeaderExamples": [
      "State",
      "Country",
      "City",
      "Postal Code",
      "Province",
      "County",
      "District",
      "Locality"
    ],
    "explanation": "This semantic type identifies the names of Mexican municipalities (municipios), which are primary local administrative divisions within Mexican states. Values are expected to be proper nouns in Spanish with typical connectors like de, del, la, las, los, y, el, and may include multiple words.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:11.715479"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_IT",
    "description": "Two-letter abbreviation for Italian provinces (e.g., MI, RM, TO). Typically uppercase alphabetic pairs used in addresses and administrative records.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 9930,
    "headerPatterns": [
      {
        "regExp": "(?i).*italian.*province.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Italian Province Code"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      },
      {
        "regExp": "(?i).*provincia.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Provincia Code"
        ],
        "negativeExamples": [
          "Provincia Nome"
        ]
      },
      {
        "regExp": "(?i).*province.*abbr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Province Abbreviation"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      },
      {
        "regExp": "(?i).*italian.*province.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Italian Province"
        ],
        "negativeExamples": [
          "Italian Region"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "MI",
      "RM",
      "TO",
      "NA",
      "FI",
      "BO",
      "BA",
      "VE"
    ],
    "negativeContentExamples": [
      "Mi",
      "RM-",
      "T0",
      "N A",
      "FIO",
      "B",
      "12",
      "VE."
    ],
    "positiveHeaderExamples": [
      "Provincia",
      "Province Code",
      "Italian Province",
      "Province Abbreviation",
      "Provincia Sigla",
      "IT Province Code",
      "Prov Code IT",
      "Italian Province Abbr"
    ],
    "negativeHeaderExamples": [
      "Province Name",
      "Region",
      "Country",
      "Province ID",
      "Postal Code",
      "State Code",
      "Italian Region Code",
      "Country Code"
    ],
    "explanation": "This semantic type detects two-letter uppercase abbreviations used for Italian provinces. It is intended for columns labeled with province-specific code terminology (e.g., 'Province Code', 'Provincia') and values consisting of exactly two uppercase letters.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:12.855375"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_US",
    "description": "US subdivision: local county jurisdiction. Covers standard county-equivalent jurisdiction names such as County, Parish, Borough, Census Area, Municipality, City and Borough, and Independent City.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Za-z]+\\.?)([ '-][A-Za-z]+\\.?)*\\s+(County|Parish|Borough|Census Area|Municipality|City and Borough|Independent City)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 9790,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\b(us|usa)\\b.*\\bcounty\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "US County"
        ],
        "negativeExamples": [
          "FIPS Code"
        ]
      },
      {
        "regExp": "(?i).*\\bcounty\\b.*\\bname\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "County Name"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*\\b(county|parish|borough)\\b.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "County"
        ],
        "negativeExamples": [
          "State"
        ]
      },
      {
        "regExp": "(?i).*\\bcnty\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "cnty"
        ],
        "negativeExamples": [
          "country"
        ]
      },
      {
        "regExp": "(?i).*\\bname\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Orange County",
      "Los Angeles County",
      "Prince George's County",
      "St. Louis County",
      "St. John the Baptist Parish",
      "Juneau City and Borough",
      "Aleutians West Census Area",
      "City and County of San Francisco"
    ],
    "negativeContentExamples": [
      "Orange",
      "Los Angeles City",
      "County Orange",
      "State of New York",
      "Bexar Co",
      "Anchorage Boroughs",
      "Aleutians West Census",
      "Parish of St. Tammany"
    ],
    "positiveHeaderExamples": [
      "County",
      "County Name",
      "US County",
      "County Jurisdiction",
      "Parish",
      "Borough Name",
      "County Full Name"
    ],
    "negativeHeaderExamples": [
      "State",
      "FIPS Code",
      "City",
      "Country",
      "Province",
      "County Code",
      "Zip Code"
    ],
    "explanation": "Identifies US county-level jurisdiction names, including county-equivalents such as parishes (LA), boroughs and city-boroughs (AK), census areas (AK), municipalities (AK), and independent cities (e.g., VA). This is useful for normalizing or validating administrative subdivision names at the county level within the United States.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:13.117858"
  },
  {
    "resultType": "generated",
    "semanticType": "LANGUAGE.TEXT_EN",
    "description": "Spoken language: full name of a natural language written in English words (e.g., English, Mandarin Chinese). Values consist of one to four capitalized words, optionally separated by a space or hyphen, and may include apostrophes within words.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z][A-Za-z']{2,}([ -][A-Z][A-Za-z']{2,}){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 92,
    "priority": 9280,
    "headerPatterns": [
      {
        "regExp": "(?i).*spoken.*language.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Spoken Language"
        ],
        "negativeExamples": [
          "Language Code"
        ]
      },
      {
        "regExp": "(?i).*language.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Language Name"
        ],
        "negativeExamples": [
          "Dialect"
        ]
      },
      {
        "regExp": "(?i).*(native|preferred).*language.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Preferred Language"
        ],
        "negativeExamples": [
          "Programming Language"
        ]
      },
      {
        "regExp": "(?i).*(lang|lng).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Lang"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*language.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Language"
        ],
        "negativeExamples": [
          "Country"
        ]
      }
    ],
    "positiveContentExamples": [
      "English",
      "Mandarin Chinese",
      "Haitian Creole",
      "Old Church Slavonic",
      "Serbo-Croatian",
      "N'Ko",
      "Quechua",
      "Norwegian Bokmal"
    ],
    "negativeContentExamples": [
      "en-US",
      "EN",
      "eng",
      "English (US)",
      "Portuguese-BR",
      "Fran\u00e7ais",
      "Chinese, Mandarin",
      "Xhosa 2"
    ],
    "positiveHeaderExamples": [
      "Language",
      "Language Name",
      "Spoken Language",
      "Primary Language",
      "Native Language Name",
      "Preferred Language"
    ],
    "negativeHeaderExamples": [
      "Language Code",
      "Country",
      "Dialect",
      "Programming Language",
      "Locale",
      "Region"
    ],
    "explanation": "This semantic type identifies cells containing the English full name of a natural (spoken) language. It targets proper-language names composed of one to four capitalized words, allowing internal apostrophes and a space or hyphen between words. Typical use cases include standardizing user profile language fields, survey responses, or metadata describing content language. Header recognition prioritizes specific phrases like 'Spoken Language' and 'Language Name' while still handling common abbreviations such as 'Lang'.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:13.684721"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.FIRST_LAST",
    "description": "A person's full name consisting of exactly two tokens: given name followed by family name, separated by a single space. Each token is alphabetic with optional internal hyphen or apostrophe (e.g., Mary-Jane, O'Neil). This excludes middle initials or additional tokens.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Za-z]{2,}|[A-Za-z]{1,}[-'][A-Za-z]{2,})\\s([A-Za-z]{2,}|[A-Za-z]{1,}[-'][A-Za-z]{2,})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 9340,
    "headerPatterns": [
      {
        "regExp": "(?i).*full.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Full Name"
        ],
        "negativeExamples": [
          "First Name"
        ]
      },
      {
        "regExp": "(?i).*(person|individual).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Person Name"
        ],
        "negativeExamples": [
          "Company Name"
        ]
      },
      {
        "regExp": "(?i).*contact.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Contact Name"
        ],
        "negativeExamples": [
          "Email Address"
        ]
      },
      {
        "regExp": "(?i).*(full.?name|name.?full).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name_full"
        ],
        "negativeExamples": [
          "first_name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Email Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "John Smith",
      "Mary-Jane Watson",
      "Liam O'Neil",
      "Alice Brown",
      "Carlos Ruiz",
      "Jean Dupont",
      "Peter McKay",
      "Ava Li"
    ],
    "negativeContentExamples": [
      "John",
      "J Smith",
      "John  Smith",
      "Smith, John",
      "John A Smith",
      "Mary_Jane Watson",
      "O'Neil",
      "Anna O'"
    ],
    "positiveHeaderExamples": [
      "Full Name",
      "Name",
      "Person Name",
      "Contact Name",
      "Customer Full Name",
      "Employee Name",
      "Applicant Name"
    ],
    "negativeHeaderExamples": [
      "First Name",
      "Last Name",
      "Email Address",
      "Company Name",
      "Username",
      "Street Name",
      "Given Name"
    ],
    "explanation": "This semantic type detects a two-token personal full name in the form 'First Last' with a single space separator. It supports common internal punctuation within tokens (hyphen, apostrophe) while excluding entries with middle initials, commas, multiple spaces, or additional tokens. Typical use cases include consolidating person identity fields, validating full-name columns, and improving entity resolution precision.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:14.235283"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.CANTON_NAME_CH",
    "description": "Swiss state: full canton name",
    "pluginType": "regex",
    "regexPattern": "\\b(Z\u00fcrich|Zurich|Zurigo|Bern|Berne|Berna|Luzern|Lucerne|Lucerna|Uri|Schwyz|Schwytz|Svitto|Obwalden|Obwald|Obvaldo|Nidwalden|Nidwald|Nidvaldo|Glarus|Glaris|Glarona|Zug|Zoug|Zugo|Fribourg|Freiburg|Friburgo|Solothurn|Soleure|Soletta|Basel[- ]Stadt|B\u00e2le[- ]Ville|Basilea Citt\u00e0|Basilea Citta|Basel[- ]Landschaft|B\u00e2le[- ]Campagne|Basilea Campagna|Schaffhausen|Schaffhouse|Sciaffusa|Appenzell Ausserrhoden|Appenzell Rhodes[- ]Ext\u00e9rieures|Appenzello Esterno|Appenzell Innerrhoden|Appenzell Rhodes[- ]Int\u00e9rieures|Appenzello Interno|St\\. Gallen|Sankt Gallen|San Gallo|Saint[- ]Gall|Graub\u00fcnden|Graubuenden|Grisons|Grigioni|Aargau|Argovie|Thurgau|Thurgovie|Tessin|Ticino|Vaud|Waadt|Valais|Wallis|Vallese|Neuch\u00e2tel|Neuenburg|Gen\u00e8ve|Geneve|Geneva|Ginevra|Genf|Jura|Giura)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 9730,
    "headerPatterns": [
      {
        "regExp": "(?i).*(canton|kanton).*(full|long).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Canton Full Name"
        ],
        "negativeExamples": [
          "Canton Code"
        ]
      },
      {
        "regExp": "(?i).*(swiss|ch).*(canton|kanton).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CH Canton Name"
        ],
        "negativeExamples": [
          "Country Name"
        ]
      },
      {
        "regExp": "(?i).*(canton|kanton).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Canton Name"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(canton|kanton).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Kanton"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "number"
        ]
      }
    ],
    "positiveContentExamples": [
      "Z\u00fcrich",
      "Bern",
      "Basel-Stadt",
      "Appenzell Ausserrhoden",
      "St. Gallen",
      "Graub\u00fcnden",
      "Vaud",
      "Neuch\u00e2tel"
    ],
    "negativeContentExamples": [
      "Canton Zurich",
      "Basel",
      "St Gallen",
      "Appenzell",
      "Graubunden",
      "Neuchatel",
      "Valais Region",
      "ZH"
    ],
    "positiveHeaderExamples": [
      "Kanton",
      "Canton Name",
      "Canton",
      "Canton Full Name",
      "CH Canton",
      "Swiss Canton",
      "Canton (CH)",
      "Canton Long Name"
    ],
    "negativeHeaderExamples": [
      "Canton Code",
      "Country",
      "City",
      "Province Code",
      "Region",
      "State Abbrev",
      "Postal Code",
      "Country Name"
    ],
    "explanation": "This semantic type identifies Swiss first-level administrative divisions (cantons) by their full name, accounting for common language variants (German, French, Italian) and standard hyphenation where applicable. Use it to recognize and validate fields that store the full canton name within Swiss address, geography, or administrative datasets.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:14.578660"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_DE",
    "description": "de_bundesland: complete German federal state name",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "BADEN-W\u00dcRTTEMBERG",
      "BAYERN",
      "BERLIN",
      "BRANDENBURG",
      "BREMEN",
      "HAMBURG",
      "HESSEN",
      "MECKLENBURG-VORPOMMERN",
      "NIEDERSACHSEN",
      "NORDRHEIN-WESTFALEN",
      "RHEINLAND-PFALZ",
      "SAARLAND",
      "SACHSEN",
      "SACHSEN-ANHALT",
      "SCHLESWIG-HOLSTEIN",
      "TH\u00dcRINGEN"
    ],
    "backout": "^[A-Z\u00c4\u00d6\u00dc\u1e9e]+([ -][A-Z\u00c4\u00d6\u00dc\u1e9e]+){0,2}$",
    "confidenceThreshold": 98,
    "priority": 10130,
    "headerPatterns": [
      {
        "regExp": "(?i).*(german|de).*(state|bundesland).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "German State Name"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*(state|bundesland).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Name"
        ],
        "negativeExamples": [
          "German State"
        ]
      },
      {
        "regExp": "(?i).*(german|de).*(state|bundesland).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "German State"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*bundesland.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Bundesland"
        ],
        "negativeExamples": [
          "Province"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Baden-W\u00fcrttemberg",
      "Bayern",
      "Berlin",
      "Mecklenburg-Vorpommern",
      "Nordrhein-Westfalen",
      "Rheinland-Pfalz",
      "Sachsen-Anhalt",
      "Schleswig-Holstein"
    ],
    "negativeContentExamples": [
      "Nordrhein Westfalen",
      "Mecklenburg Vorpommern",
      "Baden Wurttemberg",
      "Bavaria",
      "Hesse",
      "Sachsen Anhalt",
      "Schleswig Holstein",
      "Niedersachen"
    ],
    "positiveHeaderExamples": [
      "Bundesland",
      "State",
      "German State",
      "DE Bundesland",
      "State Name",
      "German State Name"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Region",
      "City",
      "Province",
      "County",
      "State Code",
      "Country Name"
    ],
    "explanation": "This semantic type recognizes complete names of Germany's 16 federal states (Bundesl\u00e4nder). It is best used to validate or classify columns containing full German state names in natural language form (including hyphens and umlauts).",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:14.657944"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.REGION_NAME_PE",
    "description": "Names of first-level administrative regions of Peru (regiones), expressed as the official region names in Spanish (uppercase, with diacritics where applicable). Typical values include single- and multi-word region names such as LIMA, CUSCO, LA LIBERTAD, and MADRE DE DIOS.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AMAZONAS",
      "\u00c1NCASH",
      "APUR\u00cdMAC",
      "AREQUIPA",
      "AYACUCHO",
      "CAJAMARCA",
      "CALLAO",
      "CUSCO",
      "HUANCAVELICA",
      "HU\u00c1NUCO",
      "ICA",
      "JUN\u00cdN",
      "LA LIBERTAD",
      "LAMBAYEQUE",
      "LIMA",
      "LORETO",
      "MADRE DE DIOS",
      "MOQUEGUA",
      "PASCO",
      "PIURA",
      "PUNO",
      "SAN MART\u00cdN",
      "TACNA",
      "TUMBES",
      "UCAYALI"
    ],
    "backout": "^[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1]+( [A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1]+){0,3}$",
    "confidenceThreshold": 97,
    "priority": 10050,
    "headerPatterns": [
      {
        "regExp": "(?i).*peru.*region.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "peru region name"
        ],
        "negativeExamples": [
          "country name"
        ]
      },
      {
        "regExp": "(?i).*(region|regi\u00f3n).*name.*pe.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "region name pe"
        ],
        "negativeExamples": [
          "region code"
        ]
      },
      {
        "regExp": "(?i).*peru.*region.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Peruvian Region"
        ],
        "negativeExamples": [
          "Peruvian Province"
        ]
      },
      {
        "regExp": "(?i).*(region|regi\u00f3n).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Regi\u00f3n"
        ],
        "negativeExamples": [
          "Province"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Region Name"
        ],
        "negativeExamples": [
          "Region Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "LIMA",
      "CALLAO",
      "AREQUIPA",
      "CUSCO",
      "LA LIBERTAD",
      "SAN MART\u00cdN",
      "MADRE DE DIOS",
      "\u00c1NCASH"
    ],
    "negativeContentExamples": [
      "LIMA METROPOLITANA",
      "PROVINCIA DE LIMA",
      "AREQUIPA CITY",
      "CUZCO",
      "SAN MARTIN",
      "MADRE DE DIOS REGION",
      "REGI\u00d3N LIMA",
      "ANCASH"
    ],
    "positiveHeaderExamples": [
      "Regi\u00f3n",
      "Region",
      "Peruvian Region",
      "Region Name",
      "Peru Region",
      "Regi\u00f3n del Per\u00fa"
    ],
    "negativeHeaderExamples": [
      "Province",
      "Country",
      "City",
      "Region Code",
      "Province Name",
      "State"
    ],
    "explanation": "This semantic type identifies the official names of Peru\u2019s first-level administrative regions. It is best used to validate or standardize columns that store region names in Spanish, ensuring consistent diacritics and formatting for regional analysis, geocoding, or data integration workflows.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:16.741824"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.DISTRICT_NAME_IN",
    "description": "Names of Indian administrative districts (second-level administrative divisions) as they typically appear in datasets, written in title case and composed of 2\u20134 space-separated tokens, optionally including a numeric token (e.g., 24) and common qualifiers like Urban, Suburban, City, or Parganas. This type focuses on district names rather than states, countries, or cities.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z][a-z]{2,}|North|South|East|West)(\\s([A-Z][a-z]{2,}|[1-9][0-9]{0,2}|Urban|Suburban|City|Parganas)){1,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 9820,
    "headerPatterns": [
      {
        "regExp": "(?i).*indian.*district.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Indian District Name"
        ],
        "negativeExamples": [
          "District Name"
        ]
      },
      {
        "regExp": "(?i).*(district|dist).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "District Name"
        ],
        "negativeExamples": [
          "Indian District"
        ]
      },
      {
        "regExp": "(?i).*(india|indian|in).*district.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Indian District"
        ],
        "negativeExamples": [
          "City District"
        ]
      },
      {
        "regExp": "(?i).*district.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "District"
        ],
        "negativeExamples": [
          "State"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Bengaluru Urban",
      "Mumbai Suburban",
      "North 24 Parganas",
      "South Andaman",
      "Shaheed Bhagat Singh Nagar",
      "New Delhi",
      "West Khasi Hills",
      "Sri Potti Sriramulu Nellore"
    ],
    "negativeContentExamples": [
      "South-24 Parganas",
      "Mumbai-Suburban",
      "North24 Parganas",
      "BengaluruUrban",
      "New-Delhi",
      "S P S Nellore",
      "Thiruvallur.",
      "J P Nagar"
    ],
    "positiveHeaderExamples": [
      "District",
      "Indian District",
      "District Name",
      "Districts of India",
      "District (IN)",
      "Administrative District",
      "Districts"
    ],
    "negativeHeaderExamples": [
      "State",
      "Country",
      "City",
      "Province",
      "Region",
      "County",
      "Tehsil",
      "Postal Code"
    ],
    "explanation": "This semantic type identifies Indian district names in data columns, leveraging a regex that matches 2\u20134 title-cased tokens with optional numeric tokens and common district qualifiers (Urban, Suburban, City, Parganas). Header patterns guide detection from highly specific (Indian district name) to the primitive concept (name), balancing precision and recall while avoiding anchors and overly permissive wildcards in value patterns. Typical uses include normalizing administrative geographies, preparing for joins to district reference tables, and validating district-level aggregations.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:18.352882"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PREFECTURE_NAME_JA",
    "description": "Japanese region: prefectural administrative division. Represents the official Japanese names of the 47 prefectural-level jurisdictions, ending in one of the standard suffixes \u90fd, \u9053, \u5e9c, or \u770c.",
    "pluginType": "regex",
    "regexPattern": "[\u4e00-\u9faf]{2,5}(\u90fd|\u9053|\u5e9c|\u770c)",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 9910,
    "headerPatterns": [
      {
        "regExp": "(?i).*(\u90fd\u9053\u5e9c\u770c\u540d|prefecture name|japanese prefecture).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Japanese Prefecture"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(\u90fd\u9053\u5e9c\u770c|prefecture).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u90fd\u9053\u5e9c\u770c"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*(pref|todofuken).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Pref"
        ],
        "negativeExamples": [
          "Province Code"
        ]
      },
      {
        "regExp": "(?i).*(jp[ _-]*prefecture).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "JP Prefecture"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Prefecture Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "\u6771\u4eac\u90fd",
      "\u5317\u6d77\u9053",
      "\u5927\u962a\u5e9c",
      "\u4eac\u90fd\u5e9c",
      "\u795e\u5948\u5ddd\u770c",
      "\u9752\u68ee\u770c",
      "\u4e09\u91cd\u770c",
      "\u9e7f\u5150\u5cf6\u770c"
    ],
    "negativeContentExamples": [
      "\u6771\u4eac",
      "\u5927\u962a",
      "\u672d\u5e4c\u5e02",
      "\u8fd1\u757f\u5730\u65b9",
      "Prefecture",
      "Hokkaido",
      "JP Prefecture",
      "\u4eac\u90fd\u5e02"
    ],
    "positiveHeaderExamples": [
      "\u90fd\u9053\u5e9c\u770c",
      "Prefecture",
      "Japanese Prefecture",
      "\u90fd\u9053\u5e9c\u770c\u540d",
      "Prefecture Name",
      "JP Prefecture",
      "\u770c\u540d"
    ],
    "negativeHeaderExamples": [
      "\u56fd",
      "Country",
      "City",
      "Province Code",
      "State",
      "Region",
      "Municipality"
    ],
    "explanation": "This semantic type identifies Japanese prefecture names written in Japanese characters that end with one of the standard administrative suffixes \u90fd, \u9053, \u5e9c, or \u770c. It is useful for classifying address components and administrative divisions within Japan where values are full prefecture names rather than codes.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:22.184117"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.REGION_NAME_FR",
    "description": "French territorial administrative designation for the official names of current regions of France (m\u00e9tropole and overseas) in French.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AUVERGNE-RH\u00d4NE-ALPES",
      "BOURGOGNE-FRANCHE-COMT\u00c9",
      "BRETAGNE",
      "CENTRE-VAL DE LOIRE",
      "CORSE",
      "GRAND EST",
      "HAUTS-DE-FRANCE",
      "\u00ceLE-DE-FRANCE",
      "NORMANDIE",
      "NOUVELLE-AQUITAINE",
      "OCCITANIE",
      "PAYS DE LA LOIRE",
      "PROVENCE-ALPES-C\u00d4TE D'AZUR",
      "GUADELOUPE",
      "MARTINIQUE",
      "GUYANE",
      "LA R\u00c9UNION",
      "MAYOTTE"
    ],
    "backout": "^[A-Z\u00c0-\u00d6\u00d8-\u00dd' \\-]{3,40}$",
    "confidenceThreshold": 98,
    "priority": 10030,
    "headerPatterns": [
      {
        "regExp": "(?i).*french.*region.*name.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "French Region Name"
        ],
        "negativeExamples": [
          "French Region Code"
        ]
      },
      {
        "regExp": "(?i).*french.*region.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "French Region"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(region[_ ]?fr|fr[_ ]?region|r\u00e9gion[_ ]?fr).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Region FR"
        ],
        "negativeExamples": [
          "Region Code"
        ]
      },
      {
        "regExp": "(?i).*(r\u00e9gion|region).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "R\u00e9gion"
        ],
        "negativeExamples": [
          "Department"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "\u00ceLE-DE-FRANCE",
      "PROVENCE-ALPES-C\u00d4TE D'AZUR",
      "HAUTS-DE-FRANCE",
      "LA R\u00c9UNION",
      "CENTRE-VAL DE LOIRE",
      "NOUVELLE-AQUITAINE",
      "BRETAGNE",
      "GRAND EST"
    ],
    "negativeContentExamples": [
      "ILE DE FRANCE",
      "PROVENCE ALPES COTE D'AZUR",
      "HAUTS DE FRANCE",
      "CENTRE VAL DE LOIRE",
      "NORMANDY",
      "PARIS",
      "BOURGOGNE",
      "RH\u00d4NE-ALPES"
    ],
    "positiveHeaderExamples": [
      "R\u00e9gion",
      "Region",
      "French Region",
      "French Region Name",
      "Region FR",
      "R\u00e9gion Fran\u00e7aise",
      "Region Name FR",
      "R\u00e9gion Fran\u00e7aise Name"
    ],
    "negativeHeaderExamples": [
      "Department",
      "Country",
      "City",
      "Region Code",
      "Province",
      "State",
      "County",
      "Postal Code"
    ],
    "explanation": "This semantic type identifies French region names using a finite, authoritative list of current French regions (including overseas). It is suitable for classifying columns that contain full region names rather than codes or abbreviations, ensuring high precision in French administrative geography contexts.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:22.399342"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_AU",
    "description": "Two- or three-letter Australian state/territory codes used as compact designations (e.g., NSW, VIC, QLD, SA, WA, TAS, NT, ACT). Intended for fields that store the abbreviated code rather than the full state/territory name.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "NSW",
      "VIC",
      "QLD",
      "SA",
      "WA",
      "TAS",
      "NT",
      "ACT"
    ],
    "backout": "^[A-Z]{2,3}$",
    "confidenceThreshold": 98,
    "priority": 10070,
    "headerPatterns": [
      {
        "regExp": "(?i).*(au|australia|australian).*(state|territory).*(code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "AU State Code"
        ],
        "negativeExamples": [
          "State Name"
        ]
      },
      {
        "regExp": "(?i).*(state|territory).*(code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Code"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*(au|aus).*(st|state).*(abbr|abbrev|short|code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "AUS St Abbrev"
        ],
        "negativeExamples": [
          "Territory"
        ]
      },
      {
        "regExp": "(?i).*(state|territory).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "State"
        ]
      }
    ],
    "positiveContentExamples": [
      "NSW",
      "VIC",
      "QLD",
      "SA",
      "WA",
      "TAS",
      "NT",
      "ACT"
    ],
    "negativeContentExamples": [
      "NS",
      "NSW1",
      "AU-NSW",
      "N SW",
      "VIC.",
      "NEW SOUTH WALES",
      "A.C.T",
      "WA-"
    ],
    "positiveHeaderExamples": [
      "State Code",
      "Australian State",
      "State",
      "AU State Code",
      "AUS St Abbrev",
      "Territory Code",
      "State Abbreviation",
      "AU Territory Code"
    ],
    "negativeHeaderExamples": [
      "State Name",
      "Country",
      "Territory",
      "Province Name",
      "Country Code",
      "Postal Code",
      "Region",
      "City"
    ],
    "explanation": "This semantic type identifies Australian state/territory abbreviations in two- or three-letter code form (e.g., NSW, QLD, ACT). It is suitable for columns storing standardized short codes rather than full state or territory names.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:25.123597"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.REGION_NAME_TZ",
    "description": "mkoa_tanzania: Tanzanian administrative regional designation. Matches official names of Tanzania's first-level administrative regions (mainland and Zanzibar), optionally with the word \"Region\" appended.",
    "pluginType": "regex",
    "regexPattern": "\\b(Arusha|Dar es Salaam|Dodoma|Geita|Iringa|Kagera|Katavi|Kigoma|Kilimanjaro|Lindi|Manyara|Mara|Mbeya|Morogoro|Mtwara|Mwanza|Njombe|Pwani|Rukwa|Ruvuma|Shinyanga|Simiyu|Singida|Songwe|Tabora|Tanga|Mjini Magharibi|Pemba North|Pemba South|Unguja North|Unguja South|Kaskazini Pemba|Kusini Pemba|Kaskazini Unguja|Kusini Unguja)(\\s+Region)?\\b",
    "regexPatternFlags": null,
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 10060,
    "headerPatterns": [
      {
        "regExp": "(?i).*(tanzania|tz).*(region|mkoa).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "TZ Region Name"
        ],
        "negativeExamples": [
          "Region"
        ]
      },
      {
        "regExp": "(?i).*(tanzania|tz).*(region|mkoa).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Tanzanian Region"
        ],
        "negativeExamples": [
          "District"
        ]
      },
      {
        "regExp": "(?i).*(region|mkoa).*(name).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Region Name"
        ],
        "negativeExamples": [
          "Country Name"
        ]
      },
      {
        "regExp": "(?i).*(administrative).*(region|mkoa).*",
        "confidence": 92,
        "mandatory": false,
        "positiveExamples": [
          "Administrative Region"
        ],
        "negativeExamples": [
          "Administrative District"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 91,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Arusha",
      "Dar es Salaam",
      "Dodoma",
      "Kilimanjaro",
      "Pwani",
      "Mjini Magharibi",
      "Unguja South",
      "Songwe Region"
    ],
    "negativeContentExamples": [
      "Arusha City",
      "Tanzania",
      "Kilimanjaro East",
      "Dar-es-Salaam",
      "Mara District",
      "Unguja Central",
      "Singida Urban",
      "Mtwara Regiona"
    ],
    "positiveHeaderExamples": [
      "Region",
      "Tanzanian Region",
      "Mkoa",
      "TZ Region Name",
      "Region Name",
      "Administrative Region",
      "Mkoa wa Tanzania"
    ],
    "negativeHeaderExamples": [
      "Country",
      "District",
      "City",
      "Province",
      "County",
      "Ward",
      "Municipality"
    ],
    "explanation": "This semantic type identifies the names of Tanzania's administrative regions, including both mainland and Zanzibar regions. The regex enumerates official region names and allows an optional trailing 'Region' token to accommodate common data variations. Header patterns progress from explicit Tanzania-specific region-name signals to the primitive 'name' term to support varied column naming conventions while minimizing collisions with countries, districts, and cities.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:25.205260"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.INSEE_CODE_FR",
    "description": "French municipality code: five digit INSEE identifier. Values are strictly five consecutive digits with no spaces, letters, or punctuation.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 9840,
    "headerPatterns": [
      {
        "regExp": "(?i).*insee.*commune.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Commune INSEE Code"
        ],
        "negativeExamples": [
          "INSEE Code"
        ]
      },
      {
        "regExp": "(?i).*commune.*insee.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Commune INSEE"
        ],
        "negativeExamples": [
          "INSEE"
        ]
      },
      {
        "regExp": "(?i).*insee.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "INSEE Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*insee.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "INSEE"
        ],
        "negativeExamples": [
          "Department"
        ]
      },
      {
        "regExp": "(?i).*code.*insee.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code INSEE"
        ],
        "negativeExamples": [
          "City Name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Department"
        ]
      }
    ],
    "positiveContentExamples": [
      "01001",
      "06088",
      "33063",
      "35238",
      "59350",
      "69123",
      "75056",
      "97411"
    ],
    "negativeContentExamples": [
      "75 056",
      "75-056",
      "2A123",
      "2B123",
      "7505A",
      "750_56",
      "7 5056",
      "1234"
    ],
    "positiveHeaderExamples": [
      "Code INSEE",
      "INSEE Code",
      "INSEE",
      "Commune INSEE Code",
      "Commune INSEE",
      "INSEE Commune Code",
      "Code Commune INSEE",
      "Commune Code (INSEE)"
    ],
    "negativeHeaderExamples": [
      "City Name",
      "Department",
      "Postal Code",
      "Municipality",
      "Zip Code",
      "Region Code",
      "Area Code",
      "Province"
    ],
    "explanation": "This semantic type identifies French INSEE commune identifiers that are represented as exactly five digits, commonly used to uniquely reference municipalities in administrative datasets. It should be used when column headers reference INSEE and the values are strictly five-digit numeric codes without separators or letters.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:34.922028"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_NL",
    "description": "Netherlands locality: municipal administrative unit. Represents official municipality names (Dutch: gemeente) as plain text values without qualifiers.",
    "pluginType": "regex",
    "regexPattern": "\\b(?!.*\\b(gemeente|provincie|province|country|municipality|code)\\b)('s-|\u2019s-|`s-|'t\\s)?[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]{2,}([ -][A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]{2,}){0,5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 9900,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\b(netherlands|dutch|nl)\\b.*\\bmunicipality\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Dutch Municipality"
        ],
        "negativeExamples": [
          "Municipality Code"
        ]
      },
      {
        "regExp": "(?i).*\\bmunicipality\\b.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Municipality Name"
        ],
        "negativeExamples": [
          "Country Name"
        ]
      },
      {
        "regExp": "(?i).*\\bgemeente\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Gemeente"
        ],
        "negativeExamples": [
          "Province"
        ]
      },
      {
        "regExp": "(?i).*\\b(gem|muni)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "GEM"
        ],
        "negativeExamples": [
          "GEO"
        ]
      },
      {
        "regExp": "(?i).*municipality.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Municipality"
        ],
        "negativeExamples": [
          "Country"
        ]
      }
    ],
    "positiveContentExamples": [
      "Amsterdam",
      "Rotterdam",
      "Utrecht",
      "'s-Hertogenbosch",
      "Capelle aan den IJssel",
      "Eijsden-Margraten",
      "S\u00fadwest-Frysl\u00e2n",
      "Gooise Meren"
    ],
    "negativeContentExamples": [
      "Gemeente Amsterdam",
      "Amsterdam Municipality",
      "'s Hertogenbosch",
      "Capelle a/d IJssel",
      "Utrecht (province)",
      "Rotterdam, NL",
      "Den Haag 2511",
      "Province Noord-Holland"
    ],
    "positiveHeaderExamples": [
      "Gemeente",
      "Municipality",
      "Dutch Municipality",
      "Municipality Name",
      "NL Municipality",
      "Gemeente Naam",
      "Local Municipality"
    ],
    "negativeHeaderExamples": [
      "Province",
      "Country",
      "Municipality Code",
      "Province Name",
      "Country Code",
      "City",
      "Postal Code"
    ],
    "explanation": "This semantic type detects municipality names in the Netherlands (gemeenten) as free-text values, accounting for common Dutch naming conventions, prefixes like 's- and 't, spaces, and hyphenation. It is suitable for columns containing only the municipality name (without words such as 'Gemeente' or 'Municipality') and is best used alongside header cues like 'Gemeente' or 'Municipality' for higher precision.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:35.471573"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.FIRST",
    "description": "given_name: primary personal identifier assigned at birth",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b[a-z][a-z]{1,}([-'][a-z][a-z]{1,})?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 9330,
    "headerPatterns": [
      {
        "regExp": "(?i).*((first|given)[_\\s]*name|forename).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "First Name"
        ],
        "negativeExamples": [
          "Last Name"
        ]
      },
      {
        "regExp": "(?i).*(person|contact).*(first|given).*(name).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Person First Name"
        ],
        "negativeExamples": [
          "Company Name"
        ]
      },
      {
        "regExp": "(?i).*(f[_\\s]*name|fname|first[_\\s]*nm|given[_\\s]*nm).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "f_name"
        ],
        "negativeExamples": [
          "l_name"
        ]
      },
      {
        "regExp": "(?i).*(forename).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Forename"
        ],
        "negativeExamples": [
          "Surname"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Full Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "John",
      "Emily",
      "D'Andre",
      "Jean-Luc",
      "Maria",
      "Aaliyah",
      "Luca",
      "Mary-Jane"
    ],
    "negativeContentExamples": [
      "John Smith",
      "J.",
      "A",
      "Mary_Ann",
      "O'Neil Jr",
      "3lizabeth",
      "Anne-Marie-Sue",
      "Ana Maria"
    ],
    "positiveHeaderExamples": [
      "First Name",
      "Given Name",
      "Forename",
      "FName",
      "First_Name",
      "Given_Name",
      "Customer First Name",
      "Contact Given Name"
    ],
    "negativeHeaderExamples": [
      "Last Name",
      "Full Name",
      "Middle Name",
      "Surname",
      "Company Name",
      "Billing Name",
      "Contact Last Name",
      "Full Address"
    ],
    "explanation": "Identifies fields that contain a single given (first) name token, optionally including one internal hyphen or apostrophe. The regex is case-insensitive and excludes spaces, numerals, multiple separators, and suffixes, reducing false matches against full names or compound person identifiers.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:36.906193"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_ES",
    "description": "Spanish region: provincial administrative division. Identifies the official names of Spain's provinces, including co-official language variants and common ASCII spellings.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(\u00c1LAVA|ALAVA|ARABA|ALBACETE|ALICANTE|ALACANT|ALMER\u00cdA|ALMERIA|ASTURIAS|\u00c1VILA|AVILA|BADAJOZ|BARCELONA|BURGOS|C\u00c1CERES|CACERES|C\u00c1DIZ|CADIZ|CANTABRIA|CASTELL\u00d3N|CASTELLON|CASTELL\u00d3|CIUDAD REAL|C\u00d3RDOBA|CORDOBA|CUENCA|GIRONA|GERONA|GRANADA|GUADALAJARA|GIPUZKOA|GUIP\u00daZCOA|GUIPUZCOA|HUELVA|HUESCA|ILLES BALEARS|ISLAS BALEARES|JA\u00c9N|JAEN|A CORU\u00d1A|LA CORU\u00d1A|A CORUNA|LA CORUNA|LE\u00d3N|LEON|LLEIDA|L\u00c9RIDA|LERIDA|LUGO|MADRID|M\u00c1LAGA|MALAGA|MURCIA|NAVARRA|NAFARROA|OURENSE|ORENSE|PALENCIA|LAS PALMAS|PONTEVEDRA|LA RIOJA|SALAMANCA|SANTA CRUZ DE TENERIFE|SEGOVIA|SEVILLA|SEVILLE|SORIA|TARRAGONA|TERUEL|TOLEDO|VALENCIA|VALLADOLID|BIZKAIA|VIZCAYA|ZAMORA|ZARAGOZA)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 9960,
    "headerPatterns": [
      {
        "regExp": "(?i).*(province|provincia).*(name|nombre).*(es|spain).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province_name_es"
        ],
        "negativeExamples": [
          "province_code_es"
        ]
      },
      {
        "regExp": "(?i).*(spanish|spain|espa\u00f1a|es).*(province|provincia).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Spanish Province"
        ],
        "negativeExamples": [
          "Spanish Region"
        ]
      },
      {
        "regExp": "(?i).*(province|provincia).*(name|nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Province Name"
        ],
        "negativeExamples": [
          "Province Code"
        ]
      },
      {
        "regExp": "(?i).*prov.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "prov_name"
        ],
        "negativeExamples": [
          "prov_code"
        ]
      },
      {
        "regExp": "(?i).*(province|provincia).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Provincia"
        ],
        "negativeExamples": [
          "City"
        ]
      }
    ],
    "positiveContentExamples": [
      "Sevilla",
      "Santa Cruz de Tenerife",
      "Illes Balears",
      "A Coru\u00f1a",
      "Ciudad Real",
      "Gipuzkoa",
      "Bizkaia",
      "\u00c1lava"
    ],
    "negativeContentExamples": [
      "Provincia de Sevilla",
      "Seville Province",
      "Catalu\u00f1a",
      "Pa\u00eds Vasco",
      "Comunidad de Madrid",
      "Tenerife",
      "Baleares",
      "A Coruna City"
    ],
    "positiveHeaderExamples": [
      "Provincia",
      "Province",
      "Spanish Province",
      "province_name_es",
      "provincia",
      "prov_name",
      "es_province",
      "provincia nombre"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Region",
      "City",
      "state",
      "county",
      "department",
      "autonomous community",
      "postal_code"
    ],
    "explanation": "This semantic type detects cell values that are exact names of Spain's provinces, including accepted co-official language forms (e.g., Gipuzkoa/Guip\u00fazcoa, Illes Balears/Islas Baleares) and common ASCII variants for accented names. Use it to validate or classify fields that store Spanish province names rather than codes or broader regions.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:37.495850"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_AU",
    "description": "au_state_name: complete Australian state/territory designation",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "NEW SOUTH WALES",
      "VICTORIA",
      "QUEENSLAND",
      "SOUTH AUSTRALIA",
      "WESTERN AUSTRALIA",
      "TASMANIA",
      "NORTHERN TERRITORY",
      "AUSTRALIAN CAPITAL TERRITORY"
    ],
    "backout": "^[A-Za-z ]{8,30}$",
    "confidenceThreshold": 98,
    "priority": 10110,
    "headerPatterns": [
      {
        "regExp": "(?i).*australian.*state.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Australian State Name"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*au.*state.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "AU State Name"
        ],
        "negativeExamples": [
          "Country Name"
        ]
      },
      {
        "regExp": "(?i).*australian.*state.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Australian State"
        ],
        "negativeExamples": [
          "Australian State Code"
        ]
      },
      {
        "regExp": "(?i).*state.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Name"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "New South Wales",
      "Victoria",
      "Queensland",
      "South Australia",
      "Western Australia",
      "Tasmania",
      "Northern Territory",
      "Australian Capital Territory"
    ],
    "negativeContentExamples": [
      "NSW",
      "VIC",
      "QLD",
      "SA",
      "WA",
      "TAS",
      "NT",
      "ACT"
    ],
    "positiveHeaderExamples": [
      "State",
      "Australian State",
      "State Name",
      "Australian State Name",
      "AU State Name",
      "Australia State",
      "State/Territory Name"
    ],
    "negativeHeaderExamples": [
      "State Code",
      "Country",
      "Territory",
      "Province",
      "Region",
      "State Abbreviation",
      "AU State Code"
    ],
    "explanation": "Identifies full Australian state and territory names in data fields. Useful for validating location dimensions, standardizing values for joins and analytics, and preventing abbreviation/code entries when full names are required.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:40.912991"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_MX",
    "description": "mx_estado_code: Mexican state/federal entity designation",
    "pluginType": "regex",
    "regexPattern": "\\bMX-[A-Z]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 10100,
    "headerPatterns": [
      {
        "regExp": "(?i).*mx.*state.*code.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "MX State Code"
        ],
        "negativeExamples": [
          "Mexican State"
        ]
      },
      {
        "regExp": "(?i).*mexic.*state.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Mexican State"
        ],
        "negativeExamples": [
          "State Name"
        ]
      },
      {
        "regExp": "(?i).*estado.*c[o\u00f3]digo.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "C\u00f3digo de Estado"
        ],
        "negativeExamples": [
          "Estado"
        ]
      },
      {
        "regExp": "(?i).*entidad.*federativa.*c[o\u00f3]digo.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Entidad Federativa C\u00f3digo"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "MX-AGU",
      "MX-BCN",
      "MX-BCS",
      "MX-CMX",
      "MX-JAL",
      "MX-NLE",
      "MX-QUE",
      "MX-YUC"
    ],
    "negativeContentExamples": [
      "AGU",
      "MX-AG",
      "MX-AGUA",
      "MX-123",
      "US-BCN",
      "MX BCN",
      "MX-agu",
      "MX_QUE"
    ],
    "positiveHeaderExamples": [
      "Estado",
      "State Code",
      "Mexican State",
      "MX State Code",
      "C\u00f3digo de Estado",
      "Entidad Federativa C\u00f3digo",
      "Estado C\u00f3digo"
    ],
    "negativeHeaderExamples": [
      "State Name",
      "Country",
      "Municipality",
      "Province Code",
      "Region",
      "Postal Code",
      "City"
    ],
    "explanation": "This semantic type identifies Mexican state or federal entity codes formatted with the country prefix followed by a three-letter subdivision indicator (e.g., MX-AGU). It is useful for validating and classifying datasets that store Mexico-specific state codes rather than full state names.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:41.569805"
  },
  {
    "resultType": "generated",
    "semanticType": "INDUSTRY_EN",
    "description": "Descriptive English name of the primary business sector or economic activity (e.g., Manufacturing, Retail Trade, Information Technology Services). Intended for human-readable industry/sector labels rather than coded classifications.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(agriculture|forestry and logging|oil and gas|real estate|public administration|information technology|professional services|scientific services|technical services|food services|social assistance|health care|healthcare|retail trade|wholesale trade|transportation and warehousing|arts entertainment and recreation|accommodation and food services|administrative and support|waste management|education services|legal services|accounting services|marketing services|advertising services|software development|biotechnology|aerospace|automotive|construction|manufacturing|mining|utilities|finance|banking|insurance|logistics|consulting|energy|metals|paper|plastics|printing|publishing|chemical|pharmaceutical|textile|apparel|warehousing|telecommunications|technology|government|nonprofit|e-commerce|hospitality)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 9220,
    "headerPatterns": [
      {
        "regExp": "(?i).*(industry|business)[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Industry Name"
        ],
        "negativeExamples": [
          "NAICS Code"
        ]
      },
      {
        "regExp": "(?i).*business[ _-]*sector.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Business Sector"
        ],
        "negativeExamples": [
          "Industry Code"
        ]
      },
      {
        "regExp": "(?i).*(primary|main)[ _-]*(industry|sector).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Primary Industry"
        ],
        "negativeExamples": [
          "Company Name"
        ]
      },
      {
        "regExp": "(?i).*industry.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Industry"
        ],
        "negativeExamples": [
          "Sector Code"
        ]
      },
      {
        "regExp": "(?i).*sector.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Sector Name"
        ],
        "negativeExamples": [
          "Industry Code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Industry Name"
        ],
        "negativeExamples": [
          "Industry Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Manufacturing",
      "Retail Trade",
      "Information Technology Services",
      "Professional, Scientific, and Technical Services",
      "Healthcare and Social Assistance",
      "Construction",
      "Transportation and Warehousing",
      "Real Estate"
    ],
    "negativeContentExamples": [
      "NAICS 54",
      "SIC 5812",
      "541330",
      "Retailer",
      "Insurer",
      "Technical Support",
      "Public Sector",
      "IT Department"
    ],
    "positiveHeaderExamples": [
      "Industry",
      "Industry Name",
      "Business Sector",
      "Primary Industry",
      "Main Business Sector",
      "Sector Name",
      "Industry Description"
    ],
    "negativeHeaderExamples": [
      "NAICS Code",
      "Company Name",
      "Revenue",
      "Sector Code",
      "Industry Code",
      "Department",
      "Product Category"
    ],
    "explanation": "This semantic type identifies human-readable industry or business sector names in English. It targets phrases commonly used to label a company's primary economic activity and is suitable for columns labeled Industry or Business Sector. It avoids coded classifications and focuses on descriptive text. Use it to normalize or profile free-text industry fields and to distinguish them from code-based taxonomies.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:46.661384"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_MX",
    "description": "mx_estado_name: complete Mexican state/federal entity name",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AGUASCALIENTES",
      "BAJA CALIFORNIA",
      "BAJA CALIFORNIA SUR",
      "CAMPECHE",
      "CHIAPAS",
      "CHIHUAHUA",
      "CIUDAD DE M\u00c9XICO",
      "COAHUILA DE ZARAGOZA",
      "COLIMA",
      "DURANGO",
      "GUANAJUATO",
      "GUERRERO",
      "HIDALGO",
      "JALISCO",
      "MICHOAC\u00c1N DE OCAMPO",
      "MORELOS",
      "NAYARIT",
      "NUEVO LE\u00d3N",
      "OAXACA",
      "PUEBLA",
      "QUER\u00c9TARO",
      "QUINTANA ROO",
      "SAN LUIS POTOS\u00cd",
      "VERACRUZ DE IGNACIO DE LA LLAVE",
      "YUCAT\u00c1N"
    ],
    "backout": "^[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1]{2,20}( [A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1]{2,20}){0,5}$",
    "confidenceThreshold": 93,
    "priority": 10140,
    "headerPatterns": [
      {
        "regExp": "(?i).*(mx|mexico|mexican).*(state|estado).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Mexican State Name"
        ],
        "negativeExamples": [
          "Mexican State"
        ]
      },
      {
        "regExp": "(?i).*(state|estado).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Name"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*(entidad|entidad federativa).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Entidad Federativa Name"
        ],
        "negativeExamples": [
          "Entidad Codigo"
        ]
      },
      {
        "regExp": "(?i).*(st|edo)[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "st_name"
        ],
        "negativeExamples": [
          "st_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "CIUDAD DE M\u00c9XICO",
      "BAJA CALIFORNIA SUR",
      "COAHUILA DE ZARAGOZA",
      "MICHOAC\u00c1N DE OCAMPO",
      "NUEVO LE\u00d3N",
      "QUINTANA ROO",
      "SAN LUIS POTOS\u00cd",
      "VERACRUZ DE IGNACIO DE LA LLAVE"
    ],
    "negativeContentExamples": [
      "CDMX",
      "CIUDAD DE MEXICO",
      "EDOMEX",
      "ESTADO DE JALISCO",
      "COAHUILA",
      "VERACRUZ",
      "SAN LUIS POTOSI",
      "QUERETARO"
    ],
    "positiveHeaderExamples": [
      "Estado",
      "State",
      "Mexican State",
      "State Name",
      "Estado Name",
      "Mexican State Name",
      "MX Estado",
      "Entidad Federativa"
    ],
    "negativeHeaderExamples": [
      "State Code",
      "Country",
      "Municipality",
      "Province",
      "Region",
      "City",
      "County",
      "Postal Code"
    ],
    "explanation": "Represents the full official names of Mexico's federal entities (states and the capital), intended for datasets that store the complete state name, including multi-word and accented forms where applicable. Use this type to validate or standardize state/federal entity names in Mexico and distinguish them from codes or abbreviations.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:46.999459"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_ZA",
    "description": "South African territory: provincial administrative division. This type matches the official names of South Africa's nine provinces, not abbreviations, codes, or subdivisions.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "EASTERN CAPE",
      "FREE STATE",
      "GAUTENG",
      "KWAZULU-NATAL",
      "LIMPOPO",
      "MPUMALANGA",
      "NORTHERN CAPE",
      "NORTH WEST",
      "WESTERN CAPE"
    ],
    "backout": "^[A-Z][A-Z-]+( [A-Z][A-Z-]+){0,2}$",
    "confidenceThreshold": 98,
    "priority": 10010,
    "headerPatterns": [
      {
        "regExp": "(?i).*south\\s*african.*province.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "South African Province Name"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      },
      {
        "regExp": "(?i).*south\\s*african.*province.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "South African Province"
        ],
        "negativeExamples": [
          "Province"
        ]
      },
      {
        "regExp": "(?i).*za.*province.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ZA Province"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      },
      {
        "regExp": "(?i).*prov.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Prov"
        ],
        "negativeExamples": [
          "State"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Title"
        ]
      }
    ],
    "positiveContentExamples": [
      "EASTERN CAPE",
      "FREE STATE",
      "GAUTENG",
      "KWAZULU-NATAL",
      "LIMPOPO",
      "MPUMALANGA",
      "NORTHERN CAPE",
      "WESTERN CAPE"
    ],
    "negativeContentExamples": [
      "Gauteng Province",
      "WESTERN-CAPE",
      "KWAZULU NATAL",
      "NORTHERN CAPE PROVINCE",
      "NORTHWEST",
      "EASTERNCAPE",
      "CAPE TOWN",
      "PROVINCE"
    ],
    "positiveHeaderExamples": [
      "Province",
      "South African Province",
      "Province Name",
      "ZA Province",
      "South African Province Name",
      "ZA Province Name",
      "Province (ZA)"
    ],
    "negativeHeaderExamples": [
      "Country",
      "District",
      "City",
      "State",
      "Region",
      "Province Code",
      "County"
    ],
    "explanation": "Identifies the official names of South Africa's nine provinces in datasets, supporting validation and standardization for location-related analytics, reporting, and geographic segmentation. Use when the column contains full province names, not abbreviations or codes.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:50.832869"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_US",
    "description": "us_state_code: American state designation",
    "pluginType": "regex",
    "regexPattern": "\\b(AL|AK|AZ|AR|CA|CO|CT|DE|FL|GA|HI|ID|IL|IN|IA|KS|KY|LA|ME|MD|MA|MI|MN|MS|MO|MT|NE|NV|NH|NJ|NM|NY|NC|ND|OH|OK|OR|PA|RI|SC|SD|TN|TX|UT|VT|VA|WA|WV|WI|WY)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 10200,
    "headerPatterns": [
      {
        "regExp": "(?i).*us.*state.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "US State Code"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*state.*postal.*code.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "State Postal Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*state.*code.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "State Code"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*us.*state.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "US State"
        ],
        "negativeExamples": [
          "State Name"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "State Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "CA",
      "NY",
      "TX",
      "FL",
      "WA",
      "OR",
      "IL",
      "GA"
    ],
    "negativeContentExamples": [
      "DC",
      "PR",
      "ZZ",
      "Ca",
      "CAL",
      "N Y",
      "NYC",
      "TX1"
    ],
    "positiveHeaderExamples": [
      "State Code",
      "US State",
      "State",
      "US State Code",
      "State Postal Code",
      "State Abbreviation",
      "ST Code"
    ],
    "negativeHeaderExamples": [
      "State Name",
      "Country",
      "County",
      "Country Code",
      "Postal Code",
      "Province Code",
      "Region"
    ],
    "explanation": "This semantic type matches two-letter uppercase USPS state codes for the 50 U.S. states only. It is useful for validating and classifying columns that store standardized state designations such as CA, NY, or TX. The regex uses word boundaries and an explicit whitelist of valid codes to minimize false positives. Values like DC and PR are excluded to focus strictly on states, and lowercase or embellished variants (e.g., Ca, NYC) are not considered valid.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:50.908875"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_PROVINCE_NA",
    "description": "na_state_province: North American territorial code designation",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(AB|BC|MB|NB|NL|NS|NT|NU|ON|PE|QC|SK|YT|AL|AK|AZ|AR|CA|CO|CT|DE|FL|GA|HI|ID|IL|IN|IA|KS|KY|LA|ME|MD|MA|MI|MN|MS|MO|MT|NE|NV|NH|NJ|NM|NY|NC|ND|OH|OK|OR|PA|RI|SC|SD|TN|TX|UT|VT|VA|WA|WV|WI|WY|DC|PR|GU|VI|AS|MP)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 10160,
    "headerPatterns": [
      {
        "regExp": "(?i).*(state|st)[ _/.-]*(province|prov)[ _-]*(code|cd).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State/Province Code"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      },
      {
        "regExp": "(?i).*(state|province)[ _/.-]*(code|cd).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Code"
        ],
        "negativeExamples": [
          "State Name"
        ]
      },
      {
        "regExp": "(?i).*(us|usa)[ _-]*(state|st)[ _-]*(code|cd).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "US State Code"
        ],
        "negativeExamples": [
          "State Name"
        ]
      },
      {
        "regExp": "(?i).*(canada|ca)[ _-]*(province|prov)[ _-]*(code|cd).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CA Province Code"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      },
      {
        "regExp": "(?i).*state[ _/.-]*province.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State/Province"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "CA",
      "NY",
      "TX",
      "QC",
      "ON",
      "BC",
      "DC",
      "PR"
    ],
    "negativeContentExamples": [
      "NYC",
      "C-A",
      "N.S.",
      "US",
      "CAN",
      "ON1",
      "QUE",
      "MX"
    ],
    "positiveHeaderExamples": [
      "State Code",
      "Province Code",
      "State/Province",
      "US State Code",
      "CA Province Code",
      "State/Prov Code",
      "Subdivision Code",
      "SP Code"
    ],
    "negativeHeaderExamples": [
      "State Name",
      "Province Name",
      "Country",
      "Country Code",
      "Postal Code",
      "County",
      "Region",
      "City"
    ],
    "explanation": "Identifies North American state and province territorial codes expressed as two-letter postal-style abbreviations for U.S. states, District of Columbia, U.S. territories (e.g., PR, GU), and Canadian provinces/territories (e.g., ON, QC, BC). The value pattern enumerates the allowed abbreviations and is case-insensitive, using word boundaries to ensure token-level matches. Typical use cases include normalizing location columns that store state/province codes, validating input, and schema discovery across North American datasets.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:51.343946"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_IT",
    "description": "Italian territory: provincial administrative division",
    "pluginType": "regex",
    "regexPattern": "\\b(L'[A-Z\u00c0-\u00d6\u00d8-\u00de][a-z\u00e0-\u00f6\u00f8-\u00ff]+|[A-Z\u00c0-\u00d6\u00d8-\u00de][a-z\u00e0-\u00f6\u00f8-\u00ff]+)(( (e|di|del|della|dei|degli) [A-Z\u00c0-\u00d6\u00d8-\u00de][a-z\u00e0-\u00f6\u00f8-\u00ff]+)|([- ][A-Z\u00c0-\u00d6\u00d8-\u00de][a-z\u00e0-\u00f6\u00f8-\u00ff]+)){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 9980,
    "headerPatterns": [
      {
        "regExp": "(?i).*(it|italian|italy).*(province|provincia).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "it_province_name"
        ],
        "negativeExamples": [
          "it_province_code"
        ]
      },
      {
        "regExp": "(?i).*(italian|it|italy).*(province|provincia).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Italian Province"
        ],
        "negativeExamples": [
          "Province Code"
        ]
      },
      {
        "regExp": "(?i).*(province|provincia).*(name).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Province Name"
        ],
        "negativeExamples": [
          "Province Code"
        ]
      },
      {
        "regExp": "(?i).*(prov|prv).*(name).*",
        "confidence": 90,
        "mandatory": false,
        "positiveExamples": [
          "prov_name"
        ],
        "negativeExamples": [
          "prov_id"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Milano",
      "Roma",
      "Torino",
      "Napoli",
      "L'Aquila",
      "Forl\u00ec-Cesena",
      "Monza e Brianza",
      "Verbano-Cusio-Ossola"
    ],
    "negativeContentExamples": [
      "Lombardia",
      "Provincia di Milano",
      "MI",
      "Milano (MI)",
      "Rome",
      "Trentino-Alto Adige",
      "Reggio nell'Emilia",
      "Citt\u00e0 Metropolitana di Napoli"
    ],
    "positiveHeaderExamples": [
      "Provincia",
      "Province",
      "Italian Province",
      "Province Name",
      "Provincia italiana",
      "IT Province",
      "Province (IT)",
      "Nome provincia"
    ],
    "negativeHeaderExamples": [
      "Province Code",
      "Region",
      "Country",
      "State",
      "City",
      "Province Abbreviation",
      "Province ID",
      "County Name"
    ],
    "explanation": "Identifies Italian province names as free-text labels, allowing for spaces, hyphens, apostrophes, and common Italian connectors (e, di, del, della, dei, degli). Intended for columns containing the province name values themselves rather than codes or regional classifications. Use when headers indicate province naming and content consists of proper-cased Italian place names.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:52.266679"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_CODE_NL",
    "description": "Netherlands municipal code: four digit CBS identifier. A four-digit numerical identifier assigned by Statistics Netherlands (CBS) to municipalities (gemeenten) in the Netherlands.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 9880,
    "headerPatterns": [
      {
        "regExp": "(?i).*(cbs).*(gemeente|municipality).*(code|id).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "CBS Municipality Code"
        ],
        "negativeExamples": [
          "Municipality Code"
        ]
      },
      {
        "regExp": "(?i).*(nl|netherlands).*(municipality|gemeente).*(code|id).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "NL Municipality Code"
        ],
        "negativeExamples": [
          "CBS Code"
        ]
      },
      {
        "regExp": "(?i).*cbs[ _-]*(code|id).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CBS Code"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*(municipality|gemeente)[ _-]*(code|id).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Gemeente Code"
        ],
        "negativeExamples": [
          "Municipality Name"
        ]
      },
      {
        "regExp": "(?i).*(municipality|gemeente).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Municipality"
        ],
        "negativeExamples": [
          "Province"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "0003",
      "0148",
      "0344",
      "0518",
      "0632",
      "0855",
      "1234"
    ],
    "negativeContentExamples": [
      "123",
      "12345",
      "12A4",
      "A123",
      "12 34",
      "1234-5",
      "1234A"
    ],
    "positiveHeaderExamples": [
      "Gemeente Code",
      "Municipality Code",
      "CBS Code",
      "NL Municipality Code",
      "CBS Municipality Code",
      "Gemeente_ID",
      "CBS Gemeente Code"
    ],
    "negativeHeaderExamples": [
      "Municipality Name",
      "Province",
      "Country",
      "City",
      "Population",
      "Address",
      "Region"
    ],
    "explanation": "This type identifies the four-digit CBS municipality (gemeente) code used in the Netherlands. It is useful for joining administrative datasets, mapping municipal-level statistics, and validating municipality identifiers where a numeric CBS code is expected.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:55.213858"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_BR",
    "description": "br_estado_name: complete Brazilian state/federal district name",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(acre|alagoas|amap\u00e1|amazonas|bahia|cear\u00e1|distrito federal|esp\u00edrito santo|goi\u00e1s|maranh\u00e3o|mato grosso do sul|mato grosso|minas gerais|par\u00e1|para\u00edba|paran\u00e1|pernambuco|piau\u00ed|rio de janeiro|rio grande do norte|rio grande do sul|rond\u00f4nia|roraima|santa catarina|s\u00e3o paulo|sergipe|tocantins)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 10120,
    "headerPatterns": [
      {
        "regExp": "(?i).*(brazil|br).*(state|estado).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "BR State Name"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*(brazil|br).*(state|estado).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Brazilian State"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(state|estado).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Name"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*(estado).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Estado"
        ],
        "negativeExamples": [
          "Region"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "S\u00e3o Paulo",
      "Rio de Janeiro",
      "Minas Gerais",
      "Esp\u00edrito Santo",
      "Distrito Federal",
      "Paran\u00e1",
      "Rio Grande do Sul",
      "Amap\u00e1"
    ],
    "negativeContentExamples": [
      "Sao Paulo",
      "Espirito Santo",
      "Goias",
      "DistritoFederal",
      "Santa-Catarina",
      "Amapa",
      "Para",
      "Parana"
    ],
    "positiveHeaderExamples": [
      "Estado",
      "State",
      "Brazilian State",
      "BR State Name",
      "Brazil State",
      "State Name",
      "Nome do Estado",
      "Brazilian State Name"
    ],
    "negativeHeaderExamples": [
      "State Code",
      "Country",
      "Region",
      "Province",
      "UF",
      "State Abbreviation",
      "County",
      "City"
    ],
    "explanation": "Identifies full Brazilian state and federal district names in Portuguese, matching official spellings with diacritics and common multi-word forms (for example, S\u00e3o Paulo, Distrito Federal, Rio Grande do Sul). Suitable for validating or profiling datasets containing complete state names rather than codes or abbreviations.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:57:58.436448"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_UNION_NAME_IN",
    "description": "in_state_name: complete Indian state/union territory name. This identifies the official full name of an Indian state or union territory, without abbreviations, punctuation variants, or appended qualifiers.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(ANDHRA PRADESH|ARUNACHAL PRADESH|ASSAM|BIHAR|CHHATTISGARH|GOA|GUJARAT|HARYANA|HIMACHAL PRADESH|JHARKHAND|KARNATAKA|KERALA|MADHYA PRADESH|MAHARASHTRA|MANIPUR|MEGHALAYA|MIZORAM|NAGALAND|ODISHA|PUNJAB|RAJASTHAN|SIKKIM|TAMIL NADU|TELANGANA|TRIPURA|UTTAR PRADESH|UTTARAKHAND|WEST BENGAL|ANDAMAN AND NICOBAR ISLANDS|CHANDIGARH|DADRA AND NAGAR HAVELI AND DAMAN AND DIU|DELHI|JAMMU AND KASHMIR|LADAKH|LAKSHADWEEP|PUDUCHERRY)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 10190,
    "headerPatterns": [
      {
        "regExp": "(?i).*(state[/ _-]*ut).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State/UT Name"
        ],
        "negativeExamples": [
          "State/UT Code"
        ]
      },
      {
        "regExp": "(?i).*(union territory).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Union Territory Name"
        ],
        "negativeExamples": [
          "Union Territory Code"
        ]
      },
      {
        "regExp": "(?i).*(indian|india).*(state).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Indian State Name"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*(state).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Name"
        ],
        "negativeExamples": [
          "Country Name"
        ]
      },
      {
        "regExp": "(?i).*(state|union territory|ut).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State"
        ],
        "negativeExamples": [
          "District"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Number"
        ]
      }
    ],
    "positiveContentExamples": [
      "Maharashtra",
      "Uttar Pradesh",
      "Tamil Nadu",
      "Delhi",
      "Jammu and Kashmir",
      "Dadra and Nagar Haveli and Daman and Diu",
      "Andaman and Nicobar Islands",
      "Arunachal Pradesh"
    ],
    "negativeContentExamples": [
      "Maharashtra State",
      "Uttar-Pradesh",
      "TN",
      "NCT of Delhi",
      "Orissa",
      "Pondicherry",
      "Andaman & Nicobar Islands",
      "Chattisgarh"
    ],
    "positiveHeaderExamples": [
      "State",
      "Indian State",
      "Union Territory",
      "State Name",
      "State/UT Name",
      "Union Territory Name",
      "State or UT",
      "Indian State/UT"
    ],
    "negativeHeaderExamples": [
      "State Code",
      "Country",
      "District",
      "Province Code",
      "Region",
      "City",
      "County",
      "Postal Code"
    ],
    "explanation": "This semantic type detects official full names of Indian states and union territories. It is designed for datasets where the value is exactly the recognized name, not abbreviations, variants with punctuation, or names with appended qualifiers like 'State' or '(India)'. The header patterns prioritize explicit mentions of state/UT names to reduce ambiguity, while still allowing recognition of generic 'name' headers with a higher threshold.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:58:02.030156"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_PE",
    "description": "Strings that explicitly denote Peruvian provincial administrative divisions, typically using markers such as \"Provincia\", \"Prov\", or \"Province\", optionally with prepositions like \"de\", \"del\", or \"of\", or with a trailing \"Province\". Supports multi-word names and Spanish diacritics (e.g., S\u00e1nchez Carri\u00f3n, Caman\u00e1).",
    "pluginType": "regex",
    "regexPattern": "\\b(Provincia|Prov\\.|Prov|Province)\\b[\\s_-]*(de|del|of)?[\\s_-]*[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1][A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1\u00e1\u00e9\u00ed\u00f3\u00fa\u00fc\u00f1' -]{2,}\\b|\\b[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1][A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1\u00e1\u00e9\u00ed\u00f3\u00fa\u00fc\u00f1' -]{2,}[\\s_-]*(Province)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 10000,
    "headerPatterns": [
      {
        "regExp": "(?i).*(peru|peruvian).*(province|provincia).*(name|nombre).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Peru Province Name"
        ],
        "negativeExamples": [
          "City Name"
        ]
      },
      {
        "regExp": "(?i).*(peru|peruvian).*(province|provincia).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Peruvian Province"
        ],
        "negativeExamples": [
          "Country Province"
        ]
      },
      {
        "regExp": "(?i).*(prov|provincia|province).*(name|nombre).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Province Name"
        ],
        "negativeExamples": [
          "Region Name"
        ]
      },
      {
        "regExp": "(?i).*(provincia|province).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Provincia"
        ],
        "negativeExamples": [
          "Region"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Provincia de Lima",
      "Province of Arequipa",
      "Prov. Sullana",
      "Prov Ja\u00e9n",
      "Provincia S\u00e1nchez Carri\u00f3n",
      "Lima Province",
      "Urubamba Province",
      "Provincia del Santa"
    ],
    "negativeContentExamples": [
      "Region of Lima",
      "Departamento de Arequipa",
      "Lima",
      "City of Trujillo",
      "Provincia #Huancayo",
      "Lima Prov.",
      "Province 123",
      "Municipalidad de Sullana"
    ],
    "positiveHeaderExamples": [
      "Provincia",
      "Province",
      "Peruvian Province",
      "Province Name",
      "Peru Province Name",
      "Nombre Provincia",
      "Provincia Nombre"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Region",
      "City",
      "State",
      "District",
      "County",
      "Department Code",
      "Postal Code"
    ],
    "explanation": "This semantic type targets strings that identify Peruvian provinces using explicit province indicators in Spanish or English. It favors precision by requiring a leading marker (Provincia/Prov/Province) with an optional preposition and a properly cased province name, or a trailing 'Province' after the name. This helps distinguish provincial names from regions, departments, cities, or other administrative levels.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:58:03.837161"
  },
  {
    "resultType": "generated",
    "semanticType": "NATIONALITY_NL",
    "description": "Dutch-language nationality or citizenship indicator representing a person's legal relationship to a nation-state. Typical values are Dutch demonyms or adjectival forms (e.g., Nederlandse, Duits, Belgisch), possibly including hyphenated combinations for dual nationality.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]{3,}([ -][A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]{3,})*(er|ers|aar|aard|s|se|sch|sche|aans|aanse|eens|eense|ees|eese|ijns|ijnse|isch|ische)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 9410,
    "headerPatterns": [
      {
        "regExp": "(?i).*persoon.*nationaliteit.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Persoon nationaliteit"
        ],
        "negativeExamples": [
          "Land van herkomst"
        ]
      },
      {
        "regExp": "(?i).*staatsburgerschap.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Staatsburgerschap"
        ],
        "negativeExamples": [
          "Land"
        ]
      },
      {
        "regExp": "(?i).*(afkomst).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Afkomst"
        ],
        "negativeExamples": [
          "Taal"
        ]
      },
      {
        "regExp": "(?i).*nationaliteit.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Nationaliteit"
        ],
        "negativeExamples": [
          "Geboorteland"
        ]
      }
    ],
    "positiveContentExamples": [
      "Nederlandse",
      "Belgisch",
      "Duitse",
      "Amerikaans",
      "Marokkaanse",
      "Portugees",
      "Chinees",
      "Brits-Nederlands"
    ],
    "negativeContentExamples": [
      "Nederland",
      "Belgi\u00eb",
      "Frankrijk",
      "Duitsland",
      "Londen",
      "Europeaan",
      "Marokko",
      "NL"
    ],
    "positiveHeaderExamples": [
      "Nationaliteit",
      "Staatsburgerschap",
      "Afkomst",
      "Persoon nationaliteit",
      "Nederlandse nationaliteit",
      "Nationaliteit (NL)",
      "Nationaliteit burger",
      "Nationaliteit persoon"
    ],
    "negativeHeaderExamples": [
      "Land",
      "Etniciteit",
      "Taal",
      "Geboorteland",
      "Woonland",
      "Land van herkomst",
      "Moedertaal",
      "Paspoortnummer"
    ],
    "explanation": "This semantic type identifies Dutch-language nationality/citizenship values, typically expressed as demonyms or adjectival forms and sometimes hyphenated for dual nationality. It is useful for person master data, KYC datasets, HR records, and census-style attributes where the legal nation-state affiliation of a person is needed.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:58:03.837749"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_BR",
    "description": "br_estado_code: Brazilian state/federal district designation. Two-letter UF codes representing Brazil\u2019s 26 states and the Federal District (DF).",
    "pluginType": "regex",
    "regexPattern": "\\b(AC|AL|AP|AM|BA|CE|DF|ES|GO|MA|MT|MS|MG|PA|PB|PR|PE|PI|RJ|RN|RS|RO|RR|SC|SP|SE|TO)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 10080,
    "headerPatterns": [
      {
        "regExp": "(?i).*(brazil|brazilian|br).*state.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Brazilian State Code"
        ],
        "negativeExamples": [
          "State Name"
        ]
      },
      {
        "regExp": "(?i).*(estado|uf).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "UF Code"
        ],
        "negativeExamples": [
          "Region Code"
        ]
      },
      {
        "regExp": "(?i).*(brazil|br).*(state|estado|uf).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "BR State"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(estado|state).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Estado"
        ],
        "negativeExamples": [
          "Province"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Code"
        ],
        "negativeExamples": [
          "State Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "SP",
      "RJ",
      "MG",
      "RS",
      "BA",
      "PR",
      "SC",
      "DF"
    ],
    "negativeContentExamples": [
      "BR",
      "Sp",
      "sp",
      "RJ1",
      "R J",
      "SSA",
      "SR",
      "SP-"
    ],
    "positiveHeaderExamples": [
      "Estado",
      "State Code",
      "Brazilian State",
      "Brazilian State Code",
      "UF",
      "UF Code",
      "Estado UF"
    ],
    "negativeHeaderExamples": [
      "State Name",
      "Country",
      "Region",
      "Province",
      "County",
      "Zip Code",
      "Country Code"
    ],
    "explanation": "Identifies Brazilian state and Federal District designations using the official two-letter UF codes (e.g., SP, RJ, DF). Useful for validating location fields, normalizing state identifiers, and joining with geospatial reference data where Brazilian administrative units are encoded as UF abbreviations.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:58:05.893608"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS_EN",
    "description": "english_street_address: complete English-formatted street location",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{1,6}[A-Za-z]?([- ][0-9]{1,4})?\\s([A-Za-z]+\\.?)(\\s[A-Za-z]+\\.?){0,4}\\s(Street|St|Avenue|Ave|Boulevard|Blvd|Road|Rd|Drive|Dr|Lane|Ln|Court|Ct|Place|Pl|Terrace|Ter|Way|Parkway|Pkwy|Circle|Cir|Highway|Hwy)\\b(\\s(N|S|E|W|NE|NW|SE|SW))?(\\s(Apt|Apartment|Unit|Suite|Ste|Flat|Floor|Fl|Bldg|Building|Room|Rm|#)\\s?[A-Za-z0-9\\-]{1,6})?",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 10260,
    "headerPatterns": [
      {
        "regExp": "(?i).*(shipping|billing|mailing|residential).*street.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Shipping Street Address"
        ],
        "negativeExamples": [
          "Shipping City"
        ]
      },
      {
        "regExp": "(?i).*(primary|home|current).*street.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Primary Street Address"
        ],
        "negativeExamples": [
          "Home Country"
        ]
      },
      {
        "regExp": "(?i).*street.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street Address"
        ],
        "negativeExamples": [
          "Street Name"
        ]
      },
      {
        "regExp": "(?i).*(st[_ ]?addr|st[_ ]?address|addr[_ ]?street|address[_ ]?street).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "st_addr"
        ],
        "negativeExamples": [
          "st_name"
        ]
      },
      {
        "regExp": "(?i).*street.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Street"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address"
        ],
        "negativeExamples": [
          "Country"
        ]
      }
    ],
    "positiveContentExamples": [
      "123 Main St",
      "742 Evergreen Terrace",
      "1600 Pennsylvania Ave NW",
      "10 Downing Street",
      "55-59 Oxford St",
      "221B Baker Street",
      "500 Fifth Ave Suite 1200",
      "24 Wall St Apt 5B"
    ],
    "negativeContentExamples": [
      "Main Street",
      "123 Main",
      "PO Box 123",
      "123 Rue de Rivoli",
      "00123",
      "99 North",
      "Corner of Elm and 2nd",
      "12A Baker"
    ],
    "positiveHeaderExamples": [
      "Street Address",
      "Address",
      "Street",
      "Shipping Street Address",
      "Primary Street Address",
      "Billing Street Address",
      "Residential Street Address",
      "Mailing Street Address"
    ],
    "negativeHeaderExamples": [
      "City",
      "ZIP Code",
      "Country",
      "State",
      "County",
      "Coordinates",
      "Address Line 2",
      "Street Name"
    ],
    "explanation": "This type recognizes complete English-formatted street addresses that begin with a street number (optionally with a suffix or range), followed by a street name and a recognized street type (e.g., St, Avenue, Road), optionally including a directional (e.g., NW) and a unit designator (e.g., Apt 5B, Suite 300). It is intended for columns storing the full street line as written on mailing labels or geocoding inputs.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:58:07.421401"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_UNION_IN",
    "description": "Indian state/union territory designation code. Supports two-letter uppercase abbreviations for Indian states and UTs, with or without the optional ISO-style \"IN-\" prefix.",
    "pluginType": "regex",
    "regexPattern": "\\b(IN-)?[A-Z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 10180,
    "headerPatterns": [
      {
        "regExp": "(?i).*(india|indian|in).*state.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IN State Code"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*(union.*territory|ut).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Union Territory Code"
        ],
        "negativeExamples": [
          "Union Territory Name"
        ]
      },
      {
        "regExp": "(?i).*state.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*(india|indian).*state.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Indian State"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "MH",
      "DL",
      "KA",
      "TN",
      "GJ",
      "KL",
      "IN-UP",
      "IN-RJ"
    ],
    "negativeContentExamples": [
      "Mh",
      "M3",
      "3M",
      "MH3",
      "M-H",
      "ABCD",
      "INM",
      "in-mh"
    ],
    "positiveHeaderExamples": [
      "State Code",
      "Indian State",
      "Union Territory Code",
      "IN State Code",
      "State/UT Code",
      "India State Abbrev"
    ],
    "negativeHeaderExamples": [
      "State Name",
      "Country",
      "District",
      "Province Code",
      "Country Code",
      "Postal Code"
    ],
    "explanation": "This type captures Indian state and union territory designations as two-letter uppercase codes, optionally prefixed with \"IN-\" (e.g., MH, DL, IN-UP). It is intended for datasets where a compact subdivision code is used rather than full names. Header patterns prioritize columns explicitly labeled for Indian state/UT codes to reduce ambiguity with other two-letter codes.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:58:09.569565"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS3_EN",
    "description": "address_line3: tertiary building location specification. Captures building or floor descriptors such as Building A, Tower 3, Floor 7, Wing West used as the third address line for refining location within a site or complex.",
    "pluginType": "regex",
    "regexPattern": "\\b((Building|Bldg|Tower|Block|Wing)[ \\-]+(East|West|North|South|NE|NW|SE|SW|E|W|N|S|[A-Za-z0-9]{1,4})|(Floor|Fl|Level|Lvl)[ \\-]+[A-Za-z0-9]{1,4})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 10230,
    "headerPatterns": [
      {
        "regExp": "(?i).*(address|addr)[ _-]*line[ _-]*3.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Address Line 3"
        ],
        "negativeExamples": [
          "Address Line 2"
        ]
      },
      {
        "regExp": "(?i).*(address|addr).*(line|ln).*(3|iii|third|tertiary).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Addr Line 3"
        ],
        "negativeExamples": [
          "Address Line 1"
        ]
      },
      {
        "regExp": "(?i).*(building|bldg|tower|block|wing).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Building"
        ],
        "negativeExamples": [
          "Street Address"
        ]
      },
      {
        "regExp": "(?i).*(floor|fl|level|lvl).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Floor"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      },
      {
        "regExp": "(?i).*line.*3.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Line 3"
        ],
        "negativeExamples": [
          "Line 2"
        ]
      }
    ],
    "positiveContentExamples": [
      "Building A",
      "Bldg 12",
      "Tower 3",
      "Block C",
      "Wing West",
      "Floor 7",
      "Fl B2",
      "Level 4"
    ],
    "negativeContentExamples": [
      "Apt 5B",
      "Suite 900",
      "Unit 12",
      "PO Box 45",
      "Street 10",
      "Building2",
      "L3",
      "Address Line 3"
    ],
    "positiveHeaderExamples": [
      "Address Line 3",
      "Building",
      "Floor",
      "AddressLine3",
      "Addr Line 3",
      "Level",
      "Wing",
      "Bldg"
    ],
    "negativeHeaderExamples": [
      "Street Address",
      "Apt",
      "ZIP Code",
      "Address Line 1",
      "Address Line 2",
      "Suite",
      "Unit",
      "City"
    ],
    "explanation": "This semantic type identifies the tertiary address line used to specify intra-site building location details (e.g., building, tower, block, wing) or vertical placement (e.g., floor/level). It is intended for fields that refine a site location beyond street and unit, enabling precise delivery or navigation within complexes and campuses. It should not be used for unit-level identifiers like apartment, suite, or unit, nor for street or postal code fields.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:58:12.765127"
  },
  {
    "resultType": "generated",
    "semanticType": "URI.URL",
    "description": "web_address: complete URL for network resource access",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(https|http|ftp)://(([A-Za-z0-9\\-]{1,63}\\.)+[A-Za-z0-9\\-]{2,63}|([0-9]{1,3}\\.){3}[0-9]{1,3})(:[0-9]{2,5})?(/[A-Za-z0-9\\-._~%!$&'()*+,;=:@/]*)?(\\?[A-Za-z0-9\\-._~%!$&'()*+,;=:@/?]*)?(#[A-Za-z0-9\\-._~%!$&'()*+,;=:@/?]*)?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 10340,
    "headerPatterns": [
      {
        "regExp": "(?i).*(website|site).*url.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "website_url"
        ],
        "negativeExamples": [
          "website_id"
        ]
      },
      {
        "regExp": "(?i).*web.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Web Address"
        ],
        "negativeExamples": [
          "Email Address"
        ]
      },
      {
        "regExp": "(?i).*(home|landing).*page.*url.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Homepage URL"
        ],
        "negativeExamples": [
          "Home Page Count"
        ]
      },
      {
        "regExp": "(?i).*web(site)? .*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Website"
        ],
        "negativeExamples": [
          "File Path"
        ]
      },
      {
        "regExp": "(?i).*uri.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Resource URI"
        ],
        "negativeExamples": [
          "Domain Name"
        ]
      },
      {
        "regExp": "(?i).*url.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "URL"
        ],
        "negativeExamples": [
          "Domain Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "https://www.example.com",
      "http://example.org/path",
      "https://sub.domain.co.uk/index.html",
      "http://192.168.1.10:8080/status",
      "ftp://files.example.net/downloads/archive.tar.gz",
      "https://example.com/search?q=openai&lang=en",
      "https://api.example.com/v1/users#top",
      "http://blog.example.com/posts?id=123&sort=asc"
    ],
    "negativeContentExamples": [
      "www.example.com",
      "https//example.com",
      "http:/example.com",
      "http://example",
      "mailto:user@example.com",
      "file:///var/www/index.html",
      "https://example..com",
      "example.com/path"
    ],
    "positiveHeaderExamples": [
      "URL",
      "Website",
      "Web Address",
      "Homepage URL",
      "Site URL",
      "Landing Page URL",
      "Target URL",
      "Canonical URL"
    ],
    "negativeHeaderExamples": [
      "Domain Name",
      "Email Address",
      "File Path",
      "Host",
      "Path",
      "Page Title",
      "Customer ID",
      "Proxy Address"
    ],
    "explanation": "This semantic type detects complete web addresses that include a scheme (http, https, or ftp), a valid domain or IPv4 address, and optional port, path, query, or fragment. It is intended for columns storing fully qualified URLs used to access network resources, not partial addresses or file system paths.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:58:16.842529"
  },
  {
    "resultType": "generated",
    "semanticType": "TIMEZONE.IANA",
    "description": "IANA time zone identifier from the TZ database, typically in a Region/Location form using slashes, letters, digits, underscores, and hyphens (for example, America/New_York, Europe/London, Etc/GMT+5). This represents standardized global time zone names rather than numeric offsets.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Za-z]+([_-][A-Za-z0-9]+)*)/([A-Za-z0-9]+([_+-][A-Za-z0-9]+)*)(/([A-Za-z0-9]+([_-][A-Za-z0-9]+)*)){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 10330,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\biana\\b.*time.?zone.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IANA Timezone"
        ],
        "negativeExamples": [
          "UTC Offset"
        ]
      },
      {
        "regExp": "(?i).*(time.?zone|tz).*identifier.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Timezone Identifier"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*\\btz\\b.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "tz name"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*\\bzone\\b.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Zone Name"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*time.?zone.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Time Zone"
        ],
        "negativeExamples": [
          "UTC Offset"
        ]
      }
    ],
    "positiveContentExamples": [
      "America/New_York",
      "Europe/London",
      "Asia/Kolkata",
      "Pacific/Auckland",
      "Etc/GMT+5",
      "America/Argentina/Buenos_Aires",
      "America/North_Dakota/Center",
      "Australia/Lord_Howe"
    ],
    "negativeContentExamples": [
      "AmericaNew_York",
      "America/New York",
      "Etc/GMT+05:00",
      "/America/New_York",
      "America//New_York",
      "Pacific/Auckland/",
      "GMT+5",
      "Europe/Lon don"
    ],
    "positiveHeaderExamples": [
      "Timezone",
      "Time Zone",
      "IANA Timezone",
      "Zone Identifier",
      "TZ Name",
      "Time Zone ID",
      "TZ",
      "Zone Name"
    ],
    "negativeHeaderExamples": [
      "UTC Offset",
      "Country",
      "City",
      "Offset Minutes",
      "Country Code",
      "City Name",
      "Region",
      "Locale"
    ],
    "explanation": "This type recognizes standardized IANA TZ database identifiers used to represent time zones in structured data. It is useful for validating and classifying fields containing Region/Location strings that map to canonical time zones, enabling consistent timezone handling across systems.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:58:17.454006"
  },
  {
    "resultType": "generated",
    "semanticType": "VIN",
    "description": "Vehicle Identification Number (VIN): a 17-character automotive identifier composed of letters and digits, excluding the letters I, O, and Q to avoid confusion with numerals. The VIN is typically a continuous string without spaces or hyphens.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-HJ-NPR-Za-hj-npr-z0-9]{17}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 10350,
    "headerPatterns": [
      {
        "regExp": "(?i).*vehicle.*identification.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Vehicle Identification Number"
        ],
        "negativeExamples": [
          "Vehicle Registration Number"
        ]
      },
      {
        "regExp": "(?i).*vehicle.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Vehicle ID"
        ],
        "negativeExamples": [
          "Vehicle Model"
        ]
      },
      {
        "regExp": "(?i).*vin.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "VIN Number"
        ],
        "negativeExamples": [
          "VIN Code"
        ]
      },
      {
        "regExp": "(?i).*vin.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "VIN"
        ],
        "negativeExamples": [
          "Vehicle Model"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Number"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "1HGCM82633A004352",
      "JH4KA9650MC012345",
      "WDBUF56X28B123456",
      "2C4RC1BG3LR123456",
      "3FAHP0HA7AR123456",
      "5YJSA1E26FF101472",
      "SALVP2BG3FH123456",
      "WAUZZZ8K7BA123456"
    ],
    "negativeContentExamples": [
      "1HGCM82633A00435",
      "1HGCM82633A0043528",
      "1HGCM82633A00I352",
      "JH4KA9650MCO12345",
      "WAUZZZ8K7BA12345Q",
      "1HG-CM82633A004352",
      "1HGCM82633A00 4352",
      "WDBUF56X28B12345!"
    ],
    "positiveHeaderExamples": [
      "VIN",
      "Vehicle ID",
      "VIN Number",
      "Vehicle Identification Number",
      "Vehicle_Id",
      "Vin number",
      "vehicle identification number"
    ],
    "negativeHeaderExamples": [
      "License Plate",
      "Model",
      "Make",
      "Vehicle Registration",
      "Engine Type",
      "Vehicle Color",
      "Odometer"
    ],
    "explanation": "This semantic type identifies Vehicle Identification Numbers (VINs), which are 17-character alphanumeric strings assigned to individual vehicles. The pattern enforces allowed characters and exact length, excluding I, O, and Q, and assumes VINs are unseparated (no spaces or hyphens). Typical use cases include validating and extracting VINs from automotive datasets, service records, and vehicle registries.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:58:20.938479"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_PROVINCE_NAME_NA",
    "description": "na_territory_name: complete North American state/province designation. Represents fully spelled-out names for subnational jurisdictions in North America (e.g., US states, Canadian provinces/territories).",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b([A-Z][a-z]+)(\\s(and|of|[A-Z][a-z]+)){0,4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 10170,
    "headerPatterns": [
      {
        "regExp": "(?i).*(state\\s*/\\s*province).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State/Province Name"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*(state|province|territory).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Province Name"
        ],
        "negativeExamples": [
          "Province Code"
        ]
      },
      {
        "regExp": "(?i).*(state|province|territory).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(prov|st|terr).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Prov Name"
        ],
        "negativeExamples": [
          "Prov Code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "California",
      "New York",
      "Texas",
      "Ontario",
      "Quebec",
      "British Columbia",
      "Newfoundland and Labrador",
      "Northwest Territories"
    ],
    "negativeContentExamples": [
      "CA",
      "QC",
      "Calif.",
      "Ontario, Canada",
      "New-York",
      "Washington D.C.",
      "Quebec (QC)",
      "NewYork"
    ],
    "positiveHeaderExamples": [
      "State",
      "Province",
      "State/Province Name",
      "State Name",
      "Province Name",
      "Territory Name",
      "Subnational Name"
    ],
    "negativeHeaderExamples": [
      "State Code",
      "Province Code",
      "Country",
      "Region Code",
      "Postal Code",
      "State Abbreviation",
      "Province ID"
    ],
    "explanation": "This semantic type identifies fully spelled-out names for North American subnational jurisdictions such as US states and Canadian provinces/territories. The content pattern favors title-cased tokens with optional connectors like 'and' or 'of', and header patterns strongly guide detection toward state/province naming fields rather than codes. It is intended for full names only, not abbreviations or codes.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:58:21.706000"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_MARKER_EN",
    "description": "English thoroughfare classification suffix token (e.g., Street, St, Avenue, Ave), intended to capture the street type/designator portion of an address. This identifies the suffix only, not full street names or address lines.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(avenue|ave|boulevard|blvd|road|rd|street|st|lane|ln|drive|dr|court|ct|parkway|pkwy|terrace|ter|place|pl|highway|hwy|square|sq|circle|cir|alley|aly|trail|trl|freeway|fwy|bypass|byp|way|crescent|cres|grove|grv|manor|mnr|path|pth|ridge|rdg|glen|gln|route|rte|park|pk|passage|psg|mews|view|vw)\\.?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 10270,
    "headerPatterns": [
      {
        "regExp": "(?i).*(street|thoroughfare).*(suffix|type|marker).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street Suffix"
        ],
        "negativeExamples": [
          "Street Name"
        ]
      },
      {
        "regExp": "(?i).*street.*type.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Street Type"
        ],
        "negativeExamples": [
          "House Number"
        ]
      },
      {
        "regExp": "(?i).*street.*marker.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Street Marker"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*(thoroughfare|road).*type.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Thoroughfare Type"
        ],
        "negativeExamples": [
          "Street Direction"
        ]
      },
      {
        "regExp": "(?i).*suffix.*",
        "confidence": 91,
        "mandatory": true,
        "positiveExamples": [
          "Suffix"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "St",
      "St.",
      "Street",
      "Ave",
      "Avenue",
      "Rd",
      "Road",
      "Blvd"
    ],
    "negativeContentExamples": [
      "Ste",
      "Str",
      "Aven",
      "Rdd",
      "Boulvard",
      "Stn",
      "Driv",
      "Hwy 1"
    ],
    "positiveHeaderExamples": [
      "Street Type",
      "Street Suffix",
      "Street Marker",
      "Thoroughfare Type",
      "Road Type",
      "Address Street Suffix",
      "Street Designator",
      "Thoroughfare Suffix"
    ],
    "negativeHeaderExamples": [
      "Street Name",
      "House Number",
      "Address",
      "Street Direction",
      "Unit Type",
      "Postal Code",
      "City",
      "State"
    ],
    "explanation": "This semantic type identifies the English street type/designator token used as a suffix in addresses (e.g., St, Ave, Rd, Blvd). It is useful for normalizing, parsing, and validating address components where the suffix is provided as a standalone field.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:58:28.545731"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_US",
    "description": "Full, unabbreviated name of a U.S. state (e.g., New York, North Dakota). Values are expected to be the complete state designation, not codes or abbreviations, and exclude territories and districts.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(Alabama|Alaska|Arizona|Arkansas|California|Colorado|Connecticut|Delaware|Florida|Georgia|Hawaii|Idaho|Illinois|Indiana|Iowa|Kansas|Kentucky|Louisiana|Maine|Maryland|Massachusetts|Michigan|Minnesota|Mississippi|Missouri|Montana|Nebraska|Nevada|New Hampshire|New Jersey|New Mexico|New York|North Carolina|North Dakota|Ohio|Oklahoma|Oregon|Pennsylvania|Rhode Island|South Carolina|South Dakota|Tennessee|Texas|Utah|Vermont|Virginia|Washington|West Virginia|Wisconsin|Wyoming)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 10150,
    "headerPatterns": [
      {
        "regExp": "(?i).*(united states|us|usa).*state.*name.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "US State Name"
        ],
        "negativeExamples": [
          "State Name"
        ]
      },
      {
        "regExp": "(?i).*(united states|us|usa).*state.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "US State"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*state.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Name"
        ],
        "negativeExamples": [
          "Country Name"
        ]
      },
      {
        "regExp": "(?i).*state.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "State"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Alabama",
      "Alaska",
      "New York",
      "North Dakota",
      "Rhode Island",
      "West Virginia",
      "Hawaii",
      "New Mexico"
    ],
    "negativeContentExamples": [
      "NewJersey",
      "North-Carolina",
      "Rhode  Island",
      "Hawai'i",
      "Puerto Rico",
      "District of Columbia",
      "New-York",
      "SouthDakota"
    ],
    "positiveHeaderExamples": [
      "State",
      "State Name",
      "US State",
      "US State Name",
      "USA State",
      "United States State Name",
      "State Full Name",
      "State (US)"
    ],
    "negativeHeaderExamples": [
      "State Code",
      "Country",
      "County",
      "Province",
      "Region",
      "US State Code",
      "Country Name",
      "Postal Code"
    ],
    "explanation": "This type detects full U.S. state names using a controlled set of allowed tokens with word boundaries to avoid partial or embedded matches. It is useful for validating columns that contain complete state names rather than abbreviations or codes, and excludes territories and districts.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:58:30.541771"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.RACE_ABBR_EN",
    "description": "ethnicity_code: abbreviated racial or ethnic category identifier in English, typically short alphabetic codes indicating race or ethnicity groups (e.g., WHT, BLK, ASN, HISP). Intended for compact categorical encodings rather than full names.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "W",
      "B",
      "A",
      "H",
      "WHT",
      "BLK",
      "ASN",
      "AI",
      "PI",
      "AIAN",
      "NHPI",
      "HISP",
      "NHISP",
      "LAT",
      "MENA",
      "MULTI",
      "OTH",
      "UNK",
      "REF",
      "TMR"
    ],
    "backout": "^[A-Z]{1,6}$",
    "confidenceThreshold": 97,
    "priority": 9490,
    "headerPatterns": [
      {
        "regExp": "(?i).*(race|ethnicity).*(abbr|short).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Race Abbr"
        ],
        "negativeExamples": [
          "Race"
        ]
      },
      {
        "regExp": "(?i).*(race|ethnicity).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Ethnicity Code"
        ],
        "negativeExamples": [
          "Nationality"
        ]
      },
      {
        "regExp": "(?i).*(race[_ ]?cd|eth[_ ]?cd|racecode|ethcode|\\brc\\b).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Race_CD"
        ],
        "negativeExamples": [
          "Race Category"
        ]
      },
      {
        "regExp": "(?i).*(race|ethnicity).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Ethnicity Abbr"
        ],
        "negativeExamples": [
          "Group"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "WHT",
      "BLK",
      "ASN",
      "AIAN",
      "NHPI",
      "HISP",
      "NHISP",
      "OTH"
    ],
    "negativeContentExamples": [
      "WHITE",
      "BLACK",
      "ASIA",
      "AI/AN",
      "NH-PI",
      "HSP",
      "WHIT",
      "MULT"
    ],
    "positiveHeaderExamples": [
      "Race Code",
      "Ethnicity Code",
      "Race Abbr",
      "Ethnicity Abbr",
      "Race Short",
      "Race_CD",
      "Eth_CD",
      "RC"
    ],
    "negativeHeaderExamples": [
      "Race",
      "Ethnicity",
      "Nationality",
      "Race Category",
      "Ethnic Group",
      "Race Name",
      "Ethnicity Type",
      "Group"
    ],
    "explanation": "This semantic type identifies compact, English-language abbreviations representing racial or ethnic categories, commonly used in person records to encode group membership in a short code. It is suited for datasets where race/ethnicity is recorded as standardized abbreviations rather than full descriptors.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:58:32.714730"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_NUMBER",
    "description": "Numeric property identifier for street addressing (house_number). Captures standalone address numbers including optional single-letter suffixes, simple short ranges, and fractional forms used in some addressing schemes. Focuses solely on the street-facing number component, not including street names or unit/apartment identifiers.",
    "pluginType": "regex",
    "regexPattern": "\\b([1-9]\\d{0,3}[A-Za-z]?-[1-9]\\d{0,3}[A-Za-z]?|[1-9]\\d{0,5} (1/2|1/4|3/4)|[1-9]\\d{0,5}[A-Za-z]?)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 10310,
    "headerPatterns": [
      {
        "regExp": "(?i).*house.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "House Number"
        ],
        "negativeExamples": [
          "House Name"
        ]
      },
      {
        "regExp": "(?i).*street.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street Number"
        ],
        "negativeExamples": [
          "Street Name"
        ]
      },
      {
        "regExp": "(?i).*(address|addr).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address Number"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*(building|premise).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Building Number"
        ],
        "negativeExamples": [
          "Building Name"
        ]
      },
      {
        "regExp": "(?i).*(house|street|addr).*\\b(no|num|nbr)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Addr Num"
        ],
        "negativeExamples": [
          "Account Num"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Number"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "221",
      "12B",
      "407",
      "1501 1/2",
      "4-6",
      "120A-124A",
      "999999",
      "75C"
    ],
    "negativeContentExamples": [
      "0001",
      "12 B",
      "12-14-16",
      "12A/14A",
      "1/2",
      "1234567",
      "A-12",
      "12345-6789"
    ],
    "positiveHeaderExamples": [
      "House Number",
      "Street Number",
      "Number",
      "Address Number",
      "Building Number",
      "Premise No",
      "Addr Num",
      "House No"
    ],
    "negativeHeaderExamples": [
      "Street Name",
      "Address",
      "City",
      "House Name",
      "Unit Number",
      "Zip Code",
      "Lot Number",
      "Phone Number"
    ],
    "explanation": "This semantic type identifies the numeric street address component used to locate a property on a street. It supports common variants such as a trailing letter suffix (e.g., 12B), short numeric ranges (e.g., 4-6), and fractional forms (e.g., 1501 1/2). Use it to recognize house numbers in address datasets while excluding street names, unit/apartment identifiers, and other codes.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:58:35.684363"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS4_EN",
    "description": "address_line4: specialized facility location designation. Used for intra-facility location descriptors such as wing, entrance, gate, dock, bay, pod, tower, block, concourse, atrium, or lobby. Intended for English-language address schemas where line 4 captures facility-specific wayfinding elements.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b((wing|entrance|gate|dock|loading dock|bay|pod|tower|block|concourse|terminal|atrium|lobby)([ -](north|south|east|west|nw|ne|sw|se))?(([ -][A-Z][0-9]{1,3})|([ -][A-Z])|([ -][0-9]{1,4}))?)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 10240,
    "headerPatterns": [
      {
        "regExp": "(?i).*(address|addr).*line.*4.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address Line 4"
        ],
        "negativeExamples": [
          "Street Address"
        ]
      },
      {
        "regExp": "(?i).*(addr4|address4|line4|ln4).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Addr4"
        ],
        "negativeExamples": [
          "Address Line 1"
        ]
      },
      {
        "regExp": "(?i).*(address|addr).*line.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address Line"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      },
      {
        "regExp": "(?i).*(wing|entrance|gate|dock|bay|pod|tower|block|concourse|atrium|lobby).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Entrance"
        ],
        "negativeExamples": [
          "Suite"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Wing B",
      "Entrance 2",
      "Gate A12",
      "Loading Dock 3",
      "Bay 7",
      "Concourse C",
      "Terminal 1",
      "Atrium West"
    ],
    "negativeContentExamples": [
      "Suite 204",
      "Floor 3",
      "Entry 2",
      "Gate 1A",
      "WingB",
      "LoadingDock 4",
      "Terminal-1A",
      "Building A"
    ],
    "positiveHeaderExamples": [
      "Address Line 4",
      "Wing",
      "Entrance",
      "Addr Line 4",
      "Address4",
      "Line4",
      "Facility Wing",
      "Gate"
    ],
    "negativeHeaderExamples": [
      "Street Address",
      "Suite",
      "ZIP Code",
      "Address Line 2",
      "Apt",
      "Street Name",
      "Country",
      "Province"
    ],
    "explanation": "This semantic type captures English address line 4 content that denotes specialized intra-facility location descriptors to aid wayfinding within a site or complex. Typical values reference parts of a facility such as a wing, entrance, gate, dock, bay, pod, tower, block, concourse, atrium, or lobby. It is distinct from apartment/suite identifiers and general street address fields, focusing specifically on facility-level sublocations.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:58:39.086732"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_NAME_EN",
    "description": "complete_street_name: full English street designation with type. Values contain the street's name followed by a standard English street type (e.g., Street, Road, Ave), allowing common abbreviations and ordinal names but excluding leading house numbers and trailing unit designators.",
    "pluginType": "regex",
    "regexPattern": "\\b(([A-Za-z][A-Za-z0-9]*|[0-9]+(st|nd|rd|th))([.'-][A-Za-z0-9]+)?(\\s+([A-Za-z][A-Za-z0-9]*|[0-9]+(st|nd|rd|th))([.'-][A-Za-z0-9]+)?){0,4})\\s+(Street|St|St\\.|Avenue|Ave|Ave\\.|Road|Rd|Rd\\.|Boulevard|Blvd|Blvd\\.|Lane|Ln|Ln\\.|Drive|Dr|Dr\\.|Court|Ct|Ct\\.|Place|Pl|Pl\\.|Terrace|Ter|Ter\\.|Way|Parkway|Pkwy|Pkwy\\.|Square|Sq|Sq\\.|Circle|Cir|Cir\\.|Trail|Trl|Trl\\.|Highway|Hwy|Hwy\\.)(\\s+(North|South|East|West|N|S|E|W|NE|NW|SE|SW))?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 10300,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bstreet[_ ]?name\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street Name"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*\\b(road|avenue|boulevard|blvd|lane|drive|way|court|place|terrace|highway)\\b.*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Road Name"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      },
      {
        "regExp": "(?i).*\\b(street|road|avenue|boulevard|blvd|lane|drive|way|court|place|terrace|highway)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street"
        ],
        "negativeExamples": [
          "House Number"
        ]
      },
      {
        "regExp": "(?i).*\\b(st|rd|ave|blvd|ln|dr|ct|pl|ter|hwy)\\b.*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Rd Name"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Street"
        ]
      }
    ],
    "positiveContentExamples": [
      "Main Street",
      "Elm St.",
      "5th Avenue",
      "Old Mill Road",
      "Queen's Road",
      "O'Connell Street",
      "Maple Dr",
      "Sunset Boulevard"
    ],
    "negativeContentExamples": [
      "123 Main Street",
      "Main Street Apt 2",
      "Main",
      "Street",
      "Rue de Rivoli",
      "Avenida Siempre Viva",
      "2nd St, NW",
      "Westside Highway 9"
    ],
    "positiveHeaderExamples": [
      "Street Name",
      "Road Name",
      "Street",
      "Avenue Name",
      "Blvd Name",
      "StreetName",
      "Street_Name",
      "Drive Name"
    ],
    "negativeHeaderExamples": [
      "House Number",
      "City",
      "ZIP Code",
      "Address Line 1",
      "Country",
      "Postal Code",
      "Latitude",
      "Building Name"
    ],
    "explanation": "Identifies full English street names that include a street type at the end (e.g., Street, St., Avenue, Ave, Road, Rd.), allowing common abbreviations, ordinals (e.g., 5th), hyphens, and apostrophes in the name. It excludes values with leading house numbers or trailing unit information, and it is aimed at columns labeled as street names rather than full addresses.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:58:42.648188"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.SUBURB_AU",
    "description": "Australian residential locality (suburb/locality) name as used in Australian addresses.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z][A-Za-z']+)([- ][A-Z][A-Za-z']+){0,3}( (North|South|East|West))?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 10210,
    "headerPatterns": [
      {
        "regExp": "(?i).*(au[ _.-]?suburb|australian[ _-]*suburb)[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Australian Suburb Name"
        ],
        "negativeExamples": [
          "Postcode"
        ]
      },
      {
        "regExp": "(?i).*(au[ _.-]?suburb|australian[ _-]*suburb).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Australian Suburb"
        ],
        "negativeExamples": [
          "State"
        ]
      },
      {
        "regExp": "(?i).*(state|province).*[ _-]suburb.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "State Suburb"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*suburb[ _-]*name.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Suburb Name"
        ],
        "negativeExamples": [
          "City Name"
        ]
      },
      {
        "regExp": "(?i).*suburb.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Suburb"
        ],
        "negativeExamples": [
          "Postcode"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Number"
        ]
      }
    ],
    "positiveContentExamples": [
      "St Kilda",
      "Port Melbourne",
      "North Sydney",
      "Surry Hills",
      "Bondi Beach",
      "O'Connor",
      "McKinnon",
      "Brighton-Le-Sands"
    ],
    "negativeContentExamples": [
      "st kilda",
      "Bondi 2026",
      "N Sydney",
      "Glebe/",
      "Sydney, NSW",
      "North  Sydney",
      "o'connor",
      "Brighton\u2013Le\u2013Sands"
    ],
    "positiveHeaderExamples": [
      "Suburb",
      "Australian Suburb",
      "Suburb Name",
      "AU Suburb",
      "Australian Suburb Name",
      "Residential Suburb",
      "Suburb (AU)"
    ],
    "negativeHeaderExamples": [
      "State",
      "City",
      "Postcode",
      "Country",
      "Region Code",
      "Postal Code",
      "Town",
      "Province"
    ],
    "explanation": "This semantic type identifies Australian suburb/locality names typically found in address datasets. The regex allows 1\u20134 capitalized tokens with spaces or hyphens, optional internal apostrophes, and an optional directional suffix (North/South/East/West). Header patterns prioritize AU-specific suburb naming before general terms to reduce collisions with other place-related fields.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:58:44.814108"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS_<LANGUAGE>",
    "description": "localized_address: language-specific street address formatting. Captures common street addresses consisting of a leading house number, street name tokens, and a terminal street type (e.g., St, Ave, Rd).",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b\\d{1,6}[A-Za-z]?\\s+([NSEW]\\s+)?[A-Za-z0-9][A-Za-z0-9.\\-']*(\\s+[A-Za-z0-9][A-Za-z0-9.\\-']*){0,4}\\s+(Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Lane|Ln|Drive|Dr|Court|Ct|Place|Pl|Terrace|Ter|Way|Highway|Hwy)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 10250,
    "headerPatterns": [
      {
        "regExp": "(?i).*(shipping|billing).*street.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Shipping Street Address"
        ],
        "negativeExamples": [
          "Shipping City"
        ]
      },
      {
        "regExp": "(?i).*street.*address.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Street Address"
        ],
        "negativeExamples": [
          "Street Name"
        ]
      },
      {
        "regExp": "(?i).*street.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Street"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      },
      {
        "regExp": "(?i).*(address).*line.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Address Line 1"
        ],
        "negativeExamples": [
          "City Lineage"
        ]
      },
      {
        "regExp": "(?i).*(shipping|billing).*address.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Billing Address"
        ],
        "negativeExamples": [
          "Billing Country"
        ]
      },
      {
        "regExp": "(?i).*(addr1|addr_1|address1|addr).*",
        "confidence": 91,
        "mandatory": true,
        "positiveExamples": [
          "Addr1"
        ],
        "negativeExamples": [
          "account_id"
        ]
      }
    ],
    "positiveContentExamples": [
      "123 Main St",
      "456 Elm Street",
      "789 Broadway Ave",
      "12B Oak Road",
      "200 W Pine Ln",
      "5 Maple Drive",
      "221B Baker Street",
      "32 King's Way"
    ],
    "negativeContentExamples": [
      "Main Street",
      "123 Main",
      "12-B Oak Road",
      "PO Box 123",
      "Avenue 5 Maple",
      "W Pine Ln 200",
      "456 Elm Str",
      "Calle Mayor 10"
    ],
    "positiveHeaderExamples": [
      "Street Address",
      "Address",
      "Street",
      "Address Line 1",
      "Shipping Street Address",
      "Billing Address",
      "Addr1",
      "Street Name and Number"
    ],
    "negativeHeaderExamples": [
      "City",
      "Country",
      "ZIP Code",
      "State",
      "Province",
      "Latitude",
      "Contact Name",
      "Email Address"
    ],
    "explanation": "This semantic type targets street-level address lines that begin with a house/building number followed by one or more street name tokens and end with a recognized street type keyword. It is intended for localized street address fields (often Address Line 1) and excludes higher-level locality fields such as city, region, or postal code.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:58:44.967192"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_NAME_BARE_<LANGUAGE>",
    "description": "Bare street name: core street identifier without any street type suffix or prefix (e.g., no \"Street\", \"Rd\", \"Avenue\"). Intended to capture the name portion only, typically composed of one to four words with letters, apostrophes, or hyphens.",
    "pluginType": "regex",
    "regexPattern": "\\b(?!(street|st|road|rd|avenue|ave|blvd|boulevard|lane|ln|drive|dr|way|court|ct|place|pl|terrace|ter|highway|hwy)\\b)[\\p{L}][\\p{L}\\p{M}'\u2019-]{1,24}(\\s+(?!(street|st|road|rd|avenue|ave|blvd|boulevard|lane|ln|drive|dr|way|court|ct|place|pl|terrace|ter|highway|hwy)\\b)[\\p{L}][\\p{L}\\p{M}'\u2019-]{1,24}){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 10280,
    "headerPatterns": [
      {
        "regExp": "(?i).*bare.*street.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Bare Street Name"
        ],
        "negativeExamples": [
          "Street Number"
        ]
      },
      {
        "regExp": "(?i).*(road|street).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street Name"
        ],
        "negativeExamples": [
          "Road Condition"
        ]
      },
      {
        "regExp": "(?i).*(street|road|straat).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Straat"
        ],
        "negativeExamples": [
          "Postcode"
        ]
      },
      {
        "regExp": "(?i).*(st|rd).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "St Name"
        ],
        "negativeExamples": [
          "Street Number"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Road Name"
        ],
        "negativeExamples": [
          "City"
        ]
      }
    ],
    "positiveContentExamples": [
      "Baker",
      "Elm",
      "Old Mill",
      "Orchard View",
      "San Mart\u00edn",
      "De la Cruz",
      "Queen Mary",
      "Van der Hof"
    ],
    "negativeContentExamples": [
      "Main Street",
      "Baker St",
      "3rd",
      "742 Evergreen",
      "12th Avenue",
      "Oak_Street",
      "N Main",
      "5th"
    ],
    "positiveHeaderExamples": [
      "Street Name",
      "Straat",
      "Road Name",
      "Bare Street Name",
      "Street Core Name",
      "St Name",
      "Primary Street Name",
      "Local Road Name"
    ],
    "negativeHeaderExamples": [
      "Street Number",
      "Postcode",
      "City",
      "Address",
      "Street Type",
      "Road Condition",
      "Zip",
      "Country"
    ],
    "explanation": "This semantic type identifies bare street names, excluding any street-type designators (e.g., Street, St, Road, Rd, Avenue, Ave) and excluding house numbers or unit identifiers. It targets 1\u20134 word names composed of letters with optional hyphens or apostrophes, accommodating diacritics. Typical use cases include datasets where the street type and number are stored in separate fields, and this column only holds the core street name.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T17:59:02.412934"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS2_EN",
    "description": "Secondary address line in English, such as apartment, suite, unit, floor, department, or similar identifiers used in addition to the primary street address. Typical values include a qualifier plus an alphanumeric identifier (often containing at least one digit), for example \"Apt 5B\" or \"Suite 200\".",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(apt|apartment|suite|ste|unit|bldg|building|fl|floor|lvl|level|rm|room|dept|department|tower|block|lot)\\.?\\s*(#)?\\s*[a-z0-9]{0,4}[0-9][a-z0-9]{0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 10220,
    "headerPatterns": [
      {
        "regExp": "(?i).*(address.*line.*2|addr.*line.*2|address2|addr2).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address Line 2"
        ],
        "negativeExamples": [
          "Address Line 1"
        ]
      },
      {
        "regExp": "(?i).*(secondary.*address|unit.*number).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Unit Number"
        ],
        "negativeExamples": [
          "Street Address"
        ]
      },
      {
        "regExp": "(?i).*(apt|apartment|suite|ste|unit|bldg|floor|fl|room|rm|dept).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Apt"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Apt 5B",
      "Apartment 12",
      "Suite 250",
      "Ste 4",
      "Unit #12A",
      "Floor 3",
      "Level 10",
      "Bldg C3"
    ],
    "negativeContentExamples": [
      "Apt.",
      "Suite-",
      "Unit Twelve",
      "Address Line 2",
      "123 Main St",
      "PO Box 123",
      "Building C",
      "Floor Three"
    ],
    "positiveHeaderExamples": [
      "Address Line 2",
      "Apt",
      "Suite",
      "Unit Number",
      "Secondary Address",
      "Address2",
      "Addr Line2",
      "Apt/Suite"
    ],
    "negativeHeaderExamples": [
      "Street Address",
      "City",
      "ZIP Code",
      "Address",
      "Address Line 1",
      "State",
      "Country",
      "Primary Address"
    ],
    "explanation": "This semantic type targets secondary address descriptors commonly stored as Address Line 2, such as apartment, suite, unit, floor, room, or department identifiers. The detection focuses on well-known qualifiers followed by a short alphanumeric identifier that includes at least one digit, reducing confusion with primary street addresses or free-form location text.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T18:00:08.768385"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_NAME_BARE_EN",
    "description": "Core English street name without any street-type suffix (e.g., Street, Rd, Ave). Accepts 1\u20134 alphabetic tokens with optional internal apostrophes or hyphens, separated by single spaces. Designed to capture the base toponym only, not the roadway class.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z]+(['-][A-Za-z]+)*( (?!Street\\b|Road\\b|Avenue\\b|Boulevard\\b|Lane\\b|Drive\\b|Court\\b|Place\\b|Terrace\\b|Way\\b|Parkway\\b|Highway\\b|Square\\b|Circle\\b|Crescent\\b|Alley\\b|Rd\\b|Ave\\b|Blvd\\b|Ln\\b|Dr\\b|Ct\\b|Pl\\b|Ter\\b|Pkwy\\b|Hwy\\b|Sq\\b|Cir\\b|Cres\\b|Aly\\b)[A-Za-z]+(['-][A-Za-z]+)*){0,3}(?<!\\bStreet)(?<!\\bRoad)(?<!\\bAvenue)(?<!\\bBoulevard)(?<!\\bLane)(?<!\\bDrive)(?<!\\bCourt)(?<!\\bPlace)(?<!\\bTerrace)(?<!\\bWay)(?<!\\bParkway)(?<!\\bHighway)(?<!\\bSquare)(?<!\\bCircle)(?<!\\bCrescent)(?<!\\bAlley)(?<!\\bRd)(?<!\\bAve)(?<!\\bBlvd)(?<!\\bLn)(?<!\\bDr)(?<!\\bCt)(?<!\\bPl)(?<!\\bTer)(?<!\\bPkwy)(?<!\\bHwy)(?<!\\bSq)(?<!\\bCir)(?<!\\bCres)(?<!\\bAly)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 10290,
    "headerPatterns": [
      {
        "regExp": "(?i).*(bare|core).*\\bstreet\\b.*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Bare Street Name"
        ],
        "negativeExamples": [
          "Full Address"
        ]
      },
      {
        "regExp": "(?i).*\\broad\\b.*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Road Name"
        ],
        "negativeExamples": [
          "House Number"
        ]
      },
      {
        "regExp": "(?i).*\\bstreet\\b.*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street Name"
        ],
        "negativeExamples": [
          "Street Type"
        ]
      },
      {
        "regExp": "(?i).*\\b(st|rd)\\b.*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Rd Name"
        ],
        "negativeExamples": [
          "Street"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Street Type"
        ]
      }
    ],
    "positiveContentExamples": [
      "Main",
      "Elm",
      "Old Mill",
      "Queen's Park",
      "St John",
      "O'Connell",
      "Green-Tree",
      "The Oaks"
    ],
    "negativeContentExamples": [
      "Main Street",
      "Oak Rd",
      "Elm Avenue",
      "High Street",
      "St John's Road",
      "Old-Mill Road",
      "Main St",
      "Broadway Ave"
    ],
    "positiveHeaderExamples": [
      "Street Name",
      "Road Name",
      "Street",
      "Bare Street Name",
      "Core Street Name",
      "Address Street Name",
      "Street Name (English)"
    ],
    "negativeHeaderExamples": [
      "Street Type",
      "House Number",
      "Full Address",
      "City",
      "State",
      "Zip Code",
      "Address Line 1"
    ],
    "explanation": "Identifies the base English street toponym without any roadway class or suffix, using 1\u20134 alphabetic tokens with optional internal apostrophes or hyphens. It rejects values that end with common street-type terms (e.g., Street, Rd, Ave) and their common abbreviations. Typical use cases include parsing addresses into components or validating that a column contains only the street name portion.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T18:00:36.887768"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.DEPARTMENT_NAME_FR",
    "description": "French territory: departmental administrative division",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z\u00c0-\u00d6\u00d8-\u00de][A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff']+)(([-\\s]([A-Z\u00c0-\u00d6\u00d8-\u00de][A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff']+|d'|de|du|des|et|l'|la|le|les))*)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 9810,
    "headerPatterns": [
      {
        "regExp": "(?i).*(fr|french).*(d\u00e9partement|departement|department).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "FR Department Name"
        ],
        "negativeExamples": [
          "Department"
        ]
      },
      {
        "regExp": "(?i).*(d\u00e9partement|departement|department).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "D\u00e9partement"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(dept|dep|dpt).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Dept FR"
        ],
        "negativeExamples": [
          "Region"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Department Name"
        ],
        "negativeExamples": [
          "City"
        ]
      }
    ],
    "positiveContentExamples": [
      "Ain",
      "Nord",
      "Paris",
      "Bouches-du-Rh\u00f4ne",
      "C\u00f4tes-d'Armor",
      "Val-d'Oise",
      "Territoire de Belfort",
      "Loire-Atlantique"
    ],
    "negativeContentExamples": [
      "ain",
      "bouches-du-rhone",
      "val\u2013d\u2019oise",
      "seine/marne",
      "loire_atlantique",
      "59",
      "FR-59",
      "nord-59"
    ],
    "positiveHeaderExamples": [
      "D\u00e9partement",
      "Department",
      "French Department",
      "FR Department Name",
      "Departement Name",
      "Department Label",
      "French Dept Name"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Region",
      "City",
      "Province Code",
      "Postal Code",
      "County Name",
      "Continent"
    ],
    "explanation": "Identifies French departmental names (state/province-level units) written as proper nouns, including multi-token forms with spaces, hyphens, and French particles such as de, du, des, d', et, l'. Use this type for columns storing the textual name of a French department, not numeric codes. Typical matches include simple names (Ain, Nord) and compound names (C\u00f4tes-d'Armor, Territoire de Belfort, Val-d'Oise).",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T18:01:05.602397"
  },
  {
    "resultType": "generated",
    "semanticType": "TELEPHONE",
    "description": "phone_number: telecommunications contact identifier. Identifies telephone numbers in common national and international formats using digits with spaces, hyphens, dots, or parentheses.",
    "pluginType": "regex",
    "regexPattern": "\\b(\\+?[0-9]{1,3}[ \\-\\.])?\\(?[0-9]{2,4}\\)?[ \\-\\.][0-9]{3,4}[ \\-\\.][0-9]{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 10320,
    "headerPatterns": [
      {
        "regExp": "(?i).*(phone|telephone).*(number|no|nbr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Phone Number"
        ],
        "negativeExamples": [
          "Email Address"
        ]
      },
      {
        "regExp": "(?i).*(primary|mobile|cell|contact).*(phone|telephone).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Mobile Phone"
        ],
        "negativeExamples": [
          "Fax Number"
        ]
      },
      {
        "regExp": "(?i).*(tel|ph|phone)[ _\\-]?(no|num|#).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "phone_no"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*telephone.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Telephone"
        ],
        "negativeExamples": [
          "Email Address"
        ]
      },
      {
        "regExp": "(?i).*phone.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Phone"
        ],
        "negativeExamples": [
          "Email"
        ]
      }
    ],
    "positiveContentExamples": [
      "+1 212-555-0199",
      "(415) 555-2671",
      "212.555.0187",
      "1-303-555-0147",
      "+44 20 7123 4567",
      "020 7946 0958",
      "03-1234-5678",
      "+49 30 1234 5678"
    ],
    "negativeContentExamples": [
      "1234567890",
      "+1 (212)5550199",
      "555-123-456",
      "123-45-67890",
      "+999-1-234-5678",
      "0207 946 0958 12",
      "212/555/0187",
      "+44-207-9460-958"
    ],
    "positiveHeaderExamples": [
      "Phone Number",
      "Telephone",
      "Phone",
      "Mobile Phone",
      "Contact Phone",
      "Primary Phone Number",
      "Tel",
      "Phone No"
    ],
    "negativeHeaderExamples": [
      "Email Address",
      "Fax Number",
      "Address",
      "Email",
      "Customer Name",
      "Zip Code",
      "URL",
      "Account Number"
    ],
    "explanation": "This semantic type detects telephone numbers in common international and national formats, allowing optional country codes, area codes with or without parentheses, and separators as spaces, hyphens, or dots. It is useful for validating and classifying contact numbers in datasets where phones appear with varying formatting but consistent token structure.",
    "description_pattern": "P6",
    "generated_at": "2025-08-10T18:01:06.517837"
  }
]
[
  {
    "resultType": "generated",
    "semanticType": "CONTINENT.CODE_EN",
    "description": "Two-letter uppercase alphabetic abbreviations representing continental regions using common English initials. Exactly two letters, no digits, spaces, or punctuation.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AF",
      "AN",
      "AS",
      "EU",
      "NA",
      "SA",
      "OC"
    ],
    "backout": "^[A-Z]{2}$",
    "confidenceThreshold": 98,
    "priority": 3980,
    "headerPatterns": [
      {
        "regExp": "(?i).*continent.*code.*en.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "continent_code_en"
        ],
        "negativeExamples": [
          "country_code_en"
        ]
      },
      {
        "regExp": "(?i).*continent.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "continent iso code"
        ],
        "negativeExamples": [
          "country code"
        ]
      },
      {
        "regExp": "(?i).*continent.*abbr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "continent_abbr"
        ],
        "negativeExamples": [
          "region_abbr"
        ]
      },
      {
        "regExp": "(?i).*cont.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cont_code"
        ],
        "negativeExamples": [
          "cont_name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "AF",
      "AN",
      "AS",
      "EU",
      "NA",
      "SA",
      "OC"
    ],
    "negativeContentExamples": [
      "af",
      "As",
      "EUR",
      "A2",
      "E-U",
      "N A",
      "AU",
      "XX"
    ],
    "positiveHeaderExamples": [
      "continent_code_en",
      "continent code en",
      "continent_code",
      "continent two-letter code",
      "continent_abbr",
      "cont_code",
      "continent iso code"
    ],
    "negativeHeaderExamples": [
      "country_code_en",
      "continent_name",
      "region_code",
      "country_code",
      "continent id",
      "cont_name",
      "geo_code"
    ],
    "explanation": "This semantic type captures the standard two-letter English abbreviations for continents. It is constrained to a small, well-defined set of values, enabling precise classification in datasets where continents are encoded as compact codes.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T16:59:28.513040"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.ISO-3166-3",
    "description": "This code consists of exactly three uppercase alphabetic characters that serve as the internationally recognized standard for country identification. The code follows ISO 3166-1 alpha-3 specifications and contains no numbers, spaces, or punctuation marks.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4090,
    "headerPatterns": [
      {
        "regExp": "(?i).*iso.*3166.*alpha.*3.*country.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iso3166_alpha3_country_code"
        ],
        "negativeExamples": [
          "iso3166_alpha2_country_code"
        ]
      },
      {
        "regExp": "(?i).*country.*iso.*3.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "country_iso3_code"
        ],
        "negativeExamples": [
          "country_iso2_code"
        ]
      },
      {
        "regExp": "(?i).*alpha.*3.*country.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "alpha3_country"
        ],
        "negativeExamples": [
          "alpha2_country"
        ]
      },
      {
        "regExp": "(?i).*iso.*3.*country.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iso3_country"
        ],
        "negativeExamples": [
          "iso2_country"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "USA",
      "GBR",
      "FRA",
      "DEU",
      "JPN",
      "BRA",
      "AUS",
      "CAN"
    ],
    "negativeContentExamples": [
      "usa",
      "US",
      "USAA",
      "U5A",
      "U_A",
      "USA1",
      "USA ",
      "U SA"
    ],
    "positiveHeaderExamples": [
      "country_iso3",
      "iso3166_alpha3",
      "country_code_alpha3",
      "iso3_country_code",
      "alpha3_country",
      "iso_3166_1_alpha3",
      "country_iso_3166_1_alpha3",
      "iso3166_country_alpha3"
    ],
    "negativeHeaderExamples": [
      "country_iso2",
      "country_code",
      "iso3166_numeric",
      "alpha2_country_code",
      "state_code",
      "currency_iso3",
      "language_code",
      "iata_code"
    ],
    "explanation": "Identifies ISO 3166-1 alpha-3 country codes consisting of exactly three uppercase letters. The value pattern strictly enforces three A\u2013Z characters with word boundaries to prevent partial matches. Header patterns prioritize strong ISO/country/code context to disambiguate from other three-letter code systems (e.g., airport or language codes).",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T16:59:35.489542"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.ABA",
    "description": "Nine-digit US ABA routing number used to identify a bank or credit union for ACH and related payment transactions. It consists solely of digits with an internal checksum and contains no spaces or separators.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{9}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 3830,
    "headerPatterns": [
      {
        "regExp": "(?i).*aba.*routing.*(number|num|no).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "aba_routing_number"
        ],
        "negativeExamples": [
          "swift_code"
        ]
      },
      {
        "regExp": "(?i).*(ach|bank|transit|federal|fed|frb).*(routing|rtn).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "ach_routing"
        ],
        "negativeExamples": [
          "account_number"
        ]
      },
      {
        "regExp": "(?i).*(rtn|rt)[_-]?(number|num|no).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "rtn_num"
        ],
        "negativeExamples": [
          "tax_id"
        ]
      },
      {
        "regExp": "(?i).*routing.*code.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "routing_code"
        ],
        "negativeExamples": [
          "zip_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "number"
        ]
      }
    ],
    "positiveContentExamples": [
      "021000021",
      "026009593",
      "111000025",
      "121000358",
      "031101114",
      "063107513",
      "073000228",
      "084000026"
    ],
    "negativeContentExamples": [
      "21000021",
      "0210000210",
      "0210A0021",
      "0210 00021",
      "021-000-021",
      "02100002",
      "021_000_021",
      "0210002l1"
    ],
    "positiveHeaderExamples": [
      "aba_routing_number",
      "routing_number",
      "bank_rtn",
      "ach_routing",
      "transit_routing_no",
      "aba_number",
      "fed_routing_num",
      "routing_code"
    ],
    "negativeHeaderExamples": [
      "account_number",
      "swift_code",
      "tax_id",
      "iban",
      "bic",
      "zip_code",
      "customer_number",
      "check_number"
    ],
    "explanation": "Identifies nine-digit ABA routing numbers used in US payments. Detection focuses on a tight numeric pattern and routing-centric header cues; checksum validation is expected to be performed by downstream logic or specialized validators.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T16:59:37.692403"
  },
  {
    "resultType": "generated",
    "semanticType": "CURRENCY_CODE.ISO-4217",
    "description": "This type represents standardized currency codes established by the International Organization for Standardization for global financial systems. The codes consist of exactly three uppercase alphabetic characters that uniquely identify national and international currencies without spaces or punctuation.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4170,
    "headerPatterns": [
      {
        "regExp": "(?i).*iso.*4217.*currency.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "iso_4217_currency_code"
        ],
        "negativeExamples": [
          "currency_code"
        ]
      },
      {
        "regExp": "(?i).*iso.*4217.*code.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "iso4217_code"
        ],
        "negativeExamples": [
          "currency_iso"
        ]
      },
      {
        "regExp": "(?i).*currency.*iso.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "currency_iso_code"
        ],
        "negativeExamples": [
          "country_iso_code"
        ]
      },
      {
        "regExp": "(?i).*(currency|curr|ccy).*code.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "ccy_code"
        ],
        "negativeExamples": [
          "account_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "currency"
        ]
      }
    ],
    "positiveContentExamples": [
      "USD",
      "EUR",
      "JPY",
      "GBP",
      "CHF",
      "AUD",
      "CAD",
      "CNY"
    ],
    "negativeContentExamples": [
      "usd",
      "US",
      "EU R",
      "EURO",
      "US1",
      "U$D",
      "GBP-",
      "ABC DEF"
    ],
    "positiveHeaderExamples": [
      "iso_4217_currency_code",
      "currency_iso_code",
      "iso4217_code",
      "currency_code",
      "ccy_code",
      "curr_code",
      "txn_currency_code",
      "currency_iso_4217"
    ],
    "negativeHeaderExamples": [
      "country_code",
      "currency_name",
      "amount",
      "exchange_rate",
      "account_code",
      "language_code",
      "iata_code",
      "iso_country_code"
    ],
    "explanation": "Identifies three-letter ISO 4217 currency codes in datasets where values are uppercase alphabetic triplets (e.g., USD, EUR). Useful for validating and classifying currency fields in financial, payments, and reporting systems where header names include currency and ISO references or generic code terms.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T16:59:38.207023"
  },
  {
    "resultType": "generated",
    "semanticType": "CREDIT_CARD_TYPE",
    "description": "This type identifies the specific credit card brand or network associated with payment cards used in financial transactions. The values represent major card issuers and payment networks using their standard commercial names without abbreviations or account-specific information.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "VISA",
      "MASTERCARD",
      "AMERICAN EXPRESS",
      "DISCOVER",
      "DINERS CLUB",
      "JCB",
      "UNIONPAY",
      "MAESTRO",
      "MIR",
      "RUPAY",
      "ELO",
      "HIPERCARD",
      "INTERAC",
      "TROY",
      "CARNET",
      "BC CARD"
    ],
    "backout": "^[A-Z][A-Z ]{2,24}$",
    "confidenceThreshold": 95,
    "priority": 4140,
    "headerPatterns": [
      {
        "regExp": "(?i).*(credit|payment).*card.*(brand|network).*type.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "credit card network type"
        ],
        "negativeExamples": [
          "credit card number"
        ]
      },
      {
        "regExp": "(?i).*(credit|payment).*card.*(brand|network).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "payment card brand"
        ],
        "negativeExamples": [
          "payment card number"
        ]
      },
      {
        "regExp": "(?i).*(cc|ccard).*(brand|network|type).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "cc brand"
        ],
        "negativeExamples": [
          "cvv code"
        ]
      },
      {
        "regExp": "(?i).*card.*(type|brand|network).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "card type"
        ],
        "negativeExamples": [
          "card number"
        ]
      },
      {
        "regExp": "(?i).*brand.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "brand"
        ],
        "negativeExamples": [
          "number"
        ]
      }
    ],
    "positiveContentExamples": [
      "Visa",
      "Mastercard",
      "American Express",
      "Discover",
      "Diners Club",
      "JCB",
      "UnionPay",
      "Maestro"
    ],
    "negativeContentExamples": [
      "VISA Debit",
      "Master Card",
      "Amex",
      "AmericanExpress",
      "Discover Card",
      "J C B",
      "Union Pay",
      "Visa Electron"
    ],
    "positiveHeaderExamples": [
      "credit card type",
      "card network type",
      "payment card brand",
      "card brand",
      "card network",
      "payment network type",
      "card scheme",
      "card type"
    ],
    "negativeHeaderExamples": [
      "credit card number",
      "cardholder name",
      "payment method",
      "expiration date",
      "cvv code",
      "issuer identification number",
      "authorization code",
      "account type"
    ],
    "explanation": "CREDIT_CARD_TYPE classifies the brand or network of a payment card using standard commercial names like Visa, Mastercard, American Express, and similar networks. It is useful for analytics, fraud rules, routing, and reporting where the card brand is needed without exposing account-specific details such as the PAN or CVV.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T16:59:38.477196"
  },
  {
    "resultType": "generated",
    "semanticType": "COLOR.HEX",
    "description": "This color representation begins with a hash symbol followed by exactly six hexadecimal characters representing red, green, and blue color intensities. The code uses digits 0-9 and uppercase letters A-F with no spaces or additional formatting.",
    "pluginType": "regex",
    "regexPattern": "#[0-9A-F]{6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3930,
    "headerPatterns": [
      {
        "regExp": "(?i).*hex.*color.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "hex color code"
        ],
        "negativeExamples": [
          "color name"
        ]
      },
      {
        "regExp": "(?i).*color.*code.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "product color code"
        ],
        "negativeExamples": [
          "color value"
        ]
      },
      {
        "regExp": "(?i).*rgb.*color.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "rgb color"
        ],
        "negativeExamples": [
          "rgb value"
        ]
      },
      {
        "regExp": "(?i).*(clr|col).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "clr_code"
        ],
        "negativeExamples": [
          "color name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "color"
        ]
      }
    ],
    "positiveContentExamples": [
      "#000000",
      "#FFFFFF",
      "#A1B2C3",
      "#12AB9F",
      "#C0FFEE",
      "#BADA55",
      "#09AF3E"
    ],
    "negativeContentExamples": [
      "000000",
      "#abc123",
      "#12345",
      "#1234567",
      "##1A2B3C",
      "#1A2B3G",
      "#1A2B-3C"
    ],
    "positiveHeaderExamples": [
      "hex color code",
      "product color code",
      "rgb color",
      "clr_code",
      "html color code",
      "ui color code",
      "theme_color_code"
    ],
    "negativeHeaderExamples": [
      "color name",
      "rgb value",
      "hex value",
      "background color",
      "color id",
      "paint finish",
      "theme_color_name"
    ],
    "explanation": "Identifies six-digit RGB hexadecimal color literals that begin with a hash and use only digits 0-9 and uppercase A-F. Useful for validating and profiling datasets storing strict HTML/CSS-style RGB hex values without shorthand or alpha components.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T16:59:39.086362"
  },
  {
    "resultType": "generated",
    "semanticType": "EMAIL",
    "description": "An email address consisting of a local part followed by an at-symbol and a domain name. The local part may include letters, digits, and certain separators (dot, underscore, percent, plus, hyphen) in segments, and the domain must include one or more dot-separated labels using letters, digits, or hyphens.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z0-9]+([._%+-][A-Za-z0-9]+)*@[A-Za-z0-9-]+(\\.[A-Za-z0-9-]+)+\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4220,
    "headerPatterns": [
      {
        "regExp": "(?i).*(email|e[-_ ]?mail).*(address|addr).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "customer_email_address"
        ],
        "negativeExamples": [
          "mailing_address"
        ]
      },
      {
        "regExp": "(?i).*(primary|work|business|personal).*(email|e[-_ ]?mail).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "primary_email"
        ],
        "negativeExamples": [
          "primary_contact"
        ]
      },
      {
        "regExp": "(?i).*(contact|customer|user|account).*(email|e[-_ ]?mail).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "user_email"
        ],
        "negativeExamples": [
          "user_name"
        ]
      },
      {
        "regExp": "(?i).*email[_-]?id.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "email_id"
        ],
        "negativeExamples": [
          "account_id"
        ]
      },
      {
        "regExp": "(?i).*(e[-_ ]?mail).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "e-mail"
        ],
        "negativeExamples": [
          "mail_subject"
        ]
      },
      {
        "regExp": "(?i).*email.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "email"
        ],
        "negativeExamples": [
          "mail"
        ]
      }
    ],
    "positiveContentExamples": [
      "jane.doe@example.com",
      "support@sub.domain.co.uk",
      "u123+alerts@service-mail.io",
      "first_last@dept.example.org",
      "sales-team@company.co",
      "x@x.io",
      "qa.test%dev@alpha-beta.net",
      "info@my-domain123.com"
    ],
    "negativeContentExamples": [
      "jane.doeexample.com",
      "jane.@example.com",
      ".jane@example.com",
      "jane..doe@example.com",
      "user@example",
      "user@ex_ample.com",
      "user@example..com",
      "user@localhost"
    ],
    "positiveHeaderExamples": [
      "email_address",
      "primary_email",
      "user_email",
      "contact_email",
      "customer_email_address",
      "e-mail",
      "work_email",
      "email_id"
    ],
    "negativeHeaderExamples": [
      "mailing_address",
      "username",
      "contact_phone",
      "customer_id",
      "website_url",
      "postal_code",
      "support_mailbox",
      "primary_contact"
    ],
    "explanation": "This semantic type identifies standard email addresses where the local part is segmented by allowed separators and the domain includes at least one dot-separated label. It is suitable for validation and classification of fields representing user contact emails, login emails, and notification addresses in tabular datasets.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T16:59:39.630011"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.NORTHING",
    "description": "This coordinate represents the vertical position in a map projection measured as distance north from a baseline or grid origin. The value is typically a decimal number expressed in linear units like meters with positive values indicating northward direction.",
    "pluginType": "regex",
    "regexPattern": "\\b\\+?\\d{1,8}(\\.\\d{1,6})?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 4050,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\butm\\b.*\\bnorthing\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "utm_northing"
        ],
        "negativeExamples": [
          "utm_easting"
        ]
      },
      {
        "regExp": "(?i).*\\bgrid\\b.*\\bnorthing\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "grid_northing_m"
        ],
        "negativeExamples": [
          "grid_easting"
        ]
      },
      {
        "regExp": "(?i).*\\bmap\\b.*\\bnorthing\\b.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "map_northing"
        ],
        "negativeExamples": [
          "map_scale"
        ]
      },
      {
        "regExp": "(?i).*\\by[_\\s-]?(coord|coordinate)\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "y_coordinate"
        ],
        "negativeExamples": [
          "x_coordinate"
        ]
      },
      {
        "regExp": "(?i).*\\bnorthing\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "northing_value"
        ],
        "negativeExamples": [
          "longitude"
        ]
      }
    ],
    "positiveContentExamples": [
      "0",
      "125",
      "45.12",
      "5321456",
      "9876543.2",
      "+3456789",
      "7501234.567",
      "10000000"
    ],
    "negativeContentExamples": [
      "-12345",
      "123,456",
      "123456789",
      "12.",
      "1234.1234567",
      "1e6",
      "N1234567",
      "12345 678"
    ],
    "positiveHeaderExamples": [
      "utm_northing",
      "grid_northing_m",
      "map_northing",
      "y_coordinate",
      "ycoord_m",
      "northing_value",
      "northing_meters",
      "y_coord"
    ],
    "negativeHeaderExamples": [
      "easting",
      "x_coordinate",
      "longitude",
      "latitude",
      "grid_easting",
      "north_angle",
      "y_index",
      "column_north"
    ],
    "explanation": "Northing values are typically the Y-axis distances in projected coordinate systems such as grid or UTM, expressed in linear units (commonly meters). This type focuses on non-negative numeric values with optional decimal fractions and optional leading plus sign, aligning with common northing representations. Use this type to validate and recognize columns that store vertical grid distances rather than generic numeric fields.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T16:59:39.856255"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.UPC",
    "description": "This barcode consists of exactly twelve numeric digits including a calculated check digit for error detection and scanning validation. The identifier contains only numbers with no letters, spaces, hyphens, or other formatting characters.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{12}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3910,
    "headerPatterns": [
      {
        "regExp": "(?i).*upc.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "upc_code"
        ],
        "negativeExamples": [
          "upc_description"
        ]
      },
      {
        "regExp": "(?i).*product.*upc.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "product_upc"
        ],
        "negativeExamples": [
          "product_code"
        ]
      },
      {
        "regExp": "(?i).*item.*upc.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "item_upc"
        ],
        "negativeExamples": [
          "item_number"
        ]
      },
      {
        "regExp": "(?i).*upc.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "upc"
        ],
        "negativeExamples": [
          "product_id"
        ]
      },
      {
        "regExp": "(?i).*gtin12.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gtin12"
        ],
        "negativeExamples": [
          "gtin14"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "012345678905",
      "036000291452",
      "042100005264",
      "071662097701",
      "099482404876",
      "123456789012",
      "638713357943",
      "850000123456"
    ],
    "negativeContentExamples": [
      "01234567890",
      "0123456789012",
      "1234567890",
      "12345678901234",
      "01234-567890",
      "012345 678905",
      "01234567890A",
      "123456789O12"
    ],
    "positiveHeaderExamples": [
      "upc",
      "upc_code",
      "product_upc",
      "item_upc",
      "barcode_upc",
      "gtin12",
      "upc12",
      "product_barcode_upc"
    ],
    "negativeHeaderExamples": [
      "ean13",
      "ean",
      "isbn13",
      "sku",
      "product_id",
      "barcode_type",
      "gtin14",
      "product_number"
    ],
    "explanation": "Detects 12-digit UPC codes with no separators. It uses a strict 12-digit numeric pattern with word boundaries; downstream validation can compute and verify the check digit if supported. Suitable for product UPC fields where headers may reference UPC, GTIN-12, or generic code terms.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T16:59:42.088069"
  },
  {
    "resultType": "generated",
    "semanticType": "DAY.FULL_<LOCALE>",
    "description": "This type captures full weekday names as they appear in different locales and language contexts for date display and internationalization purposes. The values represent complete weekday names using proper spelling, capitalization, and linguistic forms specific to the indicated locale and cultural context.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "MONDAY",
      "TUESDAY",
      "WEDNESDAY",
      "THURSDAY",
      "FRIDAY",
      "SATURDAY",
      "SUNDAY"
    ],
    "backout": "^[A-Za-z]{6,9}$",
    "confidenceThreshold": 98,
    "priority": 4200,
    "headerPatterns": [
      {
        "regExp": "(?i).*day[_ ]of[_ ]week[_ ]name.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "day_of_week_name"
        ],
        "negativeExamples": [
          "day_of_week_code"
        ]
      },
      {
        "regExp": "(?i).*weekday[_ ]name.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "weekday_name"
        ],
        "negativeExamples": [
          "weekday_code"
        ]
      },
      {
        "regExp": "(?i).*day[_ ]of[_ ]week.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "day of week"
        ],
        "negativeExamples": [
          "week_of_day"
        ]
      },
      {
        "regExp": "(?i).*(dow|wday|wkday)[_ ]?name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "dow_name"
        ],
        "negativeExamples": [
          "dow_index"
        ]
      },
      {
        "regExp": "(?i).*(weekday|dow|wday|wkday).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "weekday"
        ],
        "negativeExamples": [
          "weekend"
        ]
      },
      {
        "regExp": "(?i).*day.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "day"
        ],
        "negativeExamples": [
          "date"
        ]
      }
    ],
    "positiveContentExamples": [
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday",
      "Sunday"
    ],
    "negativeContentExamples": [
      "Mon",
      "Monday.",
      "Mondays",
      "Mon day",
      "Tues day",
      "Fryday",
      "Sun",
      "Lundi"
    ],
    "positiveHeaderExamples": [
      "day_of_week_name",
      "weekday_name",
      "day_name",
      "dow_name",
      "weekday",
      "day of week",
      "wday_name",
      "wkday_name"
    ],
    "negativeHeaderExamples": [
      "day_count",
      "birthdate",
      "week_number",
      "month_name",
      "holiday_flag",
      "timestamp",
      "timezone",
      "weekend"
    ],
    "explanation": "Captures full English weekday names for datasets where the day-of-week appears as a complete word rather than an abbreviation or numeric code. Useful for parsing and standardizing internationalized date fields, validating UI labels, and normalizing calendar data for analytics.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T16:59:42.225783"
  },
  {
    "resultType": "generated",
    "semanticType": "EPOCH.MILLISECONDS",
    "description": "This type captures Unix timestamp values expressed in milliseconds precision for high-resolution time measurement and logging systems. The values represent time as a large integer count of milliseconds from the Unix epoch without any formatting, separators, or textual date components.",
    "pluginType": "regex",
    "regexPattern": "\\b([0-9]{12}|[0-9]{13})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4230,
    "headerPatterns": [
      {
        "regExp": "(?i).*epoch.*milliseconds.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "epoch_milliseconds"
        ],
        "negativeExamples": [
          "epoch_seconds"
        ]
      },
      {
        "regExp": "(?i).*unix.*ms.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "unix_ms"
        ],
        "negativeExamples": [
          "unix_timestamp"
        ]
      },
      {
        "regExp": "(?i).*(timestamp|ts).*ms.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "timestamp_ms"
        ],
        "negativeExamples": [
          "timestamp"
        ]
      },
      {
        "regExp": "(?i).*epoch.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "log_epoch_ms"
        ],
        "negativeExamples": [
          "event_time_ms"
        ]
      },
      {
        "regExp": "(?i).*timestamp.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "timestamp_ms"
        ],
        "negativeExamples": [
          "event_time"
        ]
      }
    ],
    "positiveContentExamples": [
      "1000000000000",
      "946684800000",
      "1577836800000",
      "1609459200123",
      "1685577600456",
      "1704067200789",
      "915148800000",
      "1234567890123"
    ],
    "negativeContentExamples": [
      "1697049600",
      "16094592000000",
      "1609459200000.0",
      "+1609459200000",
      "-1609459200000",
      "160945920000O",
      "1609 459200000",
      "1609459200000ms"
    ],
    "positiveHeaderExamples": [
      "epoch_milliseconds",
      "unix_ms",
      "timestamp_ms",
      "event_time_ms",
      "log_epoch_ms",
      "created_millis",
      "ingest_time_ms"
    ],
    "negativeHeaderExamples": [
      "epoch_seconds",
      "unix_timestamp",
      "timestamp",
      "event_time",
      "ms_duration",
      "time_nanos",
      "file_timestamp_str",
      "utc_offset_ms"
    ],
    "explanation": "Detects integer Unix timestamps recorded in milliseconds, typically used in logs and telemetry. Matches 12\u201313 digit numeric tokens without signs, separators, or units, ensuring close alignment to epoch millisecond values while excluding seconds, decimals, signed values, and suffixed units.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T16:59:44.318887"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.TEXT_NL",
    "description": "This type captures complete country names as they are expressed in Dutch language for identification and documentation purposes. The values represent standard Dutch nationality terminology following proper Dutch linguistic conventions without abbreviations or alternative language forms.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "NEDERLAND",
      "BELGI\u00cb",
      "DUITSLAND",
      "FRANKRIJK",
      "VERENIGD KONINKRIJK",
      "VERENIGDE STATEN",
      "CANADA",
      "SPANJE",
      "PORTUGAL",
      "ITALI\u00cb",
      "ZWEDEN",
      "NOORWEGEN",
      "DENEMARKEN",
      "FINLAND",
      "ZWITSERLAND",
      "OOSTENRIJK",
      "POLEN",
      "TSJECHI\u00cb",
      "HONGARIJE",
      "IERLAND",
      "GRIEKENLAND",
      "TURKIJE",
      "ZUID-AFRIKA",
      "AUSTRALI\u00cb",
      "JAPAN"
    ],
    "backout": "^[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff' .-]{3,40}$",
    "confidenceThreshold": 95,
    "priority": 4130,
    "headerPatterns": [
      {
        "regExp": "(?i).*landnaam.*nl.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "landnaam_nl"
        ],
        "negativeExamples": [
          "landnaam_en"
        ]
      },
      {
        "regExp": "(?i).*country.*name.*nl.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "country_name_nl"
        ],
        "negativeExamples": [
          "country_name_de"
        ]
      },
      {
        "regExp": "(?i).*land.*naam.*nl.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "land_naam_nl"
        ],
        "negativeExamples": [
          "land_code_nl"
        ]
      },
      {
        "regExp": "(?i).*country.*dutch.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "country_dutch"
        ],
        "negativeExamples": [
          "country_german"
        ]
      },
      {
        "regExp": "(?i).*land.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "land"
        ],
        "negativeExamples": [
          "taal"
        ]
      },
      {
        "regExp": "(?i).*country.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "country"
        ],
        "negativeExamples": [
          "city"
        ]
      }
    ],
    "positiveContentExamples": [
      "NEDERLAND",
      "BELGI\u00cb",
      "DUITSLAND",
      "FRANKRIJK",
      "VERENIGD KONINKRIJK",
      "VERENIGDE STATEN",
      "ZUID-AFRIKA",
      "AUSTRALI\u00cb"
    ],
    "negativeContentExamples": [
      "NEDERLANDS",
      "NL",
      "United States",
      "DEUTSCHLAND",
      "UK",
      "VERENIGD KONINKRIJK (UK)",
      "COTE D'IVOIRE",
      "MEXICO-STAD"
    ],
    "positiveHeaderExamples": [
      "landnaam_nl",
      "country_name_nl",
      "land_naam_nl",
      "land_nl",
      "country_dutch",
      "country_nl",
      "land",
      "country"
    ],
    "negativeHeaderExamples": [
      "landnaam_en",
      "country_name",
      "landcode_nl",
      "nationality_nl",
      "language_nl",
      "staat",
      "provincie",
      "city"
    ],
    "explanation": "COUNTRY.TEXT_NL identifies full country names written in Dutch (e.g., Nederland, Belgi\u00eb, Duitsland) for use in datasets where the language of the country label is explicitly Dutch. It excludes abbreviations, codes, mixed-language forms, or adjectival nationalities. The list plugin ensures precise recognition of representative values, with a backout shape to guide validation of similar text.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T16:59:45.341195"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE_PAIR.DECIMAL",
    "description": "This coordinate pair consists of two decimal numbers separated by a comma and optional space, representing latitude first followed by longitude. The format follows standard GPS conventions with positive values for north/east and negative values for south/west hemispheres.",
    "pluginType": "regex",
    "regexPattern": "\\b-?(90(\\.0+)?|[0-8]?\\d(\\.\\d+)?), ?-?(180(\\.0+)?|1[0-7]\\d(\\.\\d+)?|0?\\d?\\d(\\.\\d+)?)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4060,
    "headerPatterns": [
      {
        "regExp": "(?i).*(gps|geo).*(lat|latitude).*(lon|longitude).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gps_latitude_longitude"
        ],
        "negativeExamples": [
          "geolocation"
        ]
      },
      {
        "regExp": "(?i).*coordinate.*pair.*decimal.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "coordinate_pair_decimal"
        ],
        "negativeExamples": [
          "coordinate_pair"
        ]
      },
      {
        "regExp": "(?i).*coordinate.*pair.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "coordinate_pair"
        ],
        "negativeExamples": [
          "coordinates_list"
        ]
      },
      {
        "regExp": "(?i).*(lat|latitude)[ _-]*(lon|longitude).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "lat_lon_pair"
        ],
        "negativeExamples": [
          "longitude_latitude"
        ]
      },
      {
        "regExp": "(?i).*coordinate.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "coordinates"
        ],
        "negativeExamples": [
          "location"
        ]
      }
    ],
    "positiveContentExamples": [
      "45.1234, -122.9876",
      "-33.865143, 151.209900",
      "0.0, 0.0",
      "89.9999, 179.9999",
      "-90.0, 0.0",
      "12, -45",
      "48.8566, 2.3522",
      "-23.5505, -46.6333"
    ],
    "negativeContentExamples": [
      "91.0, 0.0",
      "-95, 40",
      "45.0; -122.0",
      "-33.865143, 181.0000",
      "120.0000, 45.0000",
      "45.0000, -190",
      "45.0,  120.0",
      "45.0 -122.0"
    ],
    "positiveHeaderExamples": [
      "gps_latitude_longitude",
      "geo_lat_lon",
      "coordinate_pair_decimal",
      "coordinates_decimal_pair",
      "lat_lon_pair",
      "latitude_longitude",
      "lat_lon_decimal",
      "gps_coordinates"
    ],
    "negativeHeaderExamples": [
      "location",
      "address",
      "postal_code",
      "timezone",
      "ip_address",
      "email",
      "city",
      "state"
    ],
    "explanation": "Identifies latitude/longitude pairs in decimal degrees with a comma separator and optional single space, enforcing valid latitude (-90 to 90) and longitude (-180 to 180) ranges. Useful for geospatial datasets, GPS exports, and mapping pipelines where lat precedes lon.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T16:59:46.118703"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.ISO-3166-2",
    "description": "This code consists of exactly two uppercase alphabetic characters that serve as the internationally recognized standard for country identification. The code follows ISO 3166-1 alpha-2 specifications and contains no numbers, spaces, or punctuation marks.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4080,
    "headerPatterns": [
      {
        "regExp": "(?i).*iso.*3166.*1.*alpha.*2.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "iso3166_1_alpha2"
        ],
        "negativeExamples": [
          "iso3166_1_alpha3"
        ]
      },
      {
        "regExp": "(?i).*(country|cntry).*(iso|alpha).*2.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "country_iso2"
        ],
        "negativeExamples": [
          "country_iso3"
        ]
      },
      {
        "regExp": "(?i).*(iso|alpha).*2.*(country|cntry).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iso_country_alpha2"
        ],
        "negativeExamples": [
          "iso_country_alpha3"
        ]
      },
      {
        "regExp": "(?i).*(country|cntry).*(code|cd).*(iso|alpha).*2.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "country_code_iso2"
        ],
        "negativeExamples": [
          "country_code_iso3"
        ]
      },
      {
        "regExp": "(?i).*(country|cntry).*(code|cd).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "country_code"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "country_name"
        ]
      }
    ],
    "positiveContentExamples": [
      "US",
      "GB",
      "FR",
      "DE",
      "CA",
      "AU",
      "JP",
      "IN"
    ],
    "negativeContentExamples": [
      "USA",
      "us",
      "Us",
      "U2",
      "U-S",
      "U S",
      "2U",
      "US1"
    ],
    "positiveHeaderExamples": [
      "iso3166_1_alpha2",
      "country_iso2",
      "iso_country_alpha2",
      "country_code_iso2",
      "country_iso_alpha2",
      "iso2_country_code",
      "country_cd_iso2",
      "country_code"
    ],
    "negativeHeaderExamples": [
      "country_iso3",
      "country_name",
      "postal_code",
      "state_code",
      "language_code",
      "country_id",
      "country_abbr",
      "iso3166_1_alpha3"
    ],
    "explanation": "Identifies two-letter uppercase ISO 3166-1 alpha-2 country codes in datasets using a strict two-letter A\u2013Z pattern and supportive header name cues. Useful for validating and classifying country code columns, enabling normalization, joining to reference data, and enforcing standards across international datasets.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T16:59:46.517198"
  },
  {
    "resultType": "generated",
    "semanticType": "CONTINENT.TEXT_EN",
    "description": "This represents the complete name of a continental region using proper English terminology and capitalization. The name consists of one or more words identifying major landmasses without abbreviations, codes, or country-specific references.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AFRICA",
      "ANTARCTICA",
      "ASIA",
      "EUROPE",
      "NORTH AMERICA",
      "SOUTH AMERICA",
      "AUSTRALIA",
      "OCEANIA"
    ],
    "backout": "^[A-Z]+( [A-Z]+)?$",
    "confidenceThreshold": 95,
    "priority": 3990,
    "headerPatterns": [
      {
        "regExp": "(?i).*continent.*(name|text).*(en|english).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "continent_name_en"
        ],
        "negativeExamples": [
          "continent_code"
        ]
      },
      {
        "regExp": "(?i).*(full|long).*(continent).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "full_continent_name"
        ],
        "negativeExamples": [
          "continent_short_name"
        ]
      },
      {
        "regExp": "(?i).*(continent|continental).*(name|label).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "continent_label"
        ],
        "negativeExamples": [
          "region_label"
        ]
      },
      {
        "regExp": "(?i).*(continent).*(en|english).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "continent_english"
        ],
        "negativeExamples": [
          "country_english"
        ]
      },
      {
        "regExp": "(?i).*continent.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "continent"
        ],
        "negativeExamples": [
          "region"
        ]
      }
    ],
    "positiveContentExamples": [
      "Africa",
      "Asia",
      "Europe",
      "North America",
      "South America",
      "Antarctica",
      "Australia",
      "Oceania"
    ],
    "negativeContentExamples": [
      "Americas",
      "Eurasia",
      "Central America",
      "Middle East",
      "N. America",
      "SA",
      "Australia and Oceania",
      "Sub-Saharan Africa"
    ],
    "positiveHeaderExamples": [
      "continent_name_en",
      "continent_full_name",
      "continent_english",
      "continent_name",
      "continent_text_en",
      "full_continent_name",
      "continent_label",
      "primary_continent_name"
    ],
    "negativeHeaderExamples": [
      "country_name_en",
      "region_name",
      "continent_code",
      "continent_abbr",
      "country",
      "geography_region",
      "world_region_name",
      "language_name"
    ],
    "explanation": "This semantic type identifies full English continent names such as Africa, Asia, or North America. It is designed for datasets where the field represents the spelled-out name of a continent (not a code or abbreviation), supporting consistent recognition across various header naming conventions.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T16:59:46.825923"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.LATITUDE_DECIMAL",
    "description": "This coordinate represents angular distance north or south of the equatorial plane using decimal notation ranging from -90 to +90 degrees. Positive values indicate northern hemisphere locations while negative values represent southern hemisphere positions.",
    "pluginType": "regex",
    "regexPattern": "\\b[+-]?(([0-8]?\\d(\\.\\d+)?)|(90(\\.0+)?))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4010,
    "headerPatterns": [
      {
        "regExp": "(?i).*latitude.*decimal.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "latitude_decimal"
        ],
        "negativeExamples": [
          "longitude_decimal"
        ]
      },
      {
        "regExp": "(?i).*lat.*dd.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lat_dd"
        ],
        "negativeExamples": [
          "lat_dms"
        ]
      },
      {
        "regExp": "(?i).*\\blat\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lat"
        ],
        "negativeExamples": [
          "latlong"
        ]
      },
      {
        "regExp": "(?i).*latitude.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "latitude"
        ],
        "negativeExamples": [
          "longitude"
        ]
      }
    ],
    "positiveContentExamples": [
      "0",
      "-0.125",
      "+12.3456",
      "45",
      "-23.4567",
      "+89.9999",
      "90",
      "-90.0"
    ],
    "negativeContentExamples": [
      "90.00001",
      "-90.1",
      "+91",
      "-95",
      "45.0N",
      "N45.0",
      "089.123",
      "\u221245.0"
    ],
    "positiveHeaderExamples": [
      "latitude_decimal",
      "lat_dd",
      "latitude_dec",
      "lat_decimal_degrees",
      "customer_latitude_decimal",
      "ship_latitude_dd",
      "lat",
      "latitude"
    ],
    "negativeHeaderExamples": [
      "longitude_decimal",
      "long_dd",
      "lon_decimal_degrees",
      "lng",
      "latlong",
      "elevation",
      "coordinate",
      "longitude"
    ],
    "explanation": "Identifies latitude values expressed in decimal degrees within the valid geographic range of -90 to +90, inclusive, allowing optional leading plus/minus and fractional parts. Useful for geospatial datasets, GPS logs, mapping applications, and any context where latitude is recorded as a single decimal numeric token.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T16:59:47.207227"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.EAN13",
    "description": "This barcode consists of exactly thirteen numeric digits including a calculated check digit for error detection and validation. The identifier contains only numbers with no letters, spaces, hyphens, or other formatting characters.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{13}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 3850,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bean[-_ ]?13[-_ ]?(code|number)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ean_13_code"
        ],
        "negativeExamples": [
          "ean8_code"
        ]
      },
      {
        "regExp": "(?i).*\\bgtin[-_ ]?13\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gtin13"
        ],
        "negativeExamples": [
          "gtin14"
        ]
      },
      {
        "regExp": "(?i).*\\bbarcode[-_ ]?ean[-_ ]?13\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "barcode_ean13"
        ],
        "negativeExamples": [
          "barcode_ean8"
        ]
      },
      {
        "regExp": "(?i).*\\b(ean|gtin)[-_ ]?13\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "item_ean13"
        ],
        "negativeExamples": [
          "item_ean"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "number"
        ]
      }
    ],
    "positiveContentExamples": [
      "4006381333931",
      "9780306406157",
      "5901234123457",
      "6291041500213",
      "8412345678905",
      "0123456789050",
      "4000001234561",
      "9501101530003"
    ],
    "negativeContentExamples": [
      "4006381333932",
      "9780306406158",
      "590123412345",
      "01234567890500",
      "8412345678905A",
      "629104150021",
      "40063813339 31",
      "40063-81333931"
    ],
    "positiveHeaderExamples": [
      "ean13",
      "ean_13_code",
      "gtin13",
      "barcode_ean13",
      "product_ean13",
      "ean13_number",
      "item_gtin13"
    ],
    "negativeHeaderExamples": [
      "ean8",
      "gtin14",
      "isbn13",
      "upc_a",
      "barcode_type",
      "product_code",
      "serial_number",
      "customer_id"
    ],
    "explanation": "This semantic type identifies EAN-13 barcodes as 13-digit numeric strings constrained by word boundaries, suitable for product identifiers, retail barcodes, and GTIN-13 fields. The regex avoids anchors and matches only contiguous 13-digit tokens, while header patterns prioritize explicit EAN/GTIN-13 mentions and fall back to the primitive 'code' term. Priority and threshold are set to reduce collisions with broader identifier types while respecting checkdigit-specific policy.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T16:59:47.397658"
  },
  {
    "resultType": "generated",
    "semanticType": "FILENAME_EXT",
    "description": "This type captures file extensions as they appear at the end of filenames to identify file formats and types. The values represent standardized extension indicators starting with a period followed by alphabetic or alphanumeric characters without spaces or additional punctuation.",
    "pluginType": "regex",
    "regexPattern": "\\b\\.[A-Za-z0-9]{1,10}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 92,
    "priority": 4260,
    "headerPatterns": [
      {
        "regExp": "(?i).*filename.*extension.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "filename_extension"
        ],
        "negativeExamples": [
          "filename"
        ]
      },
      {
        "regExp": "(?i).*file.*extension.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "file_extension"
        ],
        "negativeExamples": [
          "file_type"
        ]
      },
      {
        "regExp": "(?i).*filename.*ext.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "filename_ext"
        ],
        "negativeExamples": [
          "file_ext_type"
        ]
      },
      {
        "regExp": "(?i).*ext.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "ext"
        ],
        "negativeExamples": [
          "external_id"
        ]
      },
      {
        "regExp": "(?i).*extension.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "extension"
        ],
        "negativeExamples": [
          "version"
        ]
      }
    ],
    "positiveContentExamples": [
      ".pdf",
      ".txt",
      ".docx",
      ".xlsx",
      ".csv",
      ".jpeg",
      ".7z",
      ".MP4"
    ],
    "negativeContentExamples": [
      "pdf",
      "file.pdf",
      ".tar.gz",
      ".json,",
      ". csv",
      ".docx ",
      ".x-1",
      ".."
    ],
    "positiveHeaderExamples": [
      "filename_extension",
      "file_extension",
      "filename_ext",
      "file_ext",
      "ext",
      "extn",
      "document_extension",
      "attachment_extension"
    ],
    "negativeHeaderExamples": [
      "filename",
      "file_type",
      "extension_number",
      "external_id",
      "file_version",
      "mime_type",
      "file_name",
      "path"
    ],
    "explanation": "Identifies file extension tokens (e.g., .pdf, .docx) as standalone values, enabling data quality checks and parsing tasks where only the extension is stored. Useful for validating extracted extensions, filtering by type, or normalizing file-related metadata.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T16:59:48.333335"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.SEDOL",
    "description": "This security identifier consists of six alphanumeric characters followed by a single check digit calculated for validation purposes. The code uses uppercase letters and numbers with no spaces, hyphens, or other punctuation marks.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z0-9]{6}[0-9]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3900,
    "headerPatterns": [
      {
        "regExp": "(?i).*sedol.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "sedol_code"
        ],
        "negativeExamples": [
          "sedol_checkdigit"
        ]
      },
      {
        "regExp": "(?i).*sedol.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SEDOL ID"
        ],
        "negativeExamples": [
          "security sedol"
        ]
      },
      {
        "regExp": "(?i).*security.*sedol.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "security_sedol"
        ],
        "negativeExamples": [
          "security_code"
        ]
      },
      {
        "regExp": "(?i).*(instrument|security).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "instrument_code"
        ],
        "negativeExamples": [
          "account_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "B0YBKJ7",
      "A1B2C38",
      "Z9X8W70",
      "1H2J3K5",
      "QW8ERT4",
      "9LMN0P2",
      "T5R4E31",
      "G7H8J92"
    ],
    "negativeContentExamples": [
      "B0YBKJ",
      "B0YBKJX",
      "B0YBKJ-7",
      "b0ybkj7",
      "B0YBKJ77",
      "B0YB KJ7",
      "B0YBK*7",
      "B0YBK7"
    ],
    "positiveHeaderExamples": [
      "sedol_code",
      "SEDOL",
      "security_sedol",
      "instrument_sedol_code",
      "sedol_id",
      "security_identifier_sedol",
      "primary_sedol_code",
      "global_sedol"
    ],
    "negativeHeaderExamples": [
      "isin_code",
      "cusip",
      "ticker",
      "security_name",
      "ric",
      "figi",
      "account_id",
      "isin"
    ],
    "explanation": "SEDOL identifiers are seven-character security codes where the first six characters are uppercase alphanumeric and the seventh is a numeric check digit. This pattern enables detection of SEDOL-shaped values in datasets where the check digit may be used for secondary validation. The header patterns favor explicit references to SEDOL while still allowing recognition under generic 'code' fields when paired with strongly conforming content.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T16:59:48.377598"
  },
  {
    "resultType": "generated",
    "semanticType": "DIRECTION",
    "description": "This type identifies cardinal and intercardinal directions used in navigation, mapping, and geographic reference systems. The values represent standard compass directions using conventional English terminology without abbreviations, coordinates, or relative directional references.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "NORTH",
      "NORTH-NORTHEAST",
      "NORTHEAST",
      "EAST-NORTHEAST",
      "EAST",
      "EAST-SOUTHEAST",
      "SOUTHEAST",
      "SOUTH-SOUTHEAST",
      "SOUTH",
      "SOUTH-SOUTHWEST",
      "SOUTHWEST",
      "WEST-SOUTHWEST",
      "WEST",
      "WEST-NORTHWEST",
      "NORTHWEST",
      "NORTH-NORTHWEST"
    ],
    "backout": "^[A-Z]+(-[A-Z]+)?$",
    "confidenceThreshold": 93,
    "priority": 4210,
    "headerPatterns": [
      {
        "regExp": "(?i).*cardinal.*direction.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cardinal_direction"
        ],
        "negativeExamples": [
          "cardinal_number"
        ]
      },
      {
        "regExp": "(?i).*compass.*direction.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "compass_direction"
        ],
        "negativeExamples": [
          "compass_bearing"
        ]
      },
      {
        "regExp": "(?i).*compass.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "primary_compass"
        ],
        "negativeExamples": [
          "compost_type"
        ]
      },
      {
        "regExp": "(?i).*compass.*dir.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "compass_dir"
        ],
        "negativeExamples": [
          "directory_compass"
        ]
      },
      {
        "regExp": "(?i).*direction.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "direction"
        ],
        "negativeExamples": [
          "heading"
        ]
      }
    ],
    "positiveContentExamples": [
      "NORTH",
      "NORTHEAST",
      "EAST",
      "EAST-SOUTHEAST",
      "SOUTH",
      "SOUTH-SOUTHWEST",
      "WEST",
      "NORTH-NORTHWEST"
    ],
    "negativeContentExamples": [
      "N",
      "NE",
      "NORTH EAST",
      "NORTH-EAST",
      "DUE NORTH",
      "NORTHWESTERLY",
      "NORTH-NORTH-EAST",
      "SOUTHWEST-"
    ],
    "positiveHeaderExamples": [
      "cardinal_direction",
      "compass_direction",
      "navigation_direction",
      "travel_direction",
      "primary_compass",
      "compass_dir",
      "map_direction",
      "direction"
    ],
    "negativeHeaderExamples": [
      "cardinal_number",
      "compass_bearing",
      "heading_deg",
      "direction_code",
      "dir",
      "directions_list",
      "directory_path",
      "navigation_route"
    ],
    "explanation": "Represents full English names of the 16-point compass rose (cardinal and intercardinal directions), using hyphenation for compound forms (e.g., WEST-NORTHWEST). This is useful for datasets labeling orientation, map references, or navigation descriptors without abbreviations or degree bearings.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T16:59:51.973386"
  },
  {
    "resultType": "generated",
    "semanticType": "FILENAME",
    "description": "This type captures complete filenames as they appear in file systems and directory listings including the base name and file extension. The values represent file identifiers using alphanumeric characters, dots, and common symbols while excluding full path information or directory separators.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z0-9][A-Za-z0-9 _\\-\\.\\(\\)\\[\\]\\+&@#]{0,100}\\.[A-Za-z0-9]{1,10}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4250,
    "headerPatterns": [
      {
        "regExp": "(?i).*(attachment|download|stored|original)[ _-]?file[ _-]?name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "attachment_file_name"
        ],
        "negativeExamples": [
          "file_path"
        ]
      },
      {
        "regExp": "(?i).*(document|image|log|export)[ _-]?file[ _-]?name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "document_filename"
        ],
        "negativeExamples": [
          "directory"
        ]
      },
      {
        "regExp": "(?i).*file[ _-]?name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "file_name"
        ],
        "negativeExamples": [
          "product_name"
        ]
      },
      {
        "regExp": "(?i).*(document|attachment)[ _-]?name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "document_name"
        ],
        "negativeExamples": [
          "filepath"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "file_size"
        ]
      }
    ],
    "positiveContentExamples": [
      "report.pdf",
      "Q3-Report 2024 (final).pdf",
      "invoice_000123.csv",
      "backup-2025-08-10.tar.gz",
      "photo 12.jpg",
      "data_export-v2.json",
      "README.txt",
      "notes[team]_v1.docx"
    ],
    "negativeContentExamples": [
      "C:\\Users\\me\\report.pdf",
      "/var/log/syslog",
      ".gitignore",
      "report.",
      "photo?.jpg",
      "my|file.txt",
      "notes:final.docx",
      "backup-2025-08-10.tar."
    ],
    "positiveHeaderExamples": [
      "filename",
      "file_name",
      "document_filename",
      "attachment_file_name",
      "stored_filename",
      "original_file_name",
      "image_file_name",
      "export_filename"
    ],
    "negativeHeaderExamples": [
      "filepath",
      "file_path",
      "directory",
      "url",
      "mime_type",
      "file_size",
      "product_name",
      "user_name"
    ],
    "explanation": "The FILENAME semantic type recognizes standalone file names that include a base name and an extension, excluding any directory components or path separators. It is useful for identifying columns that store filenames for documents, images, logs, exports, and similar files without full path information.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T16:59:53.060915"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.LATITUDE_DMS",
    "description": "This coordinate format expresses angular distance from the equator using whole degrees, minutes (0-59), and seconds (0-59) followed by N for north or S for south. The format uses degree symbols, apostrophes for minutes, quotation marks for seconds, and directional letters.",
    "pluginType": "regex",
    "regexPattern": "\\b([0-8]?\\d|90)\u00b0\\s?([0-5]?\\d)'\\s?([0-5]?\\d)\"\\s?[NS]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4020,
    "headerPatterns": [
      {
        "regExp": "(?i).*latitude.*dms.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "latitude_dms"
        ],
        "negativeExamples": [
          "latitude_decimal"
        ]
      },
      {
        "regExp": "(?i).*(latitude|lat).*(deg|degree|degrees).*(min|minute|minutes).*(sec|second|seconds).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lat_deg_min_sec"
        ],
        "negativeExamples": [
          "lat_degree"
        ]
      },
      {
        "regExp": "(?i).*(geo|coord).*(lat|latitude).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "coord_lat"
        ],
        "negativeExamples": [
          "coord_long"
        ]
      },
      {
        "regExp": "(?i).*\\blat\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lat_dms"
        ],
        "negativeExamples": [
          "latitude"
        ]
      },
      {
        "regExp": "(?i).*latitude.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "latitude"
        ],
        "negativeExamples": [
          "longitude"
        ]
      }
    ],
    "positiveContentExamples": [
      "0\u00b0 0' 0\" N",
      "45\u00b0 12' 30\" N",
      "89\u00b0 59' 59\" S",
      "7\u00b05'9\" N",
      "90\u00b0 0' 0\" S",
      "15\u00b0 00' 01\" N",
      "02\u00b0 58' 07\" S",
      "83\u00b059'0\" N"
    ],
    "negativeContentExamples": [
      "91\u00b0 0' 0\" N",
      "45\u00b0 60' 0\" N",
      "45\u00b0 59' 60\" N",
      "45 30' 30\" N",
      "45\u00b0 30 30\" N",
      "45\u00b0 30' 30 N",
      "45\u00b0 30' 30\" E",
      "-45\u00b0 30' 30\" N"
    ],
    "positiveHeaderExamples": [
      "latitude_dms",
      "lat_deg_min_sec",
      "ship_latitude_dms",
      "latitude_degrees_minutes_seconds",
      "lat_dms",
      "geo_latitude",
      "coord_lat",
      "location_latitude_dms"
    ],
    "negativeHeaderExamples": [
      "longitude_dms",
      "longitude",
      "geo_longitude",
      "northing",
      "y_coordinate",
      "altitude"
    ],
    "explanation": "Identifies latitude coordinates written in Degrees-Minutes-Seconds (DMS) with an N/S hemisphere indicator, using the degree symbol (\u00b0), apostrophe ('), and quote (\"). This type is useful for parsing and validating geospatial latitude values where precision is expressed via whole minutes and seconds rather than decimals.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T16:59:53.660240"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.LONGITUDE_DMS",
    "description": "Angular distance east or west of the Prime Meridian expressed in Degrees-Minutes-Seconds with required symbols and a trailing direction letter E or W. Format: degrees (0\u2013180) followed by \u00b0, minutes (00\u201359) followed by ', seconds (00\u201359) followed by \", and a final E or W (uppercase). Examples: 73\u00b059'08\"W, 145\u00b005'09\"E. This does not accept signs, decimals, or N/S.",
    "pluginType": "regex",
    "regexPattern": "\\b(180|1[0-7][0-9]|[1-9][0-9]|[0-9])\u00b0\\s?([0-5][0-9])'\\s?([0-5][0-9])\"\\s?[EW]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4040,
    "headerPatterns": [
      {
        "regExp": "(?i).*longitude[\\s._-]*dms.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "longitude_dms"
        ],
        "negativeExamples": [
          "longitude_dd"
        ]
      },
      {
        "regExp": "(?i).*coordinate[\\s._-]*longitude.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "coordinate_longitude"
        ],
        "negativeExamples": [
          "coordinate_latitude"
        ]
      },
      {
        "regExp": "(?i).*lon[\\s._-]*dms.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "lon_dms"
        ],
        "negativeExamples": [
          "lat_dms"
        ]
      },
      {
        "regExp": "(?i).*\\blon(gitude)?\\b.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "lon"
        ],
        "negativeExamples": [
          "lat"
        ]
      },
      {
        "regExp": "(?i).*longitude.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "longitude"
        ],
        "negativeExamples": [
          "latitude"
        ]
      }
    ],
    "positiveContentExamples": [
      "73\u00b059'08\"W",
      "0\u00b000'00\"E",
      "180\u00b000'00\"E",
      "12\u00b030'45\"E",
      "145\u00b005'09\"W",
      "9\u00b007'05\"E",
      "100\u00b059'59\"E",
      "179\u00b000'01\"W"
    ],
    "negativeContentExamples": [
      "181\u00b000'00\"E",
      "73\u00b060'00\"W",
      "73\u00b059'60\"W",
      "073\u00b059'08\"W",
      "73 59'08\"W",
      "73\u00b059'08\"N",
      "-73\u00b059'08\"W",
      "9\u00b07'05\"E",
      "100\u00b059'59'W"
    ],
    "positiveHeaderExamples": [
      "longitude_dms",
      "lon_dms",
      "coordinate_longitude",
      "geo_longitude",
      "east_west_longitude",
      "map_longitude_dms",
      "primary_longitude",
      "longitude_value"
    ],
    "negativeHeaderExamples": [
      "latitude_dms",
      "lon_dd",
      "coordinate_latitude",
      "lat_dms",
      "easting",
      "geocode",
      "prime_meridian",
      "bearing"
    ],
    "explanation": "This semantic type identifies longitude values expressed strictly in Degrees-Minutes-Seconds with a trailing E or W direction and the required symbols for degrees (\u00b0), minutes ('), and seconds (\"). It rejects decimal degrees, signed values, hemisphere letters N/S, missing symbols, out-of-range components, and improperly padded minutes/seconds. Typical use cases include GIS datasets, navigation logs, and mapping applications where formatted DMS longitude is required.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T16:59:55.970080"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.CUSIP",
    "description": "A CUSIP is a 9-character security identifier consisting of eight uppercase alphanumeric characters followed by a single numeric check digit. The code contains only A\u2013Z and 0\u20139 with no spaces, hyphens, or punctuation.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z0-9]{8}[0-9]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3840,
    "headerPatterns": [
      {
        "regExp": "(?i).*cusip.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cusip_number"
        ],
        "negativeExamples": [
          "security_number"
        ]
      },
      {
        "regExp": "(?i).*cusip.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cusip_code"
        ],
        "negativeExamples": [
          "customer_code"
        ]
      },
      {
        "regExp": "(?i).*security.*cusip.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "security_cusip"
        ],
        "negativeExamples": [
          "security_code"
        ]
      },
      {
        "regExp": "(?i).*cusip.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cusip"
        ],
        "negativeExamples": [
          "customer_id"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "id"
        ]
      }
    ],
    "positiveContentExamples": [
      "68389X105",
      "38259P508",
      "594918104",
      "17275R102",
      "023135106",
      "369604103",
      "02079K107",
      "460146103"
    ],
    "negativeContentExamples": [
      "59491810",
      "5949181047",
      "68389x105",
      "68389X-105",
      "17275R10 2",
      "02313510A",
      "36960#103",
      "02079K10X"
    ],
    "positiveHeaderExamples": [
      "cusip",
      "cusip_code",
      "security_cusip",
      "issue_cusip",
      "cusip_number",
      "cusip_id",
      "fund_cusip",
      "parent_cusip"
    ],
    "negativeHeaderExamples": [
      "isin",
      "sedol",
      "security_code",
      "security_id",
      "ticker",
      "bond_identifier",
      "account_code",
      "customer_code"
    ],
    "explanation": "CUSIP values are detected using a strict pattern: eight uppercase alphanumeric characters followed by a single numeric check digit, all without separators. This configuration targets financial security identifiers commonly used in North American markets. The regex avoids anchors and relies on word boundaries and explicit lengths to minimize false positives. Header patterns progress from highly specific CUSIP-related names to a primitive 'code' term to support varied schema conventions while maintaining precision.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T16:59:57.704473"
  },
  {
    "resultType": "generated",
    "semanticType": "CITY",
    "description": "This represents the official name of a populated place with municipal status, typically containing multiple words and proper capitalization. The name may include directional indicators, geographic descriptors, or historical references but excludes abbreviations or postal codes.",
    "pluginType": "regex",
    "regexPattern": "\\b(?!St\\b)(?!Ft\\b)(?!Mt\\b)[A-Z][a-z]{2,}([-'][A-Z][a-z]{2,})*(\\s+((of|and|the|la|le|el|de|del|da|di|du|van|von|d)\\s+)?(?!St\\b)(?!Ft\\b)(?!Mt\\b)[A-Z][a-z]{2,}([-'][A-Z][a-z]{2,})*){0,4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3920,
    "headerPatterns": [
      {
        "regExp": "(?i).*(shipping|billing|mailing).*city.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "billing_city_name"
        ],
        "negativeExamples": [
          "billing_state_name"
        ]
      },
      {
        "regExp": "(?i).*(customer|vendor|client|employee).*city.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_city"
        ],
        "negativeExamples": [
          "customer_country"
        ]
      },
      {
        "regExp": "(?i).*(municipality|locality|town).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality_name"
        ],
        "negativeExamples": [
          "municipality_code"
        ]
      },
      {
        "regExp": "(?i).*(address|residence|home|work).*city.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "address_city"
        ],
        "negativeExamples": [
          "address_line1"
        ]
      },
      {
        "regExp": "(?i).*city.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "city"
        ],
        "negativeExamples": [
          "state"
        ]
      }
    ],
    "positiveContentExamples": [
      "Paris",
      "New York",
      "Los Angeles",
      "San Francisco",
      "Rio de Janeiro",
      "Salt Lake City",
      "Cape Town",
      "Saint Petersburg"
    ],
    "negativeContentExamples": [
      "St Louis",
      "N Las Vegas",
      "New-York",
      "New York NY",
      "NYC",
      "S\u00e3o Paulo",
      "Los-Angeles",
      "Paris-13"
    ],
    "positiveHeaderExamples": [
      "city",
      "billing_city_name",
      "customer_city",
      "municipality_name",
      "address_city",
      "residence_city",
      "home_city"
    ],
    "negativeHeaderExamples": [
      "state",
      "postal_code",
      "country",
      "city_code",
      "address_line1",
      "time_zone",
      "latitude"
    ],
    "explanation": "This type identifies proper city names presented as standalone place names, emphasizing multi-word capitalization rules and allowing common lowercase connectors (e.g., of, de, and). It excludes abbreviations (e.g., St, Ft, Mt), codes, and appended region or postal qualifiers.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T16:59:58.977444"
  },
  {
    "resultType": "generated",
    "semanticType": "FREE_TEXT",
    "description": "Open-ended human-readable content such as sentences, phrases, or paragraphs without a predefined format. Values may include letters, numbers, spaces, and common punctuation, and typically span multiple words with variable length.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z][A-Za-z0-9'\"\\-]{1,}\\s+[A-Za-z0-9][A-Za-z0-9'\"\\-]{1,}[A-Za-z0-9'\".,;:\\-\\(\\)!?\\/ ]{5,}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4270,
    "headerPatterns": [
      {
        "regExp": "(?i).*free[_ ]?text.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "free_text"
        ],
        "negativeExamples": [
          "comments"
        ]
      },
      {
        "regExp": "(?i).*(description|details|summary).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "issue_description"
        ],
        "negativeExamples": [
          "issue_status"
        ]
      },
      {
        "regExp": "(?i).*(comment|comments|notes?).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "user_comments"
        ],
        "negativeExamples": [
          "user_id"
        ]
      },
      {
        "regExp": "(?i).*(message|review|feedback).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "message_body"
        ],
        "negativeExamples": [
          "customer_id"
        ]
      },
      {
        "regExp": "(?i).*text.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "text"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Please review the attached report before Friday.",
      "The customer reported intermittent issues with login.",
      "Steps to reproduce: open app, sign in, then crash occurs.",
      "This product exceeded expectations in both quality and value.",
      "Meeting notes: discuss budget, timelines, and risks.",
      "Delivery was delayed due to severe weather conditions.",
      "Provide a brief summary of the proposed changes.",
      "User feedback indicates performance has improved."
    ],
    "negativeContentExamples": [
      "Ok thanks",
      "Pending",
      "Approved -",
      "12345 see notes",
      "\"Needs info\"",
      "Address: 12B",
      "TBD",
      "High-priority"
    ],
    "positiveHeaderExamples": [
      "free_text",
      "user_comments",
      "issue_description",
      "detailed_notes",
      "review_text",
      "message_body",
      "additional_details",
      "customer_feedback"
    ],
    "negativeHeaderExamples": [
      "customer_id",
      "status",
      "error_code",
      "reference_number",
      "phone",
      "country",
      "ip_address",
      "sku"
    ],
    "explanation": "This type is intended to capture unstructured narrative fields such as comments, descriptions, notes, messages, and summaries. The value pattern requires multiple words and allows common punctuation to distinguish natural language text from short tokens, identifiers, or codes. The high confidence threshold and priority reduce conflicts with more specific semantic types.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T16:59:59.272371"
  },
  {
    "resultType": "generated",
    "semanticType": "COLOR.TEXT_NL",
    "description": "Dutch color names as plain text tokens. Values are typically lowercase, single-word descriptors of hues and appearances, without numerals, punctuation, or technical specifications. Intended for common, human-readable Dutch color terminology.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "ROOD",
      "BLAUW",
      "GROEN",
      "GEEL",
      "ORANJE",
      "PAARS",
      "ROZE",
      "BRUIN",
      "ZWART",
      "WIT",
      "GRIJS",
      "CYAAN",
      "MAGENTA",
      "INDIGO",
      "TURKOOIS",
      "BEIGE",
      "BORDEAUX",
      "LILA",
      "OKER",
      "KARMOZIJN",
      "OLIJFGROEN",
      "DONKERBLAUW",
      "LICHTGROEN",
      "BLAUWGROEN"
    ],
    "backout": "^[A-Za-z]{3,20}$",
    "confidenceThreshold": 95,
    "priority": 3960,
    "headerPatterns": [
      {
        "regExp": "(?i).*product.*kleur.*naam.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "product_kleurnaam"
        ],
        "negativeExamples": [
          "product_kleurcode"
        ]
      },
      {
        "regExp": "(?i).*product.*kleur.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "product_kleur"
        ],
        "negativeExamples": [
          "product_code"
        ]
      },
      {
        "regExp": "(?i).*hoofdkleur.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "hoofdkleur"
        ],
        "negativeExamples": [
          "hoofdcategorie"
        ]
      },
      {
        "regExp": "(?i).*kleurnaam.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "kleurnaam"
        ],
        "negativeExamples": [
          "kleurcode"
        ]
      },
      {
        "regExp": "(?i).*kleur.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "kleur"
        ],
        "negativeExamples": [
          "tint"
        ]
      }
    ],
    "positiveContentExamples": [
      "rood",
      "blauw",
      "groen",
      "geel",
      "oranje",
      "paars",
      "zwart",
      "wit"
    ],
    "negativeContentExamples": [
      "Rood",
      "blauw-groen",
      "blauw groen",
      "grijs.",
      "wit3",
      "donkergroen1",
      "donker blauw",
      "skyblue"
    ],
    "positiveHeaderExamples": [
      "product_kleurnaam",
      "product_kleur",
      "kleurnaam",
      "hoofdkleur",
      "basiskleur",
      "artikel_kleur",
      "verfkleur",
      "schermkleur"
    ],
    "negativeHeaderExamples": [
      "color_code",
      "hexwaarde",
      "pantone",
      "rgb",
      "materiaal",
      "hue_value",
      "shade_number",
      "hsl"
    ],
    "explanation": "This semantic type targets Dutch color names provided as natural-language text, commonly found in product catalogs, UI theme settings, and descriptive fields. It is optimized for single-word, lowercase Dutch tokens representing recognizable colors rather than codes or numeric formats.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T16:59:59.370871"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.TEXT_ES",
    "description": "This type captures complete country names as they are expressed in Spanish language for identification and documentation purposes. The values represent standard Spanish country names following proper Spanish linguistic conventions without abbreviations or alternative language forms.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b([a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00fc\u00f1]{2,})([ -](de|del|la|las|los|el|y|san|santo|santa|s\u00e3o|saint|sainte|dos|das)){0,2}([ -][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00fc\u00f1]{2,}){0,6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4120,
    "headerPatterns": [
      {
        "regExp": "(?i).*(nombre|name).*pa[i\u00ed]s.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "nombre_pais"
        ],
        "negativeExamples": [
          "codigo_pais"
        ]
      },
      {
        "regExp": "(?i).*pa[i\u00ed]s.*(es|espa[n\u00f1]ol|spanish).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "pais_espanol"
        ],
        "negativeExamples": [
          "pais_codigo"
        ]
      },
      {
        "regExp": "(?i).*pa[i\u00ed]s.*(origen|nacimiento|residencia|destino).*",
        "confidence": 93,
        "mandatory": false,
        "positiveExamples": [
          "pais_origen"
        ],
        "negativeExamples": [
          "region_origen"
        ]
      },
      {
        "regExp": "(?i).*country.*spanish.*",
        "confidence": 92,
        "mandatory": false,
        "positiveExamples": [
          "country_spanish"
        ],
        "negativeExamples": [
          "country_code"
        ]
      },
      {
        "regExp": "(?i).*pa[i\u00ed]s.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "pais"
        ],
        "negativeExamples": [
          "ciudad"
        ]
      }
    ],
    "positiveContentExamples": [
      "Espa\u00f1a",
      "M\u00e9xico",
      "Estados Unidos",
      "Reino Unido",
      "Rep\u00fablica Dominicana",
      "Costa Rica",
      "Bosnia y Herzegovina",
      "Pap\u00faa Nueva Guinea"
    ],
    "negativeContentExamples": [
      "US",
      "United States",
      "Rep. Dominicana",
      "Espa\u00f1a 123",
      "Rep\u00fablica deDominicana",
      "Espa\u00f1a-",
      "Nueva  Zelanda",
      "M\u00e9xico, D.F."
    ],
    "positiveHeaderExamples": [
      "nombre_pais",
      "pais_es",
      "pais_espanol",
      "nombre_pais_es",
      "pais_origen",
      "pais_residencia",
      "country_spanish"
    ],
    "negativeHeaderExamples": [
      "codigo_pais",
      "nacionalidad",
      "region_origen",
      "pais_iso",
      "country_code",
      "ciudad",
      "idioma"
    ],
    "explanation": "Identifies full country names written in Spanish, without abbreviations or codes, useful for normalizing geographic attributes such as origin, residence, and destination fields. The pattern allows multi-word Spanish country names with common connectors (e.g., de, del, y, san/santa) and supports Spanish diacritics while excluding punctuation, digits, and abbreviations.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T16:59:59.779649"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.ISBN",
    "description": "Thirteen-digit book identifier presented in five hyphen-separated numeric groups: prefix (978 or 979), registration group, registrant (publisher), publication (title number), and a single check digit. The hyphenation reflects registration group rules and all groups are numeric with the final group exactly one digit.",
    "pluginType": "regex",
    "regexPattern": "\\b97[89]-\\d{1,5}-\\d{1,7}-\\d{1,7}-\\d\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3870,
    "headerPatterns": [
      {
        "regExp": "(?i).*book.*isbn[_\\s-]*13.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "book_isbn_13"
        ],
        "negativeExamples": [
          "book_isbn_10"
        ]
      },
      {
        "regExp": "(?i).*isbn[_\\s-]*13.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "isbn-13"
        ],
        "negativeExamples": [
          "isbn10"
        ]
      },
      {
        "regExp": "(?i).*book.*isbn.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "book_isbn"
        ],
        "negativeExamples": [
          "book_id"
        ]
      },
      {
        "regExp": "(?i).*pub.*isbn.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "pub_isbn"
        ],
        "negativeExamples": [
          "publication_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "978-0-306-40615-7",
      "978-1-4028-9462-6",
      "978-3-16-148410-0",
      "979-10-90636-07-1",
      "978-0-545-01022-1",
      "979-1-2345-6789-0",
      "978-99921-58-10-7",
      "979-12-200-1234-8"
    ],
    "negativeContentExamples": [
      "978-1-4028-9462-X",
      "978-1-4028-9462",
      "97-1-4028-9462-6",
      "979-0-306-40615-",
      "978 1 4028 9462 6",
      "978-1-4028-94626",
      "978/1/4028/9462/6",
      "978-3-16-148410-00"
    ],
    "positiveHeaderExamples": [
      "isbn-13",
      "book_isbn_13",
      "book_isbn",
      "pub_isbn",
      "publication_isbn_13",
      "isbn13_code",
      "book_isbn13"
    ],
    "negativeHeaderExamples": [
      "issn",
      "ean",
      "book_id",
      "title",
      "author",
      "sku",
      "catalog_number",
      "isbn10"
    ],
    "explanation": "This type detects hyphenated ISBN-13 values, enforcing the 5-group structure with a 978/979 prefix and a single-digit check digit. Use it to validate or profile columns that store properly hyphenated ISBN-13 identifiers; non-hyphenated or ISBN-10 formats will not match.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:02.053334"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.LUHN",
    "description": "This identifier consists of a sequence of digits where the final digit serves as a checksum calculated using the Luhn mathematical algorithm for error detection. The number contains only numeric digits with no letters, spaces, or special formatting characters. Typical lengths range from 8 to 19 digits, representing common Luhn-governed identifiers.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{8,19}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3890,
    "headerPatterns": [
      {
        "regExp": "(?i).*luhn.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "luhn_number"
        ],
        "negativeExamples": [
          "checkdigit_number"
        ]
      },
      {
        "regExp": "(?i).*(check.?digit|checksum).*(number|id).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "checkdigit_id"
        ],
        "negativeExamples": [
          "luhn_id"
        ]
      },
      {
        "regExp": "(?i).*luhn.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "luhn"
        ],
        "negativeExamples": [
          "luna_count"
        ]
      },
      {
        "regExp": "(?i).*cd.*(num|number).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cd_num"
        ],
        "negativeExamples": [
          "cd_code"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "79927398713",
      "4242424242424242",
      "4012888888881881",
      "378282246310005",
      "6011111111111117",
      "5555555555554444",
      "3530111333300000",
      "2223000048400011"
    ],
    "negativeContentExamples": [
      "4242 4242 4242 4242",
      "4242-4242-4242-4242",
      "7992739",
      "42424242424242424242",
      "4242424242424242a",
      "a4242424242424242",
      "0000000",
      "000000000000000000000"
    ],
    "positiveHeaderExamples": [
      "luhn_number",
      "checkdigit_number",
      "luhn_id",
      "checksum_id",
      "cd_num",
      "account_number_luhn",
      "luhn_check_number",
      "luhn"
    ],
    "negativeHeaderExamples": [
      "checksum_flag",
      "customer_name",
      "id",
      "crc32",
      "hash",
      "cd_code",
      "serial",
      "amount"
    ],
    "explanation": "Identifies digit-only fields whose values are intended to follow the Luhn algorithm, commonly used for numeric identifiers with a trailing check digit. The value regex restricts to 8\u201319 consecutive digits with word boundaries to avoid matching embedded or formatted sequences, while header patterns prioritize explicit references to Luhn and check digit terminology. A higher threshold and mid-range priority limit conflicts with generic numeric types and prioritize more specific national identity patterns over checkdigit-only formats.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:02.268217"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.TEXT_EN",
    "description": "This represents the complete country name using proper English terminology and capitalization conventions. The name may include multiple words and follows standard English linguistic patterns but excludes abbreviations, codes, or non-English translations.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z][a-z]{2,}(-[A-Z][a-z]{2,})?)( ([A-Z][a-z]{2,}(-[A-Z][a-z]{2,})?|of|and|the)){0,6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4110,
    "headerPatterns": [
      {
        "regExp": "(?i).*(english|en).*country.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "english_country_name"
        ],
        "negativeExamples": [
          "country_name"
        ]
      },
      {
        "regExp": "(?i).*country.*(english|en).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "country_name_en"
        ],
        "negativeExamples": [
          "country_code_en"
        ]
      },
      {
        "regExp": "(?i).*country.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "country_full_name"
        ],
        "negativeExamples": [
          "region_name"
        ]
      },
      {
        "regExp": "(?i).*(ctry|cntry).*(_)?(name|nm).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ctry_nm"
        ],
        "negativeExamples": [
          "ctry_cd"
        ]
      },
      {
        "regExp": "(?i).*(name).*(_)?(english|en).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name_en"
        ],
        "negativeExamples": [
          "english_country"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "United States of America",
      "United Kingdom",
      "New Zealand",
      "South Africa",
      "Papua New Guinea",
      "Bosnia and Herzegovina",
      "Democratic Republic of the Congo",
      "Saint Kitts and Nevis"
    ],
    "negativeContentExamples": [
      "U.S.A.",
      "UK",
      "united states of america",
      "United States of America 2",
      "United_States of America",
      "Saint Kitts & Nevis",
      "Congo (DRC)",
      "United States ofAmerica"
    ],
    "positiveHeaderExamples": [
      "english_country_name",
      "country_name_en",
      "country_english_name",
      "country_full_name",
      "country_long_name",
      "ctry_nm",
      "cntry_name",
      "name_en"
    ],
    "negativeHeaderExamples": [
      "country_code",
      "country_abbr",
      "region_name",
      "nationality",
      "locale",
      "language_name",
      "code",
      "id"
    ],
    "explanation": "This semantic type detects full English country names written with standard capitalization, allowing multi-word names, hyphenated tokens, and common lowercase connectors such as 'of', 'and', and 'the'. It intentionally excludes abbreviations, codes, and non-English or transliterated variants to minimize false positives in location-related datasets.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:03.940430"
  },
  {
    "resultType": "generated",
    "semanticType": "DAY.DIGITS",
    "description": "Captures the calendar day component as plain integers from 1 to 31 with no leading zeros or additional formatting. Intended for fields storing the day-of-month as a standalone numeric token, independent of month or year context.",
    "pluginType": "regex",
    "regexPattern": "\\b([1-9]|[12][0-9]|3[01])\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4190,
    "headerPatterns": [
      {
        "regExp": "(?i).*(day.*of.*month|dom).*(number|num).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "day_of_month_number"
        ],
        "negativeExamples": [
          "invoice_number"
        ]
      },
      {
        "regExp": "(?i).*day.*number.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "day_number"
        ],
        "negativeExamples": [
          "month_number"
        ]
      },
      {
        "regExp": "(?i).*(dom|day_num|dayno).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "dom"
        ],
        "negativeExamples": [
          "doj"
        ]
      },
      {
        "regExp": "(?i).*(calendar|posting|billing).*day.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "billing_day"
        ],
        "negativeExamples": [
          "billing_date"
        ]
      },
      {
        "regExp": "(?i).*day.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "day"
        ],
        "negativeExamples": [
          "date"
        ]
      }
    ],
    "positiveContentExamples": [
      "1",
      "2",
      "9",
      "10",
      "21",
      "28",
      "30",
      "31"
    ],
    "negativeContentExamples": [
      "0",
      "32",
      "09",
      "3.0",
      "15th",
      "1-2",
      "00",
      "7/"
    ],
    "positiveHeaderExamples": [
      "day_of_month_number",
      "day_number",
      "dom",
      "day_num",
      "billing_day",
      "posting_day",
      "calendar_day"
    ],
    "negativeHeaderExamples": [
      "month_number",
      "invoice_date",
      "day_of_week",
      "weekday_name",
      "birthdate",
      "month",
      "timestamp"
    ],
    "explanation": "This semantic type identifies standalone day-of-month integers ranging from 1 to 31 without leading zeros, suffixes, or separators. It is useful for parsing or validating the day component extracted from dates or when datasets store day values independently. The regex enforces valid numeric days and excludes values like 0, 32, and forms with leading zeros or text suffixes.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:04.214255"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.IBAN",
    "description": "This account number begins with a two-letter country code followed by two check digits and up to thirty additional alphanumeric characters representing the domestic bank account. The format varies by country but always includes validation digits and contains no spaces or punctuation.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b[A-Z]{2}\\d{2}[A-Z0-9]{10,30}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3860,
    "headerPatterns": [
      {
        "regExp": "(?i).*(international.*bank.*account.*number|iban).*(check.*digit|cd).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iban_check_digit"
        ],
        "negativeExamples": [
          "iban_number"
        ]
      },
      {
        "regExp": "(?i).*(iban|international.*bank.*account.*number).*(number|no|id).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iban_number"
        ],
        "negativeExamples": [
          "bank_account_number"
        ]
      },
      {
        "regExp": "(?i).*(acct|account|beneficiary|payer|recipient).*(iban).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "beneficiary_iban"
        ],
        "negativeExamples": [
          "beneficiary_account"
        ]
      },
      {
        "regExp": "(?i).*(iban).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iban"
        ],
        "negativeExamples": [
          "swift_bic"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "number"
        ]
      }
    ],
    "positiveContentExamples": [
      "GB29NWBK60161331926819",
      "DE89370400440532013000",
      "FR1420041010050500013M02606",
      "GR1601101250000000012300695",
      "ES9121000418450200051332",
      "NL91ABNA0417164300",
      "IT60X0542811101000000123456",
      "PL61109010140000071219812874"
    ],
    "negativeContentExamples": [
      "GB29 NWBK60161331926819",
      "DE89-370400440532013000",
      "1B29NWBK60161331926819",
      "GB2ANWBK60161331926819",
      "FR14ABCD1234",
      "IT60X05428_11101000000123456",
      "GBNWBK60161331926819",
      "GB29ABCDEFGHIJKLMNOPQRSTUVWXYZABCDE"
    ],
    "positiveHeaderExamples": [
      "iban_check_digit",
      "iban_number",
      "international_bank_account_number",
      "iban",
      "beneficiary_iban",
      "account_iban_id",
      "payment_iban_code"
    ],
    "negativeHeaderExamples": [
      "bank_account_number",
      "swift_bic",
      "routing_number",
      "account_identifier",
      "payment_reference",
      "bank_id",
      "account_no"
    ],
    "explanation": "International Bank Account Number (IBAN) strings are standardized account identifiers composed of a two-letter ISO country code, two check digits, and a country-specific alphanumeric BBAN segment, with no spaces or punctuation. This type validates the structural shape and presence of check digits without performing country-specific check digit algorithms, making it suitable for broad IBAN detection in normalized datasets.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:09.222475"
  },
  {
    "resultType": "generated",
    "semanticType": "COLOR.TEXT_EN",
    "description": "This represents standard color terminology using common English words that describe visual appearance and hue characteristics. The names are typically lowercase single words or simple compound terms without numeric values or technical specifications.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b((light|dark|bright|deep|pale|pastel|neon|soft|warm|cool|vivid|muted|dusty|burnt|off|hot)[\\s-](red|blue|green|yellow|orange|purple|pink|black|white|gray|grey|brown|beige|cyan|magenta|maroon|navy|teal|indigo|violet|turquoise|lavender|olive|lime|coral|tan|salmon|sienna|ochre|ocher|charcoal|burgundy|gold|silver|bronze|cream|ivory|mustard|peach|mint|plum|rose|ruby|amber|aquamarine|azure|cerulean|copper)|(red|blue|green|yellow|orange|purple|pink|black|white|gray|grey|brown|beige|cyan|magenta|maroon|navy|teal|indigo|violet|turquoise|lavender|olive|lime|coral|tan|salmon|sienna|ochre|ocher|charcoal|burgundy|gold|silver|bronze|cream|ivory|mustard|peach|mint|plum|rose|ruby|amber|aquamarine|azure|cerulean|copper)[\\s-](blue|green|gray|grey|red|orange|violet|pink|gold|rose|brown|drab)|(red|blue|green|yellow|orange|purple|pink|black|white|gray|grey|brown|beige|cyan|magenta|maroon|navy|teal|indigo|violet|turquoise|lavender|olive|lime|coral|tan|salmon|sienna|ochre|ocher|charcoal|burgundy|gold|silver|bronze|cream|ivory|mustard|peach|mint|plum|rose|ruby|amber|aquamarine|azure|cerulean|copper))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 3940,
    "headerPatterns": [
      {
        "regExp": "(?i).*(color|colour).*(name|text).*(en|english).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "color_name_en"
        ],
        "negativeExamples": [
          "color_name"
        ]
      },
      {
        "regExp": "(?i).*english.*(color|colour).*(name|text).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "english_color_name"
        ],
        "negativeExamples": [
          "color_english_code"
        ]
      },
      {
        "regExp": "(?i).*(color|colour).*(name|text).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "material_color_name"
        ],
        "negativeExamples": [
          "color_code"
        ]
      },
      {
        "regExp": "(?i).*(col|clr).*(nm|name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "clr_nm_en"
        ],
        "negativeExamples": [
          "clr_code"
        ]
      },
      {
        "regExp": "(?i).*(color|colour).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "color"
        ],
        "negativeExamples": [
          "hue"
        ]
      }
    ],
    "positiveContentExamples": [
      "blue",
      "dark green",
      "light-pink",
      "navy blue",
      "charcoal gray",
      "dusty rose",
      "blue-green",
      "off white"
    ],
    "negativeContentExamples": [
      "bluish",
      "greyish",
      "navyblue",
      "offwhite",
      "greenish",
      "limegreen",
      "purpl",
      "rouge"
    ],
    "positiveHeaderExamples": [
      "color_name_en",
      "english_color_name",
      "color_text_en",
      "material_color_name",
      "ui_color_text",
      "clr_nm_en",
      "product_color_name",
      "display_colour_name"
    ],
    "negativeHeaderExamples": [
      "color_code",
      "hex_color",
      "rgb_color",
      "shade_name",
      "hue",
      "colour_code",
      "font_color_id",
      "paint_code"
    ],
    "explanation": "This semantic type identifies English color names expressed as plain words or simple two-word compounds, optionally including common modifiers (e.g., light, dark) or hyphenated two-color blends (e.g., blue-green). It excludes numeric formats and technical specifications such as hex, RGB, or Pantone codes. Typical use cases include UI labels, product attributes, or categorical fields where human-readable color terms are expected.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:10.220257"
  },
  {
    "resultType": "generated",
    "semanticType": "CURRENCY.TEXT_EN",
    "description": "This type captures the complete names of currencies as they are expressed in English for international financial and economic contexts. The values represent standard currency terminology using proper English names without codes, symbols, or abbreviated forms.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Za-z]{3,}([ -][A-Za-z]{3,}){0,4}\\s)?(new\\s)?(afghani|ariary|baht|balboa|birr|bolivar|boliviano|cedi|colon|cordoba|dalasi|denar|dinar|dirham|dobra|dollar|dong|dram|escudo|euro|florin|forint|franc|gourde|guarani|hryvnia|krona|krone|kroner|kronur|koruna|kuna|kwacha|kwanza|kyat|lari|lempira|leone|leu|lev|lilangeni|lira|manat|metical|naira|ngultrum|ouguiya|paanga|pataca|peso|pound sterling|pound|pula|quetzal|rand|real|riel|riyal|rial|ringgit|ruble|rouble|rupee|rupiah|shekel|sol|som|somoni|tala|tenge|tugrik|vatu|won|yen|yuan|renminbi|zloty)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 4160,
    "headerPatterns": [
      {
        "regExp": "(?i).*currency.*english.*name.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "currency_english_name"
        ],
        "negativeExamples": [
          "currency_code"
        ]
      },
      {
        "regExp": "(?i).*currency.*full.*name.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "currency_full_name"
        ],
        "negativeExamples": [
          "currency_symbol"
        ]
      },
      {
        "regExp": "(?i).*currency.*name.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "currency_name"
        ],
        "negativeExamples": [
          "country_name"
        ]
      },
      {
        "regExp": "(?i).*(ccy|curr).*name.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "ccy_name"
        ],
        "negativeExamples": [
          "ccy_code"
        ]
      },
      {
        "regExp": "(?i).*currency.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "currency"
        ],
        "negativeExamples": [
          "exchange_rate"
        ]
      }
    ],
    "positiveContentExamples": [
      "United States dollar",
      "Euro",
      "Japanese yen",
      "British pound sterling",
      "Swiss franc",
      "Brazilian real",
      "Polish zloty",
      "United Arab Emirates dirham"
    ],
    "negativeContentExamples": [
      "USD",
      "US dollar",
      "U.S. dollar",
      "$",
      "GBP",
      "Chinese RMB",
      "Australian $",
      "\u00a5"
    ],
    "positiveHeaderExamples": [
      "currency_english_name",
      "currency_full_name",
      "currency_long_name",
      "currency_name",
      "currency_name_en",
      "english_currency_name",
      "ccy_name",
      "curr_name"
    ],
    "negativeHeaderExamples": [
      "country_name",
      "language_name",
      "iso_code",
      "symbol",
      "amount",
      "exchange_rate",
      "account_name",
      "unit_price"
    ],
    "explanation": "Use this type to recognize fields containing full English currency names (e.g., British pound sterling, South Korean won) rather than symbols, ISO codes, or abbreviations. It focuses on common currency unit terms preceded by country or region descriptors written out in plain English.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:13.227690"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.TEXT_DE",
    "description": "This represents the complete country name using proper German terminology, capitalization, and linguistic conventions. The name may include multiple words and German-specific characters but excludes abbreviations, codes, or non-German translations.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z\u00c4\u00d6\u00dc][a-z\u00e4\u00f6\u00fc\u00df]{2,}([ -][A-Z\u00c4\u00d6\u00dc][a-z\u00e4\u00f6\u00fc\u00df]{2,}){0,6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 4100,
    "headerPatterns": [
      {
        "regExp": "(?i).*(country|land|l\u00e4nder|staat).*name.*(de|deu|german|deutsch).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "country_name_de"
        ],
        "negativeExamples": [
          "country_name_en"
        ]
      },
      {
        "regExp": "(?i).*(de|deu|deutsch|german).*(country|land|l\u00e4nder|staat).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "de_country_name"
        ],
        "negativeExamples": [
          "en_country_name"
        ]
      },
      {
        "regExp": "(?i).*(country|land|l\u00e4nder|staat).*(de|deu|deutsch).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "laendername_de"
        ],
        "negativeExamples": [
          "country_code"
        ]
      },
      {
        "regExp": "(?i).*(ctry|cntry|nation|geo).*(nm|name).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "ctry_nm_de"
        ],
        "negativeExamples": [
          "country_code"
        ]
      },
      {
        "regExp": "(?i).*(name).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Deutschland",
      "\u00d6sterreich",
      "Schweiz",
      "Frankreich",
      "Niederlande",
      "Bosnien-Herzegowina",
      "S\u00fcdafrika",
      "Vereinigtes K\u00f6nigreich"
    ],
    "negativeContentExamples": [
      "DE",
      "DEU",
      "1Deutschland",
      "FRANKREICH",
      "C\u00f4te d\u2019Ivoire",
      "_Schweiz",
      "usa",
      "VEREINIGTES K\u00f6nigreich"
    ],
    "positiveHeaderExamples": [
      "country_name_de",
      "laendername_de",
      "land_name_deutsch",
      "de_country_name",
      "german_country_name",
      "country_de_name",
      "staat_name_de",
      "laender_name_german"
    ],
    "negativeHeaderExamples": [
      "country_name_en",
      "iso_country_code",
      "nation_id",
      "state_name",
      "country",
      "place",
      "language",
      "region_name"
    ],
    "explanation": "The type identifies full country names written in German, allowing for multiple capitalized words, hyphenation, and German-specific characters (\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df). It rejects abbreviations, codes, punctuation beyond spaces or hyphens, digits, and non-German transliterations. Use this to detect German country name fields in multilingual datasets, especially when accompanied by language-tagged headers.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:14.072667"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE_PAIR.DECIMAL_PAREN",
    "description": "This coordinate pair consists of two decimal numbers separated by a comma and enclosed in parentheses, representing latitude first followed by longitude. The format follows mathematical conventions with positive values for north/east and negative values for south/west hemispheres.",
    "pluginType": "regex",
    "regexPattern": "\\b\\(\\s*[+-]?\\d{1,2}\\.\\d+\\s*,\\s*[+-]?\\d{1,3}\\.\\d+\\s*\\)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4070,
    "headerPatterns": [
      {
        "regExp": "(?i).*(decimal).*coord.*(paren|parentheses).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "decimal_coordinates_parentheses"
        ],
        "negativeExamples": [
          "decimal_coordinate_pair"
        ]
      },
      {
        "regExp": "(?i).*(lat|latitude).*(lon|long|longitude).*(decimal).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "latitude_longitude_decimal"
        ],
        "negativeExamples": [
          "latitude_longitude"
        ]
      },
      {
        "regExp": "(?i).*coordinate.*pair.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "coordinate_pair_decimal"
        ],
        "negativeExamples": [
          "coordinates"
        ]
      },
      {
        "regExp": "(?i).*lat.*lon.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lat_lon"
        ],
        "negativeExamples": [
          "lat_speed"
        ]
      },
      {
        "regExp": "(?i).*coordinates.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "coordinates"
        ],
        "negativeExamples": [
          "location"
        ]
      }
    ],
    "positiveContentExamples": [
      "(37.7749, -122.4194)",
      "(-33.8688, 151.2093)",
      "(+51.5074, -0.1278)",
      "(0.0000, 0.0000)",
      "(-90.0000, 180.0000)",
      "(12.5000, 100.7500)",
      "(8.123456, -13.98765)",
      "(-45.5000, 170.3333)"
    ],
    "negativeContentExamples": [
      "37.7749, -122.4194",
      "[37.7749, -122.4194]",
      "(37.7749 -122.4194)",
      "(37, -122.4194)",
      "(37.7749, -122)",
      "(37.7749,-122.4194, 12.0)",
      "(N37.7749, W122.4194)",
      "37.7749 -122.4194"
    ],
    "positiveHeaderExamples": [
      "decimal_coordinate_pair",
      "lat_lon_parentheses",
      "latitude_longitude_decimal",
      "geo_coordinates_paren",
      "coordinates_decimal_pair",
      "latlon_decimal",
      "decimal_lat_long",
      "coordinate_pair_decimal"
    ],
    "negativeHeaderExamples": [
      "location",
      "gps_point",
      "latitude",
      "longitude",
      "position",
      "geohash",
      "map_ref",
      "address"
    ],
    "explanation": "Identifies latitude/longitude coordinate pairs expressed as decimal numbers enclosed in parentheses and separated by a comma, with latitude first and longitude second. Useful for datasets containing geospatial points formatted in a mathematical tuple style, ensuring both components include a decimal fraction and optional sign.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:15.673759"
  },
  {
    "resultType": "generated",
    "semanticType": "COMPANY_NAME",
    "description": "Represents a full corporate or business entity name that includes a recognized legal suffix (e.g., Corporation, Inc., LLC, Ltd, PLC, LLP, LP, Company). Values may include multiple words, punctuation such as commas or hyphens, and proper capitalization, but should not be stock tickers or arbitrary abbreviations.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b[A-Za-z0-9][A-Za-z0-9&'\u2019\\-,\\.]*( [A-Za-z0-9][A-Za-z0-9&'\u2019\\-,\\.]*){0,6} (Company|Co\\.|Corporation|Corp|Corp\\.|Incorporated|Inc|Inc\\.|Limited|Ltd|Ltd\\.|LLC|LLP|LP|PLC)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3970,
    "headerPatterns": [
      {
        "regExp": "(?i).*registered.*company.*name.*",
        "confidence": 99,
        "mandatory": true,
        "positiveExamples": [
          "registered_company_name"
        ],
        "negativeExamples": [
          "registered_company_id"
        ]
      },
      {
        "regExp": "(?i).*legal.*(company|business|corporate|organization).*name.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "legal_business_name"
        ],
        "negativeExamples": [
          "legal_company_status"
        ]
      },
      {
        "regExp": "(?i).*(company|business|corporate|organization).*name.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "company_name"
        ],
        "negativeExamples": [
          "company_code"
        ]
      },
      {
        "regExp": "(?i).*(corp|co|biz|org).*name.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "corp_name"
        ],
        "negativeExamples": [
          "co_address"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "title"
        ]
      }
    ],
    "positiveContentExamples": [
      "Acme Corporation",
      "Acme, Inc.",
      "Global Ventures LLC",
      "Sunrise Holdings Ltd.",
      "Apex Technologies, Inc.",
      "Orion Group PLC",
      "3M Company",
      "Blue Ridge Partners LLP"
    ],
    "negativeContentExamples": [
      "Acme Co",
      "3M",
      "Blue Ridge Partners L.L.C.",
      "Apex Tech Company123",
      "Orion Group P.L.C",
      "Acme Corpora",
      "NorthWest Logistics LPX",
      "Sunrise Limited Liability Co"
    ],
    "positiveHeaderExamples": [
      "company_legal_name",
      "legal_business_name",
      "registered_company_name",
      "corporate_name",
      "business_name",
      "organization_name",
      "legal_entity_name",
      "employer_legal_name"
    ],
    "negativeHeaderExamples": [
      "company_code",
      "company_id",
      "business_unit",
      "org_id",
      "legal_status",
      "incorporation_date",
      "ticker_symbol",
      "address_line1"
    ],
    "explanation": "This semantic type targets complete company or organization names that include a recognized legal suffix, signaling a formal registered entity. It is suitable for columns containing corporate names with suffixes like Inc., LLC, Ltd, PLC, LLP, LP, Corporation, Corp, or Company, and tolerates punctuation such as commas and hyphens. The header patterns prioritize strongly worded indicators of legal company naming, with a primitive fallback on 'name' for broad schema compatibility. The content pattern is intentionally constrained by requiring a legal suffix to avoid misclassifying general labels, products, or person names.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:15.935682"
  },
  {
    "resultType": "generated",
    "semanticType": "COLOR.TEXT_ES",
    "description": "This semantic type represents common Spanish color names as simple, single-word textual values (e.g., rojo, azul, verde). Values are typically lowercase, alphabetic, and do not include numbers, symbols, or technical specifications.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "ROJO",
      "AZUL",
      "VERDE",
      "AMARILLO",
      "NEGRO",
      "BLANCO",
      "GRIS",
      "MARR\u00d3N",
      "MORADO",
      "NARANJA",
      "ROSA",
      "VIOLETA",
      "CELESTE",
      "TURQUESA",
      "BEIGE",
      "DORADO",
      "PLATEADO",
      "CREMA",
      "GRANATE",
      "FUCSIA",
      "CIAN",
      "MAGENTA",
      "LILA",
      "OCRE",
      "CAQUI"
    ],
    "backout": "^[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1]{3,8}$",
    "confidenceThreshold": 94,
    "priority": 3950,
    "headerPatterns": [
      {
        "regExp": "(?i).*color.*(name|texto).*es.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "color_name_es"
        ],
        "negativeExamples": [
          "color_code"
        ]
      },
      {
        "regExp": "(?i).*(espa\u00f1ol|spanish|es).*color.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "espanol_color"
        ],
        "negativeExamples": [
          "color_palette"
        ]
      },
      {
        "regExp": "(?i).*(col|clr)[_ -]es.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "col_es"
        ],
        "negativeExamples": [
          "col_code"
        ]
      },
      {
        "regExp": "(?i).*color.*texto.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "color_text"
        ],
        "negativeExamples": [
          "background_color"
        ]
      },
      {
        "regExp": "(?i).*color.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "color"
        ],
        "negativeExamples": [
          "hue"
        ]
      }
    ],
    "positiveContentExamples": [
      "rojo",
      "azul",
      "verde",
      "amarillo",
      "negro",
      "blanco",
      "gris",
      "marr\u00f3n"
    ],
    "negativeContentExamples": [
      "azul marino",
      "verde-oliva",
      "marron",
      "rojo claro",
      "#00FF00",
      "rgb(255,0,0)",
      "123azul",
      "blanco y negro"
    ],
    "positiveHeaderExamples": [
      "color_name_es",
      "color_text_es",
      "spanish_color",
      "espanol_color",
      "col_es",
      "clr_es",
      "color_text",
      "color"
    ],
    "negativeHeaderExamples": [
      "hex_code",
      "rgb_value",
      "hue",
      "palette_name",
      "tone_es",
      "name_es",
      "material_code",
      "paint_shade"
    ],
    "explanation": "This type captures standard Spanish color words written as a single alphabetic token, commonly used to describe hue in plain text columns. It is useful for identifying descriptive color fields where values are human-readable Spanish terms rather than technical encodings or multi-word shades.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:17.108009"
  },
  {
    "resultType": "generated",
    "semanticType": "DAY.ABBR_<LOCALE>",
    "description": "This type captures abbreviated weekday names as they appear in different locales and language contexts for date formatting and display purposes. The values represent standardized short forms of weekday names, typically three characters long, following locale-specific conventions and linguistic rules.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\bmon\\b\\.?|\\btue\\b\\.?|\\bwed\\b\\.?|\\bthu\\b\\.?|\\bfri\\b\\.?|\\bsat\\b\\.?|\\bsun\\b\\.?|\\blun\\b\\.?|\\bmar\\b\\.?|\\bmer\\b\\.?|\\bjeu\\b\\.?|\\bven\\b\\.?|\\bsam\\b\\.?|\\bdim\\b\\.?|\\bmi\u00e9\\b\\.?|\\bmie\\b\\.?|\\bjue\\b\\.?|\\bvie\\b\\.?|\\bs\u00e1b\\b\\.?|\\bsab\\b\\.?|\\bdom\\b\\.?|\\bmo\\b\\.?|\\bdi\\b\\.?|\\bmi\\b\\.?|\\bdo\\b\\.?|\\bfr\\b\\.?|\\bsa\\b\\.?|\\bso\\b\\.?|\\bgio\\b\\.?|\\bseg\\b\\.?|\\bter\\b\\.?|\\bqua\\b\\.?|\\bqui\\b\\.?|\\bsex\\b\\.?|\\bma\\b\\.?|\\bwo\\b\\.?|\\bvr\\b\\.?|\\bza\\b\\.?|\\bzo\\b\\.?|\\bm\u00e5n\\b\\.?|\\btis\\b\\.?|\\bons\\b\\.?|\\btor\\b\\.?|\\bfre\\b\\.?|\\bl\u00f6r\\b\\.?|\\bs\u00f6n\\b\\.?",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4180,
    "headerPatterns": [
      {
        "regExp": "(?i).*day[_ -]?of[_ -]?week.*abbr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "day_of_week_abbr"
        ],
        "negativeExamples": [
          "day_of_week_name"
        ]
      },
      {
        "regExp": "(?i).*weekday.*abbr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "weekday_abbr"
        ],
        "negativeExamples": [
          "weekday_full"
        ]
      },
      {
        "regExp": "(?i).*\\bdow\\b.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "dow"
        ],
        "negativeExamples": [
          "download_count"
        ]
      },
      {
        "regExp": "(?i).*weekday.*short.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "weekday_short"
        ],
        "negativeExamples": [
          "weekday_long"
        ]
      },
      {
        "regExp": "(?i).*day.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "day"
        ],
        "negativeExamples": [
          "date"
        ]
      }
    ],
    "positiveContentExamples": [
      "Mon",
      "Thu",
      "Sun",
      "lun.",
      "mi\u00e9.",
      "s\u00e1b.",
      "Mo.",
      "seg"
    ],
    "negativeContentExamples": [
      "Monday",
      "Lunes",
      "Mercredi",
      "Domingo",
      "Thurs",
      "Tues",
      "Th",
      "Samstag"
    ],
    "positiveHeaderExamples": [
      "weekday_abbr",
      "day_of_week_abbr",
      "weekday_short",
      "dow_abbr",
      "weekday_3char",
      "weekday_shortname",
      "dow",
      "day"
    ],
    "negativeHeaderExamples": [
      "month_abbr",
      "month_short",
      "date",
      "timestamp",
      "weekday_full",
      "iso_week",
      "week_number",
      "calendar_week"
    ],
    "explanation": "Abbreviated weekday names are commonly used in localized date displays, calendar widgets, and scheduling systems. This semantic type recognizes concise weekday tokens across major locales, including optional trailing periods and locale-specific diacritics, while avoiding full weekday names to reduce ambiguity.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:19.364355"
  },
  {
    "resultType": "generated",
    "semanticType": "AIRPORT_CODE.IATA",
    "description": "A three-letter airport identifier used in airline ticketing and flight operations. Values are exactly three uppercase alphabetic characters with no digits, spaces, or punctuation.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 3820,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\biata\\b.*\\bairport\\b.*\\bcode\\b.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "iata_airport_code"
        ],
        "negativeExamples": [
          "airport_code"
        ]
      },
      {
        "regExp": "(?i).*\\bairport\\b.*\\bcode\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "airport_code"
        ],
        "negativeExamples": [
          "iata"
        ]
      },
      {
        "regExp": "(?i).*\\biata\\b.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "iata"
        ],
        "negativeExamples": [
          "icao"
        ]
      },
      {
        "regExp": "(?i).*\\bapt\\b.*\\bcode\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "apt_code"
        ],
        "negativeExamples": [
          "airport_name"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "JFK",
      "LAX",
      "ORD",
      "ATL",
      "LHR",
      "CDG",
      "HND",
      "DXB"
    ],
    "negativeContentExamples": [
      "SFOO",
      "LA",
      "jfk",
      "JfK",
      "A1B",
      "L-AX",
      "123",
      "J F K"
    ],
    "positiveHeaderExamples": [
      "iata_airport_code",
      "airport_code",
      "iata",
      "origin_iata",
      "destination_iata",
      "airport_iata",
      "iata_code",
      "apt_code"
    ],
    "negativeHeaderExamples": [
      "airport_name",
      "icao",
      "city",
      "flight_number",
      "terminal",
      "gate",
      "airline",
      "country"
    ],
    "explanation": "This semantic type targets IATA airport codes consisting of exactly three uppercase letters. It is useful for validating and classifying airport identifier fields in travel, logistics, and aviation datasets where values like JFK, LAX, and CDG are expected.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:20.024339"
  },
  {
    "resultType": "generated",
    "semanticType": "FULL_ADDRESS_EN",
    "description": "This type captures complete mailing addresses as they appear in English-language contexts for postal delivery and location identification. The values represent full address strings combining street address, city, state abbreviation, and postal code with comma separators following standard US addressing conventions.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{1,6} [A-Za-z0-9.# ]*[A-Za-z][A-Za-z0-9.# ]*, [A-Za-z][A-Za-z .-]*, [A-Z]{2} \\d{5}(-\\d{4})?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4280,
    "headerPatterns": [
      {
        "regExp": "(?i).*full.*address.*en.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "full_address_en"
        ],
        "negativeExamples": [
          "full_address"
        ]
      },
      {
        "regExp": "(?i).*mailing.*full.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mailing_full_address"
        ],
        "negativeExamples": [
          "full_address_en"
        ]
      },
      {
        "regExp": "(?i).*street.*city.*state.*zip.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "street_city_state_zip"
        ],
        "negativeExamples": [
          "city_state_zip"
        ]
      },
      {
        "regExp": "(?i).*postal.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postal_address"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      },
      {
        "regExp": "(?i).*mail.*addr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mail_addr"
        ],
        "negativeExamples": [
          "mail_flag"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "address"
        ],
        "negativeExamples": [
          "email"
        ]
      }
    ],
    "positiveContentExamples": [
      "742 Evergreen Terrace, Springfield, IL 62704",
      "1600 Pennsylvania Ave NW, Washington, DC 20500",
      "1 Infinite Loop, Cupertino, CA 95014",
      "350 Fifth Ave, New York, NY 10118",
      "500 S Buena Vista St, Burbank, CA 91521-0001",
      "24 Willie Mays Plaza, San Francisco, CA 94107",
      "405 Lexington Ave, New York, NY 10174-0002",
      "1234 N Main St, Phoenix, AZ 85004"
    ],
    "negativeContentExamples": [
      "123 Main St Springfield, IL 62704",
      "123 Main St, Springfield, IL",
      "123 Main St, Springfield, il 62704",
      "123 Main St - Springfield, IL 62704",
      "123 Main St, Springfield, IL 2704",
      "10 Downing Street, London, SW1A 2AA",
      "PO Box 123, Springfield, IL 62704",
      "123 Main St, Apt 5, Springfield, IL 62704"
    ],
    "positiveHeaderExamples": [
      "full_address_en",
      "mailing_full_address",
      "street_city_state_zip",
      "postal_address",
      "mail_addr",
      "address",
      "customer_address"
    ],
    "negativeHeaderExamples": [
      "postal_code",
      "city_state",
      "city_state_zip",
      "recipient_name",
      "coordinates",
      "country",
      "state",
      "url"
    ],
    "explanation": "Full English-language mailing address including street line, city, two-letter state code, and 5-digit or ZIP+4 code, separated by commas. Useful for detecting complete US-style address fields where a single column holds the full mailing address.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:20.543130"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.LONGITUDE_DECIMAL",
    "description": "This coordinate represents angular distance east or west of the Greenwich meridian using decimal notation ranging from -180 to +180 degrees. Positive values indicate eastern hemisphere locations while negative values represent western hemisphere positions.",
    "pluginType": "regex",
    "regexPattern": "\\b[+-]?((180(\\.0+)?)|((1[0-7][0-9]|[1-9]?[0-9])(\\.[0-9]+)?))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4030,
    "headerPatterns": [
      {
        "regExp": "(?i).*longitude.*decimal.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "longitude_decimal"
        ],
        "negativeExamples": [
          "latitude_decimal"
        ]
      },
      {
        "regExp": "(?i).*longitude.*deg.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "longitude_deg"
        ],
        "negativeExamples": [
          "latitude_deg"
        ]
      },
      {
        "regExp": "(?i).*geo.*longitude.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "geo_longitude"
        ],
        "negativeExamples": [
          "geo_latitude"
        ]
      },
      {
        "regExp": "(?i).*spatial.*longitude.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "spatial_longitude"
        ],
        "negativeExamples": [
          "spatial_latitude"
        ]
      },
      {
        "regExp": "(?i).*\\blon\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lon"
        ],
        "negativeExamples": [
          "lat"
        ]
      },
      {
        "regExp": "(?i).*longitude.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "longitude"
        ],
        "negativeExamples": [
          "latitude"
        ]
      }
    ],
    "positiveContentExamples": [
      "0",
      "-0.0",
      "73.9857",
      "-122.4194",
      "179.9999",
      "180",
      "+12.5",
      "-179.0"
    ],
    "negativeContentExamples": [
      "180.0001",
      "-180.1",
      "200",
      "+181",
      "90\u00b0",
      "12,345",
      "073.5",
      "-.5"
    ],
    "positiveHeaderExamples": [
      "longitude_decimal",
      "longitude_deg",
      "geo_longitude",
      "spatial_longitude",
      "lon",
      "map_longitude",
      "coordinate_longitude"
    ],
    "negativeHeaderExamples": [
      "latitude_decimal",
      "lat",
      "longitude_minutes",
      "x_coordinate",
      "longitude_dms",
      "geocode",
      "country_long_name"
    ],
    "explanation": "Identifies decimal longitudes (\u2212180 to +180) expressed as signed integers or decimals, including 180 only when fractional part is zero. Useful for geospatial datasets where longitude is stored as a numeric field without hemisphere letters. Excludes values outside the valid range, DMS formats, hemisphere-suffixed values (E/W), commas, and bare fractional forms without a leading zero.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:21.260498"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.SIN_CA",
    "description": "This type captures the Canadian Social Insurance Number, a federal identifier required for work authorization and government services. The number consists of nine digits and is often formatted with single spaces in groups of three digits for readability.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{3}\\s\\d{3}\\s\\d{3}\\b|\\b\\d{9}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4460,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bcanad\\w*\\b.*\\bsocial\\b.*\\binsurance\\b.*\\b(number|no)\\b.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "canadian social insurance number"
        ],
        "negativeExamples": [
          "social insurance number"
        ]
      },
      {
        "regExp": "(?i).*\\bcanad\\w*\\b.*\\bsin\\b.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "canada sin"
        ],
        "negativeExamples": [
          "sin"
        ]
      },
      {
        "regExp": "(?i).*\\bsocial\\b.*\\binsurance\\b.*\\b(number|no)\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "social insurance number"
        ],
        "negativeExamples": [
          "insurance number"
        ]
      },
      {
        "regExp": "(?i).*\\bsin\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "sin"
        ],
        "negativeExamples": [
          "ssn"
        ]
      },
      {
        "regExp": "(?i).*\\bnumber\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "046 454 286",
      "123456789",
      "987 654 321",
      "135 791 357",
      "000 123 456",
      "111222333",
      "912 345 678",
      "234 567 890"
    ],
    "negativeContentExamples": [
      "123-456-789",
      "123 456789",
      "12345678",
      "123 456 7890",
      "O46 454 286",
      "1234 56 789",
      "123  456  789",
      "1234567890"
    ],
    "positiveHeaderExamples": [
      "canadian_social_insurance_number",
      "social insurance number",
      "sin",
      "ca sin",
      "sin_number",
      "canada_sin",
      "canada social insurance no",
      "ca_social_insurance_number"
    ],
    "negativeHeaderExamples": [
      "ssn",
      "national_insurance_number",
      "tax_identification_number",
      "employee_number",
      "social_security_number",
      "insurance_number",
      "driver_license_number",
      "nhs_number"
    ],
    "explanation": "Identifies Canadian Social Insurance Numbers as nine digits, either contiguous or grouped as three blocks separated by single spaces. The pattern uses word boundaries and explicit digit counts to avoid partial or ambiguous matches, reflecting common SIN presentations without permitting hyphens or irregular spacing.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:21.536161"
  },
  {
    "resultType": "generated",
    "semanticType": "AIRLINE.TEXT_EN",
    "description": "This represents the complete legal or trading name of an airline carrier as it appears in official documentation and marketing materials. The name typically includes descriptive words like 'Airlines', 'Airways', or 'Air Lines' and may contain spaces and punctuation.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b([A-Z][A-Za-z]+( [A-Z][A-Za-z]+){0,4} (Air Lines|Airlines|Airways)|Air( [A-Z][A-Za-z]+|-[A-Z][A-Za-z]+)|[A-Z][A-Za-z]+( [A-Z][A-Za-z]+){0,3} Air( Lines?)?)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3810,
    "headerPatterns": [
      {
        "regExp": "(?i).*(airline|carrier).*(legal|registered|official).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "airline_legal_name"
        ],
        "negativeExamples": [
          "airline_code"
        ]
      },
      {
        "regExp": "(?i).*(airline|carrier).*(trading|brand).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "carrier_brand_name"
        ],
        "negativeExamples": [
          "carrier_id"
        ]
      },
      {
        "regExp": "(?i).*(primary|preferred).*(airline|carrier).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "primary_airline_name"
        ],
        "negativeExamples": [
          "primary_airline_code"
        ]
      },
      {
        "regExp": "(?i).*(airline|carrier).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "airline_name"
        ],
        "negativeExamples": [
          "airport_name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "legal_name"
        ],
        "negativeExamples": [
          "airline_code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Delta Air Lines",
      "United Airlines",
      "American Airlines",
      "British Airways",
      "Air France",
      "Qatar Airways",
      "Wizz Air",
      "KLM Royal Dutch Airlines"
    ],
    "negativeContentExamples": [
      "Emirates",
      "Ryanair",
      "Lufthansa",
      "JetBlue",
      "American Airline",
      "British Air Ways",
      "Airfreight Logistics",
      "Fly Co."
    ],
    "positiveHeaderExamples": [
      "airline_legal_name",
      "carrier_official_name",
      "airline_trading_name",
      "carrier_brand_name",
      "primary_airline_name",
      "airline_name",
      "registered_airline_name",
      "official_airline_name"
    ],
    "negativeHeaderExamples": [
      "airline_code",
      "carrier_id",
      "airport_name",
      "passenger_name",
      "airline_number",
      "airline_country",
      "airline_email",
      "carrier_phone"
    ],
    "explanation": "This type identifies full airline carrier names in English by detecting key aviation naming terms such as 'Airlines', 'Airways', 'Air Lines', or a distinct 'Air' token combined with proper-noun words. It is useful for classifying organization fields that specifically hold airline legal or trading names while avoiding generic company names.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:21.646120"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.EASTING",
    "description": "This coordinate represents the horizontal position in a map projection measured as distance east from a central meridian or grid origin. The value is typically a decimal number expressed in linear units like meters with positive values indicating eastward direction.",
    "pluginType": "regex",
    "regexPattern": "\\b([1-9]\\d{3,6}|[1-9]\\d{0,2}(,\\d{3}){1,2})(\\.\\d+)?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4000,
    "headerPatterns": [
      {
        "regExp": "(?i).*(utm|stateplane|mgrs|osgb).*easting.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "utm_easting"
        ],
        "negativeExamples": [
          "utm_northing"
        ]
      },
      {
        "regExp": "(?i).*(map|grid|spatial).*easting.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "grid_easting"
        ],
        "negativeExamples": [
          "spatial_index"
        ]
      },
      {
        "regExp": "(?i).*(east|x).*coord.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "east_coord"
        ],
        "negativeExamples": [
          "north_coord"
        ]
      },
      {
        "regExp": "(?i).*easting.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "easting_meters"
        ],
        "negativeExamples": [
          "east_boundary"
        ]
      },
      {
        "regExp": "(?i).*coordinate.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "coordinate"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "500000",
      "423765.42",
      "612,345",
      "245,678.9",
      "100000",
      "833978",
      "701,234.001",
      "166021"
    ],
    "negativeContentExamples": [
      "-500000",
      "012345",
      "500,000 m",
      "E 500000",
      "999",
      "45.6",
      "1 234 567",
      "833978W"
    ],
    "positiveHeaderExamples": [
      "utm_easting",
      "grid_easting",
      "map_easting_m",
      "easting",
      "easting_meters",
      "x_coord",
      "east_coordinate",
      "stateplane_easting"
    ],
    "negativeHeaderExamples": [
      "utm_zone",
      "northing",
      "latitude",
      "longitude",
      "y_coord",
      "grid_reference",
      "spatial_index",
      "east_boundary"
    ],
    "explanation": "COORDINATE.EASTING identifies positive horizontal map grid values typically expressed in meters, often seen in projected coordinate systems such as UTM or other national grids. It focuses on numeric magnitudes suitable for eastward distances, supporting plain and comma-grouped formats with optional decimal fractions.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:22.328842"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.DUNS",
    "description": "This type represents the DUNS number, a proprietary business identifier created by Dun & Bradstreet for tracking commercial entities globally. The identifier consists of exactly nine digits with no alphabetic characters, spaces, or punctuation marks.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{9}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4390,
    "headerPatterns": [
      {
        "regExp": "(?i).*duns.*number.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "duns number"
        ],
        "negativeExamples": [
          "customer number"
        ]
      },
      {
        "regExp": "(?i).*duns.*id.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "duns id"
        ],
        "negativeExamples": [
          "vendor id"
        ]
      },
      {
        "regExp": "(?i).*d-u-n-s.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "d-u-n-s number"
        ],
        "negativeExamples": [
          "company number"
        ]
      },
      {
        "regExp": "(?i).*(company|business|vendor).*duns.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "vendor duns"
        ],
        "negativeExamples": [
          "vendor code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "123456789",
      "001234567",
      "555123456",
      "000000001",
      "314159265",
      "271828182",
      "987654321",
      "246813579"
    ],
    "negativeContentExamples": [
      "12345678",
      "1234567890",
      "123-456-789",
      "123 456 789",
      "12345678A",
      "A12345678",
      "123.456789",
      "0000-00001"
    ],
    "positiveHeaderExamples": [
      "duns number",
      "duns id",
      "d-u-n-s number",
      "vendor duns",
      "business duns code",
      "company duns identifier",
      "client duns id"
    ],
    "negativeHeaderExamples": [
      "company number",
      "vendor id",
      "business code",
      "customer account number",
      "supplier identifier",
      "duns score",
      "d-u-n-s rating",
      "company name"
    ],
    "explanation": "IDENTITY.DUNS captures nine-digit DUNS identifiers used to uniquely identify business entities. It strictly matches exactly nine digits with no spaces, punctuation, or letters. Use this semantic type to validate and standardize DUNS fields in datasets, especially for vendor, supplier, or company master data.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:23.457355"
  },
  {
    "resultType": "generated",
    "semanticType": "GENDER.TEXT_ZH",
    "description": "This type captures gender designations as they are expressed in Chinese language for demographic data collection and personal identification purposes. The values represent standard gender terminology using Chinese characters and linguistic conventions without abbreviations or alternative language forms.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "\u7537",
      "\u5973",
      "\u7537\u6027",
      "\u5973\u6027",
      "\u5176\u4ed6",
      "\u4e2d\u6027",
      "\u7b2c\u4e09\u6027",
      "\u53cc\u6027",
      "\u975e\u4e8c\u5143",
      "\u8de8\u6027\u522b",
      "\u672a\u77e5",
      "\u4e0d\u8be6",
      "\u672a\u8bf4\u660e",
      "\u4fdd\u5bc6"
    ],
    "backout": "^[\\p{IsHan}]{1,4}$",
    "confidenceThreshold": 97,
    "priority": 4310,
    "headerPatterns": [
      {
        "regExp": "(?i).*(gender|sex).*(text|label).*(zh|cn|chs|chinese).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "gender_text_zh"
        ],
        "negativeExamples": [
          "gender_code"
        ]
      },
      {
        "regExp": "(?i).*(\u6027\u522b).*(\u4e2d\u6587|\u6587\u672c|\u63cf\u8ff0).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "\u6027\u522b\u4e2d\u6587"
        ],
        "negativeExamples": [
          "\u6027\u522b\u4ee3\u7801"
        ]
      },
      {
        "regExp": "(?i).*(gender|sex).*(zh|cn|chs|chinese).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gender_cn"
        ],
        "negativeExamples": [
          "gender_en"
        ]
      },
      {
        "regExp": "(?i).*(\u4e2d\u6587|\u6c49\u5b57).*(\u6027\u522b).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u4e2d\u6587\u6027\u522b"
        ],
        "negativeExamples": [
          "\u82f1\u6587\u6027\u522b"
        ]
      },
      {
        "regExp": "(?i).*(\u6027\u522b|gender|sex).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u6027\u522b"
        ],
        "negativeExamples": [
          "\u5e74\u9f84"
        ]
      }
    ],
    "positiveContentExamples": [
      "\u7537",
      "\u5973",
      "\u7537\u6027",
      "\u5973\u6027",
      "\u5176\u4ed6",
      "\u4e2d\u6027",
      "\u7b2c\u4e09\u6027",
      "\u672a\u77e5"
    ],
    "negativeContentExamples": [
      "\u7537\u5b69",
      "\u5973\u5b50",
      "\u5973\u6027/\u7537\u6027",
      "\u6027\u522b: \u7537",
      "\u5176\u5b83",
      "\u672a\u77e5\u6027\u522b",
      "\u5973\u751f",
      "M"
    ],
    "positiveHeaderExamples": [
      "\u6027\u522b",
      "\u6027\u522b\u4e2d\u6587",
      "\u6027\u522b\u6587\u672c",
      "\u6027\u522b\u63cf\u8ff0",
      "gender_text_zh",
      "gender_cn",
      "sex_cn",
      "gender_chinese"
    ],
    "negativeHeaderExamples": [
      "gender_code",
      "\u6027\u522b\u4ee3\u7801",
      "gender",
      "sex",
      "gender_en",
      "customer_gender",
      "sex_code",
      "gender_numeric"
    ],
    "explanation": "GENDER.TEXT_ZH identifies Chinese-language gender values commonly found in demographic datasets, ensuring matching only to standard Chinese terms (e.g., \u7537, \u5973, \u7537\u6027, \u5973\u6027) rather than codes or English abbreviations. Use this type to normalize and validate gender fields stored as Chinese text while avoiding false matches to mixed-language or coded representations.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:23.671294"
  },
  {
    "resultType": "generated",
    "semanticType": "HASH.SHA1_HEX",
    "description": "This type captures SHA-1 hash digest values used for file integrity checking, digital signatures, and data verification purposes. The values represent 160-bit hash outputs encoded as hexadecimal strings using lowercase letters and digits without spaces or separators.",
    "pluginType": "regex",
    "regexPattern": "\\b[a-f0-9]{40}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 99,
    "priority": 4330,
    "headerPatterns": [
      {
        "regExp": "(?i).*sha[-_ ]?1.*hash.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "sha1_hash"
        ],
        "negativeExamples": [
          "file_hash"
        ]
      },
      {
        "regExp": "(?i).*sha[-_ ]?1.*digest.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "sha-1 digest"
        ],
        "negativeExamples": [
          "file_digest"
        ]
      },
      {
        "regExp": "(?i).*(sha[-_ ]?1|sha1sum).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "sha1sum"
        ],
        "negativeExamples": [
          "sha256sum"
        ]
      },
      {
        "regExp": "(?i).*(checksum|digest).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "file_checksum"
        ],
        "negativeExamples": [
          "file_token"
        ]
      },
      {
        "regExp": "(?i).*hash.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "hash"
        ],
        "negativeExamples": [
          "token"
        ]
      }
    ],
    "positiveContentExamples": [
      "da39a3ee5e6b4b0d3255bfef95601890afd80709",
      "0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33",
      "a9993e364706816aba3e25717850c26c9cd0d89d",
      "2fd4e1c67a2d28fced849ee1bb76e7391b93eb12",
      "3f786850e387550fdab836ed7e6dc881de23001b",
      "7c222fb2927d828af22f592134e8932480637c0d",
      "356a192b7913b04c54574d18c28d46e6395428ab",
      "1b6453892473a467d07372d45eb05abc2031647a"
    ],
    "negativeContentExamples": [
      "DA39A3EE5E6B4B0D3255BFEF95601890AFD80709",
      "da39a3ee5e6b4b0d3255bfef95601890afd8070",
      "da39a3ee5e6b4b0d3255bfef95601890afd807090",
      "g539a3ee5e6b4b0d3255bfef95601890afd80709",
      "Da39a3ee5e6b4b0d3255bfef95601890afd80709",
      "da39a3ee5e6b4b0d-3255bfef95601890afd80709",
      "da39a3ee5e6b4b0d 3255bfef95601890afd80709",
      "5d41402abc4b2a76b9719d911017c592"
    ],
    "positiveHeaderExamples": [
      "sha1_hash",
      "sha-1 digest",
      "sha1sum",
      "sha1",
      "file_checksum",
      "message_digest",
      "hash",
      "sha1_hash_value"
    ],
    "negativeHeaderExamples": [
      "md5sum",
      "sha256sum",
      "crc32",
      "uuid",
      "signature",
      "sha-256",
      "encryption_key",
      "file_token"
    ],
    "explanation": "Identifies SHA-1 digests encoded as 40-character lowercase hexadecimal strings. Suitable for classifying file integrity fields and cryptographic checksums where the content is strictly lowercase hex without separators or whitespace. Header detection prioritizes explicit SHA-1 indicators, then common checksum terms, and finally the primitive 'hash' fallback with a conservative high threshold.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:24.971943"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.INDIVIDUAL_NUMBER_JA",
    "description": "This type identifies the Japanese Individual Number system identifier, commonly called My Number, assigned to residents for social security and taxation purposes. The number consists of exactly twelve numerical digits without alphabetic characters or special symbols.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{12}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4410,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bjapan\\b.*\\bindividual\\b.*\\bnumber\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "japan individual number"
        ],
        "negativeExamples": [
          "japan individual code"
        ]
      },
      {
        "regExp": "(?i).*\\bindividual\\b.*\\bnumber\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "individual number"
        ],
        "negativeExamples": [
          "individual code"
        ]
      },
      {
        "regExp": "(?i).*\\bmy\\b.*\\bnumber\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "my number"
        ],
        "negativeExamples": [
          "monthly number"
        ]
      },
      {
        "regExp": "(?i).*\\bmynumber\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mynumber"
        ],
        "negativeExamples": [
          "my number"
        ]
      },
      {
        "regExp": "(?i).*\\bkojin\\b.*\\bbango\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "kojin bango"
        ],
        "negativeExamples": [
          "kojin code"
        ]
      },
      {
        "regExp": "(?i).*\\bnumber\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "123456789012",
      "907856341209",
      "000123456789",
      "582930174625",
      "731204859603",
      "219876543210",
      "468012345678"
    ],
    "negativeContentExamples": [
      "12345678901",
      "1234567890123",
      "1234-5678-9012",
      "1234 5678 9012",
      "12345678901A",
      "A123456789012",
      "1234567890",
      "00123456789012"
    ],
    "positiveHeaderExamples": [
      "japan individual number",
      "my number",
      "mynumber",
      "kojin bango",
      "jp individual number",
      "resident individual number jp",
      "individual number",
      "jp my number"
    ],
    "negativeHeaderExamples": [
      "account number",
      "customer number",
      "social security number",
      "national id",
      "jp resident id",
      "my id",
      "individual code",
      "taxpayer identification"
    ],
    "explanation": "Japanese Individual Number (My Number) is a national identifier consisting of exactly 12 digits with no letters, spaces, or punctuation. This type targets fields that store that identifier in its canonical numeric-only format. It is useful for compliance-related datasets in social security and taxation contexts and helps distinguish strictly 12-digit identifiers from other personal numbers that allow separators or different lengths.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:26.426649"
  },
  {
    "resultType": "generated",
    "semanticType": "INDUSTRY_CODE.NAICS",
    "description": "This type represents NAICS codes, which are hierarchical industry classification numbers used for statistical and regulatory purposes across North America. The code consists of exactly six digits where each digit level provides increasingly specific industry categorization from sector to industry detail.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 4510,
    "headerPatterns": [
      {
        "regExp": "(?i).*naics.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "naics_code"
        ],
        "negativeExamples": [
          "naics_description"
        ]
      },
      {
        "regExp": "(?i).*primary.*naics.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "primary_naics"
        ],
        "negativeExamples": [
          "primary_industry"
        ]
      },
      {
        "regExp": "(?i).*industry.*classification.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "industry_classification_code"
        ],
        "negativeExamples": [
          "industry_classification"
        ]
      },
      {
        "regExp": "(?i).*naics.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "naics6"
        ],
        "negativeExamples": [
          "sic"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "111110",
      "236115",
      "522110",
      "445120",
      "541511",
      "311611",
      "721110",
      "561320"
    ],
    "negativeContentExamples": [
      "12345",
      "1234567",
      "12-3456",
      "123 456",
      "12345A",
      "5415.11",
      "541_511",
      "54151-"
    ],
    "positiveHeaderExamples": [
      "naics_code",
      "primary_naics",
      "industry_classification_code",
      "naics6",
      "naics sector code",
      "naics classification code",
      "primary_naics_code",
      "naics industry code"
    ],
    "negativeHeaderExamples": [
      "naics_description",
      "industry_name",
      "sic_code",
      "hs_code",
      "tax_code",
      "postal_code",
      "classification",
      "product_code"
    ],
    "explanation": "NAICS codes are six-digit numeric identifiers used to classify business establishments by industry across North America. This semantic type detects values that are exactly six digits to capture NAICS code structure, and header patterns focus on NAICS-specific column naming conventions to reduce ambiguity. It is useful for analytics, regulatory reporting, and data integration tasks that rely on standardized industry classification.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:26.431059"
  },
  {
    "resultType": "generated",
    "semanticType": "CRYPTOCURRENCY.TEXT_EN",
    "description": "This type captures the complete names of digital currencies used in blockchain-based financial systems and cryptocurrency trading. The values represent established cryptocurrency names using proper capitalization and standard terminology without symbols, abbreviations, or ticker codes.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z][a-z]{2,}(( (and|of|the|for|in|on) [A-Z][a-z]{2,})|( [A-Z][a-z]{2,})){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4150,
    "headerPatterns": [
      {
        "regExp": "(?i).*crypto.*currency.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cryptocurrency name"
        ],
        "negativeExamples": [
          "cryptocurrency code"
        ]
      },
      {
        "regExp": "(?i).*digital.*currency.*name.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "digital currency name"
        ],
        "negativeExamples": [
          "digital currency code"
        ]
      },
      {
        "regExp": "(?i).*crypto.*asset.*name.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "crypto asset name"
        ],
        "negativeExamples": [
          "crypto asset id"
        ]
      },
      {
        "regExp": "(?i).*(coin|token).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "token name"
        ],
        "negativeExamples": [
          "token symbol"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Bitcoin",
      "Ethereum",
      "Binance Coin",
      "Tether",
      "Cardano",
      "Solana",
      "Bitcoin Cash",
      "Shiba Inu"
    ],
    "negativeContentExamples": [
      "bitcoin",
      "BTC",
      "Ethereum2",
      "Binance Coin 2",
      "Ethereum-classic",
      "StellarLumens",
      "USD Coin",
      "Ripple (XRP)"
    ],
    "positiveHeaderExamples": [
      "cryptocurrency name",
      "digital currency name",
      "crypto asset name",
      "coin name",
      "token name",
      "blockchain currency name",
      "crypto coin name",
      "cryptocurrency full name"
    ],
    "negativeHeaderExamples": [
      "cryptocurrency code",
      "crypto symbol",
      "currency ticker",
      "token symbol",
      "coin ticker",
      "cryptocurrency id",
      "customer name",
      "wallet name"
    ],
    "explanation": "Identifies full, human-readable names of cryptocurrencies (e.g., Bitcoin, Ethereum) written in proper title casing without symbols, numbers, or ticker codes. Useful for distinguishing descriptive currency names from their symbols or codes in trading, compliance, and catalog metadata.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:27.423791"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.NPI_US",
    "description": "This type identifies the National Provider Identifier, a standardized healthcare provider identifier mandated for use in US healthcare transactions. The number consists of exactly ten numerical digits with no alphabetic characters, spaces, or formatting symbols.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{10}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4440,
    "headerPatterns": [
      {
        "regExp": "(?i).*national.*provider.*identifier.*",
        "confidence": 98,
        "mandatory": false,
        "positiveExamples": [
          "national_provider_identifier"
        ],
        "negativeExamples": [
          "provider_license_number"
        ]
      },
      {
        "regExp": "(?i).*npi.*",
        "confidence": 97,
        "mandatory": false,
        "positiveExamples": [
          "provider_npi"
        ],
        "negativeExamples": [
          "payer_code"
        ]
      },
      {
        "regExp": "(?i).*provider.*identifier.*",
        "confidence": 95,
        "mandatory": false,
        "positiveExamples": [
          "rendering_provider_identifier"
        ],
        "negativeExamples": [
          "provider_taxonomy_code"
        ]
      },
      {
        "regExp": "(?i).*provider.*id.*",
        "confidence": 93,
        "mandatory": false,
        "positiveExamples": [
          "billing_provider_id"
        ],
        "negativeExamples": [
          "provider_license_number"
        ]
      },
      {
        "regExp": "(?i).*id.*",
        "confidence": 90,
        "mandatory": false,
        "positiveExamples": [
          "npi_id"
        ],
        "negativeExamples": [
          "account_number"
        ]
      }
    ],
    "positiveContentExamples": [
      "1234567893",
      "1987654321",
      "5678901234",
      "0001234567",
      "3141592653",
      "2468135790",
      "1010101010",
      "9090909090"
    ],
    "negativeContentExamples": [
      "123456789",
      "12345678901",
      "123 456 7890",
      "123-456-7890",
      "A123456789",
      "123456789O",
      "12345678_90",
      "1234567890A"
    ],
    "positiveHeaderExamples": [
      "npi",
      "provider_npi",
      "national_provider_identifier",
      "billing_provider_npi",
      "rendering_provider_identifier",
      "npi_id",
      "billing_provider_id",
      "rendering_provider_id"
    ],
    "negativeHeaderExamples": [
      "provider_license_number",
      "provider_taxonomy_code",
      "customer_number",
      "phone_number",
      "organization_ncpdp",
      "medicare_ptan",
      "payer_code",
      "billing_code"
    ],
    "explanation": "IDENTITY.NPI_US captures ten-digit National Provider Identifier values used across US healthcare for uniquely identifying providers in claims, eligibility, remittance, and other HIPAA-standard transactions. It strictly matches tokens that are exactly ten digits with no separators, spaces, or letters. Header cues prioritize explicit mentions of NPI and the full phrase 'national provider identifier' to reduce collisions with generic identifiers.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:27.547686"
  },
  {
    "resultType": "generated",
    "semanticType": "GENDER.TEXT_<LANGUAGE>",
    "description": "Textual representations of a person's gender in a specific natural language, including common labels and self-described terms (e.g., MALE, FEMALE, NON-BINARY). Intended for free-text or standardized label fields rather than compact codes.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "MALE",
      "FEMALE",
      "MAN",
      "WOMAN",
      "NON-BINARY",
      "NONBINARY",
      "INTERSEX",
      "TRANSGENDER",
      "OTHER",
      "UNKNOWN",
      "UNSPECIFIED",
      "PREFER NOT TO SAY",
      "DECLINE TO STATE"
    ],
    "backout": "^[A-Z][A-Z -]{1,29}$",
    "confidenceThreshold": 95,
    "priority": 4290,
    "headerPatterns": [
      {
        "regExp": "(?i).*gender.*(text|label|description).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gender_text"
        ],
        "negativeExamples": [
          "gender_code"
        ]
      },
      {
        "regExp": "(?i).*(preferred|self|self[- ]reported).*gender.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "self_reported_gender"
        ],
        "negativeExamples": [
          "customer_gender"
        ]
      },
      {
        "regExp": "(?i).*gender.*identity.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gender_identity"
        ],
        "negativeExamples": [
          "gender_label"
        ]
      },
      {
        "regExp": "(?i).*(gndr|sex).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "sex"
        ],
        "negativeExamples": [
          "gender"
        ]
      },
      {
        "regExp": "(?i).*gender.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gender"
        ],
        "negativeExamples": [
          "sex"
        ]
      }
    ],
    "positiveContentExamples": [
      "MALE",
      "FEMALE",
      "WOMAN",
      "MAN",
      "NON-BINARY",
      "INTERSEX",
      "TRANSGENDER",
      "PREFER NOT TO SAY"
    ],
    "negativeContentExamples": [
      "MALES",
      "FEMALE (BIRTH)",
      "M",
      "F",
      "NON BINARY",
      "TRANS GENDER",
      "UNK",
      "GENDER FLUID"
    ],
    "positiveHeaderExamples": [
      "gender_text",
      "gender_label",
      "gender_description",
      "preferred_gender",
      "self_reported_gender",
      "gender_identity",
      "gndr",
      "sex"
    ],
    "negativeHeaderExamples": [
      "gender_code",
      "sex_code",
      "birth_sex_code",
      "customer_name",
      "age",
      "language",
      "timezone",
      "identity_number"
    ],
    "explanation": "This semantic type targets columns that contain textual gender labels in a specific language. It is suitable for datasets where gender is stored as human-readable terms rather than compact codes. The list captures common standardized labels and typical dataset phrasings, while the backout pattern provides a bounded, conservative fallback shape to avoid overmatching.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:32.348058"
  },
  {
    "resultType": "generated",
    "semanticType": "GUID",
    "description": "A GUID (Globally Unique Identifier) formatted as 32 lowercase hexadecimal characters in five groups separated by hyphens: 8-4-4-4-12. Only digits 0-9 and letters a-f are allowed, with no spaces or alternate punctuation, and all letters must be lowercase.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4320,
    "headerPatterns": [
      {
        "regExp": "(?i).*(user|order|record|session)[_\\s-]*guid.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "user_guid"
        ],
        "negativeExamples": [
          "user_id"
        ]
      },
      {
        "regExp": "(?i).*(primary|master)[_\\s-]*guid.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "primary_guid"
        ],
        "negativeExamples": [
          "primary_id"
        ]
      },
      {
        "regExp": "(?i).*guid[_\\s-]*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "guid_id"
        ],
        "negativeExamples": [
          "id_guid"
        ]
      },
      {
        "regExp": "(?i).*guid.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "guid"
        ],
        "negativeExamples": [
          "id"
        ]
      },
      {
        "regExp": "(?i).*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "id"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "123e4567-e89b-12d3-a456-426614174000",
      "9f1b2c3d-4e5f-6789-abcd-0123456789ab",
      "a0b1c2d3-e4f5-6789-ab01-23456789cdef",
      "00000000-0000-0000-0000-000000000000",
      "ffffffff-ffff-ffff-ffff-ffffffffffff",
      "1a2b3c4d-5e6f-7a8b-9c0d-1e2f3a4b5c6d",
      "abcd1234-ef00-1234-abcd-ef0123456789",
      "deadbeef-cafe-babe-face-0123456789ab"
    ],
    "negativeContentExamples": [
      "123E4567-e89b-12d3-a456-426614174000",
      "123e4567e89b12d3a456426614174000",
      "{123e4567-e89b-12d3-a456-426614174000}",
      "123e4567-e89b-12d3-a456-42661417400",
      "123e4567-e89b-12d3-a456-426614174000-",
      "123e4567-e89b-12d3-a4567-26614174000",
      "123g4567-e89b-12d3-a456-426614174000",
      "123e4567-e89b-12d3-a456-4266141740000"
    ],
    "positiveHeaderExamples": [
      "user_guid",
      "record_guid",
      "primary_guid",
      "session_guid",
      "customer_guid",
      "guid",
      "system_id_guid",
      "global_guid"
    ],
    "negativeHeaderExamples": [
      "user_id",
      "checksum",
      "hash",
      "transaction_number",
      "postal_code",
      "email",
      "api_key",
      "invoice_code"
    ],
    "explanation": "This semantic type targets GUIDs in canonical hyphenated form with strictly lowercase hexadecimal characters and fixed group lengths 8-4-4-4-12. It is suited for datasets where GUIDs are stored as text fields and helps validate and classify identifiers that must conform to this exact formatting.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:33.672916"
  },
  {
    "resultType": "generated",
    "semanticType": "GENDER.TEXT_JA",
    "description": "This type captures gender designations as they are expressed in Japanese language for demographic data collection and personal identification purposes. The values represent standard gender terminology using Japanese characters and linguistic conventions without abbreviations or English translations.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "\u7537\u6027",
      "\u5973\u6027",
      "\u7537",
      "\u5973",
      "\u7537\u5b50",
      "\u5973\u5b50",
      "\u4e2d\u6027",
      "\u4e21\u6027",
      "X\u30b8\u30a7\u30f3\u30c0\u30fc",
      "\u30c8\u30e9\u30f3\u30b9\u30b8\u30a7\u30f3\u30c0\u30fc",
      "\u30ce\u30f3\u30d0\u30a4\u30ca\u30ea\u30fc",
      "\u305d\u306e\u4ed6",
      "\u4e0d\u660e",
      "\u4e0d\u8a73",
      "\u7121\u56de\u7b54",
      "\u56de\u7b54\u306a\u3057",
      "\u3069\u3061\u3089\u3067\u3082\u306a\u3044",
      "\u6027\u5225\u4e0d\u660e",
      "\u672a\u8a2d\u5b9a",
      "\u4e0d\u9078\u629e"
    ],
    "backout": "^[A-Za-z\\u3040-\\u309F\\u30A0-\\u30FF\\u4E00-\\u9FFF\u30fc\u30fb]{1,12}$",
    "confidenceThreshold": 97,
    "priority": 4300,
    "headerPatterns": [
      {
        "regExp": "(?i).*gender.*(text|label).*(ja|jp).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gender_text_ja"
        ],
        "negativeExamples": [
          "gender_code"
        ]
      },
      {
        "regExp": "(?i).*(\u6027\u5225|\u30b8\u30a7\u30f3\u30c0\u30fc).*(\u30c6\u30ad\u30b9\u30c8|\u6587\u5b57\u5217).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "\u6027\u5225\u30c6\u30ad\u30b9\u30c8"
        ],
        "negativeExamples": [
          "\u6027\u5225\u30b3\u30fc\u30c9"
        ]
      },
      {
        "regExp": "(?i).*(gender|sex).*(desc|value|text).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "sex_value"
        ],
        "negativeExamples": [
          "sex_code"
        ]
      },
      {
        "regExp": "(?i).*(gndr|sx|seibetsu).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "gndr_txt"
        ],
        "negativeExamples": [
          "gender_id"
        ]
      },
      {
        "regExp": "(?i).*(gender|sex|\u6027\u5225|\u30b8\u30a7\u30f3\u30c0\u30fc).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "\u6027\u5225"
        ],
        "negativeExamples": [
          "\u5e74\u9f62"
        ]
      }
    ],
    "positiveContentExamples": [
      "\u7537\u6027",
      "\u5973\u6027",
      "\u7537",
      "\u5973",
      "\u4e2d\u6027",
      "\u4e21\u6027",
      "X\u30b8\u30a7\u30f3\u30c0\u30fc",
      "\u3069\u3061\u3089\u3067\u3082\u306a\u3044"
    ],
    "negativeContentExamples": [
      "\u7537\u60271",
      "\u5973 \u6027",
      "\u7537-\u5973",
      "\u7537\u5b50\u751f\u5f92",
      "\u6027\u5225: \u7537\u6027",
      "male",
      "F",
      "\u30b8\u30a7\u30f3\u30c0\u30fcX"
    ],
    "positiveHeaderExamples": [
      "gender_text_ja",
      "\u6027\u5225\u30c6\u30ad\u30b9\u30c8",
      "\u6027\u5225_\u6587\u5b57\u5217",
      "gender_label_jp",
      "sex_value",
      "gndr_txt",
      "\u6027\u5225",
      "\u30b8\u30a7\u30f3\u30c0\u30fc"
    ],
    "negativeHeaderExamples": [
      "gender_code",
      "\u6027\u5225\u30b3\u30fc\u30c9",
      "sex_cd",
      "gender_id",
      "\u5e74\u9f62",
      "\u56fd\u7c4d",
      "\u540d\u524d",
      "\u751f\u5e74\u6708\u65e5"
    ],
    "explanation": "This semantic type identifies Japanese-language gender values commonly used in forms, surveys, and identity records. It is implemented as a curated list to ensure precision and avoid ambiguity, with a broader backout pattern for safe fallback validation. Header patterns target explicit Japanese and English labels indicating Japanese text fields for gender, progressing from specific to primitive terms.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:33.697425"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTIFIER",
    "description": "This type represents a unique alphanumeric code assigned to individual records, entities, or objects for identification purposes. The identifier can contain letters, numbers, and common symbols but must be unique within its context.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Za-z0-9]*[A-Za-z][A-Za-z0-9]*([\\-_.\\/][A-Za-z0-9]+){0,4})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4360,
    "headerPatterns": [
      {
        "regExp": "(?i).*(record|entity|object)[ _-]*id(entifier)?.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "record_identifier"
        ],
        "negativeExamples": [
          "record_date"
        ]
      },
      {
        "regExp": "(?i).*(customer|user|account|order)[ _-]*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_id"
        ],
        "negativeExamples": [
          "user_name"
        ]
      },
      {
        "regExp": "(?i).*(unique|global)[ _-]*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "unique_id"
        ],
        "negativeExamples": [
          "global_code"
        ]
      },
      {
        "regExp": "(?i).*(ref[_-]*id|guid|uid).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ref_id"
        ],
        "negativeExamples": [
          "reference_text"
        ]
      },
      {
        "regExp": "(?i).*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "id"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "A12B-34",
      "USR_0001",
      "9ZK/204A",
      "REF.2023A",
      "OBJ-77-XY",
      "ACC12345",
      "X-1-2Z-3",
      "AB12_CD34"
    ],
    "negativeContentExamples": [
      "123456",
      "-ABC123",
      "ABC_",
      "REF#123",
      "2023/07/15",
      "ID 123",
      "A..123",
      "_ID123"
    ],
    "positiveHeaderExamples": [
      "record_identifier",
      "entity_id",
      "object_id",
      "customer_id",
      "global_identifier",
      "uid",
      "ref_id",
      "unique_id"
    ],
    "negativeHeaderExamples": [
      "record_date",
      "customer_code",
      "user_name",
      "order_number",
      "reference_text",
      "account_code",
      "transaction_date",
      "email_address"
    ],
    "explanation": "Generic identifier fields often contain alphanumeric characters and may include separators such as hyphen, underscore, slash, or dot. This type aims to recognize such IDs while avoiding plain words and pure numbers to reduce ambiguity with names and numeric fields. Common use cases include record_id, entity_id, and reference identifiers across datasets.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:33.718129"
  },
  {
    "resultType": "generated",
    "semanticType": "HONORIFIC_EN",
    "description": "This type captures formal titles and prefixes used before personal names in English language correspondence and formal documentation. The values represent established honorific terms including punctuation when applicable, following standard English linguistic and social conventions for respectful address.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "MR.",
      "MRS.",
      "MS.",
      "MISS",
      "DR.",
      "PROF.",
      "SIR",
      "DAME",
      "REV.",
      "FR.",
      "LADY",
      "LORD",
      "MX.",
      "CAPT.",
      "COL.",
      "MAJ.",
      "GEN.",
      "HON.",
      "SEN.",
      "GOV.",
      "SGT.",
      "LT.",
      "CMDR.",
      "AMB."
    ],
    "backout": "^[A-Za-z]{2,5}\\.?$",
    "confidenceThreshold": 98,
    "priority": 4350,
    "headerPatterns": [
      {
        "regExp": "(?i).*honorific.*prefix.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "honorific_prefix"
        ],
        "negativeExamples": [
          "honorific_suffix"
        ]
      },
      {
        "regExp": "(?i).*(courtesy|formal).*title.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "courtesy_title"
        ],
        "negativeExamples": [
          "job_title"
        ]
      },
      {
        "regExp": "(?i).*(name.*prefix|prefix.*name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_name_prefix"
        ],
        "negativeExamples": [
          "last_name"
        ]
      },
      {
        "regExp": "(?i).*salutation.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "contact_salutation"
        ],
        "negativeExamples": [
          "signature"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "title"
        ]
      }
    ],
    "positiveContentExamples": [
      "Mr.",
      "Mrs.",
      "Ms.",
      "Miss",
      "Dr.",
      "Prof.",
      "Sir",
      "Rev."
    ],
    "negativeContentExamples": [
      "Mr",
      "Mrs",
      "Mx",
      "Prof",
      "Sir.",
      "Lady.",
      "Doctor",
      "Mme."
    ],
    "positiveHeaderExamples": [
      "honorific_prefix",
      "courtesy_title",
      "salutation",
      "name_prefix",
      "formal_title",
      "contact_salutation",
      "person_honorific",
      "customer_name_prefix"
    ],
    "negativeHeaderExamples": [
      "job_title",
      "company_name",
      "last_name",
      "file_name",
      "position_title",
      "suffix",
      "username",
      "middle_name"
    ],
    "explanation": "Honorifics are short, standardized titles placed before a personal name to convey respect, rank, or role in formal English correspondence (e.g., Mr., Ms., Dr., Prof., Sir, Rev.). This semantic type helps identify and validate such prefixes, supporting tasks like parsing names, formatting salutations, and normalizing contact data across systems.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:35.863818"
  },
  {
    "resultType": "generated",
    "semanticType": "EPOCH.SECONDS",
    "description": "This type captures Unix timestamp values expressed in seconds precision for standard time measurement and system operations. The values represent time as an integer count of seconds from the Unix epoch without any formatting, separators, or textual date components.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{9,10}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4240,
    "headerPatterns": [
      {
        "regExp": "(?i).*epoch.*seconds.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "epoch_seconds"
        ],
        "negativeExamples": [
          "epoch_milliseconds"
        ]
      },
      {
        "regExp": "(?i).*unix.*epoch.*seconds.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "unix_epoch_seconds"
        ],
        "negativeExamples": [
          "unix_epoch_ms"
        ]
      },
      {
        "regExp": "(?i).*(timestamp|time).*_s.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "timestamp_s"
        ],
        "negativeExamples": [
          "timestamp_ms"
        ]
      },
      {
        "regExp": "(?i).*(epoch|unix).*time.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "epoch_time"
        ],
        "negativeExamples": [
          "runtime"
        ]
      },
      {
        "regExp": "(?i).*date.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "date"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "1538352000",
      "1609459200",
      "1451606400",
      "1700000000",
      "1234567890",
      "2147483647",
      "946684800",
      "978307200"
    ],
    "negativeContentExamples": [
      "1538352000000",
      "1,538,352,000",
      "1538352000.0",
      "01538352000",
      "-1538352000",
      "17000000000",
      "1538 352000",
      "1700000000Z"
    ],
    "positiveHeaderExamples": [
      "epoch_seconds",
      "unix_time_seconds",
      "timestamp_s",
      "epoch_sec",
      "unix_epoch_seconds",
      "epoch_time",
      "ts_s"
    ],
    "negativeHeaderExamples": [
      "timestamp_ms",
      "date",
      "created_at",
      "milliseconds",
      "unix_millis",
      "timecode",
      "id_number"
    ],
    "explanation": "Epoch seconds are numeric timestamps representing the number of seconds elapsed since 1970-01-01 00:00:00 UTC. This type targets raw integer seconds (9\u201310 digits), excluding formatted dates, decimals, signs, separators, or millisecond-level values. It is useful for normalizing timestamps, converting to human-readable dates, and filtering out millisecond-based or string-formatted time fields.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:37.345140"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.NHS_UK",
    "description": "This type represents the NHS number, a patient identifier used throughout the UK healthcare system for medical record tracking and service delivery. The number consists of ten digits and may be displayed with spaces for readability but contains only numerical characters.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{3} \\d{3} \\d{4}\\b|\\b\\d{10}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4420,
    "headerPatterns": [
      {
        "regExp": "(?i).*(national.?health.?service|nhs).*(number|no|num).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "patient_nhs_number"
        ],
        "negativeExamples": [
          "patient_number"
        ]
      },
      {
        "regExp": "(?i).*nhs.*id.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "nhs_id"
        ],
        "negativeExamples": [
          "employee_id"
        ]
      },
      {
        "regExp": "(?i).*nhs.*no.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nhs_no"
        ],
        "negativeExamples": [
          "policy_no"
        ]
      },
      {
        "regExp": "(?i).*nhs.*num.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "nhsnum"
        ],
        "negativeExamples": [
          "account_num"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "943 476 5919",
      "1234567890",
      "001 234 5678",
      "9876543210",
      "550 123 0049",
      "219 876 3450",
      "730 000 1123",
      "4445556666"
    ],
    "negativeContentExamples": [
      "123 456 789",
      "01234567890",
      "123-456-7890",
      "1234 56 7890",
      "123 4567 890",
      "123456789O",
      "123 456 789O",
      "123  456 7890"
    ],
    "positiveHeaderExamples": [
      "nhs_number",
      "nhs no",
      "patient_nhs_number",
      "nhs_id",
      "national_health_service_number",
      "nhsnum",
      "patient nhs number",
      "nhs patient number"
    ],
    "negativeHeaderExamples": [
      "patient_number",
      "insurance_number",
      "medical_record_number",
      "nhs_trust",
      "national_insurance_number",
      "employee_id",
      "account_number",
      "hospital_number"
    ],
    "explanation": "IDENTITY.NHS_UK detects UK NHS patient identifiers represented as exactly 10 digits, either ungrouped or spaced as three-three-four. The value regex enforces numeric-only content and allows a single space between groups, using word boundaries to avoid partial matches. Header patterns prioritize explicit NHS references and common abbreviations, with a final primitive pattern for generic 'number' fields to support weakly labeled schemas. Use this type to locate and validate NHS numbers in patient or healthcare datasets.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:37.439174"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.ISIN",
    "description": "This identifier begins with a two-letter country code followed by a nine-character national security identifier and concludes with a single check digit. The code uses uppercase letters and numbers without spaces, hyphens, or other punctuation marks.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2}[A-Z0-9]{9}\\d\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3880,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bisin\\b.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "isin_code"
        ],
        "negativeExamples": [
          "cusip_code"
        ]
      },
      {
        "regExp": "(?i).*\\bisin\\b.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "isin_number"
        ],
        "negativeExamples": [
          "security_number"
        ]
      },
      {
        "regExp": "(?i).*\\bsecurity\\b.*\\bidentifier\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "security_identifier"
        ],
        "negativeExamples": [
          "document_identifier"
        ]
      },
      {
        "regExp": "(?i).*\\bisin\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "isin"
        ],
        "negativeExamples": [
          "issue_number"
        ]
      },
      {
        "regExp": "(?i).*\\bsecurity\\b.*id.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "security_id"
        ],
        "negativeExamples": [
          "session_id"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 85,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "US1234567890",
      "DEABCDE12345",
      "FR0A1B2C34Z7",
      "JP9XYZ1234Q6",
      "CAABC12DEF38",
      "AU0001XYZT25",
      "NL9ABCD123E4",
      "ESABCDEFGH12"
    ],
    "negativeContentExamples": [
      "us1234567890",
      "US123456789A",
      "U11234567890",
      "USA1234567892",
      "US12345 67890",
      "US123456789",
      "US-1234567890",
      "DEABCDE123456"
    ],
    "positiveHeaderExamples": [
      "isin_code",
      "isin_number",
      "isin",
      "security_identifier",
      "security_id",
      "global_isin_code",
      "primary_isin_number",
      "instrument_isin"
    ],
    "negativeHeaderExamples": [
      "security_number",
      "customer_identifier",
      "instrument_id",
      "issue_number",
      "document_id",
      "product_key",
      "session_id",
      "account_number"
    ],
    "explanation": "Identifies International Securities Identification Numbers (ISIN) based on their structural format: two-letter country code, nine alphanumeric characters, and a trailing check digit. Enforces uppercase A\u2013Z and digits only with no separators. This pattern validates format only; any algorithmic verification of the check digit (e.g., Luhn) should be handled by higher-level validation.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:37.715797"
  },
  {
    "resultType": "generated",
    "semanticType": "IMEI",
    "description": "Identifies the International Mobile Equipment Identity (IMEI), a globally unique identifier for mobile communication devices. IMEIs are composed of exactly 15 digits encoding manufacturer/model and a device-specific sequence, typically including a Luhn check digit.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{15}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4500,
    "headerPatterns": [
      {
        "regExp": "(?i).*device.*imei.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "device_imei_number"
        ],
        "negativeExamples": [
          "device_serial_number"
        ]
      },
      {
        "regExp": "(?i).*equipment.*imei.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "equipment_imei"
        ],
        "negativeExamples": [
          "equipment_id"
        ]
      },
      {
        "regExp": "(?i).*imei.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "imei_id"
        ],
        "negativeExamples": [
          "device_id"
        ]
      },
      {
        "regExp": "(?i).*imei.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "imei"
        ],
        "negativeExamples": [
          "imsi"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "number"
        ]
      }
    ],
    "positiveContentExamples": [
      "490154203237518",
      "356938035643809",
      "861181041234567",
      "359876054321098",
      "352099001761481",
      "864502030123456",
      "355031051234567",
      "353918057654321"
    ],
    "negativeContentExamples": [
      "35693803564380",
      "3569380356438097",
      "35693A035643809",
      "35 6938035643809",
      "35-693803-564380-9",
      "35693803564380X",
      "3569380356438",
      "3569380356438090"
    ],
    "positiveHeaderExamples": [
      "imei",
      "device_imei",
      "imei_number",
      "mobile_imei",
      "handset_imei",
      "phone_imei",
      "equipment_imei_code",
      "imei_id"
    ],
    "negativeHeaderExamples": [
      "meid",
      "imsi",
      "serial_number",
      "device_id",
      "iccid",
      "mac_address",
      "meid_number",
      "subscriber_id"
    ],
    "explanation": "This semantic type targets 15-digit IMEI values used to identify mobile devices. The regex strictly enforces a 15-digit token with word boundaries; it does not attempt checksum validation, which should be handled by higher-level logic if needed. Header patterns prioritize explicit mentions of IMEI in device-related contexts, with a final primitive catch-all for 'code' to align with generic naming. Use cases include cataloging device inventories, linking device records, and validating mobile hardware identifiers while avoiding confusion with IMSI/MEID or other identifiers.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:38.157054"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.EIN_US",
    "description": "This type captures the Employer Identification Number (EIN), a unique 9-digit federal tax ID assigned by the Internal Revenue Service to US businesses. The number is formatted with a hyphen separating the first two digits from the remaining seven digits.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{2}-\\d{7}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4400,
    "headerPatterns": [
      {
        "regExp": "(?i).*employer.*identification.*number.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "employer identification number"
        ],
        "negativeExamples": [
          "employee identification number"
        ]
      },
      {
        "regExp": "(?i).*federal.*tax.*id.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "federal tax id"
        ],
        "negativeExamples": [
          "state tax id"
        ]
      },
      {
        "regExp": "(?i).*\\bfein\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "FEIN"
        ],
        "negativeExamples": [
          "rein"
        ]
      },
      {
        "regExp": "(?i).*\\bein\\b.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "IRS EIN"
        ],
        "negativeExamples": [
          "einvoice"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "business number"
        ],
        "negativeExamples": [
          "account id"
        ]
      }
    ],
    "positiveContentExamples": [
      "12-3456789",
      "00-1234567",
      "98-7654321",
      "27-0000001",
      "53-2468135",
      "94-5555555",
      "61-1029384",
      "13-8675309"
    ],
    "negativeContentExamples": [
      "123-45-6789",
      "12 3456789",
      "123456789",
      "12-345678",
      "12-34567890",
      "1-23456789",
      "AB-1234567",
      "12\u20133456789"
    ],
    "positiveHeaderExamples": [
      "employer identification number",
      "federal tax id",
      "FEIN",
      "EIN",
      "IRS EIN",
      "business tax id",
      "company ein",
      "tax id number"
    ],
    "negativeHeaderExamples": [
      "employee id number",
      "state tax id",
      "vat number",
      "ssn",
      "itin number",
      "taxpayer id",
      "company number",
      "account id"
    ],
    "explanation": "IDENTITY.EIN_US identifies US Employer Identification Numbers formatted as two digits, a hyphen, and seven digits. It is useful for validating and classifying business tax identifiers in financial, compliance, and onboarding datasets.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:38.462248"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.BSN_NL",
    "description": "This type identifies the BSN, a 9-digit citizen service number used in the Netherlands for government and administrative purposes. The number consists of exactly nine numerical digits without any letters, spaces, or special characters.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{9}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4380,
    "headerPatterns": [
      {
        "regExp": "(?i).*bsn.*number.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "bsn_number"
        ],
        "negativeExamples": [
          "bsn_status"
        ]
      },
      {
        "regExp": "(?i).*bsn.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "bsn"
        ],
        "negativeExamples": [
          "bsr"
        ]
      },
      {
        "regExp": "(?i).*burgerservicenummer.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "burgerservicenummer"
        ],
        "negativeExamples": [
          "burger_service_portal"
        ]
      },
      {
        "regExp": "(?i).*citizen.*service.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "citizen_service_number"
        ],
        "negativeExamples": [
          "customer_service_id"
        ]
      },
      {
        "regExp": "(?i).*national.*id.*number.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "national_id_number"
        ],
        "negativeExamples": [
          "national_tax_id"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "123456789",
      "001234567",
      "987654321",
      "246813579",
      "135792468",
      "560123789",
      "830275194",
      "410986235"
    ],
    "negativeContentExamples": [
      "12345678",
      "1234567890",
      "123 456 789",
      "123-456-789",
      "A23456789",
      "12345678A",
      "1234567.89",
      "12 3456789"
    ],
    "positiveHeaderExamples": [
      "bsn_number",
      "burgerservicenummer",
      "citizen_service_number",
      "national_id_number",
      "netherlands_bsn",
      "nl_bsn",
      "dutch_bsn",
      "bsn"
    ],
    "negativeHeaderExamples": [
      "citizen_service_id",
      "national_tax_id",
      "burgerservice_id",
      "customer_id",
      "passport_id",
      "phone",
      "user_identifier",
      "bsr_code"
    ],
    "explanation": "IDENTITY.BSN_NL identifies Dutch citizen service numbers that are exactly nine digits with no separators or letters. It uses a strict word-boundary 9-digit pattern to minimize false positives and is tuned for columns labeled with BSN-related terms or generic number headers when combined with numeric-only content.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:41.295819"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.SSN_CH",
    "description": "This type identifies the Swiss AHV number, a social security identifier that combines a country code prefix with individual identification digits. The number uses a standardized format with dots as separators between digit groups and includes validation checksums.",
    "pluginType": "regex",
    "regexPattern": "\\b756\\.[0-9]{4}\\.[0-9]{4}\\.[0-9]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4470,
    "headerPatterns": [
      {
        "regExp": "(?i).*swiss.*ahv.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Swiss AHV number"
        ],
        "negativeExamples": [
          "Swiss tax number"
        ]
      },
      {
        "regExp": "(?i).*swiss.*social.*security.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Swiss social security number"
        ],
        "negativeExamples": [
          "Social security number US"
        ]
      },
      {
        "regExp": "(?i).*swiss.*national.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Swiss national ID"
        ],
        "negativeExamples": [
          "National ID"
        ]
      },
      {
        "regExp": "(?i).*(ssn).*(swiss|ch).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SSN CH"
        ],
        "negativeExamples": [
          "SSN US"
        ]
      },
      {
        "regExp": "(?i).*ahv.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "AHV"
        ],
        "negativeExamples": [
          "ID number"
        ]
      }
    ],
    "positiveContentExamples": [
      "756.1234.5678.97",
      "756.0001.2345.83",
      "756.8420.1102.55",
      "756.7777.8888.12",
      "756.3012.4509.66",
      "756.6492.7310.04",
      "756.9876.5432.10",
      "756.1203.4506.39"
    ],
    "negativeContentExamples": [
      "756.1234.5678.9",
      "756.1234.5678.971",
      "756-1234-5678-97",
      "757.1234.5678.97",
      "756.12345.678.97",
      "756.1234.5678.9A",
      "756 1234 5678 97",
      "756.1234.5678"
    ],
    "positiveHeaderExamples": [
      "Swiss AHV number",
      "AHV ID",
      "Swiss SSN",
      "AHV number",
      "Swiss social security number",
      "CH AHV",
      "Swiss national ID (AHV)"
    ],
    "negativeHeaderExamples": [
      "Swiss tax number",
      "AHV status",
      "SSN US",
      "social security code",
      "Swiss ID card number",
      "employee number",
      "national identification"
    ],
    "explanation": "Swiss AHV numbers follow a strict dotted structure with a fixed country prefix 756 and three subsequent digit groups, the last of which is a checksum. This semantic type uses a precise pattern with word boundaries to minimize false positives while accommodating typical column headers seen in datasets. It is suited for validating and classifying Swiss social security identifiers presented in their standardized dotted format.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:41.684073"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.AADHAAR_IN",
    "description": "This type captures the Aadhaar number, which is a 12-digit numerical identifier assigned to Indian residents by UIDAI. The number consists of exactly twelve digits with no letters, special characters, or separators in its basic form.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{12}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4370,
    "headerPatterns": [
      {
        "regExp": "(?i).*aadhaar.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "aadhaar_number"
        ],
        "negativeExamples": [
          "passport_number"
        ]
      },
      {
        "regExp": "(?i).*aadhaar.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "aadhaar id"
        ],
        "negativeExamples": [
          "customer_id"
        ]
      },
      {
        "regExp": "(?i).*uidai.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "uidai_id"
        ],
        "negativeExamples": [
          "voter_id"
        ]
      },
      {
        "regExp": "(?i).*uid.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "uid"
        ],
        "negativeExamples": [
          "ssn"
        ]
      },
      {
        "regExp": "(?i).*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "id"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "234567890123",
      "987654321098",
      "512345678901",
      "102938475610",
      "764532198765",
      "345612789034",
      "609876543210",
      "870123456789"
    ],
    "negativeContentExamples": [
      "12345678901",
      "1234567890123",
      "1234 5678 9012",
      "1234-5678-9012",
      "A23456789012",
      "12345678A012",
      "12345678901B",
      "00000000000"
    ],
    "positiveHeaderExamples": [
      "aadhaar_number",
      "aadhaar id",
      "uidai_id",
      "uid",
      "national_id_aadhaar",
      "resident_aadhaar",
      "aadhaar_identifier",
      "id"
    ],
    "negativeHeaderExamples": [
      "voter_id",
      "pan_number",
      "passport_number",
      "customer_id",
      "national_identity_card",
      "ssn",
      "tax_id",
      "employee_number"
    ],
    "explanation": "Aadhaar numbers are strictly 12 consecutive digits without separators or letters. This semantic type uses a precise numeric token count with word boundaries to detect values while avoiding false positives from formatted variants or other identifiers.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:44.891253"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.NI_UK",
    "description": "This type captures the UK National Insurance Number, used for social security and employment purposes throughout Britain. The identifier consists of two letters followed by six digits and ends with a single letter, with no spaces or separators in its canonical form.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z]{2}[0-9]{6}[A-Za-z]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4430,
    "headerPatterns": [
      {
        "regExp": "(?i).*uk.*national.*insurance.*number.*",
        "confidence": 99,
        "mandatory": true,
        "positiveExamples": [
          "uk_national_insurance_number"
        ],
        "negativeExamples": [
          "uk_insurance_policy_number"
        ]
      },
      {
        "regExp": "(?i).*national.*insurance.*number.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "national_insurance_number"
        ],
        "negativeExamples": [
          "insurance_number"
        ]
      },
      {
        "regExp": "(?i).*nino.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "nino"
        ],
        "negativeExamples": [
          "nin"
        ]
      },
      {
        "regExp": "(?i).*ni.*number.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "ni_number"
        ],
        "negativeExamples": [
          "net_income_number"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "AB123456C",
      "QW987654D",
      "cd000001a",
      "XY654321B",
      "MK112233Z",
      "pr765432k",
      "GH000000T"
    ],
    "negativeContentExamples": [
      "AB123456",
      "AB 123456 C",
      "A123456C",
      "ABC123456C",
      "AB12345C",
      "AB1234567C",
      "AB12A456C",
      "AB1234567"
    ],
    "positiveHeaderExamples": [
      "uk_national_insurance_number",
      "national_insurance_number",
      "nino",
      "ni_number",
      "employee_ni_number",
      "uk_nino",
      "national_insurance_number_uk"
    ],
    "negativeHeaderExamples": [
      "insurance_number",
      "national_id_number",
      "social_security_number",
      "nin",
      "net_income_number",
      "national_insurance_code",
      "policy_number",
      "taxpayer_number"
    ],
    "explanation": "Identifies compact UK National Insurance Numbers in canonical form without spaces or separators. Useful for validating and classifying UK employment and tax identifiers in HR, payroll, and government reporting datasets. The pattern is constrained to two letters, six digits, and a final letter, using word boundaries to avoid partial matches.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:45.030197"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.PERSONNUMMER_SE",
    "description": "This type represents the Swedish personal identity number (personnummer), which encodes birth date information followed by a unique individual identifier. The number commonly appears as YYMMDD-XXXX or YYMMDD+XXXX (10 digits) and can also include a century prefix as YYYYMMDD-XXXX (12 digits). The last four digits include an individual sequence (odd/even indicating gender) and a check digit.",
    "pluginType": "regex",
    "regexPattern": "\\b((19|20)\\d{2}[01]\\d[0-3]\\d[- ]?\\d{4}|\\d{2}[01]\\d[0-3]\\d[-+ ]?\\d{4})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4450,
    "headerPatterns": [
      {
        "regExp": "(?i).*personnummer.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "personnummer"
        ],
        "negativeExamples": [
          "personnumber"
        ]
      },
      {
        "regExp": "(?i).*(swedish|se).*personal.*identity.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "swedish_personal_identity_number"
        ],
        "negativeExamples": [
          "personal_identity_number"
        ]
      },
      {
        "regExp": "(?i).*(sweden|se).*national.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "se_national_id"
        ],
        "negativeExamples": [
          "national_id"
        ]
      },
      {
        "regExp": "(?i).*(pnr|personnr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "pnr"
        ],
        "negativeExamples": [
          "pin"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "850623-1423",
      "850623+1423",
      "8506231423",
      "19900115-2394",
      "199001152394",
      "20011231 0192",
      "19640505-1234",
      "0301011237"
    ],
    "negativeContentExamples": [
      "19800101+1234",
      "850623--1423",
      "850623_1423",
      "850623-142",
      "850623-14231",
      "850623 14A3",
      "030101 12345",
      "20011231-019"
    ],
    "positiveHeaderExamples": [
      "personnummer",
      "se_personnummer",
      "swedish_personal_identity_number",
      "person_id_number_se",
      "national_id_se",
      "personnr",
      "se_pnr",
      "sweden_personal_id"
    ],
    "negativeHeaderExamples": [
      "personal_number",
      "person_name",
      "passport_number",
      "ssn",
      "employee_id",
      "norwegian_personnummer",
      "national_insurance_number",
      "customer_number"
    ],
    "explanation": "This semantic type targets Swedish personal identity numbers that embed the birth date and an individual sequence with a check digit. It accepts both 10-digit forms (YYMMDD-XXXX or YYMMDD+XXXX) and 12-digit forms with century (YYYYMMDD-XXXX), allowing either a hyphen, a space, or no delimiter as used in real-world datasets. The pattern is constrained with word boundaries and explicit digit counts to avoid over-matching while remaining flexible for common formatting variations.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:53.060313"
  },
  {
    "resultType": "generated",
    "semanticType": "HASH.SHA256_HEX",
    "description": "This type captures SHA-256 hash digest values used for secure file integrity checking, blockchain applications, and advanced cryptographic verification. The values represent 256-bit hash outputs encoded as hexadecimal strings using lowercase letters and digits without spaces or separators.",
    "pluginType": "regex",
    "regexPattern": "\\b[a-f0-9]{64}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4340,
    "headerPatterns": [
      {
        "regExp": "(?i).*sha[-_ ]?256.*(hash|digest|checksum).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "sha256_checksum"
        ],
        "negativeExamples": [
          "sha1_digest"
        ]
      },
      {
        "regExp": "(?i).*(file|record|txn|block|message).*sha[-_ ]?256.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "file_sha256"
        ],
        "negativeExamples": [
          "file_sha1"
        ]
      },
      {
        "regExp": "(?i).*sha[-_ ]?256.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "sha256"
        ],
        "negativeExamples": [
          "sha512"
        ]
      },
      {
        "regExp": "(?i).*sha2[-_ ]?256.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "sha2_256_digest"
        ],
        "negativeExamples": [
          "sha256"
        ]
      },
      {
        "regExp": "(?i).*hash.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "hash"
        ],
        "negativeExamples": [
          "checksum"
        ]
      }
    ],
    "positiveContentExamples": [
      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
      "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
      "0000000000000000000000000000000000000000000000000000000000000000",
      "a1b2c3d4e5f60718293a4b5c6d7e8f9012ab34cd56ef7890ab12cd34ef56ab78",
      "1a2b3c4d5e6f708192a3b4c5d6e7f8090a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d",
      "de9f2c7fd25e1b3afad3e85a0bd17d9b100db4b3f9b9e7b3d7f8c6a9e5d4c3b2",
      "bcdefa0123456789aa55cc33ee77dd44112233445566778899aabbccddeeff00"
    ],
    "negativeContentExamples": [
      "E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855",
      "e3b0c442-98fc-1c14-9afb-f4c8996fb92427ae41e4649b934ca495991b7852b855",
      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b85",
      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b8555",
      "g3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b85z",
      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4 649b934ca495991b7852b855",
      "sha256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855"
    ],
    "positiveHeaderExamples": [
      "sha256_hash",
      "file_sha256",
      "sha256_checksum",
      "sha256_digest",
      "record_sha256_hash",
      "blockchain_sha256",
      "tx_sha256",
      "sha256"
    ],
    "negativeHeaderExamples": [
      "md5_digest",
      "sha1",
      "checksum",
      "signature",
      "mac_code",
      "sha512_checksum",
      "encryption_key",
      "file_id"
    ],
    "explanation": "SHA-256 hex digests are 256-bit cryptographic hash outputs represented as 64-character lowercase hexadecimal strings. This semantic type is useful for identifying columns storing file integrity checks, blockchain transaction identifiers in hex digest form, and other cryptographic verification values. The header patterns prioritize explicit mentions of SHA-256 and digest terms, with a final primitive fallback on 'hash' to support generic naming while maintaining a high content-based threshold.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:00:54.664334"
  },
  {
    "resultType": "generated",
    "semanticType": "JOB_TITLE_EN",
    "description": "This type captures job titles and occupational designations as they appear in professional contexts, employment records, and organizational structures. The values represent standard professional roles, specialized positions, or functional titles using conventional workplace terminology.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b([A-Za-z][A-Za-z.&/-]{1,}( [A-Za-z.&/-]{2,}){0,6} (Engineer|Developer|Manager|Director|Analyst|Specialist|Consultant|Coordinator|Administrator|Officer|Assistant|Associate|Technician|Architect|Scientist|Supervisor|Executive|Attorney|Counsel|Auditor|Planner|Designer|Recruiter|Advisor|Controller))\\b|\\b(Chief|Head|VP|Vice President|President)\\b([ ,\\-]+[A-Za-z.&/-]{2,}){1,6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4550,
    "headerPatterns": [
      {
        "regExp": "(?i).*job.*title.*en.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "job_title_en"
        ],
        "negativeExamples": [
          "employee_title"
        ]
      },
      {
        "regExp": "(?i).*(employee|staff|worker).*title.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "employee_title"
        ],
        "negativeExamples": [
          "job_code"
        ]
      },
      {
        "regExp": "(?i).*(job|position|role).*(title|ttl).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "position_title"
        ],
        "negativeExamples": [
          "employee_name"
        ]
      },
      {
        "regExp": "(?i).*(designation|occupation).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "designation"
        ],
        "negativeExamples": [
          "department"
        ]
      },
      {
        "regExp": "(?i).*title.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "title"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "Senior Software Engineer",
      "Marketing Manager",
      "Chief Financial Officer",
      "Vice President, Sales",
      "HR Specialist",
      "Data Scientist",
      "Lead Product Designer",
      "Customer Support Coordinator"
    ],
    "negativeContentExamples": [
      "John A. Smith",
      "Engineering",
      "Manager 2",
      "VP",
      "Product Owner",
      "Assistant-Manager",
      "QA Lead",
      "CFO"
    ],
    "positiveHeaderExamples": [
      "job_title",
      "employee_title",
      "position_title",
      "job_title_en",
      "professional_title",
      "role_title",
      "designation"
    ],
    "negativeHeaderExamples": [
      "job_code",
      "employee_name",
      "job_description",
      "department",
      "start_date",
      "salary",
      "status"
    ],
    "explanation": "This semantic type identifies English-language job titles by requiring multi-token phrases composed of letters and common separators, and by ensuring either a recognized role noun (e.g., Engineer, Manager, Analyst) appears as a whole word or the title begins with leadership keywords (e.g., Chief, Head, VP, Vice President, President) followed by one or more valid tokens. The approach minimizes false positives from personal names, departments, and codes by restricting allowed characters and enforcing job-specific vocabulary. Typical use cases include parsing HR exports, normalizing workforce datasets, and labeling columns containing professional titles.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:01:03.930099"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.VAT_<COUNTRY>",
    "description": "This type captures VAT registration numbers, which are unique tax identifiers assigned to businesses by tax authorities for value-added tax purposes. The format and length vary significantly by country but generally consists of alphanumeric characters with possible country-specific prefixes or formatting rules.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z]{2}[ -]?[A-Za-z0-9]{8,12}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4490,
    "headerPatterns": [
      {
        "regExp": "(?i).*vat[ _-]*(registration|reg)[ _-]*(number|no|nbr).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "vat_registration_number"
        ],
        "negativeExamples": [
          "vat_rate"
        ]
      },
      {
        "regExp": "(?i).*(company|business|vendor|supplier)[ _-]*vat[ _-]*(id|number|no).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "supplier_vat_number"
        ],
        "negativeExamples": [
          "supplier_tax_number"
        ]
      },
      {
        "regExp": "(?i).*(eu|uk|gb|de|fr|es|it|nl|se|dk|ie|pl|pt|ro|bg|gr|cy|cz|hu|sk|si|hr|at|be|lu|lt|lv|ee)[ _-]*vat[ _-]*(id|no|number).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "gb_vat_id"
        ],
        "negativeExamples": [
          "gb_tax_id"
        ]
      },
      {
        "regExp": "(?i).*vat[ _-]*(id|identification|ident|number|no|nr|num).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "vat_identification"
        ],
        "negativeExamples": [
          "vat_amount"
        ]
      },
      {
        "regExp": "(?i).*vat.*id.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "vat_id"
        ],
        "negativeExamples": [
          "tax_id"
        ]
      }
    ],
    "positiveContentExamples": [
      "DE123456789",
      "FR12A3456789",
      "IT-12345678901",
      "ESX1234567A",
      "NL123456789B01",
      "GB 123456789",
      "IE9D12345F",
      "SE 123456789012"
    ],
    "negativeContentExamples": [
      "FR1234567",
      "GB1234567890123",
      "DE123/45678",
      "it_12345678901",
      "NL 1234 56789",
      "CZ12-3456789",
      "GR\u0391\u039212345678",
      "ES#12345678"
    ],
    "positiveHeaderExamples": [
      "vat_registration_number",
      "vat_reg_no",
      "company_vat_id",
      "supplier_vat_number",
      "eu_vat_no",
      "gb_vat_id",
      "vat_identification",
      "business_vat_number"
    ],
    "negativeHeaderExamples": [
      "tax_identification_number",
      "gst_registration_number",
      "vat_rate",
      "vat_amount",
      "invoice_number",
      "national_id",
      "sales_tax_id",
      "vat_country"
    ],
    "explanation": "This semantic type identifies VAT registration numbers that include a two-letter country code followed by an 8\u201312 character alphanumeric sequence, optionally separated from the country code by a single space or hyphen. It is intended to validate and classify business VAT identifiers across different countries while relying on header context to disambiguate from other identifiers.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:01:15.887774"
  },
  {
    "resultType": "generated",
    "semanticType": "MONTH.FULL_<LOCALE>",
    "description": "This type captures full month names as they appear in a specific locale for date display and internationalization purposes. The values represent complete month names using proper spelling and capitalization for the indicated locale.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "JANUARY",
      "FEBRUARY",
      "MARCH",
      "APRIL",
      "MAY",
      "JUNE",
      "JULY",
      "AUGUST",
      "SEPTEMBER",
      "OCTOBER",
      "NOVEMBER",
      "DECEMBER"
    ],
    "backout": "^[A-Za-z]{3,9}$",
    "confidenceThreshold": 96,
    "priority": 4620,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bfull\\b.*\\bmonth\\b.*\\bname\\b.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "full_month_name"
        ],
        "negativeExamples": [
          "month_code"
        ]
      },
      {
        "regExp": "(?i).*\\bbilling\\b.*\\bmonth\\b.*\\bname\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "billing_month_name"
        ],
        "negativeExamples": [
          "billing_month_code"
        ]
      },
      {
        "regExp": "(?i).*\\breporting\\b.*\\bmonth\\b.*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "reporting_month_name"
        ],
        "negativeExamples": [
          "reporting_month_number"
        ]
      },
      {
        "regExp": "(?i).*\\bmonth\\b[_ ]*\\bname\\b.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "month_name"
        ],
        "negativeExamples": [
          "month_number"
        ]
      },
      {
        "regExp": "(?i).*\\bmonth\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "month"
        ],
        "negativeExamples": [
          "months_count"
        ]
      }
    ],
    "positiveContentExamples": [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "September",
      "December"
    ],
    "negativeContentExamples": [
      "Jan",
      "Sept",
      "JANUARY",
      "January 2023",
      "Jan.",
      "02",
      "August-2020",
      "Mayo"
    ],
    "positiveHeaderExamples": [
      "full_month_name",
      "billing_month_name",
      "reporting_month_name",
      "posting_month_name",
      "month_name",
      "month_label",
      "ui_month_name",
      "display_month"
    ],
    "negativeHeaderExamples": [
      "month_code",
      "month_number",
      "month_abbrev",
      "months_count",
      "calendar_month_id",
      "transaction_date",
      "customer_name",
      "start_month_num"
    ],
    "explanation": "A finite list of the 12 full English month names enables precise detection of textual month values used in UI labels and date displays. Use this type to validate and standardize month-name fields in datasets where the locale is English and the full month word is expected.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:01:18.343226"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_PT",
    "description": "This type represents postal codes used within Portugal's postal system for mail routing and delivery. The format consists of four digits, followed by a hyphen, then three additional digits creating a structured seven-digit identifier.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{4}-\\d{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4930,
    "headerPatterns": [
      {
        "regExp": "(?i).*postal[_ ]?code[_ ]?portugal.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postal_code_portugal"
        ],
        "negativeExamples": [
          "portugal_postal"
        ]
      },
      {
        "regExp": "(?i).*postal[_ ]?code[_ ]?pt.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postal code pt"
        ],
        "negativeExamples": [
          "pt_postal"
        ]
      },
      {
        "regExp": "(?i).*portugal.*postcode.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "portugal_postcode"
        ],
        "negativeExamples": [
          "portugal_posttown"
        ]
      },
      {
        "regExp": "(?i).*(postal[_ ]?code|postcode).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postcode"
        ],
        "negativeExamples": [
          "postal_address"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "1000-001",
      "1990-002",
      "2000-123",
      "2720-105",
      "4000-008",
      "8005-501",
      "9950-350",
      "1100-089"
    ],
    "negativeContentExamples": [
      "1000-01",
      "10000-001",
      "1000 001",
      "1000-0013",
      "1000-AB1",
      "1000\u2014001",
      "1000/001",
      "1000001"
    ],
    "positiveHeaderExamples": [
      "postal_code_portugal",
      "postal code pt",
      "portugal_postcode",
      "pt_postal_code",
      "postcode",
      "postal_code",
      "recipient_postal_code",
      "ship_to_postcode_portugal"
    ],
    "negativeHeaderExamples": [
      "portugal_address",
      "postal_city",
      "post_town_pt",
      "pt_postal_area",
      "postalzone_portugal",
      "mail_region_pt",
      "address_portugal",
      "shipping_label"
    ],
    "explanation": "Portuguese postal codes are structured as four digits, a hyphen, and three digits (e.g., 1234-567). This semantic type is useful for validating, parsing, and standardizing Portuguese mailing data, ensuring columns intended to hold Portugal postal codes are correctly identified and validated.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:01:22.152727"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_BG",
    "description": "This type identifies Bulgarian postal codes as they appear in addressing and mail delivery systems within Bulgaria. The codes consist of exactly four numerical digits assigned to specific cities, regions, and postal delivery areas for efficient mail processing and routing.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4830,
    "headerPatterns": [
      {
        "regExp": "(?i).*(bg|bulgarian|bulgaria).*(postal.*code|postcode).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "bg_postal_code"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      },
      {
        "regExp": "(?i).*(bg|bulgarian|bulgaria).*(zip|postcode|postal).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "bulgaria_zip"
        ],
        "negativeExamples": [
          "zip_us"
        ]
      },
      {
        "regExp": "(?i).*(bg|bulgaria).*pcode.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "bg_pcode"
        ],
        "negativeExamples": [
          "customer_pcode"
        ]
      },
      {
        "regExp": "(?i).*(postal.*code|postcode|zip).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "postal_code"
        ],
        "negativeExamples": [
          "shipping_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "1000",
      "1307",
      "1680",
      "4020",
      "5300",
      "8142",
      "2227",
      "9010"
    ],
    "negativeContentExamples": [
      "999",
      "12345",
      "1 234",
      "12-34",
      "A234",
      "23B4",
      "BG1000",
      "100O"
    ],
    "positiveHeaderExamples": [
      "bg_postal_code",
      "postal_code_bg",
      "bulgarian_postcode",
      "bg_pcode",
      "bulgaria_zip",
      "bg_postcode",
      "postcode_bg",
      "postal_code"
    ],
    "negativeHeaderExamples": [
      "shipping_code",
      "country_code",
      "zip_us",
      "city_postal",
      "postal_area",
      "address_code",
      "post_office_code",
      "po_box"
    ],
    "explanation": "Bulgarian postal codes are four-digit numeric tokens used for mail routing within Bulgaria. This semantic type uses a strict 4-digit numeric pattern with word boundaries to distinguish standalone postal codes from longer numeric strings. Header patterns prioritize country-specific signals (BG/Bulgaria/Bulgarian) combined with postal terms, then fall back to broader variants and finally the primitive 'code'. A high threshold and moderate priority reduce collisions with other 4-digit fields such as years.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:01:29.114238"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_NL",
    "description": "This type identifies postal codes used in the Netherlands postal system for mail routing and delivery. The structure consists of four digits, followed by a single space, then two uppercase letters without additional formatting.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{4} [A-Z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4920,
    "headerPatterns": [
      {
        "regExp": "(?i).*(netherlands|dutch|nl).*post.?code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "netherlands_postcode"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      },
      {
        "regExp": "(?i).*(ship|bill|residence|home|office).*post.?code.*nl.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ship_to_postcode_nl"
        ],
        "negativeExamples": [
          "shipping_postal_code"
        ]
      },
      {
        "regExp": "(?i).*(nl).*zip.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nl_zip_code"
        ],
        "negativeExamples": [
          "zip_code"
        ]
      },
      {
        "regExp": "(?i).*postcode.*nl.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postcode_nl"
        ],
        "negativeExamples": [
          "postcode"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "country"
        ]
      }
    ],
    "positiveContentExamples": [
      "1234 AB",
      "5678 CD",
      "1000 AA",
      "3456 ZX",
      "7890 LM",
      "4321 PQ",
      "9056 RT",
      "8123 GH"
    ],
    "negativeContentExamples": [
      "1234AB",
      "123 AB",
      "12345 AB",
      "1234 A",
      "1234 ABC",
      "1234 aB",
      "12 34 AB",
      "1234 A1"
    ],
    "positiveHeaderExamples": [
      "nl_postal_code",
      "netherlands_postcode",
      "dutch_postal_code",
      "postcode_nl",
      "ship_to_postcode_nl",
      "customer_nl_postal_code",
      "nl_zip_code",
      "residence_postcode_nl"
    ],
    "negativeHeaderExamples": [
      "postal_code",
      "billing_postal_code",
      "postcode",
      "zip_code",
      "de_postal_code",
      "us_zip_code",
      "postal_code_ca",
      "shipping_postal_code"
    ],
    "explanation": "Recognizes Dutch postal codes of the form four digits, a single space, and two uppercase letters (e.g., 1234 AB). Useful for validating and classifying Netherlands-specific postal address fields where format consistency is required.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:01:34.140434"
  },
  {
    "resultType": "generated",
    "semanticType": "IPADDRESS.IPV4",
    "description": "Identifies IPv4 addresses, which are 32-bit numerical identifiers composed of four decimal octets separated by dots. Each octet is a decimal number from 0 to 255, representing one byte of the address.",
    "pluginType": "regex",
    "regexPattern": "\\b(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]?|0)\\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]?|0)\\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]?|0)\\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]?|0)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4530,
    "headerPatterns": [
      {
        "regExp": "(?i).*(\\bipv4\\b).*(\\baddress\\b).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "ipv4_address"
        ],
        "negativeExamples": [
          "ipv6_address"
        ]
      },
      {
        "regExp": "(?i).*(\\bip\\b).*(\\bv?4\\b).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "client_ip4"
        ],
        "negativeExamples": [
          "client_ipv6"
        ]
      },
      {
        "regExp": "(?i).*(\\bip\\b).*(\\baddress\\b).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ip_address"
        ],
        "negativeExamples": [
          "mac_address"
        ]
      },
      {
        "regExp": "(?i).*(\\bsource|\\bsrc|\\bclient|\\bremote).*(\\bip\\b).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "source_ip"
        ],
        "negativeExamples": [
          "source_port"
        ]
      },
      {
        "regExp": "(?i).*(\\bip\\b).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ip"
        ],
        "negativeExamples": [
          "address"
        ]
      }
    ],
    "positiveContentExamples": [
      "0.0.0.0",
      "255.255.255.255",
      "192.168.1.1",
      "10.0.0.1",
      "172.16.0.5",
      "8.8.8.8",
      "127.0.0.1",
      "100.64.0.1"
    ],
    "negativeContentExamples": [
      "256.100.50.25",
      "192.168.1",
      "192.168.1.1.1",
      "192.168.01.1",
      "192.168.1.1/24",
      "192.168.1.1:80",
      "999.1.1.1",
      "192.168.1.-1"
    ],
    "positiveHeaderExamples": [
      "ipv4_address",
      "source_ipv4",
      "client_ip",
      "ip_address",
      "user_ip_v4",
      "remote_ip",
      "src_ip",
      "ip"
    ],
    "negativeHeaderExamples": [
      "mac_address",
      "ipv6_address",
      "email_address",
      "device_id",
      "postal_code",
      "host_name",
      "coordinates",
      "gateway"
    ],
    "explanation": "This semantic type targets IPv4 addresses using a strict, bounded pattern for four decimal octets (0\u2013255) separated by dots and delimited by word boundaries to avoid partial matches. It is suited for fields storing client, server, source, or destination IPv4s and excludes CIDR notations, ports, and out-of-range or malformed octets.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:01:38.832243"
  },
  {
    "resultType": "generated",
    "semanticType": "AIRLINE.IATA_CODE",
    "description": "This type captures standardized airline identification codes used throughout the aviation industry for booking systems and flight operations. Each code consists of exactly two uppercase letters with no numeric digits, punctuation, or spacing allowed.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 3800,
    "headerPatterns": [
      {
        "regExp": "(?i).*(airline|carrier).*iata.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "airline_iata_code"
        ],
        "negativeExamples": [
          "airport_iata_code"
        ]
      },
      {
        "regExp": "(?i).*iata.*(airline|carrier).*(code|cd).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iata_airline_cd"
        ],
        "negativeExamples": [
          "iata_airport_code"
        ]
      },
      {
        "regExp": "(?i).*(airline|carrier).*iata.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "carrier_iata"
        ],
        "negativeExamples": [
          "airline_icao"
        ]
      },
      {
        "regExp": "(?i).*iata.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iata_code"
        ],
        "negativeExamples": [
          "icao_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "number"
        ]
      }
    ],
    "positiveContentExamples": [
      "AA",
      "BA",
      "LH",
      "QF",
      "CX",
      "EK",
      "AF",
      "DL"
    ],
    "negativeContentExamples": [
      "A3",
      "ABC",
      "A",
      "aa",
      "A-",
      "A_",
      "A B",
      "1A"
    ],
    "positiveHeaderExamples": [
      "airline_iata_code",
      "iata_airline_code",
      "carrier_iata",
      "airline_code",
      "iata_code",
      "carrier_code_iata",
      "airline_iata",
      "iata_carrier_cd"
    ],
    "negativeHeaderExamples": [
      "airport_iata_code",
      "airline_icao_code",
      "icao_airline_code",
      "iata_airport_code",
      "reservation_code",
      "flight_number",
      "passenger_name",
      "country_code"
    ],
    "explanation": "AIRLINE.IATA_CODE identifies two-letter airline codes composed strictly of uppercase A\u2013Z characters, with no digits, spaces, or punctuation. It is useful for classifying carrier identifiers in booking, scheduling, and operational datasets. The regex enforces exactly two uppercase letters with word boundaries to avoid partial matches within larger strings. Header patterns prioritize explicit mentions of airline/carrier and IATA before falling back to the primitive term 'code' to reduce conflicts with other code-like fields.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:01:46.652437"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.MARITAL_STATUS_EN",
    "description": "This type captures marital status designations as they appear in demographic data, legal documents, and personal records using standard English terminology. The values represent recognized relationship states following conventional marital status categories without abbreviated forms or informal descriptions.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "SINGLE",
      "MARRIED",
      "DIVORCED",
      "WIDOWED",
      "SEPARATED",
      "LEGALLY SEPARATED",
      "ANNULLED",
      "NEVER MARRIED",
      "CIVIL UNION",
      "DOMESTIC PARTNERSHIP",
      "COMMON-LAW MARRIAGE",
      "REGISTERED PARTNERSHIP"
    ],
    "backout": "^[A-Z][A-Z -]{2,49}$",
    "confidenceThreshold": 96,
    "priority": 4780,
    "headerPatterns": [
      {
        "regExp": "(?i).*(person|applicant|customer).*marital.*status.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "person_marital_status"
        ],
        "negativeExamples": [
          "marital_history"
        ]
      },
      {
        "regExp": "(?i).*relationship.*status.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "relationship_status"
        ],
        "negativeExamples": [
          "employment_status"
        ]
      },
      {
        "regExp": "(?i).*civil.*status.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "civil_status"
        ],
        "negativeExamples": [
          "marital_status"
        ]
      },
      {
        "regExp": "(?i).*marital.*category.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "marital_category"
        ],
        "negativeExamples": [
          "marital_notes"
        ]
      },
      {
        "regExp": "(?i).*(mrtl|marit).*status.*",
        "confidence": 91,
        "mandatory": true,
        "positiveExamples": [
          "mrtl_status"
        ],
        "negativeExamples": [
          "marital_date"
        ]
      },
      {
        "regExp": "(?i).*status.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "status"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "SINGLE",
      "MARRIED",
      "DIVORCED",
      "WIDOWED",
      "SEPARATED",
      "LEGALLY SEPARATED",
      "ANNULLED",
      "NEVER MARRIED"
    ],
    "negativeContentExamples": [
      "MARRIED WITH CHILDREN",
      "SEPARATED (TRIAL)",
      "CIVIL-UNION",
      "DOMESTIC PARTNER",
      "SINGLE/NEVER MARRIED",
      "IN A RELATIONSHIP",
      "UNKNOWN",
      "WIDOWER"
    ],
    "positiveHeaderExamples": [
      "marital_status",
      "person_marital_status",
      "relationship_status",
      "marital_category",
      "mrtl_status",
      "civil_status",
      "applicant_marital_status",
      "customer_marital_status"
    ],
    "negativeHeaderExamples": [
      "employment_status",
      "account_status",
      "status_code",
      "marital_notes",
      "marital_date",
      "relationship_type",
      "family_status",
      "spouse_name"
    ],
    "explanation": "This semantic type identifies formal marital status values written in standard English and commonly found in demographic and legal records. It is implemented as a finite list to ensure precise recognition of canonical terms while a conservative, anchored backout pattern covers their general shape for validation and fallback. Header patterns progress from highly specific variants (e.g., person_marital_status) to the primitive status term to support robust schema-driven identification across datasets.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:01:49.602739"
  },
  {
    "resultType": "generated",
    "semanticType": "INDUSTRY_EN",
    "description": "This type captures industry names as they are commonly expressed in English business terminology and classifications. The values represent broad economic sectors, specific industries, or business categories using standard commercial language and terminology.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b([a-z]+(?:[ \\/&-][a-z]+){1,3}[ \\/&-](industry|industries|services|service|technology|manufacturing|retail|wholesale|healthcare|pharmaceuticals|telecommunications|construction|energy|utilities|mining|agriculture|automotive|finance|banking|insurance|logistics|transportation|hospitality|tourism|aerospace|defense|chemicals|food|beverage|education|media|entertainment|software|hardware|goods|packaging|trade))\\b|\\b(industry|industries|services|service|technology|manufacturing|retail|wholesale|healthcare|pharmaceuticals|telecommunications|construction|energy|utilities|mining|agriculture|automotive|finance|banking|insurance|logistics|transportation|hospitality|tourism|aerospace|defense|chemicals|food|beverage|education|media|entertainment|software|hardware|real estate|public sector|consumer goods|consumer packaged goods|trade)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4520,
    "headerPatterns": [
      {
        "regExp": "(?i).*(industry|sector).*(name|title).*en.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "industry_name_en"
        ],
        "negativeExamples": [
          "industry_code_en"
        ]
      },
      {
        "regExp": "(?i).*(industry|sector).*(description|desc|title).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "industry_description"
        ],
        "negativeExamples": [
          "product_description"
        ]
      },
      {
        "regExp": "(?i).*(company|business|employer).*(industry|sector).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "company_industry"
        ],
        "negativeExamples": [
          "company_size"
        ]
      },
      {
        "regExp": "(?i).*(ind|sect).*(name|desc|title).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "ind_name"
        ],
        "negativeExamples": [
          "ind_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Information Technology",
      "Financial Services",
      "Manufacturing",
      "Healthcare",
      "Energy & Utilities",
      "Real Estate",
      "Retail Trade",
      "Transportation and Logistics"
    ],
    "negativeContentExamples": [
      "Finance & Accounting",
      "Retailer",
      "Manufacturing Dept",
      "Industry 4.0",
      "Tech Support",
      "Product Category",
      "Oil & Gas",
      "E-commerce"
    ],
    "positiveHeaderExamples": [
      "industry_name_en",
      "industry_description",
      "company_industry",
      "sector_name",
      "business_sector",
      "naics_industry_title",
      "employer_industry",
      "industry_title"
    ],
    "negativeHeaderExamples": [
      "industry_code",
      "sector_id",
      "company_name",
      "job_title",
      "product_category",
      "naics_code",
      "country",
      "currency_code"
    ],
    "explanation": "This semantic type identifies English industry names and sectors commonly used in business data, such as Manufacturing, Financial Services, and Information Technology. It targets descriptive labels of economic activities rather than alphanumeric codes or identifiers. Use it to classify columns that store narrative industry labels for companies, organizations, or records.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:01:55.034942"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_IN",
    "description": "This type represents Indian Postal Index Numbers used for mail routing throughout India. The format requires exactly six consecutive numeric digits without spaces, hyphens, or any non-numeric characters.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4890,
    "headerPatterns": [
      {
        "regExp": "(?i).*indian.*postal.*index.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "indian postal index number"
        ],
        "negativeExamples": [
          "postal index number"
        ]
      },
      {
        "regExp": "(?i).*india.*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "india postal code"
        ],
        "negativeExamples": [
          "postal code canada"
        ]
      },
      {
        "regExp": "(?i).*postal.*index.*number.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "postal index number"
        ],
        "negativeExamples": [
          "postal code"
        ]
      },
      {
        "regExp": "(?i).*pin.*code.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "pin code"
        ],
        "negativeExamples": [
          "zip code"
        ]
      },
      {
        "regExp": "(?i).*pin.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "pin"
        ],
        "negativeExamples": [
          "pan"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "560001",
      "110001",
      "400076",
      "700001",
      "302015",
      "835103",
      "682013",
      "781001"
    ],
    "negativeContentExamples": [
      "56001",
      "5600013",
      "56 0001",
      "560-001",
      "560_001",
      "56000A",
      "A560001",
      "PIN560001"
    ],
    "positiveHeaderExamples": [
      "indian postal index number",
      "india postal code",
      "postal index number",
      "pin code",
      "pincode",
      "in postal code",
      "in_pin",
      "pin"
    ],
    "negativeHeaderExamples": [
      "postal code",
      "zip code",
      "postcode",
      "area code",
      "ifsc code",
      "pan number",
      "address code",
      "customer code"
    ],
    "explanation": "Identifies Indian PINs as exactly six consecutive digits, disallowing spaces, hyphens, or letters. Useful for validating and standardizing Indian mailing addresses, enriching geocoding pipelines, and filtering datasets for India-specific postal routing fields. Header patterns prioritize phrases like Indian Postal Index Number and PIN Code to distinguish this from other postal code systems.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:01:55.847910"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.DATE_OF_BIRTH",
    "description": "This type captures birth dates as they appear in personal identification documents, records, and biographical data using various date formatting conventions. The values represent complete birth dates including year, month, and day components formatted according to different regional and international date standards.",
    "pluginType": "regex",
    "regexPattern": "\\b([0-3]?\\d[\\/-\\. ][0-1]?\\d[\\/-\\. ][1-2]\\d{3}|[1-2]\\d{3}[\\/-\\. ][0-1]?\\d[\\/-\\. ][0-3]?\\d|(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Sept|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[ ]+[0-3]?\\d,?[ ]+[1-2]\\d{3}|[0-3]?\\d[ ]+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Sept|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[, ]+[1-2]\\d{3}|[1-2]\\d{3}[ ]+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Sept|Oct|Nov|Dec|January|February|March|April|May|June|July|August|September|October|November|December)[ ]+[0-3]?\\d)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4770,
    "headerPatterns": [
      {
        "regExp": "(?i).*(person|customer|employee|applicant|patient)[ _-]*date[ _-]*of[ _-]*birth.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "person_date_of_birth"
        ],
        "negativeExamples": [
          "employee_hire_date"
        ]
      },
      {
        "regExp": "(?i).*(person|customer|employee|applicant|patient)[ _-]*(dob|birth[ _-]*date|birthdate).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "customer_dob"
        ],
        "negativeExamples": [
          "customer_join_date"
        ]
      },
      {
        "regExp": "(?i).*date[ _-]*of[ _-]*birth.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "date_of_birth"
        ],
        "negativeExamples": [
          "birth_place"
        ]
      },
      {
        "regExp": "(?i).*(dob|birthdate|birth[ _-]*date).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "birthdate"
        ],
        "negativeExamples": [
          "birth_year"
        ]
      },
      {
        "regExp": "(?i).*date.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "date"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "1982-08-05",
      "05/08/1982",
      "8/5/1982",
      "Aug 5, 1982",
      "5 Aug 1982",
      "1982 Aug 5",
      "05.08.1982",
      "1982/8/5"
    ],
    "negativeContentExamples": [
      "8/5/82",
      "Aug 05 82",
      "05/1982",
      "1982-08",
      "1982-08-05T00:00:00",
      "19820805",
      "5th Aug 1982",
      "1982-Aug-05"
    ],
    "positiveHeaderExamples": [
      "person_date_of_birth",
      "customer_dob",
      "birthdate",
      "birth_date",
      "applicant_birth_date",
      "employee_date_of_birth",
      "patient_dob",
      "date_of_birth"
    ],
    "negativeHeaderExamples": [
      "hire_date",
      "transaction_date",
      "age",
      "anniversary_date",
      "created_at",
      "birth_year",
      "name",
      "place_of_birth"
    ],
    "explanation": "Identifies complete birth dates (year, month, and day) across common numeric and month-name formats used in personal records. Supports day-month-year, month-day-year, and year-month-day with separators like slash, dash, dot, or space, as well as textual month variants with optional comma. Intended for fields storing a person's date of birth, complementing header cues such as DOB or birthdate.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:01:58.202302"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.YEAR_OF_BIRTH",
    "description": "This type captures four-digit birth years as they appear in demographic data, personal records, and age-related analyses. Values are the year component only (no month or day), represented as a four-digit calendar year within a plausible range.",
    "pluginType": "regex",
    "regexPattern": "\\b(19[0-9]{2}|200[0-9]|201[0-9]|202[0-5])\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 4810,
    "headerPatterns": [
      {
        "regExp": "(?i).*year[ _-]?of[ _-]?birth.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "year_of_birth"
        ],
        "negativeExamples": [
          "birth_date"
        ]
      },
      {
        "regExp": "(?i).*(birth[ _-]?year|dob[ _-]?year).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "birth_year"
        ],
        "negativeExamples": [
          "birth_month"
        ]
      },
      {
        "regExp": "(?i).*(yob|yr[ _-]?birth|birthyear).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "yob"
        ],
        "negativeExamples": [
          "year_started"
        ]
      },
      {
        "regExp": "(?i).*person[ _-]?(birth[ _-]?year|yob).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "person_birth_year"
        ],
        "negativeExamples": [
          "person_age"
        ]
      },
      {
        "regExp": "(?i).*year.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "year"
        ],
        "negativeExamples": [
          "date"
        ]
      }
    ],
    "positiveContentExamples": [
      "1990",
      "2001",
      "1955",
      "2018",
      "1969",
      "1970",
      "1900",
      "2025"
    ],
    "negativeContentExamples": [
      "1899",
      "2100",
      "0999",
      "20255",
      "201",
      "201A",
      "1975-06-01",
      "02/12/1980"
    ],
    "positiveHeaderExamples": [
      "year_of_birth",
      "birth_year",
      "dob_year",
      "person_birth_year",
      "birthyear",
      "yob",
      "yr_birth",
      "birth_year_num"
    ],
    "negativeHeaderExamples": [
      "birth_date",
      "age",
      "year_started",
      "hire_year",
      "expiry_year",
      "fiscal_year",
      "anniversary_year",
      "date_of_birth"
    ],
    "explanation": "PERSON.YEAR_OF_BIRTH identifies standalone four-digit birth years for individuals, enabling age calculations, cohort analysis, and demographic segmentation. It strictly matches plausible four-digit years with word boundaries, avoiding ambiguity with full dates or other year-like fields.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:01:58.983368"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_JA",
    "description": "This type captures Japanese postal codes used for mail distribution across Japan. The format consists of three digits, followed by a hyphen, then four more digits, creating a seven-digit code with mandatory hyphen separation.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{3}-[0-9]{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4900,
    "headerPatterns": [
      {
        "regExp": "(?i).*jp.*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "jp_postal_code"
        ],
        "negativeExamples": [
          "shipping_postal_code"
        ]
      },
      {
        "regExp": "(?i).*japan.*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "japan_postal_code"
        ],
        "negativeExamples": [
          "jp_postal_code"
        ]
      },
      {
        "regExp": "(?i).*jp.*postcode.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "jp_postcode"
        ],
        "negativeExamples": [
          "customer_postcode"
        ]
      },
      {
        "regExp": "(?i).*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "shipping_postal_code"
        ],
        "negativeExamples": [
          "postal_zone"
        ]
      },
      {
        "regExp": "(?i).*zip.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "zip_code_jp"
        ],
        "negativeExamples": [
          "postage_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "postal"
        ]
      }
    ],
    "positiveContentExamples": [
      "100-0001",
      "001-0000",
      "150-0002",
      "060-0042",
      "530-0001",
      "812-0011",
      "980-0021",
      "904-0323"
    ],
    "negativeContentExamples": [
      "1234567",
      "12-34567",
      "1234-567",
      "123-456",
      "123-45678",
      "123\u20134567",
      "\uff11\uff12\uff13-\uff14\uff15\uff16\uff17",
      "123-45A7"
    ],
    "positiveHeaderExamples": [
      "jp_postal_code",
      "japan_postal_code",
      "jp_postcode",
      "postal_code",
      "shipping_postal_code",
      "mailing_postcode",
      "zip_code_jp",
      "delivery_postal_code"
    ],
    "negativeHeaderExamples": [
      "postal_address",
      "zip_file",
      "shipping_city",
      "country",
      "region",
      "prefecture",
      "delivery_method",
      "contact_phone"
    ],
    "explanation": "Japanese postal codes follow a strict 3-4 digit structure with a mandatory hyphen separator (NNN-NNNN). This semantic type detects values that fit this exact format and is useful for validating addresses, standardizing mailing data, and geocoding tasks specific to Japan.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:02:10.267245"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_FR",
    "description": "This type identifies French postal codes used for mail delivery across France and its territories. The structure requires exactly five numeric digits arranged consecutively without any separators, alphabetic characters, or formatting.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4880,
    "headerPatterns": [
      {
        "regExp": "(?i).*code[ _]?postal[ _]?(fr|france).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code_postal_fr"
        ],
        "negativeExamples": [
          "postal_code_fr"
        ]
      },
      {
        "regExp": "(?i).*(fr|france)[ _]?postal[ _]?code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fr_postal_code"
        ],
        "negativeExamples": [
          "postal_code_uk"
        ]
      },
      {
        "regExp": "(?i).*postal[ _]?code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postal_code"
        ],
        "negativeExamples": [
          "area_code"
        ]
      },
      {
        "regExp": "(?i).*(cp|pc)[ _]?(fr|france).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cp_fr"
        ],
        "negativeExamples": [
          "cp_mx"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "postal"
        ]
      }
    ],
    "positiveContentExamples": [
      "01000",
      "13008",
      "75001",
      "69007",
      "97400",
      "97110",
      "98800",
      "20167"
    ],
    "negativeContentExamples": [
      "7500",
      "750001",
      "75 001",
      "75-001",
      "FR75001",
      "75001A",
      "0075001",
      "75001."
    ],
    "positiveHeaderExamples": [
      "code_postal",
      "code_postal_fr",
      "code_postal_france",
      "fr_postal_code",
      "postal_code_fr",
      "fr_postcode",
      "cp_fr",
      "zipcode_france"
    ],
    "negativeHeaderExamples": [
      "zip_code_us",
      "postal_code_uk",
      "province_code",
      "area_code",
      "customer_code",
      "country_code",
      "street_code",
      "cp_mx"
    ],
    "explanation": "French postal codes are five consecutive digits with no spaces, hyphens, or letters. This type is useful for validating and classifying address datasets where the country is France or its overseas territories. The pattern is intentionally strict to avoid matching other identifiers that may contain separators or alphabetic characters.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:02:12.664739"
  },
  {
    "resultType": "generated",
    "semanticType": "SPATIAL.GEOJSON",
    "description": "This type identifies GeoJSON formatted geometric objects used for spatial data representation in mapping and GIS applications. The structure follows JSON formatting with required type and coordinates fields, containing arrays of numeric coordinate pairs for geographic positioning.",
    "pluginType": "regex",
    "regexPattern": "\\b\\{\\s*\"(type|TYPE)\"\\s*:\\s*\"(Point|MultiPoint|LineString|MultiLineString|Polygon|MultiPolygon)\"\\s*,[^{}]*\"(coordinates|COORDINATES)\"\\s*:\\s*\\[\\s*[\\s\\[\\]\\-0-9\\.,eE\\+]+\\s*\\]\\s*\\}",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4990,
    "headerPatterns": [
      {
        "regExp": "(?i).*geometry.*geojson.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "geometry_geojson"
        ],
        "negativeExamples": [
          "geometry_json"
        ]
      },
      {
        "regExp": "(?i).*geom.*geojson.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "geom_geojson"
        ],
        "negativeExamples": [
          "geom_wkb"
        ]
      },
      {
        "regExp": "(?i).*shape.*geojson.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "shape_geojson"
        ],
        "negativeExamples": [
          "shapefile"
        ]
      },
      {
        "regExp": "(?i).*spatial.*geometry.*geojson.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "spatial_geometry_geojson"
        ],
        "negativeExamples": [
          "spatial_geometry_json"
        ]
      },
      {
        "regExp": "(?i).*geojson.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "geojson"
        ],
        "negativeExamples": [
          "json_geometry"
        ]
      }
    ],
    "positiveContentExamples": [
      "{\"type\":\"Point\",\"coordinates\":[-73.9857,40.7484]}",
      "{\"type\":\"Point\",\"coordinates\":[100,0]}",
      "{\"type\":\"LineString\",\"coordinates\":[[0,0],[10.5,-5.2]]}",
      "{\"type\":\"Polygon\",\"coordinates\":[[[30,10],[40,40],[20,40],[10,20],[30,10]]]}",
      "{\"type\":\"MultiPoint\",\"coordinates\":[[100.0,0.0],[101.0,1.0]]}",
      "{\"type\":\"MultiLineString\",\"coordinates\":[[[0,0],[1,1]],[[2,2],[3,3]]]}",
      "{\"type\":\"MultiPolygon\",\"coordinates\":[[[[0,0],[0,1],[1,1],[1,0],[0,0]]]]]}",
      "{\"type\":\"Polygon\",\"bbox\":[0,0,1,1],\"coordinates\":[[[0,0],[1,0],[1,1],[0,1],[0,0]]]}"
    ],
    "negativeContentExamples": [
      "{\"type\":Point,\"coordinates\":[-73.9857,40.7484]}",
      "{\"type\":\"Feature\",\"geometry\":{\"type\":\"Point\",\"coordinates\":[-73.9857,40.7484]}}",
      "{\"type\":\"Point\",\"coordinate\":[-73.9857,40.7484]}",
      "{\"type\":\"Point\",\"coordinates\":[-73.9857]}",
      "{\"type\":\"Point\",\"coordinates\":[[-73.9,40.7],[foo,bar]]}",
      "{\"coordinates\":[-73.9857,40.7484]}",
      "POINT(-73.9857 40.7484)",
      "{\"type\":\"Polygon\",\"coordinates\":\"[[[30,10],[40,40],[20,40],[10,20],[30,10]]]\"}"
    ],
    "positiveHeaderExamples": [
      "geometry_geojson",
      "geom_geojson",
      "shape_geojson",
      "spatial_geometry_geojson",
      "feature_geometry_geojson",
      "route_geojson",
      "parcel_geojson"
    ],
    "negativeHeaderExamples": [
      "geometry_json",
      "geometry_wkt",
      "geom_wkb",
      "topojson",
      "spatial_ref",
      "coordinates",
      "geo_shape",
      "wkt_geometry"
    ],
    "explanation": "SPATIAL.GEOJSON detects GeoJSON geometry objects represented as JSON strings that include a geometry type and a coordinates array containing numeric tuples. It is useful for classifying columns storing inlined GeoJSON geometries such as Point, LineString, Polygon, and their multi-variants. The header patterns prioritize columns explicitly labeled as geometry in GeoJSON form while still matching generic 'geojson' headers.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:02:13.495524"
  },
  {
    "resultType": "generated",
    "semanticType": "SPATIAL.WKT",
    "description": "This type represents Well-Known Text formatted spatial geometries used in geographic information systems and spatial databases. The format begins with a geometry type keyword followed by parentheses containing coordinate values separated by spaces and commas.",
    "pluginType": "regex",
    "regexPattern": "\\b(POINT|LINESTRING|POLYGON|MULTIPOINT|MULTILINESTRING|MULTIPOLYGON|GEOMETRYCOLLECTION)\\b\\s*(Z|M|ZM)?\\s*(EMPTY|\\([\\s0-9+\\-.,()]*\\d[\\s0-9+\\-.,()]*\\))",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 5000,
    "headerPatterns": [
      {
        "regExp": "(?i).*geometry.*wkt.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "geometry_wkt"
        ],
        "negativeExamples": [
          "geometry_json"
        ]
      },
      {
        "regExp": "(?i).*well.*known.*text.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "well_known_text"
        ],
        "negativeExamples": [
          "well_known_types"
        ]
      },
      {
        "regExp": "(?i).*geom.*wkt.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "geom_wkt"
        ],
        "negativeExamples": [
          "geom_json"
        ]
      },
      {
        "regExp": "(?i).*shape.*wkt.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "shape_wkt"
        ],
        "negativeExamples": [
          "shape_length"
        ]
      },
      {
        "regExp": "(?i).*wkt.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "wkt"
        ],
        "negativeExamples": [
          "geojson"
        ]
      }
    ],
    "positiveContentExamples": [
      "POINT (30 10)",
      "POINT Z (30 10 5)",
      "LINESTRING (30 10, 10 30, 40 40)",
      "POLYGON ((30 10, 40 40, 20 40, 10 20, 30 10))",
      "MULTIPOINT ((10 40), (40 30), (20 20), (30 10))",
      "MULTILINESTRING ((10 10, 20 20, 10 40), (40 40, 30 30, 40 20, 30 10))",
      "MULTIPOLYGON (((-73.99 40.75, -73.98 40.76, -73.97 40.75, -73.99 40.75)))",
      "GEOMETRYCOLLECTION (POINT (10 10), LINESTRING (10 10, 20 20))"
    ],
    "negativeContentExamples": [
      "POINT 30 10",
      "POLYLINE (30 10, 10 30)",
      "GEOMETRYCOLLECTION POINT (10 10), LINESTRING (10 10, 20 20)",
      "POINT()",
      "POINT (30 10",
      "LINESTRING 30 10, 10 30",
      "PT (30 10)",
      "ENVELOPE (30, 10, 40, 30)"
    ],
    "positiveHeaderExamples": [
      "geometry_wkt",
      "geom_wkt",
      "shape_wkt",
      "well_known_text",
      "spatial_wkt",
      "wkt",
      "geom_as_wkt"
    ],
    "negativeHeaderExamples": [
      "geometry_json",
      "geom",
      "shape_area",
      "geometry_type",
      "wkid",
      "geojson",
      "centroid_lat"
    ],
    "explanation": "WKT strings encode planar and geographic geometries as human-readable text, covering points, lines, polygons, and collections, with optional Z/M dimensions or EMPTY variants. This type is useful for detecting and parsing geometry fields in spatial databases and GIS exports where geometries are stored as WKT rather than as binary or structured JSON.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:02:15.484961"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_CO",
    "description": "This type identifies Colombian postal codes as they appear in addressing and mail delivery systems within Colombia. The codes consist of exactly six numerical digits assigned to specific cities, departments, and postal delivery zones for efficient mail processing and routing.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4850,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\b(colombia|colombian|co)\\b.*\\b(codigo[_ ]?postal|postal[_ ]?code|postalcode)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "colombia_postal_code"
        ],
        "negativeExamples": [
          "postal_code_br"
        ]
      },
      {
        "regExp": "(?i).*\\b(codigo[_ ]?postal|postal[_ ]?code|postalcode)\\b.*\\bco\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "codigo_postal_co"
        ],
        "negativeExamples": [
          "postal_code_us"
        ]
      },
      {
        "regExp": "(?i).*\\bzip[_ ]?code\\b.*\\bco\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "zip_code_co"
        ],
        "negativeExamples": [
          "zip_code"
        ]
      },
      {
        "regExp": "(?i).*\\bcp\\b.*\\bco\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cp_co"
        ],
        "negativeExamples": [
          "cp_mx"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "110111",
      "050001",
      "080020",
      "130014",
      "760001",
      "250210",
      "540006"
    ],
    "negativeContentExamples": [
      "12345",
      "1234567",
      "12-3456",
      "123 456",
      "12345A",
      "A23456",
      "12345O"
    ],
    "positiveHeaderExamples": [
      "colombia_postal_code",
      "postal_code_co",
      "codigo_postal_colombia",
      "co_codigo_postal",
      "co_postalcode",
      "zip_code_co",
      "cp_co"
    ],
    "negativeHeaderExamples": [
      "postal_code",
      "country_code",
      "us_zip_code",
      "postal_code_br",
      "area_code_co",
      "codigo_postal_mx",
      "zip"
    ],
    "explanation": "Detects Colombian postal codes formatted as exactly six digits using a strict digit-count pattern with word boundaries. Header patterns prioritize columns referencing Colombia (CO), codigo postal, or zip code to disambiguate from other 6-digit identifiers. Suitable for validation, standardization, and extraction of Colombian postal codes in address datasets.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:02:16.209524"
  },
  {
    "resultType": "generated",
    "semanticType": "NATIONALITY_NL",
    "description": "This type captures nationality designations as they are expressed in Dutch language for identification and demographic purposes in Dutch-speaking contexts. The values represent standard nationality terms following Dutch linguistic conventions and proper grammatical forms without abbreviations or alternative language expressions.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]{3,}(aans|aanse|ees|ezen|isch|ische|ijns|ijnse|iaans|iaanse|ier|iers|ierse|lands|landse|ks|kse|se)\\b|\\b[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]{2,}[ -][A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]{3,}(aans|aanse|ees|ezen|isch|ische|ijns|ijnse|iaans|iaanse|ier|iers|ierse|lands|landse|ks|kse|se)\\b|\\b[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]{2,}[ -][A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]{2,}[ -][A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]{3,}(aans|aanse|ees|ezen|isch|ische|ijns|ijnse|iaans|iaanse|ier|iers|ierse|lands|landse|ks|kse|se)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4710,
    "headerPatterns": [
      {
        "regExp": "(?i).*(nationaliteit|nationality)[ _-]*nl.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nationaliteit_nl"
        ],
        "negativeExamples": [
          "nationality_code"
        ]
      },
      {
        "regExp": "(?i).*(persoon|klant|burger).*[ _-]nationaliteit.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "klant_nationaliteit"
        ],
        "negativeExamples": [
          "klant_geboorteland"
        ]
      },
      {
        "regExp": "(?i).*(demoniem|herkomst).*[ _-]nl.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "herkomst_nl"
        ],
        "negativeExamples": [
          "herkomst_land"
        ]
      },
      {
        "regExp": "(?i).*(nat|national).*(ned|nl).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "nat_nl"
        ],
        "negativeExamples": [
          "nations"
        ]
      },
      {
        "regExp": "(?i).*nationaliteit.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nationaliteit"
        ],
        "negativeExamples": [
          "national_code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Nederlands",
      "Nederlandse",
      "Belgisch",
      "Belgische",
      "Duitse",
      "Franse",
      "Zuid-Afrikaanse",
      "Bosnisch-Herzegovijns"
    ],
    "negativeContentExamples": [
      "Nederland",
      "Belgi\u00eb",
      "Duitsland",
      "Frankrijk",
      "Spanje",
      "Itali\u00eb",
      "Dutch",
      "NL"
    ],
    "positiveHeaderExamples": [
      "nationaliteit",
      "nationaliteit_nl",
      "klant_nationaliteit",
      "burger_nationaliteit",
      "nationaliteit_nederlands",
      "herkomst_nl",
      "demoniem_nl",
      "persoon_nationaliteit"
    ],
    "negativeHeaderExamples": [
      "geboorteland",
      "land",
      "land_code",
      "taal",
      "national_code",
      "nationality",
      "woonland",
      "land_van_herkomst"
    ],
    "explanation": "This semantic type identifies Dutch-language demonyms (nationality terms), including common adjective and noun forms and their gendered variants, as standalone tokens or short hyphenated/multiword compounds. It is useful for classifying demographic attributes where nationality is recorded in Dutch rather than as country names or codes.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:02:17.532051"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.RACE_ABBR_EN",
    "description": "This type captures abbreviated racial and ethnic designations as they appear in demographic surveys, forms, and statistical analysis using shortened code formats. The values represent standard abbreviations for racial and ethnic categories following conventional demographic coding systems without full descriptive terms.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "W",
      "B",
      "A",
      "H",
      "NH",
      "AIAN",
      "NHPI",
      "PI",
      "ASN",
      "BLK",
      "WHT",
      "HISP",
      "LAT",
      "MR",
      "MENA",
      "OTH"
    ],
    "backout": "^[A-Z]{1,5}$",
    "confidenceThreshold": 93,
    "priority": 4790,
    "headerPatterns": [
      {
        "regExp": "(?i).*race.*ethni.*abbr.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "race_ethnicity_abbr"
        ],
        "negativeExamples": [
          "race_ethnicity_name"
        ]
      },
      {
        "regExp": "(?i).*race.*ethni.*code.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "race_ethnicity_code"
        ],
        "negativeExamples": [
          "ethnicity_code"
        ]
      },
      {
        "regExp": "(?i).*race.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "race_cd"
        ],
        "negativeExamples": [
          "race_name"
        ]
      },
      {
        "regExp": "(?i).*ethni.*code.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "ethnicity_cd"
        ],
        "negativeExamples": [
          "race_count"
        ]
      },
      {
        "regExp": "(?i).*cd.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "rce_cd"
        ],
        "negativeExamples": [
          "rec_id"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "W",
      "B",
      "A",
      "H",
      "NH",
      "AIAN",
      "NHPI",
      "WHT"
    ],
    "negativeContentExamples": [
      "Wh",
      "Blk",
      "AiAn",
      "HIS",
      "WHITE",
      "ASIAN",
      "N-H",
      "NHPI1"
    ],
    "positiveHeaderExamples": [
      "race_abbr",
      "race_ethnicity_abbr",
      "race_ethnicity_code",
      "race_cd",
      "ethnicity_cd",
      "rce_cd",
      "dem_race_code",
      "person_race_code"
    ],
    "negativeHeaderExamples": [
      "race_name",
      "ethnicity_desc",
      "race_category",
      "race_percentage",
      "language_code",
      "country_code",
      "gender_code",
      "person_id"
    ],
    "explanation": "Abbreviated English codes for race/ethnicity are commonly used in demographic datasets to compactly encode categories (e.g., W, B, A, H, AIAN, NHPI). This type is intended to recognize those concise codes rather than full descriptive labels. It intentionally excludes full-word labels (e.g., \"ASIAN\", \"WHITE\") and free-text descriptors, focusing on short uppercase abbreviations that are typical in code columns.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:02:24.601133"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_MX",
    "description": "This type represents postal codes used within Mexico's national postal system for mail delivery services. The format consists of exactly five consecutive numeric digits with no spaces, letters, hyphens, or other formatting characters.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4910,
    "headerPatterns": [
      {
        "regExp": "(?i).*postal.*code.*mx.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postal_code_mx"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      },
      {
        "regExp": "(?i).*mexico.*postal.*code.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "mexico_postal_code"
        ],
        "negativeExamples": [
          "mexico_area_code"
        ]
      },
      {
        "regExp": "(?i).*codigo.*postal.*mx.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "codigo_postal_mx"
        ],
        "negativeExamples": [
          "codigo_postal_ar"
        ]
      },
      {
        "regExp": "(?i).*mx.*zip.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "mx_zip"
        ],
        "negativeExamples": [
          "us_zip"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "postal"
        ]
      }
    ],
    "positiveContentExamples": [
      "01000",
      "02860",
      "06000",
      "11550",
      "20010",
      "44970",
      "64000",
      "97310"
    ],
    "negativeContentExamples": [
      "1000",
      "100000",
      "01 000",
      "01-000",
      "A1000",
      "1000A",
      "010.00",
      " 01000"
    ],
    "positiveHeaderExamples": [
      "postal_code_mx",
      "mexico_postal_code",
      "codigo_postal_mx",
      "cp_mx",
      "mx_postal",
      "mx_zip",
      "mx_zipcode"
    ],
    "negativeHeaderExamples": [
      "postal_code",
      "zip_code",
      "mexico_area_code",
      "codigo_postal_ar",
      "cp",
      "us_zip",
      "area_code_mx"
    ],
    "explanation": "This semantic type targets Mexican postal codes, which are exactly five digits with no separators or letters. It is suitable for datasets containing addresses in Mexico and relies on a strict numeric, fixed-length pattern. Header patterns emphasize Mexico-specific keywords (MX, Mexico, c\u00f3digo postal) to disambiguate from other five-digit postal systems such as US ZIP codes.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:02:24.618205"
  },
  {
    "resultType": "generated",
    "semanticType": "MONTH.ABBR_<LOCALE>",
    "description": "This type captures abbreviated month names as they appear in different locales and language contexts for date formatting and display purposes. The values represent standardized short forms of month names, typically three characters long, following locale-specific conventions and linguistic rules.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "JAN",
      "FEB",
      "MAR",
      "APR",
      "MAY",
      "JUN",
      "JUL",
      "AUG",
      "SEP",
      "OCT",
      "NOV",
      "DEC"
    ],
    "backout": "^[A-Z]{3}$",
    "confidenceThreshold": 98,
    "priority": 4600,
    "headerPatterns": [
      {
        "regExp": "(?i).*month[_ ]?abbr.*en.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "month_abbr_en"
        ],
        "negativeExamples": [
          "month_abbr"
        ]
      },
      {
        "regExp": "(?i).*mmm.*en.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mmm_en"
        ],
        "negativeExamples": [
          "mmm"
        ]
      },
      {
        "regExp": "(?i).*month[_ ]?abbr.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "month_abbreviation"
        ],
        "negativeExamples": [
          "year_abbreviation"
        ]
      },
      {
        "regExp": "(?i).*(mon[_ ]?abbr|mo[_ ]?abbr).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "mon_abbr"
        ],
        "negativeExamples": [
          "mon"
        ]
      },
      {
        "regExp": "(?i).*month.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "month"
        ],
        "negativeExamples": [
          "date"
        ]
      }
    ],
    "positiveContentExamples": [
      "JAN",
      "FEB",
      "MAR",
      "APR",
      "MAY",
      "JUN",
      "JUL",
      "AUG"
    ],
    "negativeContentExamples": [
      "SEPT",
      "JAN.",
      "Jan",
      "JANE",
      "00J",
      "AUGUST",
      "F\u00c9V",
      "Mar-"
    ],
    "positiveHeaderExamples": [
      "month_abbr_en",
      "month_short_en",
      "mmm_en",
      "month_abbreviation",
      "short_month",
      "mon_abbr",
      "mo_abbr",
      "month"
    ],
    "negativeHeaderExamples": [
      "month_name",
      "weekday_abbr_en",
      "fiscal_month_num",
      "date",
      "year",
      "mon",
      "abbr",
      "month_code"
    ],
    "explanation": "This semantic type recognizes English three-letter month abbreviations commonly used in formatted dates and calendar-related data. It is intended for fields storing month names in abbreviated form rather than numeric months or full month names, supporting consistent parsing and validation.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:02:40.285393"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_UY",
    "description": "This type represents postal codes used within Uruguay's postal system for mail routing and delivery services. The format consists of exactly five consecutive numeric digits without spaces, hyphens, or any non-numeric formatting characters.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4960,
    "headerPatterns": [
      {
        "regExp": "(?i).*(uruguay|uy).*(postal|post|zip).*(code|cod|cp).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "uy_postal_code"
        ],
        "negativeExamples": [
          "uruguay_country_code"
        ]
      },
      {
        "regExp": "(?i).*(postal|post).*(code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_postcode"
        ],
        "negativeExamples": [
          "postal_address"
        ]
      },
      {
        "regExp": "(?i).*zip.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "billing_zip_code"
        ],
        "negativeExamples": [
          "zip_region"
        ]
      },
      {
        "regExp": "(?i).*(cp|codigo.*postal).*(uy|uruguay).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "codigo_postal_uy"
        ],
        "negativeExamples": [
          "codigo_postal_ar"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "01000",
      "11050",
      "12900",
      "20003",
      "30150",
      "40570",
      "50001",
      "70005"
    ],
    "negativeContentExamples": [
      "1000",
      "100000",
      "12 345",
      "12-345",
      "1234A",
      "A1234",
      "123.45",
      "1 2345"
    ],
    "positiveHeaderExamples": [
      "uruguay_postal_code",
      "uy_postal_code",
      "codigo_postal_uy",
      "postcode_uruguay",
      "billing_zip_code_uy",
      "cp_uy",
      "customer_postal_code",
      "shipping_postcode"
    ],
    "negativeHeaderExamples": [
      "postal_address",
      "zip_region",
      "uruguay_province",
      "area_code",
      "country_code",
      "cp_us",
      "customer_postal_city",
      "postal_box"
    ],
    "explanation": "Identifies Uruguay postal codes composed of exactly five digits with no separators or letters. Useful for validating and parsing address data specific to Uruguay and for routing, deduplication, and geospatial joins. Because five-digit numeric codes are common in multiple countries, header context (e.g., presence of 'UY', 'Uruguay', or 'postal/postcode') is leveraged to disambiguate from other postal code systems such as generic ZIP codes.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:02:43.463368"
  },
  {
    "resultType": "generated",
    "semanticType": "LANGUAGE.ISO-639-2",
    "description": "This type identifies ISO 639-2 language codes, which are internationally standardized three-character alphabetic codes providing more comprehensive language coverage than the two-letter standard. The codes consist of exactly three lowercase letters and include both bibliographic and terminologic variants for some languages.",
    "pluginType": "regex",
    "regexPattern": "\\b[a-z]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4570,
    "headerPatterns": [
      {
        "regExp": "(?i).*iso.*639.*2.*language.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iso639_2_language_code"
        ],
        "negativeExamples": [
          "iso639_1_language_code"
        ]
      },
      {
        "regExp": "(?i).*iso.*639.*2.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iso_639_2_code"
        ],
        "negativeExamples": [
          "iso_639_1_code"
        ]
      },
      {
        "regExp": "(?i).*language.*3.*letter.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "language_3_letter_code"
        ],
        "negativeExamples": [
          "language_2_letter_code"
        ]
      },
      {
        "regExp": "(?i).*lang3.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lang3_code"
        ],
        "negativeExamples": [
          "lang_code"
        ]
      },
      {
        "regExp": "(?i).*iso.*639.*2.*language.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "language_iso639_2"
        ],
        "negativeExamples": [
          "language_iso639_1"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "eng",
      "spa",
      "fra",
      "fre",
      "deu",
      "ger",
      "zho",
      "jpn"
    ],
    "negativeContentExamples": [
      "ENg",
      "ENG",
      "Eng",
      "eng1",
      "en",
      "engl",
      "en-US",
      "spa_"
    ],
    "positiveHeaderExamples": [
      "iso639_2_language_code",
      "language_iso639_2",
      "iso_639_2_code",
      "lang3_code",
      "language_3_letter_code",
      "iso639_2_lang",
      "content_language_code_3",
      "primary_language_code"
    ],
    "negativeHeaderExamples": [
      "iso639_1_language_code",
      "locale_code",
      "country_code",
      "language_name",
      "language",
      "lang_code",
      "iso_code",
      "script_code"
    ],
    "explanation": "ISO 639-2 language codes are three-letter lowercase alphabetic identifiers for languages (including bibliographic and terminologic variants). This semantic type is useful for validating and classifying columns that store standardized 3-letter language codes across multilingual datasets, APIs, and metadata fields.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:02:48.891855"
  },
  {
    "resultType": "generated",
    "semanticType": "MONTH.DIGITS",
    "description": "This type identifies numeric month values as they appear in date representations and calendar systems using integer notation. The values range from 1 to 12 corresponding to the twelve months of the Gregorian calendar, with consistent numerical mapping across systems.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "10",
      "11",
      "12",
      "01",
      "02",
      "03",
      "04",
      "05",
      "06",
      "07",
      "08",
      "09"
    ],
    "backout": "^(0?[1-9]|1[0-2])$",
    "confidenceThreshold": 98,
    "priority": 4610,
    "headerPatterns": [
      {
        "regExp": "(?i).*(month|mo)[ _-]*(number|num|digit|digits).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "month_number"
        ],
        "negativeExamples": [
          "month_name"
        ]
      },
      {
        "regExp": "(?i).*billing[ _-]*month[ _-]*(number|num|digit|digits).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "billing_month_number"
        ],
        "negativeExamples": [
          "billing_date"
        ]
      },
      {
        "regExp": "(?i).*numeric[ _-]*month.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "numeric_month"
        ],
        "negativeExamples": [
          "month_text"
        ]
      },
      {
        "regExp": "(?i).*(fiscal|calendar)[ _-]*month.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fiscal_month"
        ],
        "negativeExamples": [
          "fiscal_year"
        ]
      },
      {
        "regExp": "(?i).*(mo|mth|mnth)[ _-]*(num|no|nbr|digit|digits).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mth_num"
        ],
        "negativeExamples": [
          "mo_name"
        ]
      },
      {
        "regExp": "(?i).*month.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "month"
        ],
        "negativeExamples": [
          "year"
        ]
      }
    ],
    "positiveContentExamples": [
      "1",
      "12",
      "09",
      "3",
      "10",
      "07",
      "2",
      "11"
    ],
    "negativeContentExamples": [
      "00",
      "13",
      "1.0",
      "001",
      "1/",
      "5-",
      "12a",
      " 9"
    ],
    "positiveHeaderExamples": [
      "month_number",
      "month_num",
      "billing_month_number",
      "fiscal_month",
      "mo_num",
      "mth_num",
      "numeric_month",
      "calendar_month"
    ],
    "negativeHeaderExamples": [
      "month_name",
      "month_text",
      "day_number",
      "fiscal_year",
      "year_quarter",
      "date",
      "timestamp",
      "weekday"
    ],
    "explanation": "Identifies standalone month values encoded as integers from 1 to 12, allowing both zero-padded (01\u201309) and non-padded (1\u20139) forms. Use when a column stores only the month component separate from day/year or as a parsed date part. Not intended for month names or full date strings.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:02:57.443415"
  },
  {
    "resultType": "generated",
    "semanticType": "LANGUAGE.ISO-639-1",
    "description": "This type identifies ISO 639-1 language codes, which are internationally standardized two-character alphabetic codes for language identification. The codes consist of exactly two lowercase letters derived from the language names and are used for internationalization and localization purposes.",
    "pluginType": "regex",
    "regexPattern": "\\b[a-z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4560,
    "headerPatterns": [
      {
        "regExp": "(?i).*language.*iso.*639.*1.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "language_iso_639_1_code"
        ],
        "negativeExamples": [
          "language_iso_639_code"
        ]
      },
      {
        "regExp": "(?i).*language.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "language_code"
        ],
        "negativeExamples": [
          "language_name"
        ]
      },
      {
        "regExp": "(?i).*lang.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lang_code"
        ],
        "negativeExamples": [
          "lang_name"
        ]
      },
      {
        "regExp": "(?i).*language.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "preferred_language"
        ],
        "negativeExamples": [
          "locale"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "status"
        ]
      }
    ],
    "positiveContentExamples": [
      "en",
      "fr",
      "es",
      "de",
      "zh",
      "pt",
      "ru",
      "ar"
    ],
    "negativeContentExamples": [
      "EN",
      "Fr",
      "eng",
      "e",
      "e1",
      "en-US",
      "pt_BR",
      "zh cn"
    ],
    "positiveHeaderExamples": [
      "language_iso_639_1_code",
      "iso6391_lang_code",
      "language_code",
      "lang_code",
      "ui_language_code",
      "content_language",
      "browser_lang",
      "preferred_language"
    ],
    "negativeHeaderExamples": [
      "country_code",
      "locale",
      "iso_3166_1_alpha2",
      "region",
      "currency_code",
      "time_zone",
      "script_code",
      "encoding"
    ],
    "explanation": "This semantic type classifies two-letter lowercase ISO 639-1 language codes used to represent languages in internationalization and localization contexts (for example, user interface language or content language fields). It is suited for datasets where values are compact language identifiers like en, fr, or zh, and header names reference language codes or ISO 639-1 conventions.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:03:02.142453"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.CANTON_CH",
    "description": "This type represents official Swiss canton codes used for identifying federal states within Switzerland's administrative system. The format consists of exactly two uppercase letters derived from the canton names without spaces, numbers, or special characters.",
    "pluginType": "regex",
    "regexPattern": "\\b(AG|AI|AR|BE|BL|BS|FR|GE|GL|GR|JU|LU|NE|NW|OW|SG|SH|SO|SZ|TG|TI|UR|VD|VS|ZG|ZH)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 5020,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\b(ch|swiss)\\b.*\\bcanton\\b.*\\bcode\\b.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "ch_canton_code"
        ],
        "negativeExamples": [
          "state_code"
        ]
      },
      {
        "regExp": "(?i).*\\b(canton|kanton)\\b.*\\bcode\\b.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "canton_code"
        ],
        "negativeExamples": [
          "country_code"
        ]
      },
      {
        "regExp": "(?i).*\\b(ch|swiss)\\b.*\\b(canton|kanton)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "swiss_canton"
        ],
        "negativeExamples": [
          "swiss_state"
        ]
      },
      {
        "regExp": "(?i).*\\b(ct|kt|cant)\\b.*\\bcode\\b.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "ct_code"
        ],
        "negativeExamples": [
          "ct_name"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "ZH",
      "ZG",
      "VD",
      "VS",
      "GE",
      "TI",
      "BE",
      "GR"
    ],
    "negativeContentExamples": [
      "NY",
      "CH",
      "EU",
      "ZRH",
      "be",
      "zh",
      "AGG",
      "OW1"
    ],
    "positiveHeaderExamples": [
      "ch_canton_code",
      "swiss_canton_code",
      "canton_code",
      "kanton_code",
      "swiss_canton",
      "ct_code",
      "ch_ct_code",
      "canton_ch_code"
    ],
    "negativeHeaderExamples": [
      "canton_name",
      "state",
      "province",
      "country",
      "region",
      "kanton_name",
      "swiss_state",
      "location"
    ],
    "explanation": "Swiss canton codes are a fixed set of two-letter uppercase abbreviations used to label the 26 cantons of Switzerland. This semantic type is useful for validating and classifying fields containing these codes in datasets such as addresses, regional aggregations, and administrative records. The regex precisely enumerates the valid tokens and requires whole-token matches via word boundaries to minimize false positives.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:03:03.417595"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.DEPARTMENT_NAME_FR",
    "description": "This type identifies French department names used for administrative identification within France's governmental structure. The format consists of proper noun text strings representing official department names in French without abbreviations or numerical codes.",
    "pluginType": "regex",
    "regexPattern": "\\b([\\p{L}]{2,}|[dlmsDLMS]['\u2019])([ -]([\\p{L}]{2,}|[dlmsDLMS]['\u2019]))*\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 5110,
    "headerPatterns": [
      {
        "regExp": "(?i).*departement.*name.*fr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "departement_name_fr"
        ],
        "negativeExamples": [
          "department_name"
        ]
      },
      {
        "regExp": "(?i).*french.*department.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "french_department_name"
        ],
        "negativeExamples": [
          "department_code"
        ]
      },
      {
        "regExp": "(?i).*(departement|department).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "department_name_fr"
        ],
        "negativeExamples": [
          "department_code"
        ]
      },
      {
        "regExp": "(?i).*(dept|dep).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "dept_name_fr"
        ],
        "negativeExamples": [
          "dept_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Ain",
      "Alpes-de-Haute-Provence",
      "C\u00f4tes-d'Armor",
      "Val-d'Oise",
      "Sa\u00f4ne-et-Loire",
      "Territoire de Belfort",
      "Loire-Atlantique",
      "Haute-Corse"
    ],
    "negativeContentExamples": [
      "Val d Oise",
      "75 Paris",
      "Alpes_de_Haute_Provence",
      "Haute-Corse 2B",
      "Ain.",
      "Guadeloupe (FR)",
      "Territoire de Belfort, France",
      "Seine Saint-Denis 93"
    ],
    "positiveHeaderExamples": [
      "departement_name_fr",
      "french_department_name",
      "departement_nom",
      "department_name_fr",
      "nom_departement_fr",
      "dept_name_fr",
      "dep_name_fr"
    ],
    "negativeHeaderExamples": [
      "region_name_fr",
      "department_code",
      "city_name_fr",
      "province_name",
      "country_name_fr",
      "postal_code",
      "iso_code"
    ],
    "explanation": "French department names are typically multi-word proper nouns with spaces, hyphens, and occasional apostrophes (e.g., d'). This regex allows only letters (including diacritics), spaces, hyphens, and apostrophes, and prohibits digits, underscores, and trailing punctuation to reduce false positives. Use this type to classify columns containing official department names in French without numeric codes or abbreviations; pair with header cues like 'departement_name_fr' for higher confidence.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:03:07.983774"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.FIRST_LAST",
    "description": "This type represents full personal names formatted in the first name followed by last name order, which is common in Western naming conventions. The values combine given names and family names separated by a single space without including middle names, titles, or additional name components.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z]{2,}([\\-'][A-Za-z]{2,})?\\s[A-Za-z]{2,}([\\-'][A-Za-z]{2,})?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4640,
    "headerPatterns": [
      {
        "regExp": "(?i).*first.*last.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "first_last_name"
        ],
        "negativeExamples": [
          "last_first_name"
        ]
      },
      {
        "regExp": "(?i).*given.*surname.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "given_surname"
        ],
        "negativeExamples": [
          "surname_given"
        ]
      },
      {
        "regExp": "(?i).*fname.*lname.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fname_lname"
        ],
        "negativeExamples": [
          "lname_fname"
        ]
      },
      {
        "regExp": "(?i).*(person|contact|employee).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "person_name"
        ],
        "negativeExamples": [
          "person_id"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "full_name"
        ],
        "negativeExamples": [
          "customer_id"
        ]
      }
    ],
    "positiveContentExamples": [
      "John Smith",
      "Alice Brown",
      "Peter O'Brien",
      "Anne-Marie Clark",
      "Maria Garcia",
      "David O'Neil",
      "Laura Taylor",
      "Brian Lee"
    ],
    "negativeContentExamples": [
      "John Q Smith",
      "Smith John",
      "John  Smith",
      "John",
      "John Smith Jr",
      "Dr John Smith",
      "John A. Smith",
      "John, Smith"
    ],
    "positiveHeaderExamples": [
      "first_last_name",
      "given_surname",
      "fname_lname",
      "person_name",
      "contact_name",
      "employee_name",
      "full_name",
      "customer_name"
    ],
    "negativeHeaderExamples": [
      "user_id",
      "account_holder",
      "last_first",
      "nickname",
      "handle",
      "company",
      "customer_id",
      "initials"
    ],
    "explanation": "This semantic type targets two-token personal names composed of a given name followed by a family name, separated by a single space. It allows internal hyphens or apostrophes within each token but excludes titles, suffixes, middle names/initials, commas, and multiple spaces. Use this to classify datasets storing simple first\u2013last personal names.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:03:08.834521"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_UK",
    "description": "This type identifies UK county names used for administrative and geographic identification throughout the United Kingdom. The format consists of proper noun text strings representing official county names in English without abbreviations or special formatting characters.",
    "pluginType": "regex",
    "regexPattern": "\\b(County [A-Z][a-z]+|Greater [A-Z][a-z]+|[A-Z][a-z]+shire|(North|South|East|West)( (East|West))? [A-Z][a-z]+|Isle of [A-Z][a-z]+|East Riding of [A-Z][a-z]+|Tyne and Wear)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5080,
    "headerPatterns": [
      {
        "regExp": "(?i).*(uk|united\\s*kingdom).*(county).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "uk_county_name"
        ],
        "negativeExamples": [
          "uk_county_code"
        ]
      },
      {
        "regExp": "(?i).*(county).*(uk|united\\s*kingdom).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "county_of_residence_uk"
        ],
        "negativeExamples": [
          "country_of_residence"
        ]
      },
      {
        "regExp": "(?i).*(british).*(county).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "british_county"
        ],
        "negativeExamples": [
          "british_country"
        ]
      },
      {
        "regExp": "(?i).*(residence|home).*(county).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "residence_county"
        ],
        "negativeExamples": [
          "residence_country"
        ]
      },
      {
        "regExp": "(?i).*(cty|cnty).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cty_name"
        ],
        "negativeExamples": [
          "city_name"
        ]
      },
      {
        "regExp": "(?i).*(county).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "county"
        ],
        "negativeExamples": [
          "country"
        ]
      }
    ],
    "positiveContentExamples": [
      "Oxfordshire",
      "West Midlands",
      "North Yorkshire",
      "East Sussex",
      "Greater Manchester",
      "County Antrim",
      "Isle of Wight",
      "East Riding of Yorkshire"
    ],
    "negativeContentExamples": [
      "City of London",
      "Durham County",
      "East-Sussex",
      "Greater-Manchester",
      "Isle ofWight",
      "East Riding Yorkshire",
      "Oxford shire",
      "N Yorkshire"
    ],
    "positiveHeaderExamples": [
      "uk_county_name",
      "county_name_uk",
      "british_county",
      "county_of_residence_uk",
      "residence_county",
      "county",
      "county_name",
      "uk_county"
    ],
    "negativeHeaderExamples": [
      "county_code",
      "country",
      "province",
      "state",
      "city",
      "borough",
      "local_authority",
      "us_county_name"
    ],
    "explanation": "This semantic type targets UK county names represented as natural-language proper nouns, emphasizing common structural patterns such as '-shire' endings, directional forms (e.g., West Midlands, North Yorkshire), and established multi-word constructs (Isle of Wight, East Riding of Yorkshire, County Antrim, Tyne and Wear). The regex avoids anchors and relies on word boundaries and explicit token structures to reduce false positives, focusing on known county-like formations rather than generic place names or codes.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:03:12.229116"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.CANTON_NAME_CH",
    "description": "This type identifies official Swiss canton names used to designate the federal states within Switzerland's political structure. The format consists of proper noun text strings representing the full canton names in their official language without abbreviations or codes.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "Z\u00dcRICH",
      "BERN",
      "LUZERN",
      "URI",
      "SCHWYZ",
      "OBWALDEN",
      "GLARUS",
      "ZUG",
      "FRIBOURG",
      "SOLOTHURN",
      "BASEL-STADT",
      "BASEL-LANDSCHAFT",
      "SCHAFFHAUSEN",
      "APPENZELL AUSSERRHODEN",
      "APPENZELL INNERRHODEN",
      "ST. GALLEN",
      "GRAUB\u00dcNDEN",
      "AARGAU",
      "THURGAU",
      "TICINO",
      "VAUD",
      "VALAIS",
      "NEUCH\u00c2TEL",
      "GEN\u00c8VE",
      "JURA"
    ],
    "backout": "^[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff][A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff .\\-\u2019']{1,30}$",
    "confidenceThreshold": 96,
    "priority": 5030,
    "headerPatterns": [
      {
        "regExp": "(?i).*(switzerland|ch).*canton.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Switzerland Canton Name"
        ],
        "negativeExamples": [
          "Switzerland Canton Code"
        ]
      },
      {
        "regExp": "(?i).*(swiss).*canton.*name.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Swiss Canton Name"
        ],
        "negativeExamples": [
          "Swiss Canton ID"
        ]
      },
      {
        "regExp": "(?i).*(canton|kanton|cantone|cant\u00f3n).*name.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Canton Name"
        ],
        "negativeExamples": [
          "Canton Code"
        ]
      },
      {
        "regExp": "(?i).*(canton|kanton|cantone|cant\u00f3n).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Canton"
        ],
        "negativeExamples": [
          "Province"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Z\u00fcrich",
      "Basel-Landschaft",
      "St. Gallen",
      "Gen\u00e8ve",
      "Graub\u00fcnden",
      "Appenzell Innerrhoden",
      "Vaud",
      "Fribourg"
    ],
    "negativeContentExamples": [
      "Zurich",
      "Berne",
      "St Gallen",
      "Basel Stadt",
      "Canton of Vaud",
      "ZH",
      "Graubuenden",
      "Valais-Wallis"
    ],
    "positiveHeaderExamples": [
      "Swiss Canton Name",
      "Switzerland Canton Name",
      "CH Canton Name",
      "Canton Full Name",
      "Canton Name (CH)",
      "Kanton Name",
      "Cantone Name"
    ],
    "negativeHeaderExamples": [
      "Swiss State Code",
      "CH Province Code",
      "Region",
      "Municipality",
      "District Code",
      "State Abbreviation",
      "Province",
      "Country"
    ],
    "explanation": "This semantic type captures the official full names of the 26 Swiss cantons, written in the canton\u2019s own official language(s), without abbreviations, codes, or added qualifiers. It is intended for fields where the content is a proper noun denoting a Swiss canton, such as geographic dimension attributes, administrative records, or location master data.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:03:16.116747"
  },
  {
    "resultType": "generated",
    "semanticType": "PERIOD.YEAR_RANGE",
    "description": "Identifies values representing a span of years expressed as a start year and an end year joined by a separator (hyphen, en/em dash, slash) or the word \"to\". Examples include 1999-2003, 1980/1985, and 2000 to 2000. This focuses strictly on year-to-year ranges without prefixes or suffixes and without months or days.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{4}\\s*(-|\u2013|\u2014|/)\\s*[0-9]{4}\\b|\\b[0-9]{4}\\s+[Tt][Oo]\\s+[0-9]{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4740,
    "headerPatterns": [
      {
        "regExp": "(?i).*(fiscal|validity|coverage)[_\\s-]*year[_\\s-]*range.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fiscal_year_range"
        ],
        "negativeExamples": [
          "birth_year"
        ]
      },
      {
        "regExp": "(?i).*(year[_\\s-]*to[_\\s-]*year|year[_\\s-]*start[_\\s-]*end).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "year_to_year"
        ],
        "negativeExamples": [
          "fiscal_year"
        ]
      },
      {
        "regExp": "(?i).*year[_\\s-]*(range|span).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "year_range"
        ],
        "negativeExamples": [
          "age_range"
        ]
      },
      {
        "regExp": "(?i).*(yr|yrs)[_\\s-]*(rng|range|span).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "yr_range"
        ],
        "negativeExamples": [
          "year"
        ]
      },
      {
        "regExp": "(?i).*year.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "years"
        ],
        "negativeExamples": [
          "date"
        ]
      }
    ],
    "positiveContentExamples": [
      "1999-2003",
      "2010 \u2013 2012",
      "1980/1985",
      "2000 to 2000",
      "1901\u20141905",
      "2021-2022",
      "0750-0755",
      "2015 to 2019"
    ],
    "negativeContentExamples": [
      "2010",
      "2010-12",
      "1999\u20132003\u20132004",
      "FY2010-2012",
      "2010/201",
      "20102012",
      "201a-2012",
      "2010 to2012"
    ],
    "positiveHeaderExamples": [
      "fiscal_year_range",
      "validity_year_range",
      "coverage_year_range",
      "year_range",
      "years_span",
      "yr_range",
      "year_to_year",
      "period_years"
    ],
    "negativeHeaderExamples": [
      "year",
      "birth_year",
      "fiscal_year",
      "date_range",
      "age_range",
      "quarter_range",
      "range",
      "start_end_date"
    ],
    "explanation": "This semantic type detects values that represent a year-to-year span where both endpoints are four-digit years connected by a clear separator (hyphen, en/em dash, slash) or the word \"to\" with spaces. It is useful for modeling validity periods, coverage spans, and historical intervals recorded at year granularity only, excluding single years, date ranges with months/days, and strings with prefixes or suffixes.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:03:22.755263"
  },
  {
    "resultType": "generated",
    "semanticType": "MACADDRESS",
    "description": "Identifies Media Access Control (MAC) addresses, the 48-bit hardware identifiers assigned to network interfaces. Values consist of six groups of two hexadecimal digits separated consistently by either colons or hyphens (e.g., 00:1A:2B:3C:4D:5E or 00-1A-2B-3C-4D-5E).",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9A-Fa-f]{2}([-:])[0-9A-Fa-f]{2}(\\1[0-9A-Fa-f]{2}){4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4590,
    "headerPatterns": [
      {
        "regExp": "(?i).*mac[ _-]*address.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "mac_address"
        ],
        "negativeExamples": [
          "ip_address"
        ]
      },
      {
        "regExp": "(?i).*(device|adapter|wifi|ethernet)[ _-]*mac.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "device_mac"
        ],
        "negativeExamples": [
          "mac_version"
        ]
      },
      {
        "regExp": "(?i).*(hardware|ethernet|physical)[ _-]*address.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "hardware_address"
        ],
        "negativeExamples": [
          "shipping_address"
        ]
      },
      {
        "regExp": "(?i).*\\bmac\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "wifi_mac"
        ],
        "negativeExamples": [
          "machine_id"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "physical_address"
        ],
        "negativeExamples": [
          "hostname"
        ]
      }
    ],
    "positiveContentExamples": [
      "00:1A:2B:3C:4D:5E",
      "aa:bb:cc:dd:ee:ff",
      "AF:0B:12:CD:34:EF",
      "01-23-45-67-89-ab",
      "FF-FF-FF-FF-FF-FF",
      "12-34-56-78-9A-BC",
      "00-00-00-00-00-00",
      "de:ad:be:ef:00:01"
    ],
    "negativeContentExamples": [
      "00:1A:2B:3C:4D",
      "00:1A:2B:3C:4D:5E:6F",
      "00:1G:2B:3C:4D:5E",
      "001A:2B:3C:4D:5E",
      "00-1A-2B-3C-4D-5E-",
      "00:1A-2B:3C-4D:5E",
      "001A.2B3C.4D5E",
      "00:1a:2b:3c:4d:5"
    ],
    "positiveHeaderExamples": [
      "mac_address",
      "device_mac",
      "ethernet_address",
      "hardware_address",
      "physical_address",
      "adapter_mac",
      "wifi_mac",
      "address"
    ],
    "negativeHeaderExamples": [
      "ip_address",
      "shipping_address",
      "email_address",
      "mac_version",
      "machine_id",
      "adapter_id",
      "hardware_id",
      "ethernet_speed"
    ],
    "explanation": "This semantic type targets MAC addresses used to uniquely identify network interfaces at the data link layer. It accepts colon- or hyphen-separated formats with exactly six octets of hexadecimal digits, with consistent separators and case-insensitive hex. Typical uses include network inventory, device telemetry, and security logs where hardware identifiers must be validated and standardized.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:03:23.368649"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.MIDDLE",
    "description": "This type captures middle names as they appear in personal identification and formal documentation between first and last names. The values represent additional given names using standard spelling conventions without including first names, surnames, titles, or middle initials.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z][a-z]{1,29}([\\-'][A-Z][a-z]{1,29})?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4670,
    "headerPatterns": [
      {
        "regExp": "(?i).*(middle[ _-]*name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "middle_name"
        ],
        "negativeExamples": [
          "first_name"
        ]
      },
      {
        "regExp": "(?i).*(middle[ _-]*given[ _-]*name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "middle given name"
        ],
        "negativeExamples": [
          "maiden name"
        ]
      },
      {
        "regExp": "(?i).*((second|additional|other)[ _-]*(given|forename)[ _-]*name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "second given name"
        ],
        "negativeExamples": [
          "preferred given name"
        ]
      },
      {
        "regExp": "(?i).*((m[ _-]*name)|(mid[ _-]*name)|(mn[ _-]*name)).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mname"
        ],
        "negativeExamples": [
          "lname"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "title"
        ]
      }
    ],
    "positiveContentExamples": [
      "Marie",
      "Elizabeth",
      "James",
      "Anne-Marie",
      "D'Angelo",
      "Louise",
      "Alexander",
      "Jean"
    ],
    "negativeContentExamples": [
      "M.",
      "J",
      "JAMES",
      "anne",
      "Mary Jane",
      "Anne_Marie",
      "John-Paul-Smith",
      "O'"
    ],
    "positiveHeaderExamples": [
      "middle_name",
      "middle name",
      "middle given name",
      "second given name",
      "additional given name",
      "other given name",
      "mname",
      "m name"
    ],
    "negativeHeaderExamples": [
      "first_name",
      "last_name",
      "maiden name",
      "preferred given name",
      "lname",
      "username",
      "middle_initial",
      "nickname"
    ],
    "explanation": "This semantic type is intended for columns that exclusively contain a person's middle name as a full given name, not initials. It supports standard capitalization, and permits a single hyphen or apostrophe within the name to accommodate common name constructions. Use this to isolate the middle component of a personal name in datasets where headers or context indicate the field stores middle names.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:03:24.372898"
  },
  {
    "resultType": "generated",
    "semanticType": "SSN",
    "description": "This type represents US Social Security Numbers used for individual identification and government benefit administration. The format consists of three digits, followed by a hyphen, two digits, another hyphen, then four final digits creating a structured nine-digit identifier.",
    "pluginType": "regex",
    "regexPattern": "\\b(?!000|666|9\\d\\d)\\d{3}-(?!00)\\d{2}-(?!0000)\\d{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5010,
    "headerPatterns": [
      {
        "regExp": "(?i).*social.*security.*number.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "social_security_number"
        ],
        "negativeExamples": [
          "social_security_code"
        ]
      },
      {
        "regExp": "(?i).*\\bus\\b.*\\bssn\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "us_ssn"
        ],
        "negativeExamples": [
          "employee_ssn"
        ]
      },
      {
        "regExp": "(?i).*\\bssn\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ssn"
        ],
        "negativeExamples": [
          "session_id"
        ]
      },
      {
        "regExp": "(?i).*\\bss\\b.*\\bnumber\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ss_number"
        ],
        "negativeExamples": [
          "subscriber_number"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "123-45-6789",
      "001-01-0001",
      "212-99-1234",
      "575-12-3456",
      "219-83-9021",
      "457-65-4321",
      "008-07-3456",
      "732-44-1987"
    ],
    "negativeContentExamples": [
      "123456789",
      "12-345-6789",
      "123-456-789",
      "000-12-3456",
      "666-12-3456",
      "987-65-4321",
      "123-00-4567",
      "123-45-0000"
    ],
    "positiveHeaderExamples": [
      "social_security_number",
      "ssn",
      "us_ssn",
      "employee_ssn",
      "applicant_social_security_number",
      "ss_number",
      "soc_sec_number",
      "primary_ssn"
    ],
    "negativeHeaderExamples": [
      "taxpayer_identification_number",
      "national_id_number",
      "employee_number",
      "session_id",
      "serial_number",
      "passport_number",
      "account_number",
      "phone_number"
    ],
    "explanation": "US Social Security Number in hyphenated 3-2-4 format with basic validity guards: area not 000/666/9xx, group not 00, and serial not 0000. Suitable for detecting columns containing full SSNs; excludes partials like last4 or unhyphenated strings. Header patterns prioritize explicit SSN and Social Security terms, falling back to more general 'number' only as a last resort.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:03:26.517423"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_CODE_BR",
    "description": "This type represents Brazilian municipality codes used for official statistical identification of municipal areas within Brazil's administrative system. The format consists of exactly seven consecutive numeric digits without spaces, letters, or special formatting characters for standardized municipal referencing.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{7}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5170,
    "headerPatterns": [
      {
        "regExp": "(?i).*(brazil|br).*(municipality|municipio).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality_code_br"
        ],
        "negativeExamples": [
          "municipality_code_mx"
        ]
      },
      {
        "regExp": "(?i).*(municipality|municipio).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality_code"
        ],
        "negativeExamples": [
          "municipality_name"
        ]
      },
      {
        "regExp": "(?i).*(muni|mun|munic).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "muni_code"
        ],
        "negativeExamples": [
          "muni_id"
        ]
      },
      {
        "regExp": "(?i).*city.*code.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "city_code_br"
        ],
        "negativeExamples": [
          "city_name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "id"
        ]
      }
    ],
    "positiveContentExamples": [
      "3550308",
      "5300108",
      "1100015",
      "2604106",
      "4216602",
      "1501402",
      "0100100",
      "0355030"
    ],
    "negativeContentExamples": [
      "355030",
      "35503089",
      "355 0308",
      "355-0308",
      "35503O8",
      "a3550308",
      "3550308a",
      "12345"
    ],
    "positiveHeaderExamples": [
      "municipality_code_br",
      "br_municipality_code",
      "brazil_municipality_code",
      "municipio_codigo",
      "municipality_code",
      "muni_code",
      "city_code_br",
      "municipal_code"
    ],
    "negativeHeaderExamples": [
      "municipality_name_br",
      "state_code_br",
      "country_code",
      "city_id",
      "zip_code_br",
      "municipality_code_mx",
      "br_municipality_id",
      "municipality"
    ],
    "explanation": "This semantic type identifies Brazilian municipality identifiers formatted as exactly seven digits, with no separators or letters. It is suitable for validating and classifying columns that store such municipality codes in administrative, statistical, and geographic datasets. The regex enforces strict length and numeric-only content to avoid confusion with postal codes, state codes, or generic IDs.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:03:26.568827"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.DISTRICT_NAME_IN",
    "description": "This type identifies Indian district names used for administrative identification within India's governmental structure. The format consists of proper noun text strings representing official district names in English or transliterated from local languages without abbreviations.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z][a-z]{2,})(\\s(and|of|[0-9]{1,3}|[A-Z][a-z]{2,})){0,5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5120,
    "headerPatterns": [
      {
        "regExp": "(?i).*(indian|india).*district.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "indian_district_name"
        ],
        "negativeExamples": [
          "district_name"
        ]
      },
      {
        "regExp": "(?i).*district.*name.*(in|india).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "district_name_in"
        ],
        "negativeExamples": [
          "indian_districts"
        ]
      },
      {
        "regExp": "(?i).*district.*name.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "district_name"
        ],
        "negativeExamples": [
          "state_name"
        ]
      },
      {
        "regExp": "(?i).*dist.*name.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "dist_name"
        ],
        "negativeExamples": [
          "state_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "South 24 Parganas",
      "Bengaluru Urban",
      "Dakshin Dinajpur",
      "East Khasi Hills",
      "Shahid Bhagat Singh Nagar",
      "Sri Ganganagar",
      "Kaimur",
      "Ahmedabad"
    ],
    "negativeContentExamples": [
      "SPSR Nellore",
      "North-24 Parganas",
      "South24 Parganas",
      "Bengaluru (Urban)",
      "EAST GODAVARI",
      "24 Parganas South",
      "S.A.S. Nagar",
      "North& 24 Parganas"
    ],
    "positiveHeaderExamples": [
      "indian_district_name",
      "district_name_in",
      "district_name",
      "dist_name",
      "in_district_name",
      "india_district_name",
      "district_full_name"
    ],
    "negativeHeaderExamples": [
      "state_name",
      "district_code",
      "tehsil_name",
      "city_name",
      "province_name",
      "subdistrict",
      "county_name"
    ],
    "explanation": "Use this type to recognize columns containing official Indian district names as proper nouns, often comprising one to five tokens, which may include a numeric token (e.g., 24) and simple connectors like 'and' or 'of'. It is suited for datasets where districts are provided without abbreviations or punctuation.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:03:28.483601"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_DE",
    "description": "This type identifies German postal codes (Postleitzahl) as they appear in addressing and mail delivery systems within Germany. The codes consist of exactly five numerical digits assigned to specific cities, districts, and postal delivery areas following the German postal system structure.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4860,
    "headerPatterns": [
      {
        "regExp": "(?i).*(german|de).*(postal.*code|postcode|postleitzahl|plz|zip.*code).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "german_postal_code"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      },
      {
        "regExp": "(?i).*(postleitzahl|plz).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "postleitzahl"
        ],
        "negativeExamples": [
          "postcode"
        ]
      },
      {
        "regExp": "(?i).*(postal.*code|postcode|zip.*code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postal_code"
        ],
        "negativeExamples": [
          "area_code"
        ]
      },
      {
        "regExp": "(?i).*(\\bplz\\b|\\bzip\\b).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "plz"
        ],
        "negativeExamples": [
          "zipper_length"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "10115",
      "20095",
      "50667",
      "60311",
      "80331",
      "01067",
      "04109",
      "28195"
    ],
    "negativeContentExamples": [
      "1011",
      "101150",
      "A10115",
      "10115B",
      "DE10115",
      "10 115",
      "10-115",
      "1234"
    ],
    "positiveHeaderExamples": [
      "german_postal_code",
      "de_postal_code",
      "postal_code_de",
      "postleitzahl",
      "de_plz",
      "zip_code_de",
      "plz",
      "recipient_postcode_de"
    ],
    "negativeHeaderExamples": [
      "city",
      "state",
      "country_name",
      "address_line",
      "phone",
      "customer_id",
      "shipping_region",
      "street_number"
    ],
    "explanation": "German postal codes are five-digit numeric identifiers used in mailing addresses throughout Germany. This semantic type is intended to detect standalone five-digit tokens that represent these postal codes in datasets such as shipping records, customer addresses, or logistics files. The header patterns prioritize explicit German context (DE/German and Postleitzahl/PLZ) and progressively broaden to generic postal code terms, with a final primitive hint on 'code' to allow flexible schema matching.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:03:30.183795"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_IE",
    "description": "This type identifies Irish county names used for geographic and administrative identification throughout Ireland. The format consists of proper noun text strings representing official county names in English without abbreviations, prefixes, or special formatting.",
    "pluginType": "regex",
    "regexPattern": "\\b(Antrim|Armagh|Carlow|Cavan|Clare|Cork|Donegal|Down|Dublin|Fermanagh|Galway|Kerry|Kildare|Kilkenny|Laois|Leitrim|Limerick|Longford|Louth|Mayo|Meath|Monaghan|Offaly|Roscommon|Sligo|Tipperary|Waterford|Westmeath|Wexford|Wicklow|Londonderry|Tyrone)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5070,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bcounty[_\\s-]?ie\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "county_ie"
        ],
        "negativeExamples": [
          "county_code"
        ]
      },
      {
        "regExp": "(?i).*\\b(irish|ireland|eire)[_\\s-]?county\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "irish_county"
        ],
        "negativeExamples": [
          "county_manager"
        ]
      },
      {
        "regExp": "(?i).*\\b(address|billing|shipping|home|residence)[_\\s-]?county\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "address_county"
        ],
        "negativeExamples": [
          "county_rate"
        ]
      },
      {
        "regExp": "(?i).*\\b(county[_\\s-]?name|cnty[_\\s-]?name|cty[_\\s-]?name)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "county_name"
        ],
        "negativeExamples": [
          "country_name"
        ]
      },
      {
        "regExp": "(?i).*county.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "county"
        ],
        "negativeExamples": [
          "country"
        ]
      }
    ],
    "positiveContentExamples": [
      "Dublin",
      "Cork",
      "Galway",
      "Limerick",
      "Tipperary",
      "Westmeath",
      "Londonderry",
      "Armagh"
    ],
    "negativeContentExamples": [
      "County Cork",
      "Co. Dublin",
      "Derry",
      "Dublin City",
      "West Meath",
      "Galway County",
      "MAYO",
      "offaly"
    ],
    "positiveHeaderExamples": [
      "county",
      "county_name",
      "county_ie",
      "irish_county",
      "address_county",
      "home_county",
      "billing_county",
      "county_of_residence"
    ],
    "negativeHeaderExamples": [
      "country",
      "province",
      "state",
      "city",
      "county_code",
      "county_id",
      "county_abbrev",
      "company"
    ],
    "explanation": "This semantic type identifies official English names of counties on the island of Ireland, suitable for validating or classifying county fields in addresses, locations, and administrative datasets. It excludes prefixes like 'County' or 'Co.' and requires the standalone county name in proper case.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:03:31.399467"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_CODE_NL",
    "description": "This type represents Dutch municipality codes used for official statistical identification of municipal areas within the Netherlands administrative system. The format consists of exactly four consecutive numeric digits without spaces, letters, or special formatting characters for standardized municipal referencing.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5180,
    "headerPatterns": [
      {
        "regExp": "(?i).*municipality[ _-]*code[ _-]*nl.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality_code_nl"
        ],
        "negativeExamples": [
          "municipality_name"
        ]
      },
      {
        "regExp": "(?i).*nl[ _-]*municipality[ _-]*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nl_municipality_code"
        ],
        "negativeExamples": [
          "postal_code_nl"
        ]
      },
      {
        "regExp": "(?i).*gemeente[ _-]*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gemeente_code"
        ],
        "negativeExamples": [
          "gemeentenaam"
        ]
      },
      {
        "regExp": "(?i).*municipality.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality"
        ],
        "negativeExamples": [
          "country"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "0012",
      "0143",
      "1023",
      "2741",
      "3107",
      "4589",
      "6204",
      "7991"
    ],
    "negativeContentExamples": [
      "123",
      "12345",
      "12 34",
      "12-34",
      "A234",
      "234B",
      "1.234",
      "202A"
    ],
    "positiveHeaderExamples": [
      "municipality_code_nl",
      "dutch_municipality_code",
      "nl_municipality_code",
      "gemeentecode",
      "gemeente_code",
      "municipal_code_nl",
      "municipality_code",
      "nl_gemeente_code"
    ],
    "negativeHeaderExamples": [
      "municipality_name",
      "country_code",
      "province_code",
      "postal_code_nl",
      "city_code",
      "gemeentenaam",
      "nl_municipality_name",
      "district_code"
    ],
    "explanation": "Dutch municipality codes are four-digit numeric identifiers used to reference municipalities in the Netherlands. This semantic type helps detect and validate these codes in datasets where they appear as compact, numeric tokens. The pattern is intentionally strict to exclude spaces, separators, or letters, and is paired with header cues to differentiate from other four-digit numbers such as years.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:03:33.158809"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_UK",
    "description": "This type captures UK postcodes used for mail routing throughout the United Kingdom postal system. It expects an outward code consisting of one or two letters followed by one digit and an optional alphanumeric character, a mandatory space, and an inward code of one digit and two letters (uppercase). Examples of accepted shapes include A9 9AA, A9A 9AA, AA9 9AA, AA9A 9AA, A99 9AA, and AA99 9AA.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z]{1,2}[0-9][0-9A-Z]?) [0-9][A-Z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4950,
    "headerPatterns": [
      {
        "regExp": "(?i).*(uk|gb).*(post.?code|postcode).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "uk_postal_code"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      },
      {
        "regExp": "(?i).*(post.?code|postcode).*(uk|gb).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postcode_uk"
        ],
        "negativeExamples": [
          "gb_address"
        ]
      },
      {
        "regExp": "(?i).*(post.?code|postcode).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gb_postcode"
        ],
        "negativeExamples": [
          "country_code"
        ]
      },
      {
        "regExp": "(?i).*pcode.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "pcode_uk"
        ],
        "negativeExamples": [
          "product_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "SW1A 1AA",
      "EC1A 1BB",
      "W1A 0AX",
      "M1 1AE",
      "B33 8TH",
      "CR2 6XH",
      "DN55 1PT",
      "N1C 4AG"
    ],
    "negativeContentExamples": [
      "SW1A1AA",
      "W1A-0AX",
      "EC1A1BB",
      "CR2 6X",
      "DN551PT",
      "M11AE",
      "SW 1A 1AA",
      "EC1 1B"
    ],
    "positiveHeaderExamples": [
      "uk_postal_code",
      "gb_postcode",
      "postcode_uk",
      "uk_postcode",
      "postal_code_gb",
      "delivery_postcode_uk",
      "recipient_uk_postcode",
      "british_postcode"
    ],
    "negativeHeaderExamples": [
      "postal_code",
      "zip_code",
      "country_postal_code",
      "area_code",
      "us_zip",
      "postal_code_ca",
      "address_code",
      "region_code"
    ],
    "explanation": "This semantic type identifies UK postcodes by enforcing the standard outward+inward structure with a mandatory space and uppercase alphanumeric tokens. It is suitable for validating and classifying columns containing UK postal addresses where strict UK postcode formatting is expected.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:03:33.802887"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.DISTRICT_NAME_PT",
    "description": "This type identifies Portuguese district names used for administrative identification within Portugal's governmental structure. The format consists of proper noun text strings representing official district names in Portuguese without abbreviations or special formatting characters.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AVEIRO",
      "BEJA",
      "BRAGA",
      "BRAGAN\u00c7A",
      "CASTELO BRANCO",
      "COIMBRA",
      "\u00c9VORA",
      "FARO",
      "GUARDA",
      "LEIRIA",
      "LISBOA",
      "PORTALEGRE",
      "PORTO",
      "SANTAR\u00c9M",
      "SET\u00daBAL",
      "VIANA DO CASTELO",
      "VILA REAL",
      "VISEU"
    ],
    "backout": "^[A-Z\u00c1\u00c2\u00c3\u00c0\u00c4\u00c9\u00ca\u00cd\u00d3\u00d4\u00d5\u00da\u00c7]{2,}( [A-Z\u00c1\u00c2\u00c3\u00c0\u00c4\u00c9\u00ca\u00cd\u00d3\u00d4\u00d5\u00da\u00c7]{2,}){0,3}$",
    "confidenceThreshold": 98,
    "priority": 5130,
    "headerPatterns": [
      {
        "regExp": "(?i).*(district|distrito).*(name|nome).*(pt|portugal).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "district_name_pt"
        ],
        "negativeExamples": [
          "district_name_en"
        ]
      },
      {
        "regExp": "(?i).*(nome.*distrito|distrito.*nome).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nome_distrito"
        ],
        "negativeExamples": [
          "district_code"
        ]
      },
      {
        "regExp": "(?i).*(pt|portugal).*(district|distrito).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "portugal_district"
        ],
        "negativeExamples": [
          "district_list"
        ]
      },
      {
        "regExp": "(?i).*(dist|distr).*(name|nome).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "distr_name"
        ],
        "negativeExamples": [
          "municipio_nome"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Lisboa",
      "\u00c9vora",
      "Bragan\u00e7a",
      "Viana do Castelo",
      "Castelo Branco",
      "Set\u00fabal",
      "Santar\u00e9m",
      "Vila Real"
    ],
    "negativeContentExamples": [
      "Lisbon",
      "Lisboa.",
      "Viana do Castello",
      "VilaReal",
      "Porto District",
      "Setubal",
      "A\u00e7ores",
      "Castelo Branco - PT"
    ],
    "positiveHeaderExamples": [
      "district_name_pt",
      "nome_distrito",
      "distrito",
      "distrito_nome",
      "pt_district",
      "district_name_portugal",
      "district_pt_name",
      "distr_name"
    ],
    "negativeHeaderExamples": [
      "district_name_en",
      "district_code",
      "district_list",
      "municipio",
      "concelho",
      "provincia",
      "region",
      "postcode"
    ],
    "explanation": "Portuguese district names are a finite, official set used to identify first-level administrative districts in mainland Portugal. This semantic type matches only exact district names in Portuguese and is best applied to columns storing district labels for addresses, administrative records, or territorial segmentation. The list-based approach ensures high precision by restricting matches to the official district set, while the backout pattern provides a controlled fallback on similarly shaped uppercase multi-word names.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:03:33.892489"
  },
  {
    "resultType": "generated",
    "semanticType": "LANGUAGE.TEXT_EN",
    "description": "This type captures natural language names as they are commonly expressed in English text and international communication. The values represent complete language names using standard English terminology and conventional spelling without abbreviated forms or codes.",
    "pluginType": "regex",
    "regexPattern": "\\b(([A-Z][a-z]+(-[A-Z][a-z]+)?)( [A-Z][a-z]+(-[A-Z][a-z]+)?){0,2} )?(([A-Z][a-z]+-){0,2})(English|Spanish|Portuguese|Chinese|Arabic|Gaelic|Slavonic|Croatian|Serbian|Bosnian|Hindi|Bengali|Russian|German|French|Italian|Japanese|Korean|Turkish|Persian|Farsi|Urdu|Swahili|Yoruba|Zulu|Amharic|Hebrew|Greek|Thai|Vietnamese|Indonesian|Malay|Polish|Czech|Slovak|Ukrainian|Belarusian|Bulgarian|Slovenian|Macedonian|Albanian|Romanian|Catalan|Basque|Galician|Welsh|Irish|Maltese|Norwegian|Danish|Swedish|Finnish|Estonian|Latvian|Lithuanian|Icelandic|Hungarian|Armenian|Georgian|Dutch|Latin)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4580,
    "headerPatterns": [
      {
        "regExp": "(?i).*primary.*language.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "primary_language"
        ],
        "negativeExamples": [
          "secondary_language"
        ]
      },
      {
        "regExp": "(?i).*preferred.*language.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "preferred_language"
        ],
        "negativeExamples": [
          "default_language"
        ]
      },
      {
        "regExp": "(?i).*spoken.*language.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "spoken_language"
        ],
        "negativeExamples": [
          "written_language"
        ]
      },
      {
        "regExp": "(?i).*user.*language.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "user_language"
        ],
        "negativeExamples": [
          "system_language"
        ]
      },
      {
        "regExp": "(?i).*language.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "language"
        ],
        "negativeExamples": [
          "country"
        ]
      }
    ],
    "positiveContentExamples": [
      "English",
      "Spanish",
      "Brazilian Portuguese",
      "Traditional Chinese",
      "Modern Standard Arabic",
      "Scottish Gaelic",
      "Old Church Slavonic",
      "Serbo-Croatian"
    ],
    "negativeContentExamples": [
      "en",
      "EN",
      "en-US",
      "English (UK)",
      "Chinese (Traditional)",
      "Portuguese - Brazil",
      "Germany",
      "English 2"
    ],
    "positiveHeaderExamples": [
      "language",
      "primary_language",
      "preferred_language",
      "native_language",
      "spoken_language",
      "user_language",
      "interface_language",
      "display_language"
    ],
    "negativeHeaderExamples": [
      "programming_language",
      "language_code",
      "locale",
      "country",
      "nationality",
      "mother_tongue_code",
      "translation",
      "script"
    ],
    "explanation": "Identifies English-text language names, including single and multi-word forms with common qualifiers and hyphenated compounds. It excludes codes and abbreviations, and disallows parentheses, commas, or numeric suffixes often seen in locale tags or metadata.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:03:37.632005"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.RACE_EN",
    "description": "This type captures racial and ethnic designations as they appear in demographic surveys, census forms, and diversity analysis using complete descriptive terminology. The values represent standard racial and ethnic categories following established demographic classification systems with full English language terms.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AMERICAN INDIAN OR ALASKA NATIVE",
      "AMERICAN INDIAN",
      "ALASKA NATIVE",
      "ASIAN",
      "EAST ASIAN",
      "SOUTH ASIAN",
      "SOUTHEAST ASIAN",
      "BLACK OR AFRICAN AMERICAN",
      "AFRICAN AMERICAN",
      "BLACK",
      "NATIVE HAWAIIAN OR OTHER PACIFIC ISLANDER",
      "PACIFIC ISLANDER",
      "WHITE",
      "CAUCASIAN",
      "HISPANIC OR LATINO",
      "NOT HISPANIC OR LATINO",
      "MIDDLE EASTERN OR NORTH AFRICAN",
      "TWO OR MORE RACES",
      "SOME OTHER RACE",
      "OTHER RACE"
    ],
    "backout": "^[A-Z][A-Z /-]{2,60}$",
    "confidenceThreshold": 94,
    "priority": 4800,
    "headerPatterns": [
      {
        "regExp": "(?i).*(race[ _-]*ethnic|ethnic[ _-]*race).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "race_ethnicity"
        ],
        "negativeExamples": [
          "race_code"
        ]
      },
      {
        "regExp": "(?i).*(ethnicity|ethnic[ _-]*origin).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ethnic_origin"
        ],
        "negativeExamples": [
          "race_group"
        ]
      },
      {
        "regExp": "(?i).*(race|racial)[ _-]*(category|group).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "racial_category"
        ],
        "negativeExamples": [
          "ethnicity"
        ]
      },
      {
        "regExp": "(?i).*(demographic|demo)[ _-]*race.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "demographics_race"
        ],
        "negativeExamples": [
          "demographic_region"
        ]
      },
      {
        "regExp": "(?i).*race.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "race"
        ],
        "negativeExamples": [
          "ethnicity"
        ]
      }
    ],
    "positiveContentExamples": [
      "WHITE",
      "BLACK OR AFRICAN AMERICAN",
      "ASIAN",
      "AMERICAN INDIAN OR ALASKA NATIVE",
      "NATIVE HAWAIIAN OR OTHER PACIFIC ISLANDER",
      "HISPANIC OR LATINO",
      "NOT HISPANIC OR LATINO",
      "MIDDLE EASTERN OR NORTH AFRICAN"
    ],
    "negativeContentExamples": [
      "WHITE/CAUCASIAN",
      "BLACK - AFRICAN AMERICAN",
      "HISPANIC",
      "NATIVE HAWAIIAN AND OTHER PACIFIC ISLANDER",
      "TWO OR MORE",
      "EUROPEAN",
      "MIDDLE EASTERN",
      "OTHER"
    ],
    "positiveHeaderExamples": [
      "race_ethnicity",
      "racial_ethnic_group",
      "ethnicity",
      "ethnic_origin",
      "race_category",
      "demographics_race",
      "primary_race",
      "self_identified_race"
    ],
    "negativeHeaderExamples": [
      "country_of_birth",
      "nationality",
      "gender",
      "language",
      "citizenship_status",
      "religion",
      "age_group",
      "customer_segment"
    ],
    "explanation": "PERSON.RACE_EN classifies values representing racial and ethnic categories expressed in full English terms as commonly collected in demographic and DEI contexts. It is useful for profiling, schema inference, and validation of columns that store respondents' self-identified race/ethnicity using standard, descriptive labels rather than codes or abbreviations.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:03:37.792923"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_CO",
    "description": "This type identifies Colombian municipality names used for local administrative identification within Colombia's governmental structure. The format consists of proper noun text strings representing official municipality names in Spanish without abbreviations or special formatting characters.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc]+|[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc]{2,})(\\s((de|del|la|las|los|y)|([A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc]+|[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc]{2,}))){0,5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5160,
    "headerPatterns": [
      {
        "regExp": "(?i).*(municipality|municipio).*(name|nombre).*(colombia|co).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality_name_co"
        ],
        "negativeExamples": [
          "department_name_co"
        ]
      },
      {
        "regExp": "(?i).*(colombia|co).*(municipality|municipio).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "co_municipality"
        ],
        "negativeExamples": [
          "co_department"
        ]
      },
      {
        "regExp": "(?i).*(municipality|municipio).*(name|nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipio_nombre"
        ],
        "negativeExamples": [
          "municipio_codigo"
        ]
      },
      {
        "regExp": "(?i).*(municipality|municipio).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality"
        ],
        "negativeExamples": [
          "department"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Medell\u00edn",
      "Bogot\u00e1",
      "Cartagena de Indias",
      "San Jos\u00e9 del Guaviare",
      "El Carmen de Bol\u00edvar",
      "Puerto Carre\u00f1o",
      "Santander de Quilichao",
      "Villa de Leyva"
    ],
    "negativeContentExamples": [
      "Bogot\u00e1 D.C.",
      "Santa_Rosa de Cabal",
      "Villa-de-Leyva",
      "Cartagena d Indias",
      "San jose de C\u00facuta",
      "C\u00facuta, Norte de Santander",
      "San Andr\u00e9s de Sotavento 2023",
      "Leticia (Amazonas)"
    ],
    "positiveHeaderExamples": [
      "municipality_name_co",
      "co_municipality",
      "municipality_colombia",
      "municipio_nombre",
      "colombian_municipality_name",
      "municipality_co",
      "co_municipality_name",
      "nombre_municipio_co"
    ],
    "negativeHeaderExamples": [
      "department_name_co",
      "state_province_name",
      "city_name",
      "municipality_code_co",
      "country_name",
      "postal_code",
      "locality",
      "township_name"
    ],
    "explanation": "This semantic type is intended to classify Colombian municipality names as they appear in datasets for administrative, demographic, and geographic analysis. It focuses on proper-noun forms in Spanish, allowing multi-word names with common Spanish connectors while excluding abbreviations, digits, and punctuation.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:03:39.137874"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_AU",
    "description": "This type identifies Australian postal codes as they appear in addressing and mail delivery systems throughout Australia. The codes consist of exactly four numerical digits assigned to specific geographic regions, suburbs, and localities for efficient mail processing and delivery routing.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4820,
    "headerPatterns": [
      {
        "regExp": "(?i).*(billing|shipping|delivery|mail|address).*(australia|au).*(post.?code|postcode).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "billing_postcode_au"
        ],
        "negativeExamples": [
          "billing_zip_code"
        ]
      },
      {
        "regExp": "(?i).*(australia|au).*(post.?code|postcode).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "au_postcode"
        ],
        "negativeExamples": [
          "au_area_code"
        ]
      },
      {
        "regExp": "(?i).*(address|recipient|customer).*(post.?code|postcode).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "recipient_postcode"
        ],
        "negativeExamples": [
          "recipient_code"
        ]
      },
      {
        "regExp": "(?i).*postcode.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postcode"
        ],
        "negativeExamples": [
          "post_id"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "number"
        ]
      }
    ],
    "positiveContentExamples": [
      "0800",
      "0822",
      "2000",
      "2600",
      "3000",
      "4000",
      "6000",
      "7000"
    ],
    "negativeContentExamples": [
      "200",
      "20000",
      "2 000",
      "2,000",
      "200A",
      "A200",
      "20O0",
      "2019-"
    ],
    "positiveHeaderExamples": [
      "au_postcode",
      "australia_postal_code",
      "billing_postcode_au",
      "ship_to_postcode_au",
      "recipient_postcode",
      "delivery_post_code",
      "customer_postcode",
      "postcode"
    ],
    "negativeHeaderExamples": [
      "zip_code",
      "area_code",
      "country_code",
      "invoice_code",
      "postal_area",
      "post_id",
      "address_line1",
      "routing_number"
    ],
    "explanation": "Australian postcodes are exactly four digits and commonly appear in address-related columns. This type uses a strict four-digit word-bounded regex to classify values while header patterns focus on AU-specific and postcode-oriented column names to reduce confusion with other numeric fields such as years or generic codes.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:03:40.952777"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.ZIP5_PLUS4_US",
    "description": "This type captures extended US postal codes used for precise mail delivery within the United States Postal Service system. The format consists of five digits, followed by a hyphen, then four additional digits creating a nine-digit postal identifier.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{5}-\\d{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4970,
    "headerPatterns": [
      {
        "regExp": "(?i).*(usps|postal|zipcode|zip).*\\+[-_ ]*4.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "usps_zip+4_code"
        ],
        "negativeExamples": [
          "zipcode"
        ]
      },
      {
        "regExp": "(?i).*(zip9|zip[-_ ]*9).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "zip9"
        ],
        "negativeExamples": [
          "zip5"
        ]
      },
      {
        "regExp": "(?i).*(us|usps).*zip.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "us_zip_code"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      },
      {
        "regExp": "(?i).*(postal|zip).*code.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "extended_zip_code"
        ],
        "negativeExamples": [
          "postal_area"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "number"
        ]
      }
    ],
    "positiveContentExamples": [
      "02139-4307",
      "10001-0001",
      "30309-1234",
      "60614-5678",
      "94105-1230",
      "75201-4321",
      "33109-0000",
      "48104-9876"
    ],
    "negativeContentExamples": [
      "021394307",
      "02139-430",
      "02139-43077",
      "2139-4307",
      "02139 4307",
      "02139\u20134307",
      "02139-43O7",
      "02139- 4307"
    ],
    "positiveHeaderExamples": [
      "zip+4",
      "zipcode_plus4",
      "usps_zip+4_code",
      "zip9",
      "zip9_code",
      "postal_zip+4",
      "us_zipplus4",
      "extended_zip_code"
    ],
    "negativeHeaderExamples": [
      "zip",
      "zipcode",
      "postal_code",
      "zip4",
      "zip_suffix",
      "zip5",
      "postcode",
      "city_zipcode"
    ],
    "explanation": "Use this semantic type to detect and validate extended USPS ZIP+4 codes that follow the strict 5-digit, hyphen, 4-digit pattern. It is suitable for datasets requiring high-precision US mail routing and address normalization.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:03:45.904993"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_CA",
    "description": "This type identifies Canadian postal codes as they appear in addressing and mail delivery systems throughout Canada. The codes follow a specific pattern of alternating letters and numbers in six characters, formatted with a space between the third and fourth characters for readability.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z][0-9][A-Z] [0-9][A-Z][0-9]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4840,
    "headerPatterns": [
      {
        "regExp": "(?i).*canadian[_ ]*postal[_ ]*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "canadian_postal_code"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      },
      {
        "regExp": "(?i).*postal[_ ]*code[_ ]*ca.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postal_code_ca"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      },
      {
        "regExp": "(?i).*postcode[_ ]*(ca|canada).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postcode_ca"
        ],
        "negativeExamples": [
          "postcode_uk"
        ]
      },
      {
        "regExp": "(?i).*(postal[_ ]*code|postcode).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postal_code"
        ],
        "negativeExamples": [
          "area_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "K1A 0B1",
      "H2Z 1A7",
      "V6B 4N5",
      "T2P 3G7",
      "B3J 2K9",
      "M5V 2T6",
      "R2C 0A1",
      "S7K 3M9"
    ],
    "negativeContentExamples": [
      "K1A0B1",
      "K1A-0B1",
      "K1A 0B",
      "KA1 0B1",
      "1KA 0B1",
      "M5V  2T6",
      "M5V 2TG",
      "M5 2T6"
    ],
    "positiveHeaderExamples": [
      "canadian_postal_code",
      "postal_code_ca",
      "ca_postal_code",
      "postcode_ca",
      "canada_postal_code",
      "delivery_postal_code_ca",
      "postalcode_canada"
    ],
    "negativeHeaderExamples": [
      "zip_code",
      "postal_address",
      "country_code",
      "state_province",
      "postal_zone",
      "area_code",
      "province_code"
    ],
    "explanation": "Canadian postal codes follow a strict alphanumeric pattern of three characters, a space, and three characters (letter-digit-letter space digit-letter-digit). This semantic type helps identify and validate Canadian postal code fields in datasets, improving data quality for addressing, geocoding, and logistics workflows.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:03:46.069934"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_CA",
    "description": "This type identifies official Canadian province names used to designate provinces and territories within Canada's federal structure. The format consists of proper noun text strings representing full province names in English without abbreviations or codes.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "ALBERTA",
      "BRITISH COLUMBIA",
      "MANITOBA",
      "NEW BRUNSWICK",
      "NEWFOUNDLAND AND LABRADOR",
      "NOVA SCOTIA",
      "ONTARIO",
      "PRINCE EDWARD ISLAND",
      "QUEBEC",
      "SASKATCHEWAN",
      "NORTHWEST TERRITORIES",
      "NUNAVUT",
      "YUKON"
    ],
    "backout": "^[A-Z ]{5,30}$",
    "confidenceThreshold": 98,
    "priority": 5240,
    "headerPatterns": [
      {
        "regExp": "(?i).*(canada|ca).*(province|territory).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "canada_province_name"
        ],
        "negativeExamples": [
          "canada_province_code"
        ]
      },
      {
        "regExp": "(?i).*province.*name.*ca.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province_name_ca"
        ],
        "negativeExamples": [
          "province_abbr_ca"
        ]
      },
      {
        "regExp": "(?i).*(canada|ca).*(province|territory).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "ca_province"
        ],
        "negativeExamples": [
          "country_province"
        ]
      },
      {
        "regExp": "(?i).*(state[_ ]?province|prov).*name.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "state_province_name"
        ],
        "negativeExamples": [
          "state_province_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Alberta",
      "British Columbia",
      "Manitoba",
      "New Brunswick",
      "Newfoundland and Labrador",
      "Nova Scotia",
      "Ontario",
      "Prince Edward Island"
    ],
    "negativeContentExamples": [
      "Quebec City",
      "BC",
      "Ontario, Canada",
      "Newfoundland & Labrador",
      "Yukon Territory",
      "Nova-Scotia",
      "Prince Edward Island (PEI)",
      "Northwest Territory"
    ],
    "positiveHeaderExamples": [
      "canada_province_name",
      "province_name_ca",
      "ca_province",
      "canadian_territory_name",
      "state_province_name",
      "province_or_territory",
      "province",
      "territory_name"
    ],
    "negativeHeaderExamples": [
      "country_name",
      "province_code",
      "state_name_us",
      "city_name",
      "region",
      "postal_code",
      "province_abbr",
      "country_province"
    ],
    "explanation": "This semantic type is a finite list of the official English names of Canadian provinces and territories. It is best used to validate or classify columns containing full province/territory names without abbreviations or appended qualifiers. The list plugin ensures precise matching against known names, while the anchored backout provides a broader shape for fallback checks.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:03:46.311754"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.INSEE_CODE_FR",
    "description": "This type represents French INSEE codes used for official statistical identification of communes within France's administrative system. The format consists of exactly five consecutive numeric digits without spaces, letters, or special formatting characters for standardized territorial referencing.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5140,
    "headerPatterns": [
      {
        "regExp": "(?i).*commune.*insee.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "commune_insee_code"
        ],
        "negativeExamples": [
          "commune_postal_code"
        ]
      },
      {
        "regExp": "(?i).*commune.*code.*insee.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "commune_code_insee"
        ],
        "negativeExamples": [
          "department_code_insee"
        ]
      },
      {
        "regExp": "(?i).*insee.*commune.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "insee_commune"
        ],
        "negativeExamples": [
          "insee_departement"
        ]
      },
      {
        "regExp": "(?i).*insee.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "insee_code"
        ],
        "negativeExamples": [
          "product_code"
        ]
      },
      {
        "regExp": "(?i).*insee.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "insee"
        ],
        "negativeExamples": [
          "census"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "01001",
      "75056",
      "13055",
      "59350",
      "06088",
      "33063",
      "97105",
      "69123"
    ],
    "negativeContentExamples": [
      "1234",
      "123456",
      "12 345",
      "12-345",
      "2A123",
      "075O6",
      "A12345",
      "12345B"
    ],
    "positiveHeaderExamples": [
      "commune_insee_code",
      "insee_code",
      "code_insee",
      "insee_commune",
      "commune_code_insee",
      "code_commune_insee",
      "insee_identifier",
      "insee_ref"
    ],
    "negativeHeaderExamples": [
      "commune_postal",
      "postal",
      "department_identifier",
      "municipality_id",
      "commune_number",
      "region_reference",
      "city_postal",
      "department_name"
    ],
    "explanation": "French commune INSEE codes are five-digit numeric identifiers used in official statistics and administrative datasets. This semantic type detects standalone five-digit numeric tokens and is best combined with header cues containing 'insee' to distinguish from other five-digit numbers such as postal codes.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:03:47.644654"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PREFECTURE_NAME_JA",
    "description": "This type identifies Japanese prefecture names used for regional administrative identification within Japan's governmental structure. The format consists of proper noun text strings representing official prefecture names in Japanese characters without abbreviations or romanization.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "\u6771\u4eac\u90fd",
      "\u5317\u6d77\u9053",
      "\u5927\u962a\u5e9c",
      "\u4eac\u90fd\u5e9c",
      "\u795e\u5948\u5ddd\u770c",
      "\u5343\u8449\u770c",
      "\u57fc\u7389\u770c",
      "\u611b\u77e5\u770c",
      "\u5175\u5eab\u770c",
      "\u798f\u5ca1\u770c",
      "\u9759\u5ca1\u770c",
      "\u8328\u57ce\u770c",
      "\u65b0\u6f5f\u770c",
      "\u9577\u91ce\u770c",
      "\u5c90\u961c\u770c",
      "\u4e09\u91cd\u770c",
      "\u5ca1\u5c71\u770c",
      "\u5e83\u5cf6\u770c",
      "\u5c71\u53e3\u770c",
      "\u5bae\u57ce\u770c",
      "\u6c96\u7e04\u770c",
      "\u9e7f\u5150\u5cf6\u770c",
      "\u718a\u672c\u770c",
      "\u9999\u5ddd\u770c",
      "\u77f3\u5ddd\u770c"
    ],
    "backout": "^[\\u4E00-\\u9FFF\u3005\u30f6]{2,3}(\u90fd|\u9053|\u5e9c|\u770c)$",
    "confidenceThreshold": 98,
    "priority": 5210,
    "headerPatterns": [
      {
        "regExp": "(?i).*(jp|ja|jpn).*prefecture.*name.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "jp_prefecture_name"
        ],
        "negativeExamples": [
          "prefecture_name_ja"
        ]
      },
      {
        "regExp": "(?i).*\u90fd\u9053\u5e9c\u770c\u540d.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "\u90fd\u9053\u5e9c\u770c\u540d"
        ],
        "negativeExamples": [
          "\u90fd\u9053\u5e9c\u770c\u30b3\u30fc\u30c9"
        ]
      },
      {
        "regExp": "(?i).*(pref[_ ]?name|pref[_ ]?nm|todofuken[_ ]?name).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "pref_nm"
        ],
        "negativeExamples": [
          "pref_code"
        ]
      },
      {
        "regExp": "(?i).*(prefecture|\u90fd\u9053\u5e9c\u770c).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "prefecture"
        ],
        "negativeExamples": [
          "province"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "title"
        ]
      }
    ],
    "positiveContentExamples": [
      "\u6771\u4eac\u90fd",
      "\u5317\u6d77\u9053",
      "\u5927\u962a\u5e9c",
      "\u4eac\u90fd\u5e9c",
      "\u795e\u5948\u5ddd\u770c",
      "\u798f\u5ca1\u770c",
      "\u6c96\u7e04\u770c",
      "\u9e7f\u5150\u5cf6\u770c"
    ],
    "negativeContentExamples": [
      "\u6771\u4eac",
      "\u795e\u5948\u5ddd",
      "\u5317\u6d77\u9053\u770c",
      "\u4eac\u90fd\u5e02",
      "\u6771\u4eac\u90fd\u533a",
      "Tokyo",
      "\u304b\u306a\u304c\u308f\u770c",
      "\u9752\u68ee\u770c\u9752\u68ee\u5e02"
    ],
    "positiveHeaderExamples": [
      "jp_prefecture_name",
      "prefecture_name_ja",
      "\u90fd\u9053\u5e9c\u770c\u540d",
      "pref_name",
      "todofuken_name",
      "pref_nm",
      "prefecture",
      "\u90fd\u9053\u5e9c\u770c"
    ],
    "negativeHeaderExamples": [
      "prefecture_code",
      "province_name",
      "city_name",
      "state_province",
      "prefecture_id",
      "pref_code_ja",
      "language_name",
      "country_name"
    ],
    "explanation": "Recognizes official Japanese prefecture names written in Japanese characters and ending with \u90fd, \u9053, \u5e9c, or \u770c. Useful for validating location dimensions in Japanese datasets, address normalization, and regional aggregation when columns contain full prefecture names rather than codes or romanized forms.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:03:50.254363"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.ZIP5_US",
    "description": "This type represents standard US postal codes used for mail routing throughout the United States Postal Service network. The format consists of exactly five consecutive numeric digits without spaces, hyphens, or any additional formatting characters.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4980,
    "headerPatterns": [
      {
        "regExp": "(?i).*us[-_ ]?zip[-_ ]?5.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "us_zip5"
        ],
        "negativeExamples": [
          "eu_zip5"
        ]
      },
      {
        "regExp": "(?i).*zip[-_ ]?code[-_ ]?5.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "zip_code_5"
        ],
        "negativeExamples": [
          "zip_code_4"
        ]
      },
      {
        "regExp": "(?i).*us[-_ ]?zipcode.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "us_zipcode"
        ],
        "negativeExamples": [
          "ca_zipcode"
        ]
      },
      {
        "regExp": "(?i).*zipcode.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "zipcode"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      },
      {
        "regExp": "(?i).*zip.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "zip"
        ],
        "negativeExamples": [
          "post_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "zip"
        ]
      }
    ],
    "positiveContentExamples": [
      "00544",
      "02139",
      "07030",
      "10001",
      "30301",
      "60614",
      "73301",
      "96815"
    ],
    "negativeContentExamples": [
      "1234",
      "123456",
      "12345-6789",
      "12 345",
      "A2345",
      "01234 ",
      " 01234",
      "1234O"
    ],
    "positiveHeaderExamples": [
      "us_zip5",
      "zip_code_5",
      "us_zipcode",
      "zipcode",
      "zip",
      "code",
      "shipping_zip5"
    ],
    "negativeHeaderExamples": [
      "eu_zip5",
      "zip_code_4",
      "ca_zipcode",
      "postal_code",
      "post_code",
      "id"
    ],
    "explanation": "Identifies five-digit US ZIP codes with strict numeric-only content and fixed length. Useful for validating and profiling US mailing address fields where only the 5-digit base ZIP is expected, excluding ZIP+4 and any formatted variants. The value pattern uses word boundaries to avoid matching digits embedded within longer tokens while remaining unanchored for FTA compatibility.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:03:51.348573"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_EC",
    "description": "This type identifies Ecuadorian province names used for regional administrative identification within Ecuador's governmental structure. The format consists of proper noun text strings representing official province names in Spanish without abbreviations or special formatting characters.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AZUAY",
      "BOL\u00cdVAR",
      "CA\u00d1AR",
      "CARCHI",
      "CHIMBORAZO",
      "COTOPAXI",
      "EL ORO",
      "ESMERALDAS",
      "GAL\u00c1PAGOS",
      "GUAYAS",
      "IMBABURA",
      "LOJA",
      "LOS R\u00cdOS",
      "MANAB\u00cd",
      "MORONA SANTIAGO",
      "NAPO",
      "ORELLANA",
      "PASTAZA",
      "PICHINCHA",
      "SANTA ELENA",
      "SANTO DOMINGO DE LOS TS\u00c1CHILAS",
      "SUCUMB\u00cdOS",
      "TUNGURAHUA",
      "ZAMORA CHINCHIPE"
    ],
    "backout": "^[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc]+( [A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc]+){0,5}$",
    "confidenceThreshold": 98,
    "priority": 5250,
    "headerPatterns": [
      {
        "regExp": "(?i).*(ecuador|ec).*(provincia|province).*(name|nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ecuador_province_name"
        ],
        "negativeExamples": [
          "ecuador_country_name"
        ]
      },
      {
        "regExp": "(?i).*(provincia|province).*(name|nombre).*(ec|ecuador).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "provincia_nombre_ec"
        ],
        "negativeExamples": [
          "provincia_codigo_ec"
        ]
      },
      {
        "regExp": "(?i).*(provincia|province).*(ec|ecuador).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ec_provincia"
        ],
        "negativeExamples": [
          "ec_canton"
        ]
      },
      {
        "regExp": "(?i).*(prov|provincia|province).*(name|nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "prov_name"
        ],
        "negativeExamples": [
          "prov_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Azuay",
      "Santo Domingo de los Ts\u00e1chilas",
      "Los R\u00edos",
      "Pichincha",
      "Gal\u00e1pagos",
      "Morona Santiago",
      "Zamora Chinchipe",
      "El Oro"
    ],
    "negativeContentExamples": [
      "Santa Elena Province",
      "Pichincha ECUADOR",
      "Sto Domingo de los Tsachilas",
      "Guayas, EC",
      "Santo Domingo",
      "Manabi",
      "Imbabura - Norte",
      "Provincia de Esmeraldas"
    ],
    "positiveHeaderExamples": [
      "ecuador_province_name",
      "provincia_nombre",
      "prov_name_ec",
      "nombre_provincia_ecuador",
      "province_name_ec",
      "ec_provincia",
      "province_ec",
      "prov_name"
    ],
    "negativeHeaderExamples": [
      "ecuador_country_name",
      "provincia_codigo_ec",
      "ec_canton",
      "prov_code",
      "code",
      "country_name",
      "province_code_ec",
      "region_name"
    ],
    "explanation": "This semantic type strictly enumerates the official names of Ecuador's 24 provinces in Spanish. It is intended for columns storing province names for geocoding, regional aggregation, or administrative classification. The list plugin ensures precise matching to the official set, with a backout pattern that constrains the general shape to uppercase Spanish words separated by single spaces.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:03:54.549311"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.MIDDLE_INITIAL",
    "description": "This type captures middle name initials as they appear in abbreviated personal name formats and formal documentation. The values represent single alphabetic characters, often followed by a period, that abbreviate the full middle name for space-efficient name display.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z](\\.|\\b)",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4680,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bmiddle[_ ]name[_ ]initial\\b.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "middle_name_initial"
        ],
        "negativeExamples": [
          "middle_name"
        ]
      },
      {
        "regExp": "(?i).*\\bmiddle[_ ]initial\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "middle initial"
        ],
        "negativeExamples": [
          "first initial"
        ]
      },
      {
        "regExp": "(?i).*\\bmiddle[_ ]name\\b.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "middle name"
        ],
        "negativeExamples": [
          "first name"
        ]
      },
      {
        "regExp": "(?i).*\\bmi\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "mi"
        ],
        "negativeExamples": [
          "min"
        ]
      },
      {
        "regExp": "(?i).*\\bname\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "initial"
        ]
      }
    ],
    "positiveContentExamples": [
      "A",
      "B.",
      "c",
      "D.",
      "e",
      "Z.",
      "m",
      "H."
    ],
    "negativeContentExamples": [
      "AB",
      "AB.",
      "A1",
      "Mr.",
      "\u00c9.",
      "Qq",
      "A_B",
      "LMN"
    ],
    "positiveHeaderExamples": [
      "middle_name_initial",
      "middle initial",
      "middle name initial",
      "mi",
      "name_middle_initial",
      "person middle initial",
      "middle_initial"
    ],
    "negativeHeaderExamples": [
      "first_initial",
      "last_initial",
      "initials",
      "middle_name",
      "name_suffix",
      "prefix",
      "middle_name_code"
    ],
    "explanation": "Identifies a single-letter middle initial with an optional trailing period, commonly used in personal names (e.g., A, B.). Useful for parsing or validating name components where only the middle initial is stored rather than the full middle name. The pattern is strict to avoid matching multi-letter tokens or accented characters and uses word boundaries to minimize false positives.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:04:01.003119"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_CA",
    "description": "This type represents official Canadian province codes used for identifying provinces and territories within Canada's federal system. The format consists of exactly two uppercase letters derived from the province names without spaces, numbers, or special characters.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AB",
      "BC",
      "MB",
      "NB",
      "NL",
      "NS",
      "NT",
      "NU",
      "ON",
      "PE",
      "QC",
      "SK",
      "YT"
    ],
    "backout": "^[A-Z]{2}$",
    "confidenceThreshold": 98,
    "priority": 5220,
    "headerPatterns": [
      {
        "regExp": "(?i).*(canad|ca).*(province|prov|territory|terr).*(code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "canadian_province_code"
        ],
        "negativeExamples": [
          "ca_province_name"
        ]
      },
      {
        "regExp": "(?i).*(province|prov|territory|terr)[ _-]*(code|abbr|abbrev).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province_code"
        ],
        "negativeExamples": [
          "province_count"
        ]
      },
      {
        "regExp": "(?i).*prov[_-]?cd.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "prov_cd"
        ],
        "negativeExamples": [
          "prov_id"
        ]
      },
      {
        "regExp": "(?i).*(canad|ca).*(prov|province|territory|terr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ca_province"
        ],
        "negativeExamples": [
          "ca_postal_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "AB",
      "BC",
      "MB",
      "NB",
      "NL",
      "NS",
      "ON",
      "QC"
    ],
    "negativeContentExamples": [
      "PQ",
      "NF",
      "YK",
      "PEI",
      "Ont",
      "Q C",
      "ON-",
      "QC1"
    ],
    "positiveHeaderExamples": [
      "canadian_province_code",
      "ca_prov_code",
      "province_abbrev",
      "territory_code",
      "prov_cd",
      "province_territory_code_ca",
      "canada_prov_code",
      "province_code"
    ],
    "negativeHeaderExamples": [
      "province_name",
      "state_code",
      "country_code",
      "postal_code",
      "us_state_code",
      "province_id",
      "territory_name",
      "region_code"
    ],
    "explanation": "Identifies Canadian province and territory postal codes using a finite, authoritative set of two-letter uppercase values. This is useful for validating location attributes, normalizing addresses, and enforcing country-specific constraints in data pipelines. The list plugin ensures exact matching to the official codes while the backout pattern screens for two-letter uppercase tokens during discovery.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:04:01.833293"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.FIRST",
    "description": "This type captures individual given names as they appear in personal identification, records, and formal documentation across different cultures. The values represent first names using standard spelling and formatting conventions without including middle names, surnames, or titles.",
    "pluginType": "regex",
    "regexPattern": "\\b\\p{Lu}\\p{Ll}{1,29}([\\-'\u0019\u007f\u0000\u0000\\u2019]\\p{Lu}\\p{Ll}{1,29})?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4630,
    "headerPatterns": [
      {
        "regExp": "(?i).*first[_ -]?name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "first_name"
        ],
        "negativeExamples": [
          "first_initial"
        ]
      },
      {
        "regExp": "(?i).*given[_ -]?name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "given_name"
        ],
        "negativeExamples": [
          "middle_name"
        ]
      },
      {
        "regExp": "(?i).*(customer|applicant|user|person|employee|account).*(first|given).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_first_name"
        ],
        "negativeExamples": [
          "account_name"
        ]
      },
      {
        "regExp": "(?i).*(f[_-]?name|first[_-]?nm|given[_-]?nm)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fname"
        ],
        "negativeExamples": [
          "lname"
        ]
      },
      {
        "regExp": "(?i).*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "account_id"
        ]
      }
    ],
    "positiveContentExamples": [
      "John",
      "Anne-Marie",
      "D'Angelo",
      "Jos\u00e9",
      "\u00c9mile",
      "Li",
      "Jean-Luc",
      "De\u2019Andre"
    ],
    "negativeContentExamples": [
      "JOHN",
      "john",
      "Anne Marie",
      "D'Angelo Smith",
      "Ms Anne",
      "J",
      "Jean-",
      "O\u2019"
    ],
    "positiveHeaderExamples": [
      "first_name",
      "given_name",
      "customer_first_name",
      "applicant_given_name",
      "forename",
      "fname",
      "primary_first_name",
      "legal_given_name"
    ],
    "negativeHeaderExamples": [
      "full_name",
      "last_name",
      "middle_name",
      "first_initial",
      "nickname",
      "account_name",
      "user_name",
      "customer_id"
    ],
    "explanation": "First names are typically a single token starting with an uppercase letter followed by lowercase letters, and may include a single internal hyphen or apostrophe for hyphenated or elided given names. This type is useful for parsing person-related datasets where the given name is stored separately from other name components.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:04:05.068201"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.SUFFIX",
    "description": "This type captures name suffixes that appear after personal names to denote generational relationships, professional qualifications, or honorific designations. The values represent standard suffix abbreviations and designations used in formal naming conventions without including the preceding personal names.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "JR",
      "JR.",
      "SR",
      "SR.",
      "II",
      "III",
      "IV",
      "V",
      "MD",
      "M.D.",
      "PHD",
      "PH.D.",
      "ESQ",
      "ESQ.",
      "JD",
      "J.D.",
      "CPA",
      "DDS",
      "DVM",
      "RN",
      "PE",
      "MBA",
      "MS",
      "BS",
      "CFA"
    ],
    "backout": "^[A-Z0-9.]{2,6}$",
    "confidenceThreshold": 93,
    "priority": 4690,
    "headerPatterns": [
      {
        "regExp": "(?i).*(customer|person|applicant|employee|client)[ _-]name[ _-]suffix.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_name_suffix"
        ],
        "negativeExamples": [
          "customer_suffix"
        ]
      },
      {
        "regExp": "(?i).*(personal|legal|full)[ _-]name[ _-]suffix.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "legal_name_suffix"
        ],
        "negativeExamples": [
          "legal_suffix"
        ]
      },
      {
        "regExp": "(?i).*(name|nm)[ _-]sfx.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "nm_sfx"
        ],
        "negativeExamples": [
          "nm_suffix"
        ]
      },
      {
        "regExp": "(?i).*suffix.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "suffix"
        ],
        "negativeExamples": [
          "prefix"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "title"
        ]
      }
    ],
    "positiveContentExamples": [
      "JR",
      "JR.",
      "SR.",
      "III",
      "IV",
      "MD",
      "PH.D.",
      "CPA"
    ],
    "negativeContentExamples": [
      "JR,",
      "JR ",
      "J R",
      "PH D",
      "MD/",
      "I",
      "C.P.A.",
      "ESQ.."
    ],
    "positiveHeaderExamples": [
      "customer_name_suffix",
      "person_name_suffix",
      "legal_name_suffix",
      "full_name_suffix",
      "name_sfx",
      "nm_sfx",
      "suffix",
      "name"
    ],
    "negativeHeaderExamples": [
      "customer_title",
      "initials",
      "honorific",
      "degree",
      "generation",
      "role",
      "alias",
      "prefix"
    ],
    "explanation": "NAME.SUFFIX identifies standalone tokens representing generational, professional, or honorific suffixes appended to personal names (e.g., Jr, Sr, II, MD, PhD). It is intended for fields that store only the suffix value, not the full name. Typical use cases include parsing or standardizing person records where the suffix is isolated in its own column.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:04:05.816097"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_SE",
    "description": "This type identifies postal codes used within Sweden's postal system for mail sorting and delivery services. The structure consists of three digits, followed by a single space, then two additional digits without other formatting. Values with hyphens, country prefixes, extra or missing digits, or misplaced spaces are not included.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{3} [0-9]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4940,
    "headerPatterns": [
      {
        "regExp": "(?i).*(sweden|swedish|se)[ _-]*(postal|post)[ _-]*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "swedish_postal_code"
        ],
        "negativeExamples": [
          "postal_code_no"
        ]
      },
      {
        "regExp": "(?i).*(postal|post)[ _-]*code[ _-]*(sweden|swedish|se).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postal_code_se"
        ],
        "negativeExamples": [
          "country_code_se"
        ]
      },
      {
        "regExp": "(?i).*(recipient|destination|shipping)[ _-]*(postal|post)[ _-]*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "destination_postal_code"
        ],
        "negativeExamples": [
          "destination_city_code"
        ]
      },
      {
        "regExp": "(?i).*(postcode|zip)[ _-]*(se|sweden|swedish).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postcode_se"
        ],
        "negativeExamples": [
          "zip_code_us"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "114 55",
      "211 20",
      "411 07",
      "903 29",
      "972 32",
      "831 34",
      "753 10",
      "164 40"
    ],
    "negativeContentExamples": [
      "11455",
      "114-55",
      "114 5",
      "11 455",
      "A14 55",
      "114.55",
      "114 5A",
      "114  55"
    ],
    "positiveHeaderExamples": [
      "se_postal_code",
      "swedish_postal_code",
      "postal_code_sweden",
      "postcode_se",
      "recipient_postal_code_se",
      "destination_postcode_se",
      "shipping_post_code_se",
      "post_code_sweden"
    ],
    "negativeHeaderExamples": [
      "zip_code_us",
      "postal_code_no",
      "country_code_se",
      "state_code",
      "area_code",
      "post_area",
      "address_code",
      "tax_code"
    ],
    "explanation": "Swedish postal codes follow a strict five-digit format with a single space after the first three digits (NNN NN). This semantic type is useful for validating and classifying address fields, ensuring consistent formatting for shipping, billing, and geocoding processes that specifically expect Sweden's postal code structure.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:04:06.623757"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_AU",
    "description": "This type captures abbreviated codes for Australian states and territories used in official documentation and geographic identification systems. The values represent standardized abbreviations derived from state names using uppercase letters without periods or additional punctuation.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "ACT",
      "NSW",
      "NT",
      "QLD",
      "SA",
      "TAS",
      "VIC",
      "WA"
    ],
    "backout": "^[A-Z]{2,3}$",
    "confidenceThreshold": 98,
    "priority": 5370,
    "headerPatterns": [
      {
        "regExp": "(?i).*(australia|au).*(state|territory).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "au_state_code"
        ],
        "negativeExamples": [
          "us_state_code"
        ]
      },
      {
        "regExp": "(?i).*(australian|au).*(state|territory).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "australian_state"
        ],
        "negativeExamples": [
          "canadian_province"
        ]
      },
      {
        "regExp": "(?i).*(state|territory).*(abbr|abbrev).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_abbrev"
        ],
        "negativeExamples": [
          "country_abbrev"
        ]
      },
      {
        "regExp": "(?i).*(state|territory).*(code|cd).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_cd"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "ACT",
      "NSW",
      "NT",
      "QLD",
      "SA",
      "TAS",
      "VIC",
      "WA"
    ],
    "negativeContentExamples": [
      "AC",
      "N.S.W",
      "NSW-",
      "qld",
      "VIC1",
      "WAU",
      "TAS.",
      "SA/AU"
    ],
    "positiveHeaderExamples": [
      "au_state_code",
      "australian_state",
      "state_abbrev",
      "state_cd",
      "state_code",
      "state_territory_code_au",
      "au_territory_code",
      "state_au"
    ],
    "negativeHeaderExamples": [
      "postal_code",
      "country_code",
      "us_state_code",
      "province_code",
      "state_name",
      "region",
      "city",
      "timezone"
    ],
    "explanation": "Australian state/territory abbreviation codes are a small, finite, and standardized set, making a list-based semantic type appropriate. This type helps validate and normalize location attributes where Australian state/territory codes are expected, such as addresses, customer profiles, and shipment records.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:04:08.947206"
  },
  {
    "resultType": "generated",
    "semanticType": "PERIOD.QUARTER",
    "description": "This type identifies quarterly period designations as they appear in business reporting, financial analysis, and temporal data organization. The values represent standardized quarter indicators using common abbreviations to denote three-month periods within annual business or calendar cycles.",
    "pluginType": "regex",
    "regexPattern": "\\b(((FY|FISCAL)[ ]*(\\d{2,4})[ ]*[/\\-\\.,']?[ ]*)|((\\d{2,4})[ ]*[/\\-\\.,']?[ ]*))?((Q[1-4])|([1-4][ ]*Q)|(QTR[ ]*[1-4])|(QUARTER[ ]*[1-4]))([ ]*[/\\-\\.,']?[ ]*((FY[ ]*)?(\\d{2,4})))?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4730,
    "headerPatterns": [
      {
        "regExp": "(?i).*(fiscal|fy).*quarter.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fiscal_quarter"
        ],
        "negativeExamples": [
          "fiscal_year"
        ]
      },
      {
        "regExp": "(?i).*(report|reporting|statement).*quarter.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "reporting_quarter"
        ],
        "negativeExamples": [
          "reporting_month"
        ]
      },
      {
        "regExp": "(?i).*(quarter|qtr).*(period|pd|year|yr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "quarter_period"
        ],
        "negativeExamples": [
          "month_period"
        ]
      },
      {
        "regExp": "(?i).*\\bqtr\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "qtr"
        ],
        "negativeExamples": [
          "qty"
        ]
      },
      {
        "regExp": "(?i).*quarter.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "quarter"
        ],
        "negativeExamples": [
          "month"
        ]
      }
    ],
    "positiveContentExamples": [
      "Q1 2023",
      "2024-Q3",
      "FY2021 Q4",
      "Q2'22",
      "1Q2020",
      "QTR 3 2019",
      "Quarter 4 FY18",
      "2023Q2"
    ],
    "negativeContentExamples": [
      "Q5 2023",
      "H1 2023",
      "2023 Q0",
      "Quarter 2.5 2023",
      "Q 2 2023",
      "2023Q",
      "FY23",
      "Quarterly 2023"
    ],
    "positiveHeaderExamples": [
      "fiscal_quarter",
      "quarter",
      "qtr",
      "reporting_quarter",
      "quarter_period",
      "fiscal_qtr",
      "quarter_year",
      "quarter_label"
    ],
    "negativeHeaderExamples": [
      "fiscal_year",
      "month",
      "qty",
      "semester",
      "half_year",
      "period",
      "month_name",
      "week_of_year"
    ],
    "explanation": "PERIOD.QUARTER identifies values that denote business or calendar quarters, such as Q1\u2013Q4, optionally combined with fiscal markers (FY, FISCAL) and years (2- or 4-digit), with common separators like spaces, hyphens, slashes, or apostrophes. It supports forms like Q1 2023, 2023-Q1, FY2021 Q4, Q2'22, 1Q2020, QTR 3 2019, Quarter 4 FY18, and 2023Q2. This type is useful for financial statements, period-based aggregations, and time-series analyses that operate at the quarter granularity.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:04:11.393103"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.AGE",
    "description": "This type captures individual ages as they appear in demographic data, personal records, and age-related analysis using numerical year values. The values represent current age in completed years without fractional components, typically ranging from birth to advanced elderly ages.",
    "pluginType": "regex",
    "regexPattern": "\\b(0|[1-9]\\d|1[01]\\d|120)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4750,
    "headerPatterns": [
      {
        "regExp": "(?i).*person.*age.*years.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "person_age_years"
        ],
        "negativeExamples": [
          "person_years"
        ]
      },
      {
        "regExp": "(?i).*applicant.*age.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "applicant_age"
        ],
        "negativeExamples": [
          "applicant_id"
        ]
      },
      {
        "regExp": "(?i).*age.*years.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "age_years"
        ],
        "negativeExamples": [
          "years_old"
        ]
      },
      {
        "regExp": "(?i).*age_yr.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "age_yr"
        ],
        "negativeExamples": [
          "yr_age"
        ]
      },
      {
        "regExp": "(?i).*age.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "age"
        ],
        "negativeExamples": [
          "years"
        ]
      }
    ],
    "positiveContentExamples": [
      "0",
      "1",
      "7",
      "18",
      "21",
      "45",
      "99",
      "120"
    ],
    "negativeContentExamples": [
      "05",
      "-1",
      "121",
      "17.0",
      "100+",
      "2 0",
      "1e2",
      "030"
    ],
    "positiveHeaderExamples": [
      "person_age",
      "person_age_years",
      "applicant_age",
      "customer_age",
      "age_years",
      "age_yr",
      "age"
    ],
    "negativeHeaderExamples": [
      "date_of_birth",
      "birth_year",
      "years_of_service",
      "tenure_years",
      "seniority",
      "yob",
      "dob"
    ],
    "explanation": "Represents an individual's current age in completed years as a whole-number value, constrained to typical human lifespan ranges. Intended for columns containing strictly numeric ages without units or decimals. The pattern accepts integers 0\u2013120 without leading zeros (except for 0), and rejects negatives, decimals, scientific notation, embedded spaces, unit suffixes, and values above 120.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:04:13.015611"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.REGION_NAME_PE",
    "description": "This type captures the official names of Peruvian regions as they are used in national administration and geographic identification. The values represent complete regional names using proper Spanish spelling and standard formatting as established by Peruvian territorial organization.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AMAZONAS",
      "\u00c1NCASH",
      "APUR\u00cdMAC",
      "AREQUIPA",
      "AYACUCHO",
      "CAJAMARCA",
      "CALLAO",
      "CUSCO",
      "HUANCAVELICA",
      "HU\u00c1NUCO",
      "ICA",
      "JUN\u00cdN",
      "LA LIBERTAD",
      "LAMBAYEQUE",
      "LIMA",
      "LORETO",
      "MADRE DE DIOS",
      "MOQUEGUA",
      "PASCO",
      "PIURA",
      "PUNO",
      "SAN MART\u00cdN",
      "TACNA",
      "TUMBES",
      "UCAYALI"
    ],
    "backout": "^[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1]+( [A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1]+){0,3}$",
    "confidenceThreshold": 98,
    "priority": 5350,
    "headerPatterns": [
      {
        "regExp": "(?i).*(peru|pe)[ _-]*region[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "peru_region_name"
        ],
        "negativeExamples": [
          "peru_region_code"
        ]
      },
      {
        "regExp": "(?i).*region[ _-]*name[ _-]*pe.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "region_name_pe"
        ],
        "negativeExamples": [
          "region_code_pe"
        ]
      },
      {
        "regExp": "(?i).*(region|departamento)[ _-]*(peru|pe).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "departamento_peru"
        ],
        "negativeExamples": [
          "province_peru"
        ]
      },
      {
        "regExp": "(?i).*(reg|dpto|depto)[ _-]*(pe|peru).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "reg_pe"
        ],
        "negativeExamples": [
          "reg_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "number"
        ]
      }
    ],
    "positiveContentExamples": [
      "AMAZONAS",
      "\u00c1NCASH",
      "APUR\u00cdMAC",
      "AREQUIPA",
      "CAJAMARCA",
      "CUSCO",
      "LA LIBERTAD",
      "SAN MART\u00cdN"
    ],
    "negativeContentExamples": [
      "LIMA METROPOLITANA",
      "CUSCO REGION",
      "REGION LIMA",
      "SAN MARTIN",
      "ANCASH",
      "HUANUCO",
      "MADRE-DE-DIOS",
      "LA  LIBERTAD"
    ],
    "positiveHeaderExamples": [
      "peru_region_name",
      "pe_region_name",
      "region_name_pe",
      "departamento_peru",
      "region_peru",
      "reg_pe",
      "dpto_pe",
      "region_name"
    ],
    "negativeHeaderExamples": [
      "region_code_pe",
      "peru_region_code",
      "province",
      "state",
      "region_id",
      "departament_pe",
      "reg_num",
      "geographic_region"
    ],
    "explanation": "The STATE_PROVINCE.REGION_NAME_PE semantic type identifies official Peruvian region names in their canonical Spanish form, including proper use of accents and multi-word names. It is designed for columns storing full region names for geospatial analysis, address normalization, and administrative reporting. Using a finite list ensures high precision and avoids confusion with similar geographic terms such as provinces or districts.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:04:19.092695"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_ZA",
    "description": "This type identifies South African province names used for regional administrative identification within South Africa's governmental structure. The format consists of proper noun text strings representing official province names in English without abbreviations or special formatting characters.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "EASTERN CAPE",
      "FREE STATE",
      "GAUTENG",
      "KWAZULU-NATAL",
      "LIMPOPO",
      "MPUMALANGA",
      "NORTH WEST",
      "NORTHERN CAPE",
      "WESTERN CAPE"
    ],
    "backout": "^[A-Z][A-Z -]{5,14}$",
    "confidenceThreshold": 98,
    "priority": 5310,
    "headerPatterns": [
      {
        "regExp": "(?i).*south.*africa.*province.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "south_africa_province_name"
        ],
        "negativeExamples": [
          "province_code_za"
        ]
      },
      {
        "regExp": "(?i).*za.*province.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province_name_za"
        ],
        "negativeExamples": [
          "za_province_code"
        ]
      },
      {
        "regExp": "(?i).*state.*province.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_province_name"
        ],
        "negativeExamples": [
          "state_province_code"
        ]
      },
      {
        "regExp": "(?i).*(prov|prv).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "prov_name"
        ],
        "negativeExamples": [
          "prov_code"
        ]
      },
      {
        "regExp": "(?i).*province.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province"
        ],
        "negativeExamples": [
          "region"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Eastern Cape",
      "Free State",
      "Gauteng",
      "KwaZulu-Natal",
      "Limpopo",
      "Mpumalanga",
      "Northern Cape",
      "Western Cape"
    ],
    "negativeContentExamples": [
      "KZN",
      "Kwa Zulu Natal",
      "WesternCape",
      "Eastern-Cape",
      "Gauteng Province",
      "North-West",
      "Free-State",
      "NorthernCape"
    ],
    "positiveHeaderExamples": [
      "south_africa_province_name",
      "province_name_za",
      "state_province_name",
      "za_province_name",
      "prov_name",
      "province",
      "south_african_province_name",
      "province_full_name"
    ],
    "negativeHeaderExamples": [
      "province_code",
      "province_abbrev",
      "region_name",
      "state_name_us",
      "city_name",
      "country_name",
      "province_id",
      "province_number"
    ],
    "explanation": "South African province names form a small, finite set of official English names. This type is best recognized via an explicit list of allowed values and a conservative backout shape to protect against near-miss variants such as abbreviations or formatting deviations. Typical use cases include address normalization, regional reporting, and validation of administrative geography fields within South Africa.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:04:19.555994"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_ES",
    "description": "This type represents postal codes used within Spain's postal system for mail sorting and delivery. The format consists of exactly five consecutive numeric digits with no spaces, letters, or special characters.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4870,
    "headerPatterns": [
      {
        "regExp": "(?i).*(spain|spanish|es).*(postal|postcode|zip).*(code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "spain_postal_code"
        ],
        "negativeExamples": [
          "country_postal_code"
        ]
      },
      {
        "regExp": "(?i).*(codigo).*(postal).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "codigo_postal"
        ],
        "negativeExamples": [
          "codigo_area"
        ]
      },
      {
        "regExp": "(?i).*(postal|postcode|zip).*(code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postalcode"
        ],
        "negativeExamples": [
          "postal_route"
        ]
      },
      {
        "regExp": "(?i).*(es).*(zip|post).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "zip_es"
        ],
        "negativeExamples": [
          "zip_plus4"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "28013",
      "08001",
      "46007",
      "20014",
      "15705",
      "03182",
      "29015",
      "41001"
    ],
    "negativeContentExamples": [
      "2801",
      "280130",
      "28 013",
      "28-013",
      "2801A",
      "A28013",
      "2801_3",
      "280.13"
    ],
    "positiveHeaderExamples": [
      "spain_postal_code",
      "spanish_zip_code",
      "es_postcode",
      "codigo_postal",
      "postal_code_es",
      "zip_es",
      "es_zip",
      "postalcode"
    ],
    "negativeHeaderExamples": [
      "area_code",
      "country_code",
      "transaction_code",
      "zip_plus4",
      "postal_route",
      "state_postal_abbr",
      "service_code",
      "geo_code"
    ],
    "explanation": "Spanish postal codes are exactly five digits with no separators or letters. This type is useful for validating and profiling columns that contain Spain-specific postal codes, differentiating them from more general ZIP/postcode formats by leveraging header cues that reference Spain (ES) or Spanish terminology.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:04:25.442875"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_BR",
    "description": "This type captures the complete names of Brazilian states and the federal district as they are used in official documentation and government administration. The values represent full state names using proper Portuguese spelling including diacritical marks and standard formatting as established by Brazilian constitutional and administrative systems.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(Acre|Alagoas|Amap\u00e1|Amazonas|Bahia|Cear\u00e1|Distrito Federal|Esp\u00edrito Santo|Goi\u00e1s|Maranh\u00e3o|Mato Grosso|Mato Grosso do Sul|Minas Gerais|Par\u00e1|Para\u00edba|Paran\u00e1|Pernambuco|Piau\u00ed|Rio de Janeiro|Rio Grande do Norte|Rio Grande do Sul|Rond\u00f4nia|Roraima|Santa Catarina|S\u00e3o Paulo|Sergipe|Tocantins)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5420,
    "headerPatterns": [
      {
        "regExp": "(?i).*nome.*estado.*br.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nome_estado_br"
        ],
        "negativeExamples": [
          "estado_sigla_br"
        ]
      },
      {
        "regExp": "(?i).*(estado|uf).*(nome).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "uf_nome"
        ],
        "negativeExamples": [
          "uf_codigo"
        ]
      },
      {
        "regExp": "(?i).*nome.*unidade.*federativa.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nome_unidade_federativa"
        ],
        "negativeExamples": [
          "codigo_unidade_federativa"
        ]
      },
      {
        "regExp": "(?i).*(estado|uf).*(br|brasil).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "estado_brasil"
        ],
        "negativeExamples": [
          "estado_codigo"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "S\u00e3o Paulo",
      "Rio de Janeiro",
      "Minas Gerais",
      "Par\u00e1",
      "Paran\u00e1",
      "Mato Grosso do Sul",
      "Esp\u00edrito Santo",
      "Distrito Federal"
    ],
    "negativeContentExamples": [
      "Sao Paulo",
      "Rio de Janeiro RJ",
      "Estado de S\u00e3o Paulo",
      "Mato Grosso doSul",
      "Distrito Federal - DF",
      "Rondonia",
      "Amapa",
      "Ceara"
    ],
    "positiveHeaderExamples": [
      "nome_estado_br",
      "estado_brasil_nome",
      "uf_nome",
      "nome_unidade_federativa",
      "br_state_name",
      "estado_nome",
      "nome_estado"
    ],
    "negativeHeaderExamples": [
      "estado_sigla",
      "uf",
      "codigo_uf",
      "country_name",
      "province_name",
      "cidade",
      "estado_codigo"
    ],
    "explanation": "This semantic type detects full Brazilian state names and the federal district in Portuguese with correct diacritics, enabling precise identification of administrative units in Brazil. It is intended for columns storing complete state names (e.g., S\u00e3o Paulo, Minas Gerais) rather than abbreviations or enriched strings.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:04:27.983451"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.REGION_NAME_TZ",
    "description": "This type captures the official names of Tanzanian regions as they are used in government administration and official documentation. The values represent complete regional names using standard English or Swahili spelling as established by Tanzanian territorial organization.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(ARUSHA|DAR ES SALAAM|DODOMA|GEITA|IRINGA|KAGERA|KATAVI|KIGOMA|KILIMANJARO|LINDI|MANYARA|MARA|MBEYA|MOROGORO|MTWARA|MWANZA|NJOMBE|PWANI|RUKWA|RUVUMA|SHINYANGA|SIMIYU|SINGIDA|SONGWE|TABORA|TANGA|ZANZIBAR NORTH|ZANZIBAR SOUTH|ZANZIBAR WEST|PEMBA NORTH|PEMBA SOUTH|MJINI MAGHARIBI|KASKAZINI UNGUJA|KUSINI UNGUJA|KASKAZINI PEMBA|KUSINI PEMBA)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5360,
    "headerPatterns": [
      {
        "regExp": "(?i).*tanzania.*region.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "tanzania_region_name"
        ],
        "negativeExamples": [
          "region_name_tz"
        ]
      },
      {
        "regExp": "(?i).*(tz).*region.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "tz_region_name"
        ],
        "negativeExamples": [
          "tanzania_region"
        ]
      },
      {
        "regExp": "(?i).*tanzania.*region.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "tanzania_region"
        ],
        "negativeExamples": [
          "region_code"
        ]
      },
      {
        "regExp": "(?i).*region.*tanzania.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "region_tanzania"
        ],
        "negativeExamples": [
          "country_region"
        ]
      },
      {
        "regExp": "(?i).*region.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "region_name"
        ],
        "negativeExamples": [
          "region_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Dar es Salaam",
      "Kilimanjaro",
      "Zanzibar West",
      "Kaskazini Unguja",
      "Pemba South",
      "Simiyu",
      "Ruvuma",
      "Morogoro"
    ],
    "negativeContentExamples": [
      "Dar es Salam",
      "Kilimanjarro",
      "Zanzibar East",
      "Kaskazini Ungujja",
      "Pemba Southern",
      "Simuyu",
      "Ruvu",
      "Morogora"
    ],
    "positiveHeaderExamples": [
      "tanzania_region_name",
      "tz_region_name",
      "tanzania_region",
      "region_tanzania",
      "region_name_tz",
      "tanzanian_region_name",
      "region_name"
    ],
    "negativeHeaderExamples": [
      "province_name",
      "country_region",
      "region_code",
      "admin_area_name",
      "city_region",
      "timezone_region",
      "county_name"
    ],
    "explanation": "This semantic type identifies values that are official names of Tanzania\u2019s first-order administrative regions, including both English and standard Swahili spellings. It is useful for validating and standardizing region fields in datasets covering Tanzania mainland and Zanzibar.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:04:33.566615"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_NL",
    "description": "This type identifies Dutch municipality names used for local administrative identification within the Netherlands governmental structure. The format consists of proper noun text strings representing official municipality names in Dutch without abbreviations or special formatting characters.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z][a-z]{1,}(\\s[A-Z][a-z]{1,}){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5200,
    "headerPatterns": [
      {
        "regExp": "(?i).*dutch.*municipality.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "dutch_municipality_name"
        ],
        "negativeExamples": [
          "dutch_municipality_code"
        ]
      },
      {
        "regExp": "(?i).*municipality.*nl.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality_nl"
        ],
        "negativeExamples": [
          "municipality_se"
        ]
      },
      {
        "regExp": "(?i).*gemeente.*naam.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gemeente_naam"
        ],
        "negativeExamples": [
          "gemeente_code"
        ]
      },
      {
        "regExp": "(?i).*(municipality|gemeente).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "municipality"
        ],
        "negativeExamples": [
          "province"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Amsterdam",
      "Rotterdam",
      "Utrecht",
      "Eindhoven",
      "Groningen",
      "Tilburg",
      "Den Haag",
      "De Bilt"
    ],
    "negativeContentExamples": [
      "AMSTERDAM",
      "amsterdam-zuidoost",
      "gem. utrecht",
      "nl-utrecht",
      "rotterdam_1",
      "gemeente utrecht",
      "NL UTRECHT",
      "noord-holland"
    ],
    "positiveHeaderExamples": [
      "dutch_municipality_name",
      "municipality_nl",
      "gemeente_naam",
      "municipality_name",
      "nl_municipality",
      "municipality",
      "dutch_municipality",
      "local_municipality_name"
    ],
    "negativeHeaderExamples": [
      "municipality_code",
      "province_name",
      "state_province",
      "country",
      "postal_code",
      "city_name",
      "airport_code",
      "subdivision"
    ],
    "explanation": "This semantic type targets cell values that are official Dutch municipality names written as one to four capitalized words separated by spaces, without abbreviations, digits, or special punctuation. It is useful for classifying columns containing municipality names for joins, normalization, and geographic aggregation within the Netherlands context. The pattern is intentionally conservative to avoid matching generic location strings or codes and pairs best with municipality-focused headers.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:04:37.312814"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.REGION_NAME_FR",
    "description": "This type captures the official names of French regions as they are used in government documentation and administrative contexts. The values represent complete regional names using proper French spelling, including diacritical marks and standard formatting as established by French territorial administration.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AUVERGNE-RH\u00d4NE-ALPES",
      "BOURGOGNE-FRANCHE-COMT\u00c9",
      "BRETAGNE",
      "CENTRE-VAL DE LOIRE",
      "CORSE",
      "GRAND EST",
      "HAUTS-DE-FRANCE",
      "\u00ceLE-DE-FRANCE",
      "NORMANDIE",
      "NOUVELLE-AQUITAINE",
      "OCCITANIE",
      "PAYS DE LA LOIRE",
      "PROVENCE-ALPES-C\u00d4TE D'AZUR",
      "GUADELOUPE",
      "MARTINIQUE",
      "GUYANE",
      "LA R\u00c9UNION",
      "MAYOTTE"
    ],
    "backout": "^[A-Z\u00c0\u00c2\u00c4\u00c7\u00c9\u00c8\u00ca\u00cb\u00ce\u00cf\u00d4\u00d6\u00d9\u00db\u00dc\u0178][A-Z\u00c0\u00c2\u00c4\u00c7\u00c9\u00c8\u00ca\u00cb\u00ce\u00cf\u00d4\u00d6\u00d9\u00db\u00dc\u0178' -]{2,38}$",
    "confidenceThreshold": 98,
    "priority": 5330,
    "headerPatterns": [
      {
        "regExp": "(?i).*region.*name.*fr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "region_name_fr"
        ],
        "negativeExamples": [
          "region_name"
        ]
      },
      {
        "regExp": "(?i).*nom.*region.*fr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nom_region_fr"
        ],
        "negativeExamples": [
          "nom_departement_fr"
        ]
      },
      {
        "regExp": "(?i).*french.*region.*name.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "french_region_name"
        ],
        "negativeExamples": [
          "french_region_code"
        ]
      },
      {
        "regExp": "(?i).*(region|reg).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "region_name_fra"
        ],
        "negativeExamples": [
          "region_code_fr"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "\u00cele-de-France",
      "Provence-Alpes-C\u00f4te d'Azur",
      "Auvergne-Rh\u00f4ne-Alpes",
      "Bourgogne-Franche-Comt\u00e9",
      "Centre-Val de Loire",
      "La R\u00e9union",
      "Guyane",
      "Occitanie"
    ],
    "negativeContentExamples": [
      "Ile-de-France",
      "Provence Alpes Cote d'Azur",
      "Bourgogne Franche Comte",
      "Hauts de France",
      "Centre Val de Loire",
      "French Guiana",
      "Corse-du-Sud",
      "Pays de Loire"
    ],
    "positiveHeaderExamples": [
      "region_name_fr",
      "nom_region_fr",
      "french_region_name",
      "region_fr_name",
      "nom_officiel_region_fr",
      "region_administrative_name_fr",
      "nom_de_la_region",
      "region_name_fra"
    ],
    "negativeHeaderExamples": [
      "region_code_fr",
      "province_name_fr",
      "departement_name_fr",
      "country_region_name",
      "city_name_fr",
      "state_province_name",
      "region_abbrev",
      "timezone_name"
    ],
    "explanation": "This semantic type identifies official French region names, including metropolitan and overseas regions, with exact French spelling and diacritics. It is ideal for validating administrative datasets, standardizing geographic attributes, and ensuring consistent region-level classification in multilingual or international data stores.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:04:37.569872"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_BR",
    "description": "This type captures abbreviated codes for Brazilian states and the federal district used in official documentation and geographic identification systems. The values represent standardized two-character abbreviations derived from state names using uppercase letters without periods or additional punctuation.",
    "pluginType": "regex",
    "regexPattern": "\\b(AC|AL|AP|AM|BA|CE|DF|ES|GO|MA|MT|MS|MG|PA|PB|PR|PE|PI|RJ|RN|RS|RO|RR|SC|SP|SE|TO)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5380,
    "headerPatterns": [
      {
        "regExp": "(?i).*(brazil|br).*(state|estado|uf).*(code|abbr|abbreviation).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "br_state_code"
        ],
        "negativeExamples": [
          "country_code"
        ]
      },
      {
        "regExp": "(?i).*(state|estado).*(code|abbr|abbreviation).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_abbr"
        ],
        "negativeExamples": [
          "state_name"
        ]
      },
      {
        "regExp": "(?i).*\\buf\\b.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "uf"
        ],
        "negativeExamples": [
          "buffer_length"
        ]
      },
      {
        "regExp": "(?i).*(state|estado).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "estado"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "status"
        ]
      }
    ],
    "positiveContentExamples": [
      "SP",
      "RJ",
      "MG",
      "DF",
      "BA",
      "RS",
      "PR",
      "SC"
    ],
    "negativeContentExamples": [
      "BR",
      "SR",
      "SP-",
      "RJ1",
      "Ap",
      "DF/",
      "GOIA",
      "Minas"
    ],
    "positiveHeaderExamples": [
      "br_state_code",
      "brazil_state_abbr",
      "uf",
      "state_abbreviation",
      "estado_codigo",
      "uf_code",
      "br_uf"
    ],
    "negativeHeaderExamples": [
      "state_name",
      "province_code",
      "country_code",
      "region",
      "postal_code",
      "timezone",
      "city_code",
      "state_id"
    ],
    "explanation": "Brazilian state abbreviations (UF) are two-letter uppercase codes representing the 26 states and the federal district, with no punctuation or digits. This semantic type is useful for validating and standardizing address data, geospatial joins, and administrative reporting where UF codes are expected.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:04:37.716445"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_UNION_IN",
    "description": "This type captures abbreviated codes for Indian states and union territories used in official documentation and geographic identification systems. The values represent standardized two-character abbreviations derived from state names using uppercase letters without periods or additional punctuation.",
    "pluginType": "regex",
    "regexPattern": "\\b(AN|AP|AR|AS|BR|CH|CT|DD|DL|DN|GA|GJ|HP|HR|JH|JK|KA|KL|LA|LD|MH|ML|MN|MP|MZ|NL|OD|PB|PY|RJ|SK|TN|TR|TS|UK|UP|WB)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5480,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\b(india|in)\\b.*\\b(state|ut)\\b.*\\b(code|abbrev|abbr)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "india_state_code"
        ],
        "negativeExamples": [
          "state_code"
        ]
      },
      {
        "regExp": "(?i).*\\b(state|ut)\\b.*\\b(code|abbrev|abbr)\\b.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "state_ut_code"
        ],
        "negativeExamples": [
          "country_code"
        ]
      },
      {
        "regExp": "(?i).*\\bst\\b.*\\bcd\\b.*\\b(in|india)\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "st_cd_in"
        ],
        "negativeExamples": [
          "st_name"
        ]
      },
      {
        "regExp": "(?i).*\\bstate\\b.*\\b(abbrev|abbr)\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "state_abbrev"
        ],
        "negativeExamples": [
          "state_name"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "KA",
      "DL",
      "MH",
      "WB",
      "TN",
      "TS",
      "JK",
      "LA"
    ],
    "negativeContentExamples": [
      "ka",
      "MH-",
      "GJ1",
      "K L",
      "IN",
      "OR",
      "TS.",
      "DLN"
    ],
    "positiveHeaderExamples": [
      "india_state_code",
      "state_ut_code",
      "st_cd_in",
      "state_abbrev",
      "state_code_india",
      "in_state_code",
      "state_union_territory_code"
    ],
    "negativeHeaderExamples": [
      "country_code",
      "postal_code",
      "state_name",
      "province_code",
      "iso_country_code",
      "region_code",
      "location_id"
    ],
    "explanation": "Two-letter uppercase abbreviations uniquely identifying Indian states and union territories, suitable for columns storing standardized regional codes. The regex enumerates the allowed codes and uses word boundaries to avoid partial matches within longer strings. This type is useful for validating and classifying datasets containing Indian state/UT codes in licenses, registrations, addresses, and administrative records.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:04:41.767375"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_DE",
    "description": "This type captures the complete names of German federal states as they are used in official documentation and government administration. The values represent full state names using proper German spelling including umlauts and standard formatting as established by the German federal constitutional system.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "BADEN-W\u00dcRTTEMBERG",
      "BAYERN",
      "BERLIN",
      "BRANDENBURG",
      "BREMEN",
      "HAMBURG",
      "HESSEN",
      "MECKLENBURG-VORPOMMERN",
      "NIEDERSACHSEN",
      "NORDRHEIN-WESTFALEN",
      "RHEINLAND-PFALZ",
      "SAARLAND",
      "SACHSEN",
      "SACHSEN-ANHALT",
      "SCHLESWIG-HOLSTEIN",
      "TH\u00dcRINGEN"
    ],
    "backout": "^[A-Za-z\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df]+([ -][A-Za-z\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df]+)*$",
    "confidenceThreshold": 98,
    "priority": 5430,
    "headerPatterns": [
      {
        "regExp": "(?i).*state.*name.*de.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_name_de"
        ],
        "negativeExamples": [
          "state_code_de"
        ]
      },
      {
        "regExp": "(?i).*bundesland.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "bundesland_name"
        ],
        "negativeExamples": [
          "bundesland_code"
        ]
      },
      {
        "regExp": "(?i).*bundesland.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "bundesland"
        ],
        "negativeExamples": [
          "bundesland_code"
        ]
      },
      {
        "regExp": "(?i).*(de|german).*state.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "german_state"
        ],
        "negativeExamples": [
          "state_code"
        ]
      },
      {
        "regExp": "(?i).*laender.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "laender_name"
        ],
        "negativeExamples": [
          "laender_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Baden-W\u00fcrttemberg",
      "Bayern",
      "Berlin",
      "Mecklenburg-Vorpommern",
      "Nordrhein-Westfalen",
      "Rheinland-Pfalz",
      "Schleswig-Holstein",
      "Th\u00fcringen"
    ],
    "negativeContentExamples": [
      "Baden W\u00fcrttemberg",
      "Hesse",
      "Mecklenburg Vorpommern",
      "Nordrhein Westfalen",
      "Rheinland Pfalz",
      "Thuringen",
      "Saxony",
      "Niedersachen"
    ],
    "positiveHeaderExamples": [
      "state_name_de",
      "bundesland_name",
      "bundesland",
      "de_state",
      "german_state_name",
      "laender_name",
      "de_state_name"
    ],
    "negativeHeaderExamples": [
      "state_code",
      "province_code_de",
      "country",
      "postal_code",
      "city",
      "region_code",
      "iso_country_code",
      "municipality_id"
    ],
    "explanation": "Identifies full official names of German federal states (Bundesl\u00e4nder) using canonical German spelling, including umlauts and hyphenation where applicable. Best suited for columns containing state names rather than codes or abbreviations. Excludes English translations, short codes, and non-state geographic entities such as cities, regions, or postal codes.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:04:44.375614"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_FIPS_US",
    "description": "This type captures FIPS state codes used in US federal government databases and statistical reporting systems. The values represent two-digit numerical identifiers assigned to each state and territory using zero-padded format without separators or additional characters.",
    "pluginType": "regex",
    "regexPattern": "\\b(0[1-9]|1[0-9]|2[0-9]|3[0-9]|4[0-9]|5[0-6]|60|66|69|72|78)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5390,
    "headerPatterns": [
      {
        "regExp": "(?i).*us.*state.*fips.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "us_state_fips_code"
        ],
        "negativeExamples": [
          "state_fips_code"
        ]
      },
      {
        "regExp": "(?i).*state.*fips.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_fips_code"
        ],
        "negativeExamples": [
          "county_fips_code"
        ]
      },
      {
        "regExp": "(?i).*state.*fips.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_fips"
        ],
        "negativeExamples": [
          "fips_county"
        ]
      },
      {
        "regExp": "(?i).*(statefp|st_fips|stfips).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "st_fips"
        ],
        "negativeExamples": [
          "ctry_fips"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "01",
      "02",
      "11",
      "36",
      "48",
      "55",
      "60",
      "72"
    ],
    "negativeContentExamples": [
      "00",
      "57",
      "59",
      "62",
      "79",
      "6",
      "056",
      "72.0"
    ],
    "positiveHeaderExamples": [
      "us_state_fips_code",
      "state_fips_code",
      "state_fips",
      "st_fips",
      "statefp",
      "fips_state_code",
      "fips_st_code",
      "state_fips_us"
    ],
    "negativeHeaderExamples": [
      "fips_county_code",
      "county_fips",
      "state_abbr",
      "state_name",
      "us_state_code",
      "fips_place_code",
      "geoid_state",
      "postal_state_code"
    ],
    "explanation": "This semantic type identifies two-digit US FIPS state and territory codes in zero-padded numeric form. It is useful for normalizing and linking state-level identifiers across federal datasets where the FIPS standard is used, ensuring consistent joins with state-level geographic and statistical tables.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:04:46.045607"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_HU",
    "description": "This type identifies Hungarian county names used for administrative identification within Hungary's governmental structure. The values are official county names in Hungarian, written as proper nouns and using the correct diacritics and hyphenation where applicable, without abbreviations or additional suffixes.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "B\u00c1CS-KISKUN",
      "BARANYA",
      "B\u00c9K\u00c9S",
      "BORSOD-ABA\u00daJ-ZEMPL\u00c9N",
      "CSONGR\u00c1D-CSAN\u00c1D",
      "FEJ\u00c9R",
      "GY\u0150R-MOSON-SOPRON",
      "HAJD\u00da-BIHAR",
      "HEVES",
      "J\u00c1SZ-NAGYKUN-SZOLNOK",
      "KOM\u00c1ROM-ESZTERGOM",
      "N\u00d3GR\u00c1D",
      "PEST",
      "SOMOGY",
      "SZABOLCS-SZATM\u00c1R-BEREG",
      "TOLNA",
      "VAS",
      "VESZPR\u00c9M",
      "ZALA"
    ],
    "backout": "^[A-Z\u00c1\u00c9\u00cd\u00d3\u00d6\u0150\u00da\u00dc\u0170]+(?:-[A-Z\u00c1\u00c9\u00cd\u00d3\u00d6\u0150\u00da\u00dc\u0170]+){0,3}$",
    "confidenceThreshold": 98,
    "priority": 5060,
    "headerPatterns": [
      {
        "regExp": "(?i).*(hungarian|hu).*county.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "hu_county_name"
        ],
        "negativeExamples": [
          "hu_city_name"
        ]
      },
      {
        "regExp": "(?i).*megye.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "megye_name"
        ],
        "negativeExamples": [
          "megye_code"
        ]
      },
      {
        "regExp": "(?i).*(hungarian_county|hu_county|county_hu).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "county_hu"
        ],
        "negativeExamples": [
          "country_hu"
        ]
      },
      {
        "regExp": "(?i).*(cty).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cty_name"
        ],
        "negativeExamples": [
          "city_name"
        ]
      },
      {
        "regExp": "(?i).*county.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "county"
        ],
        "negativeExamples": [
          "country"
        ]
      }
    ],
    "positiveContentExamples": [
      "B\u00e1cs-Kiskun",
      "Baranya",
      "B\u00e9k\u00e9s",
      "Borsod-Aba\u00faj-Zempl\u00e9n",
      "Csongr\u00e1d-Csan\u00e1d",
      "Gy\u0151r-Moson-Sopron",
      "J\u00e1sz-Nagykun-Szolnok",
      "Szabolcs-Szatm\u00e1r-Bereg"
    ],
    "negativeContentExamples": [
      "Budapest",
      "Pest megye",
      "Bacs-Kiskun",
      "Borsod Aba\u00faj Zempl\u00e9n",
      "Csongrad-Csanad",
      "Gy\u0151r Moson Sopron",
      "Pest County",
      "Kom\u00e1rom\u2013Esztergom"
    ],
    "positiveHeaderExamples": [
      "hu_county_name",
      "hungarian_county",
      "megye",
      "megye_name",
      "county_hu",
      "cty_name",
      "county"
    ],
    "negativeHeaderExamples": [
      "country",
      "state_province",
      "city",
      "district",
      "postcode",
      "county_code",
      "county_number",
      "region_name"
    ],
    "explanation": "This semantic type targets the finite set of official Hungarian counties (megy\u00e9k). Values must be the exact county names in Hungarian with correct diacritics and hyphenation, and without suffixes such as 'megye', English translations, or alternative punctuation. It is useful for validating address components, normalizing administrative geography attributes, and ensuring consistent county-level classification in Hungarian datasets.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:04:46.426892"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_ZA",
    "description": "This type captures abbreviated codes for South African provinces used in official documentation and geographic identification systems. The values represent standardized two-character abbreviations derived from province names using uppercase letters without periods or additional punctuation.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "EC",
      "FS",
      "GP",
      "KZ",
      "LP",
      "MP",
      "NC",
      "NW",
      "WC"
    ],
    "backout": "^[A-Z]{2}$",
    "confidenceThreshold": 98,
    "priority": 5320,
    "headerPatterns": [
      {
        "regExp": "(?i).*south.*africa.*province.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "south_africa_province_code"
        ],
        "negativeExamples": [
          "south_america_province_code"
        ]
      },
      {
        "regExp": "(?i).*za.*province.*code.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "za_province_code"
        ],
        "negativeExamples": [
          "za_province_name"
        ]
      },
      {
        "regExp": "(?i).*za.*province.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "za_province"
        ],
        "negativeExamples": [
          "za_region_code"
        ]
      },
      {
        "regExp": "(?i).*prov.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "prov_code"
        ],
        "negativeExamples": [
          "prov_name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "EC",
      "FS",
      "GP",
      "KZ",
      "LP",
      "MP",
      "NC",
      "NW"
    ],
    "negativeContentExamples": [
      "ec",
      "GP-",
      "KZN",
      "WC1",
      "ZA",
      "ZN",
      "G P",
      "E-C"
    ],
    "positiveHeaderExamples": [
      "za_province_code",
      "south_africa_province_code",
      "province_code_za",
      "za_prov_code",
      "province_abbrev_za",
      "south_africa_prov_code",
      "prov_code"
    ],
    "negativeHeaderExamples": [
      "za_province_name",
      "south_america_province_code",
      "country_code",
      "province_id",
      "region_code_za",
      "postal_code_za",
      "state_code"
    ],
    "explanation": "A finite, authoritative list of two-character uppercase codes representing South African provinces. Use this type to validate and standardize province abbreviations in datasets where South Africa\u2013specific province codes are expected. The backout pattern constrains candidates to two uppercase letters, while the list ensures only valid province codes are accepted.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:04:46.995230"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_US",
    "description": "This type captures abbreviated codes for US states and territories used in official documentation and geographic identification systems. The values represent standardized two-character abbreviations derived from state names using uppercase letters without periods or additional punctuation.",
    "pluginType": "regex",
    "regexPattern": "\\b(AL|AK|AS|AZ|AR|CA|CO|CT|DC|DE|FL|GA|GU|HI|IA|ID|IL|IN|KS|KY|LA|MA|MD|ME|MI|MN|MO|MP|MS|MT|NC|ND|NE|NH|NJ|NM|NV|NY|OH|OK|OR|PA|PR|RI|SC|SD|TN|TX|UT|VA|VI|VT|WA|WI|WV|WY)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5500,
    "headerPatterns": [
      {
        "regExp": "(?i).*us.*state.*abbreviation.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "us_state_abbreviation"
        ],
        "negativeExamples": [
          "state_name_us"
        ]
      },
      {
        "regExp": "(?i).*us.*state.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "us_state_code"
        ],
        "negativeExamples": [
          "country_code_us"
        ]
      },
      {
        "regExp": "(?i).*state.*(abbreviation|abbr|code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_code"
        ],
        "negativeExamples": [
          "country_abbreviation"
        ]
      },
      {
        "regExp": "(?i).*(us|usa).*st.*(abbr|cd).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "usa_st_abbr"
        ],
        "negativeExamples": [
          "st_name"
        ]
      },
      {
        "regExp": "(?i).*(state|st).*2.*letter.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_2_letter"
        ],
        "negativeExamples": [
          "country_2_letter"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "NY",
      "CA",
      "TX",
      "FL",
      "DC",
      "PR",
      "AS",
      "MP"
    ],
    "negativeContentExamples": [
      "Ny",
      "N.Y.",
      "CAL",
      "PR-",
      "US",
      "XX",
      "N C",
      "AE"
    ],
    "positiveHeaderExamples": [
      "us_state_code",
      "us_state_abbreviation",
      "state_abbr_us",
      "state_code_us",
      "postal_state_code",
      "state_abbreviation",
      "state_two_letter",
      "us_state"
    ],
    "negativeHeaderExamples": [
      "country_code",
      "province_code_ca",
      "state_name",
      "zipcode",
      "airport_code",
      "country",
      "currency_code",
      "county_name"
    ],
    "explanation": "This semantic type recognizes the official two-letter USPS-style abbreviations for US states plus the District of Columbia and US territories (AS, GU, MP, PR, VI). It enforces uppercase alphabetic tokens without punctuation or additional characters. Typical uses include validating location fields, normalizing address datasets, and ensuring consistent geographic codes for analytics and integration.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:04:57.293810"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_PROVINCE_NAME_NA",
    "description": "This type captures complete names of states and provinces across North America including US states, Canadian provinces, and Mexican states. The values represent full territorial names using proper spelling and formatting conventions appropriate to each country's linguistic standards.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(ALABAMA|ALASKA|ARIZONA|ARKANSAS|CALIFORNIA|COLORADO|CONNECTICUT|DELAWARE|FLORIDA|GEORGIA|HAWAII|IDAHO|ILLINOIS|INDIANA|IOWA|KANSAS|KENTUCKY|LOUISIANA|MAINE|MARYLAND|MASSACHUSETTS|MICHIGAN|MINNESOTA|MISSISSIPPI|MISSOURI|MONTANA|NEBRASKA|NEVADA|NEW HAMPSHIRE|NEW JERSEY|NEW MEXICO|NEW YORK|NORTH CAROLINA|NORTH DAKOTA|OHIO|OKLAHOMA|OREGON|PENNSYLVANIA|RHODE ISLAND|SOUTH CAROLINA|SOUTH DAKOTA|TENNESSEE|TEXAS|UTAH|VERMONT|VIRGINIA|WASHINGTON|WEST VIRGINIA|WISCONSIN|WYOMING|ALBERTA|BRITISH COLUMBIA|MANITOBA|NEW BRUNSWICK|NEWFOUNDLAND AND LABRADOR|NOVA SCOTIA|ONTARIO|PRINCE EDWARD ISLAND|QU\u00c9BEC|QUEBEC|SASKATCHEWAN|NORTHWEST TERRITORIES|NUNAVUT|YUKON|AGUASCALIENTES|BAJA CALIFORNIA|BAJA CALIFORNIA SUR|CAMPECHE|CHIAPAS|CHIHUAHUA|COAHUILA DE ZARAGOZA|COLIMA|DURANGO|GUANAJUATO|GUERRERO|HIDALGO|JALISCO|ESTADO DE M\u00c9XICO|MICHOAC\u00c1N DE OCAMPO|MORELOS|NAYARIT|NUEVO LE\u00d3N|OAXACA|PUEBLA|QUER\u00c9TARO|QUINTANA ROO|SAN LUIS POTOS\u00cd|SINALOA|SONORA|TABASCO|TAMAULIPAS|TLAXCALA|VERACRUZ DE IGNACIO DE LA LLAVE|YUCAT\u00c1N|ZACATECAS|CIUDAD DE M\u00c9XICO)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5470,
    "headerPatterns": [
      {
        "regExp": "(?i).*(north america|na).*(state|province).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "na_state_province_name"
        ],
        "negativeExamples": [
          "state_name"
        ]
      },
      {
        "regExp": "(?i).*(us|usa|united states|canada|mexico).*(state|province).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mexico_state_name"
        ],
        "negativeExamples": [
          "country_name"
        ]
      },
      {
        "regExp": "(?i).*(state|province|st|prov).*(full|complete).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_province_full_name"
        ],
        "negativeExamples": [
          "prov_code"
        ]
      },
      {
        "regExp": "(?i).*(state|province|st|prov).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province_name"
        ],
        "negativeExamples": [
          "territory_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "California",
      "New York",
      "Newfoundland and Labrador",
      "British Columbia",
      "Qu\u00e9bec",
      "Prince Edward Island",
      "Baja California Sur",
      "Veracruz de Ignacio de la Llave"
    ],
    "negativeContentExamples": [
      "California State",
      "NewYork",
      "Quebec Province",
      "Baja California S.",
      "Coahuila",
      "Veracruz",
      "Mexico City",
      "Estado de Mexico"
    ],
    "positiveHeaderExamples": [
      "na_state_province_name",
      "state_province_full_name",
      "us_state_name",
      "canada_province_name",
      "mexico_state_name",
      "north_america_state_name",
      "province_name",
      "state_name"
    ],
    "negativeHeaderExamples": [
      "state_code",
      "province_abbr",
      "country_name",
      "city_name",
      "region_name",
      "state_province_code",
      "us_state_id",
      "province_number"
    ],
    "explanation": "Identifies full state/province names across North America (United States states, Canadian provinces/territories, and Mexican states including Ciudad de M\u00e9xico). Values are expected to be complete, properly spelled territorial names (not abbreviations or codes). Typical use cases include standardizing location fields where the full jurisdiction name is required and validating columns that should contain state/province names rather than codes or mixed locality data.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:05:05.284011"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_PE",
    "description": "This type identifies Peruvian province names used for regional administrative identification within Peru's governmental structure. The format consists of proper noun text strings representing official province names in Spanish without abbreviations or special formatting characters.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc]+)( (de|del|la|las|los|y))?( [A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc]+){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5300,
    "headerPatterns": [
      {
        "regExp": "(?i).*(provincia|province).*(name|nombre).*(peru|pe).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "provincia_nombre_pe"
        ],
        "negativeExamples": [
          "provincia_codigo_pe"
        ]
      },
      {
        "regExp": "(?i).*(nombre|name).*(provincia|province).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nombre_provincia"
        ],
        "negativeExamples": [
          "provincia_id"
        ]
      },
      {
        "regExp": "(?i).*(peru|pe).*(provincia|province).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "pe_province"
        ],
        "negativeExamples": [
          "state_pe"
        ]
      },
      {
        "regExp": "(?i).*(prov_|provincia|province).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "prov_name"
        ],
        "negativeExamples": [
          "region_name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Lima",
      "Trujillo",
      "Huarochir\u00ed",
      "Ca\u00f1ete",
      "Mariscal Nieto",
      "La Convenci\u00f3n",
      "Coronel Portillo",
      "General S\u00e1nchez Cerro"
    ],
    "negativeContentExamples": [
      "LIMA",
      "Prov. Lima",
      "Lima 01",
      "Trujillo/La Libertad",
      "general s\u00e1nchez cerro",
      "Lima, Peru",
      "St. Catalina",
      "La-Mar"
    ],
    "positiveHeaderExamples": [
      "provincia_nombre_pe",
      "nombre_provincia_peru",
      "pe_province",
      "provincia_peru",
      "province_name_pe",
      "prov_name",
      "provincia",
      "province"
    ],
    "negativeHeaderExamples": [
      "provincia_codigo_pe",
      "distrito_nombre_pe",
      "region_name_peru",
      "ubigeo_provincia",
      "state_name",
      "province_code",
      "municipio_nombre",
      "city_name"
    ],
    "explanation": "This semantic type targets Spanish-formatted names of Peru's provinces, capturing capitalized words with optional common connectors and Spanish diacritics. It excludes abbreviations, codes, punctuation, numerals, and multi-part descriptors that include country names or administrative qualifiers.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:05:09.455429"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_FIPS_US",
    "description": "This type represents US county FIPS codes used for federal statistical identification and data processing of American counties. The format consists of exactly five consecutive numeric digits with no spaces, letters, or special characters for standardized county referencing.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 5050,
    "headerPatterns": [
      {
        "regExp": "(?i).*us.*county.*fips.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "us_county_fips_code"
        ],
        "negativeExamples": [
          "us_zip_code"
        ]
      },
      {
        "regExp": "(?i).*fips.*county.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fips_county_code"
        ],
        "negativeExamples": [
          "fips_state_code"
        ]
      },
      {
        "regExp": "(?i).*county.*fips.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "county_fips"
        ],
        "negativeExamples": [
          "state_fips"
        ]
      },
      {
        "regExp": "(?i).*county.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "county_code"
        ],
        "negativeExamples": [
          "country_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "01001",
      "02185",
      "06037",
      "12086",
      "17031",
      "26163",
      "41051",
      "53033"
    ],
    "negativeContentExamples": [
      "1001",
      "010010",
      "01-001",
      "ABCDE",
      "12 345",
      "1234a",
      "A1234",
      "123_45"
    ],
    "positiveHeaderExamples": [
      "us_county_fips_code",
      "fips_county_code",
      "county_fips",
      "county_code",
      "cnty_fips_code_us",
      "usa_county_fips",
      "county_fips_id",
      "county_fipscode"
    ],
    "negativeHeaderExamples": [
      "zip_code",
      "state_fips_code",
      "country_code",
      "county_name",
      "fips_state",
      "postal_code",
      "county_population",
      "iso_code"
    ],
    "explanation": "US County FIPS codes are five-digit numeric identifiers formed by a two-digit state code followed by a three-digit county code. This semantic type helps reliably recognize and validate county identifiers in datasets for geospatial analysis, public records, and federal reporting. The pattern is intentionally strict to avoid confusion with other five-digit numbers and leverages header context (county + FIPS + code) to disambiguate.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:05:12.228091"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.REGION_NAME_IT",
    "description": "This type captures the official names of Italian regions as they are used in government administration and official documentation. The values represent complete regional names using proper Italian spelling and linguistic conventions as established by the Italian constitutional system.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "ABRUZZO",
      "BASILICATA",
      "CALABRIA",
      "CAMPANIA",
      "EMILIA-ROMAGNA",
      "FRIULI-VENEZIA GIULIA",
      "LAZIO",
      "LIGURIA",
      "LOMBARDIA",
      "MARCHE",
      "MOLISE",
      "PIEMONTE",
      "PUGLIA",
      "SARDEGNA",
      "SICILIA",
      "TOSCANA",
      "TRENTINO-ALTO ADIGE/S\u00dcDTIROL",
      "UMBRIA",
      "VALLE D'AOSTA/VALL\u00c9E D'AOSTE",
      "VENETO"
    ],
    "backout": "^[A-Z\u00c0-\u00d6\u00d8-\u00dd'\\/\\- ]{4,40}$",
    "confidenceThreshold": 98,
    "priority": 5340,
    "headerPatterns": [
      {
        "regExp": "(?i).*(italian|italy|italia|it).*region.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "italian_region_name"
        ],
        "negativeExamples": [
          "italian_region_code"
        ]
      },
      {
        "regExp": "(?i).*(nome|denominazione).*regione.*ital.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nome_regione_italiana"
        ],
        "negativeExamples": [
          "codice_regione_italiana"
        ]
      },
      {
        "regExp": "(?i).*region.*it.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "region_it"
        ],
        "negativeExamples": [
          "region_us"
        ]
      },
      {
        "regExp": "(?i).*(reg|regione).*(it|ita).*name.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "reg_it_name"
        ],
        "negativeExamples": [
          "reg_code_it"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "ABRUZZO",
      "BASILICATA",
      "EMILIA-ROMAGNA",
      "FRIULI-VENEZIA GIULIA",
      "LOMBARDIA",
      "TRENTINO-ALTO ADIGE/S\u00dcDTIROL",
      "VALLE D'AOSTA/VALL\u00c9E D'AOSTE",
      "TOSCANA"
    ],
    "negativeContentExamples": [
      "EMILIA ROMAGNA",
      "FRIULI VENEZIA GIULIA",
      "TRENTINO-ALTO ADIGE",
      "VALLE D'AOSTA",
      "LOMBARDY",
      "PUGLIA'",
      "SICILIA-",
      "LIGURIA."
    ],
    "positiveHeaderExamples": [
      "italian_region_name",
      "nome_regione_italiana",
      "regione_it_name",
      "region_name_it",
      "official_region_name_italy",
      "regione_italia_denominazione",
      "it_region_name",
      "denominazione_regione_it"
    ],
    "negativeHeaderExamples": [
      "italian_region_code",
      "regione_it_code",
      "country_region_name",
      "province_name_it",
      "state_province_name",
      "nome_regione",
      "regione",
      "area_name"
    ],
    "explanation": "STATE_PROVINCE.REGION_NAME_IT identifies values that exactly match the official Italian region names. It is useful for validating columns that should contain region-level administrative names for Italy, enforcing standardized nomenclature in datasets and facilitating accurate joins, aggregations, and geospatial mapping.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:05:13.934963"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS_<LANGUAGE>",
    "description": "Captures full street addresses formatted for English-language locales, including a leading building number, optional directional, street name, and a recognized street suffix, with optional unit designators (e.g., Apt, Ste, #). This type is intended for complete delivery-ready street lines without city, state/province, or postal code appended.",
    "pluginType": "regex",
    "regexPattern": "\\b(\\d{1,6}[A-Z]?|\\d{1,5}-\\d{1,5})\\b\\s+(N|S|E|W|NE|NW|SE|SW)?\\s*[A-Za-z][A-Za-z0-9'\\- ]{1,40}\\s+(St|Street|Ave|Avenue|Rd|Road|Blvd|Boulevard|Ln|Lane|Dr|Drive|Ct|Court|Pl|Place|Pkwy|Parkway|Ter|Terrace|Way|Hwy|Highway|Cir|Circle)\\b(\\s*(N|S|E|W|NE|NW|SE|SW))?(\\s*(,|#)?\\s*(Apt|Unit|Ste|Suite|Fl|Floor|#)\\s*[A-Za-z0-9\\-]{1,6})?",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 5550,
    "headerPatterns": [
      {
        "regExp": "(?i).*street.*address.*(en|english).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "street_address_en"
        ],
        "negativeExamples": [
          "street_address_fr"
        ]
      },
      {
        "regExp": "(?i).*(shipping|billing).*(street.*address|street|addr|address).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "shipping_street_address"
        ],
        "negativeExamples": [
          "shipping_postal_code"
        ]
      },
      {
        "regExp": "(?i).*(street|st)[ _]?(addr|address|addr_line1|address_line1|line1|line_1).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "street_addr_line1_en"
        ],
        "negativeExamples": [
          "street_name"
        ]
      },
      {
        "regExp": "(?i).*(delivery|residential|home).*(street|address).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "residential_street_address"
        ],
        "negativeExamples": [
          "business_phone"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "english_street_address"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      }
    ],
    "positiveContentExamples": [
      "221B Baker Street",
      "123 Main St",
      "10 Downing St",
      "455 N Maple Ave",
      "789 SE 5th Ave",
      "55-21 48th Ave",
      "1600 Pennsylvania Avenue",
      "500 W 5th St Apt 2B"
    ],
    "negativeContentExamples": [
      "PO Box 123",
      "123 Main",
      "N Main St",
      "123- Main St",
      "Apt 4B, 123 Main Street",
      "Main Street 123",
      "500 W Fifth",
      "221B Baker Street, London"
    ],
    "positiveHeaderExamples": [
      "street_address_en",
      "shipping_street_address",
      "billing_street_en",
      "addr_street_en",
      "street_addr_line1_en",
      "delivery_address_street",
      "residential_street_address",
      "english_street_address"
    ],
    "negativeHeaderExamples": [
      "street_address_fr",
      "email_address",
      "ip_address",
      "street_name",
      "addr_line2",
      "postal_code",
      "city",
      "billing_name"
    ],
    "explanation": "This semantic type identifies English-formatted street address lines consisting of a building number (including hyphenated numbers), optional directional prefix/suffix, a street name, and a recognized street type suffix, with an optional unit indicator at the end. It excludes PO Boxes and composite address strings that include locality, region, or postal code, focusing on a single deliverable street line.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:05:13.953584"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COMMUNE_IT",
    "description": "This type identifies Italian commune names used for municipal identification within Italy's administrative structure. The format consists of proper noun text strings representing official commune names in Italian without abbreviations or special formatting.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]+'?[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]+(?:[ -][A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]+'?[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]+){0,4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5040,
    "headerPatterns": [
      {
        "regExp": "(?i).*(it|italian)[ _-]*comune[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "it_comune_name"
        ],
        "negativeExamples": [
          "comune_name"
        ]
      },
      {
        "regExp": "(?i).*(it|italian)[ _-]*municipality[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "italian_municipality_name"
        ],
        "negativeExamples": [
          "municipality_name"
        ]
      },
      {
        "regExp": "(?i).*(comune|commune|municipality)[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "comune_name"
        ],
        "negativeExamples": [
          "comune_code"
        ]
      },
      {
        "regExp": "(?i).*(muni)[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "muni_name"
        ],
        "negativeExamples": [
          "muni_code"
        ]
      },
      {
        "regExp": "(?i).*(comune|commune|municipality).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "comune"
        ],
        "negativeExamples": [
          "province_name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Roma",
      "Milano",
      "Napoli",
      "Torino",
      "Bologna",
      "L'Aquila",
      "Reggio nell'Emilia",
      "San Giovanni Lupatoto"
    ],
    "negativeContentExamples": [
      "S. Giovanni Lupatoto",
      "Roma (IT)",
      "Milano-20100",
      "Reggio Emilia",
      "L Aquila",
      "Comune di Milano",
      "Bolzano/Bozen",
      "San G. Lupatoto"
    ],
    "positiveHeaderExamples": [
      "italian_commune_name",
      "it_commune_name",
      "commune_name",
      "comune_name",
      "municipality_name",
      "comune_it_name",
      "comune",
      "municipality"
    ],
    "negativeHeaderExamples": [
      "commune_code",
      "municipality_code",
      "province_name",
      "state_name",
      "city",
      "country_name",
      "comune_abbrev",
      "commune_id"
    ],
    "explanation": "Italian communes (comuni) are the basic administrative divisions in Italy. This semantic type targets official commune names as they typically appear in datasets: alphabetic words with possible spaces, apostrophes, and hyphens, and without abbreviations, codes, or extraneous punctuation. It is useful for identifying municipality name fields in Italian administrative and demographic data.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:05:15.814394"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_MX",
    "description": "This type captures abbreviated codes for Mexican states and federal districts used in official documentation and geographic identification systems. The values represent standardized abbreviations derived from state names using uppercase letters without periods or additional punctuation.",
    "pluginType": "regex",
    "regexPattern": "\\b(AGU|BCN|BCS|CAM|CHH|CHP|CMX|COA|COL|DUR|GUA|GRO|HID|JAL|MEX|MIC|MOR|NAY|NLE|OAX|PUE|QUE|ROO|SIN|SLP|SON|TAB|TAM|TLA|VER|YUC|ZAC)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5400,
    "headerPatterns": [
      {
        "regExp": "(?i).*(mexico|mx).*(state|estado|entidad).*(code|codigo|clave|abbr).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "mexico_state_code"
        ],
        "negativeExamples": [
          "mexico_state_name"
        ]
      },
      {
        "regExp": "(?i).*(state|estado|entidad).*(mx|mexico).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "state_mx"
        ],
        "negativeExamples": [
          "state_abbr_us"
        ]
      },
      {
        "regExp": "(?i).*(mx|mex).*(state|estado).*(abbr|clave).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "mx_state_abbr"
        ],
        "negativeExamples": [
          "mx_state_name"
        ]
      },
      {
        "regExp": "(?i).*(state|estado|entidad).*(code|codigo|clave).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "estado_clave"
        ],
        "negativeExamples": [
          "country_code_mx"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "AGU",
      "BCN",
      "BCS",
      "CMX",
      "JAL",
      "MEX",
      "NLE",
      "SLP"
    ],
    "negativeContentExamples": [
      "MX-AGU",
      "agu",
      "AG",
      "AGUA",
      "CMEX",
      "NLEO",
      "S-LP",
      "MEX1"
    ],
    "positiveHeaderExamples": [
      "mexico_state_code",
      "state_code_mx",
      "mx_state_abbr",
      "estado_clave",
      "clave_estado_mx",
      "entidad_federativa_codigo",
      "codigo_estado_mx",
      "mx_entidad_code"
    ],
    "negativeHeaderExamples": [
      "mexico_state_name",
      "state_abbr_us",
      "province_code_ca",
      "mx_state",
      "entidad_federativa",
      "municipio_codigo",
      "country_code_mx",
      "postal_code_mx"
    ],
    "explanation": "Identifies standardized three-letter uppercase abbreviations representing the 32 Mexican states and the federal district as used in official and geographic datasets. Useful for normalizing regional attributes, joining reference tables, and validating location codes in Mexico-focused data.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:05:18.041129"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_US",
    "description": "This type captures the complete names of US states and territories as they are used in official documentation and government administration. The values represent full state names using proper English spelling and standard formatting as established by the US constitutional and administrative systems.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(Alabama|Alaska|Arizona|Arkansas|California|Colorado|Connecticut|Delaware|Florida|Georgia|Hawaii|Idaho|Illinois|Indiana|Iowa|Kansas|Kentucky|Louisiana|Maine|Maryland|Massachusetts|Michigan|Minnesota|Mississippi|Missouri|Montana|Nebraska|Nevada|New Hampshire|New Jersey|New Mexico|New York|North Carolina|North Dakota|Ohio|Oklahoma|Oregon|Pennsylvania|Rhode Island|South Carolina|South Dakota|Tennessee|Texas|Utah|Vermont|Virginia|Washington|West Virginia|Wisconsin|Wyoming|District of Columbia|Puerto Rico|Guam|American Samoa|Northern Mariana Islands|United States Virgin Islands|U\\.S\\. Virgin Islands)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5450,
    "headerPatterns": [
      {
        "regExp": "(?i).*(united states|us|u\\.s\\.).*state.*full.*name.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "us_state_full_name"
        ],
        "negativeExamples": [
          "state_code"
        ]
      },
      {
        "regExp": "(?i).*(us|u\\.s\\.|united states).*(state|territory).*(name).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "state_territory_name_us"
        ],
        "negativeExamples": [
          "territory_code"
        ]
      },
      {
        "regExp": "(?i).*state.*province.*name.*us.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_province_name_us"
        ],
        "negativeExamples": [
          "province_abbreviation"
        ]
      },
      {
        "regExp": "(?i).*(us|u\\.s\\.|united states).*state.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "us_state_name"
        ],
        "negativeExamples": [
          "state_id"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "California",
      "New Hampshire",
      "District of Columbia",
      "Puerto Rico",
      "U.S. Virgin Islands",
      "American Samoa",
      "North Dakota",
      "West Virginia"
    ],
    "negativeContentExamples": [
      "CA",
      "California State",
      "NewYork",
      "Washington, DC",
      "Virgin Islands",
      "North Dakota Territory",
      "Puerto Rico USA",
      "U. S. Virgin Islands"
    ],
    "positiveHeaderExamples": [
      "us_state_full_name",
      "united_states_state_name",
      "state_territory_name_us",
      "state_province_name_us",
      "full_state_name",
      "state_name_us",
      "us_state_or_territory_name",
      "us_state_name"
    ],
    "negativeHeaderExamples": [
      "state_code",
      "iso_subdivision_code",
      "province_abbreviation",
      "city_name",
      "country_name",
      "region",
      "state_id",
      "postal_state_code"
    ],
    "explanation": "Matches full English names of the 50 US states plus the District of Columbia and the five major inhabited US territories. Useful for validating columns that store normalized jurisdiction names in addresses, licensing records, voter rolls, or government datasets where full names are required rather than abbreviations.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:05:19.499444"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.SSN_FR",
    "description": "This type represents the French social security number (INSEE/NIR), a 15-digit identifier encoding gender (1 or 2), birth year and month, birth location code, an individual sequence, and a 2-digit validation key. Values may be written as a continuous 15-digit string or with spaces or hyphens between tokens. The regex validates overall structure (including month 01\u201312) but does not compute or verify the check key.",
    "pluginType": "regex",
    "regexPattern": "\\b[12][ -]?\\d{2}[ -]?(0[1-9]|1[0-2])[ -]?\\d{2}[ -]?\\d{3}[ -]?\\d{3}[ -]?\\d{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4480,
    "headerPatterns": [
      {
        "regExp": "(?i).*(fr|french).*(ssn|social.*security|securite.*sociale).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "french_ssn"
        ],
        "negativeExamples": [
          "social_security_claim"
        ]
      },
      {
        "regExp": "(?i).*(numero|num|no).*securite.*sociale.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "numero_securite_sociale"
        ],
        "negativeExamples": [
          "securite_sociale_benefit"
        ]
      },
      {
        "regExp": "(?i).*(insee|nir).*(number|num|no|code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "insee_number"
        ],
        "negativeExamples": [
          "insee_dataset"
        ]
      },
      {
        "regExp": "(?i).*(national.*id|national.*identifier).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "national_id_code"
        ],
        "negativeExamples": [
          "national_insurance_number"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "1 84 12 75 123 456 78",
      "2 99 05 13 001 245 36",
      "184127512345678",
      "1-85-10-99-450-123-07",
      "2 00 12 97 215 003 44",
      "1 73 01 02 345 678 90",
      "2-19-11-99-010-001-12",
      "1 60 07 75 321 654 09"
    ],
    "negativeContentExamples": [
      "1 84 13 75 123 456 78",
      "1841275123456789",
      "3 84 12 75 123 456 78",
      "2 99 00 13 001 245 36",
      "1-84-12-7-123-456-78",
      "1 84 12 75 123 456 7A",
      "1--84-12-75-123-456-78",
      "12 84 12 75 123 456 78"
    ],
    "positiveHeaderExamples": [
      "insee_number",
      "nir",
      "numero_securite_sociale",
      "french_ssn",
      "num_nir",
      "no_securite_sociale",
      "national_id_code",
      "social_security_fr"
    ],
    "negativeHeaderExamples": [
      "insee_commune_code",
      "siret_number",
      "tax_id_code",
      "security_code",
      "national_insurance_number",
      "ssn_last4",
      "social_security_claim",
      "passport_code"
    ],
    "explanation": "French NIR/INSEE numbers are 15 digits with structured segments: 1 digit for gender (1 or 2), 2 for year, 2 for month (01\u201312), 2 for department/location prefix, 3 for commune, 3 for individual sequence, and 2 for the key. This configuration recognizes compact and separated formats using spaces or hyphens while enforcing token lengths and valid month range. It targets datasets containing full French social security numbers and relies on structural validation rather than checksum computation.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:05:20.022577"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS2_EN",
    "description": "This type captures supplementary addressing information that provides additional location specificity beyond the primary street address. The values represent apartment numbers, suite designations, unit identifiers, or floor information using standard English addressing conventions and common abbreviations.",
    "pluginType": "regex",
    "regexPattern": "\\b((apt|apt\\.|apartment|suite|ste|ste\\.|unit|room|rm|rm\\.|building|bldg|bldg\\.)( |\\-)?(number|no)?( |\\-)?#?( |\\-)?[A-Za-z0-9]{1,4}([\\- ][A-Za-z0-9]{1,4})?|(floor|fl|fl\\.|level|lvl)( |\\-)?[0-9]{1,2}(st|nd|rd|th)?|#( |\\-)?[A-Za-z0-9]{1,4}([\\- ][A-Za-z0-9]{1,4})?)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5520,
    "headerPatterns": [
      {
        "regExp": "(?i).*(address2|address_2|addr2|addr_2|addressline2|address_line_2|street_address2|street_address_2).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "address_line_2"
        ],
        "negativeExamples": [
          "address_line"
        ]
      },
      {
        "regExp": "(?i).*(address|addr).*(line|ln|lne).*(two|2nd|second).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "address_line_two"
        ],
        "negativeExamples": [
          "address_line_one"
        ]
      },
      {
        "regExp": "(?i).*(secondary|2nd|second).*(address|addr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "secondary_address"
        ],
        "negativeExamples": [
          "primary_address"
        ]
      },
      {
        "regExp": "(?i).*(apt|apartment|suite|ste|unit|floor|fl|level|lvl|room|rm).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "unit"
        ],
        "negativeExamples": [
          "street_name"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "address"
        ],
        "negativeExamples": [
          "email"
        ]
      }
    ],
    "positiveContentExamples": [
      "Apt 5B",
      "Apartment 12",
      "Suite 400",
      "Ste. 200",
      "Unit A-12",
      "Floor 3",
      "Rm 210",
      "#12-3"
    ],
    "negativeContentExamples": [
      "Suite",
      "Unit-",
      "Floor B",
      "Apartment Twelve",
      "Unit 12345",
      "#12A-3B-4",
      "PO Box 123",
      "Bldg"
    ],
    "positiveHeaderExamples": [
      "address_line_2",
      "addr2",
      "street_address_2",
      "addressline2",
      "secondary_address",
      "unit",
      "apartment_unit",
      "suite"
    ],
    "negativeHeaderExamples": [
      "address_line_1",
      "billing_address",
      "city",
      "postal_code",
      "street",
      "email_address",
      "phone",
      "country"
    ],
    "explanation": "This semantic type recognizes secondary address line content that commonly appears as apartment, suite, unit, room, or floor designations, often including a short alphanumeric identifier with optional separators or a leading # symbol. It is intended for fields that store Address Line 2 data in English-language addressing contexts and avoids matching full street addresses or unrelated contact fields.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:05:27.546557"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_NAME_BARE_EN",
    "description": "Captures the core identifying portion of English street names, excluding street type markers or suffixes (e.g., Street, Ave, Rd). Values consist of one to four Title Case words, allowing internal apostrophes or hyphens within words, but no trailing street-type designators.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z][a-z]+(['-][A-Z]?[a-z]+)?)(\\s+[A-Z][a-z]+(['-][A-Z]?[a-z]+)?){0,3}(?!\\s+(Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Lane|Ln|Drive|Dr|Court|Ct|Circle|Cir|Way|Terrace|Ter|Place|Pl|Highway|Hwy|Pike|Parkway|Pkwy|Alley|Aly)\\b)",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 5590,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bstreet\\b.*\\bname\\b.*\\b(bare|core|base)\\b.*\\ben\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "street_name_bare_en"
        ],
        "negativeExamples": [
          "street_name"
        ]
      },
      {
        "regExp": "(?i).*\\bstreet\\b.*\\bname\\b.*\\ben\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "primary_street_name_en"
        ],
        "negativeExamples": [
          "street_type_en"
        ]
      },
      {
        "regExp": "(?i).*\\b(thoroughfare|road|rd|avenue|ave)\\b.*\\b(base|core|bare)\\b.*\\bname\\b.*\\ben\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "thoroughfare_base_name_en"
        ],
        "negativeExamples": [
          "road_name"
        ]
      },
      {
        "regExp": "(?i).*\\bst\\b.*\\b(name|nm)\\b.*\\ben\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "st_nm_en"
        ],
        "negativeExamples": [
          "state_name_en"
        ]
      },
      {
        "regExp": "(?i).*\\bstreet\\b.*\\bcore\\b.*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "street_core_name"
        ],
        "negativeExamples": [
          "street_full_name"
        ]
      },
      {
        "regExp": "(?i).*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Maple",
      "O'Connor",
      "King's Meadow",
      "Martin Luther King",
      "Queen Anne",
      "Baker",
      "Greenwood",
      "Saint Andrew"
    ],
    "negativeContentExamples": [
      "Main Street",
      "Cedar Rd",
      "Queen Avenue",
      "Baker St",
      "Elm Drive",
      "Maple Blvd",
      "O'Connor Lane",
      "7th"
    ],
    "positiveHeaderExamples": [
      "street_name_bare_en",
      "bare_street_name_en",
      "street_core_name_en",
      "primary_street_name_en",
      "street_name_core_en",
      "thoroughfare_base_name_en",
      "base_street_name_en",
      "st_nm_en"
    ],
    "negativeHeaderExamples": [
      "street_name",
      "street_type_en",
      "address_line1",
      "city_name",
      "state_name_en",
      "street_full",
      "street_suffix_en",
      "road_name"
    ],
    "explanation": "This semantic type targets the base component of English street names to support parsing, standardization, and geocoding workflows where suffix/type is handled separately. It expects Title Case alphabetic words (1\u20134 tokens) and rejects values that include trailing street-type terms such as Street, Ave, or Rd.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:05:31.352061"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_BR",
    "description": "This type identifies Brazilian municipality names used for local administrative identification within Brazil's governmental structure. The format consists of proper noun text strings representing official municipality names in Portuguese without abbreviations or special formatting characters.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z\u00c1\u00c2\u00c3\u00c0\u00c9\u00ca\u00cd\u00d3\u00d4\u00d5\u00da\u00c7][a-z\u00e1\u00e2\u00e3\u00e0\u00e9\u00ea\u00ed\u00f3\u00f4\u00f5\u00fa\u00e7]+( (de|da|do|das|dos|e) [A-Z\u00c1\u00c2\u00c3\u00c0\u00c9\u00ca\u00cd\u00d3\u00d4\u00d5\u00da\u00c7][a-z\u00e1\u00e2\u00e3\u00e0\u00e9\u00ea\u00ed\u00f3\u00f4\u00f5\u00fa\u00e7]+| [A-Z\u00c1\u00c2\u00c3\u00c0\u00c9\u00ca\u00cd\u00d3\u00d4\u00d5\u00da\u00c7][a-z\u00e1\u00e2\u00e3\u00e0\u00e9\u00ea\u00ed\u00f3\u00f4\u00f5\u00fa\u00e7]+){0,5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 5150,
    "headerPatterns": [
      {
        "regExp": "(?i).*(municipality|munic\u00edpio).*(brazil|br).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality_name_br"
        ],
        "negativeExamples": [
          "municipality_code_br"
        ]
      },
      {
        "regExp": "(?i).*(municipality|munic\u00edpio).*(brazil|br).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipio_br"
        ],
        "negativeExamples": [
          "province_br"
        ]
      },
      {
        "regExp": "(?i).*(city|cidade).*(brazil|br).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "city_brazil"
        ],
        "negativeExamples": [
          "city_code"
        ]
      },
      {
        "regExp": "(?i).*(muni|mun).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mun_name_br"
        ],
        "negativeExamples": [
          "mun_code_br"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "S\u00e3o Paulo",
      "Rio de Janeiro",
      "Belo Horizonte",
      "Porto Alegre",
      "S\u00e3o Jos\u00e9 dos Campos",
      "Juiz de Fora",
      "Foz do Igua\u00e7u",
      "Jo\u00e3o Pessoa"
    ],
    "negativeContentExamples": [
      "SAO PAULO",
      "S\u00e3o Paulo - SP",
      "Belo-Horizonte",
      "Olho d'\u00c1gua",
      "Rio de Janeiro 2",
      "Fortaleza/CE",
      "St Jose dos Campos",
      "Jo\u00e3o Pessoa, PB"
    ],
    "positiveHeaderExamples": [
      "municipality_name_br",
      "municipio_br",
      "city_brazil",
      "nome_municipio_br",
      "municipio_nome",
      "brazil_municipality_name",
      "municipio_brasil",
      "mun_name_br"
    ],
    "negativeHeaderExamples": [
      "municipality_code",
      "state_name",
      "province",
      "country",
      "postal_code",
      "city_code_br",
      "airport_city",
      "county_name"
    ],
    "explanation": "This semantic type targets full, official Brazilian municipality names written as proper nouns in Portuguese. It accepts multi-word names with standard Portuguese diacritics and common lowercase connectors such as de, da, do, das, dos, and e, while excluding abbreviations and special formatting like hyphens, slashes, apostrophes, or appended state codes. Typical use cases include classifying location fields at the municipality level in Brazilian datasets for geospatial analysis, address normalization, and administrative reporting.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:05:31.796399"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS_EN",
    "description": "This type captures street addresses as they are formatted in English-speaking contexts for postal delivery and location identification. The values represent complete address strings combining house numbers, street names, and street types using standard English formatting and common abbreviations.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{1,6}(-[0-9]{1,4})?[A-Za-z]?\\s+(([A-Za-z]+('[A-Za-z]+)?)|([0-9]{1,3}(st|nd|rd|th)))(\\s+(([A-Za-z]+('[A-Za-z]+)?)|([0-9]{1,3}(st|nd|rd|th)))){0,3}\\s+(Street|St\\.|St|Avenue|Ave\\.|Ave|Road|Rd\\.|Rd|Boulevard|Blvd\\.|Blvd|Drive|Dr\\.|Dr|Lane|Ln\\.|Ln|Court|Ct\\.|Ct|Place|Pl\\.|Pl|Terrace|Ter\\.|Ter|Way|Highway|Hwy\\.|Hwy|Parkway|Pkwy\\.|Pkwy|Circle|Cir\\.|Cir|Row|Trail|Trl\\.|Trl|Commons|Cmns|Square|Sq\\.|Sq)\\b(\\s+(N|S|E|W|NE|NW|SE|SW))?",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5560,
    "headerPatterns": [
      {
        "regExp": "(?i).*(shipping|billing|mailing|service).*street.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "shipping_street_address"
        ],
        "negativeExamples": [
          "billing_city"
        ]
      },
      {
        "regExp": "(?i).*billing.*address.*line.*1.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "billing_address_line1"
        ],
        "negativeExamples": [
          "billing_address_line2"
        ]
      },
      {
        "regExp": "(?i).*(street|st).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "street_address"
        ],
        "negativeExamples": [
          "email_address"
        ]
      },
      {
        "regExp": "(?i).*(service|residence|site).*(address|addr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "service_street_addr"
        ],
        "negativeExamples": [
          "site_code"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "address"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      }
    ],
    "positiveContentExamples": [
      "221B Baker Street",
      "10 Downing St",
      "1600 Pennsylvania Ave NW",
      "12 O'Connor Rd",
      "45-12 31st St",
      "3 Queens Blvd",
      "742 Evergreen Terrace",
      "200 King's Rd"
    ],
    "negativeContentExamples": [
      "Main Street",
      "123 Main",
      "12-B Main Street",
      "55 N.W. Ave",
      "88 7th",
      "123 Main Streetroom",
      "99999 Verylongstreetnamewithnumbers123 Rd",
      "45-12 31 St"
    ],
    "positiveHeaderExamples": [
      "shipping_street_address",
      "billing_address_line1",
      "street_address",
      "service_street_addr",
      "residence_address",
      "mailing_street_address",
      "site_address",
      "address"
    ],
    "negativeHeaderExamples": [
      "email",
      "ip",
      "postal_code",
      "city_name",
      "state_province",
      "country",
      "apartment_number",
      "street_name"
    ],
    "explanation": "Identifies English-formatted street address strings that start with a house number (including hyphenated numbers and letter suffixes), followed by one to four street name tokens (alphabetic with optional apostrophes or numeric ordinals like 1st/2nd), and a recognized street type (e.g., St, Ave, Rd, Blvd), with an optional trailing cardinal/ordinal direction (e.g., NW). This is useful for extracting and validating line-1 street address fields in datasets focused on postal delivery or geocoding.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:05:41.132551"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_NUMBER",
    "description": "House or building numbers used in street addressing systems to identify specific properties along thoroughfares. Values are typically numeric and may include letter suffixes, fractional halves, or certain hyphenated formats used by local conventions.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{1,6}[A-Za-z]{0,2}\\b|\\b\\d{1,3}-\\d{1,4}\\b|\\b\\d{1,4}\\s1/2\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 5610,
    "headerPatterns": [
      {
        "regExp": "(?i).*street[_\\s]*(number|no|num|nbr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "street_number"
        ],
        "negativeExamples": [
          "street_name"
        ]
      },
      {
        "regExp": "(?i).*(house|building)[_\\s]*(number|no|num|nbr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "house_no"
        ],
        "negativeExamples": [
          "building_name"
        ]
      },
      {
        "regExp": "(?i).*(addr|address).*\\b(house|street)[_\\s]*(number|no|num|nbr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "addr_house_number"
        ],
        "negativeExamples": [
          "address_line1"
        ]
      },
      {
        "regExp": "(?i).*(st|hse|bldg)[_\\s]*(no|num|nbr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "bldg_no"
        ],
        "negativeExamples": [
          "st_name"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "12",
      "7B",
      "221B",
      "34-12",
      "58 1/2",
      "1024A",
      "5",
      "12000"
    ],
    "negativeContentExamples": [
      "A12",
      "12A/3",
      "12-B",
      "12 3",
      "34-12B",
      "12\u00bd",
      "B12-3",
      "1A-2"
    ],
    "positiveHeaderExamples": [
      "street_number",
      "house_no",
      "building_number",
      "streetnumber",
      "addr_house_number",
      "primary_street_no",
      "house_nbr",
      "bldg_no"
    ],
    "negativeHeaderExamples": [
      "street_name",
      "building_name",
      "unit_number",
      "apartment_no",
      "address_line1",
      "postal_code",
      "lot_number",
      "phone_number"
    ],
    "explanation": "This semantic type identifies the property number component of a street address, typically consisting of digits with optional letter suffixes (e.g., 221B), certain hyphenated formats used in local addressing systems (e.g., 34-12), or fractional halves (e.g., 58 1/2). It is intended to capture the standalone street number token without street names or unit/apartment identifiers.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:05:45.833597"
  },
  {
    "resultType": "generated",
    "semanticType": "URI.URL",
    "description": "This type captures web addresses and resource locators used to identify and access content across networks including websites, files, and services. The values represent complete URL strings including protocol schemes, domain names, paths, and optional parameters following standardized URI formatting conventions.",
    "pluginType": "regex",
    "regexPattern": "\\b(https|http|ftp)://([A-Za-z0-9-]+\\.)+[A-Za-z]{2,}(:[0-9]{2,5})?(/[A-Za-z0-9._~:/?#\\[\\]@!$&'()*+,;=%-]*)?",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 5640,
    "headerPatterns": [
      {
        "regExp": "(?i).*customer.*profile.*url.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_profile_url"
        ],
        "negativeExamples": [
          "customer_profile_id"
        ]
      },
      {
        "regExp": "(?i).*(website|web|page).*url.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "website_url"
        ],
        "negativeExamples": [
          "website_name"
        ]
      },
      {
        "regExp": "(?i).*(page|profile|website).*link.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "profile_link"
        ],
        "negativeExamples": [
          "link_count"
        ]
      },
      {
        "regExp": "(?i).*(uri|resource).*locator.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "resource_locator"
        ],
        "negativeExamples": [
          "resource_owner"
        ]
      },
      {
        "regExp": "(?i).*url.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "url"
        ],
        "negativeExamples": [
          "address"
        ]
      }
    ],
    "positiveContentExamples": [
      "https://www.example.com",
      "http://example.org/resource",
      "https://sub.domain.co.uk/path/to/page?query=1&sort=asc",
      "ftp://files.example.net/downloads/archive.zip",
      "https://api.example.com/v1/users?id=42#section",
      "http://blog.example.io/posts/2025/08/title",
      "https://shop.example.com:8443/cart/checkout?ref=mail",
      "https://cdn.example.com/assets/img/logo.png"
    ],
    "negativeContentExamples": [
      "www.example.com",
      "example.com/path",
      "http:/example.com",
      "https//example.com",
      "http://exa_mple.com",
      "https://example",
      "htp://example.com",
      "https:///example.com"
    ],
    "positiveHeaderExamples": [
      "url",
      "website_url",
      "landing_page_url",
      "profile_link",
      "resource_locator",
      "product_page_url",
      "homepage_url",
      "redirect_url"
    ],
    "negativeHeaderExamples": [
      "website_name",
      "page_title",
      "profile_id",
      "link_count",
      "uri",
      "address",
      "file_path",
      "email"
    ],
    "explanation": "This semantic type identifies full URLs with supported schemes (http, https, ftp), a valid domain structure, optional port, and an optional path/query/fragment. The regex deliberately avoids anchors to remain FTA-compatible and uses a word boundary to reduce false positives while enforcing clear token structure for scheme, host, and optional components. Header patterns progress from specific business-oriented variants to the primitive term 'url' to robustly capture common column naming conventions while minimizing collisions with unrelated fields.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:05:47.262037"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.DEPARTMENT_CO",
    "description": "This type identifies Colombian department names used for regional administrative identification within Colombia's governmental structure. The format consists of proper noun text strings representing official department names in Spanish without abbreviations or special formatting characters.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(AMAZONAS|ANTIOQUIA|ARAUCA|ATL\u00c1NTICO|BOL\u00cdVAR|BOYAC\u00c1|CALDAS|CAQUET\u00c1|CASANARE|CAUCA|CESAR|CHOC\u00d3|C\u00d3RDOBA|CUNDINAMARCA|GUAIN\u00cdA|GUAVIARE|HUILA|LA GUAJIRA|MAGDALENA|META|NARI\u00d1O|NORTE DE SANTANDER|PUTUMAYO|QUIND\u00cdO|RISARALDA|SAN ANDR\u00c9S Y PROVIDENCIA|SANTANDER|SUCRE|TOLIMA|VALLE DEL CAUCA|VAUP\u00c9S|VICHADA)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5100,
    "headerPatterns": [
      {
        "regExp": "(?i).*(colombia|\\bco\\b).*(departamento|department).*(nombre|name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "colombia_department_name"
        ],
        "negativeExamples": [
          "department_name"
        ]
      },
      {
        "regExp": "(?i).*(departamento|department).*(colombia|\\bco\\b).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "department_co_name"
        ],
        "negativeExamples": [
          "department_code"
        ]
      },
      {
        "regExp": "(?i).*(departamento|department).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "departamento_nombre"
        ],
        "negativeExamples": [
          "province_name"
        ]
      },
      {
        "regExp": "(?i).*(dpto|depto|dept).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "depto_nombre"
        ],
        "negativeExamples": [
          "dep_id"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_province_name_co"
        ],
        "negativeExamples": [
          "department_code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Antioquia",
      "Atl\u00e1ntico",
      "C\u00f3rdoba",
      "Quind\u00edo",
      "Norte de Santander",
      "San Andr\u00e9s y Providencia",
      "Valle del Cauca",
      "Guain\u00eda"
    ],
    "negativeContentExamples": [
      "Bogot\u00e1",
      "Norte Santander",
      "San Andres y Providencia",
      "Valle de Cauca",
      "Choco",
      "Cordoba",
      "La-Guajira",
      "Santander de Quilichao"
    ],
    "positiveHeaderExamples": [
      "co_department_name",
      "colombia_department_name",
      "departamento_nombre",
      "department_co_name",
      "depto_nombre",
      "state_province_name_co",
      "departamento_co",
      "department_name_co"
    ],
    "negativeHeaderExamples": [
      "country",
      "city",
      "region_id",
      "state_code",
      "municipio",
      "province_code",
      "postal_code",
      "area"
    ],
    "explanation": "This semantic type recognizes official Colombian department names in Spanish, written as standalone proper nouns without abbreviations or punctuation. It is suitable for classifying administrative region fields where values are department names rather than codes or IDs. Typical uses include normalizing regional attributes in customer, address, and regional reporting datasets.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:05:47.336755"
  },
  {
    "resultType": "generated",
    "semanticType": "VIN",
    "description": "Standardized vehicle identification numbers used by automotive manufacturers and regulatory agencies for vehicle tracking and identification. Values are exactly 17 alphanumeric characters following international VIN conventions, using letters and digits with position-based encoding for manufacturer, vehicle characteristics, and serial information. Letters I, O, and Q are excluded to avoid confusion with digits.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9A-HJ-NPR-Za-hj-npr-z]{17}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5650,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\b(vehicle|auto|car)\\b[_\\s-]*\\bidentification\\b[_\\s-]*\\bnumber\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "vehicle_identification_number"
        ],
        "negativeExamples": [
          "vehicle_registration_number"
        ]
      },
      {
        "regExp": "(?i).*\\bvin\\b[_\\s-]*\\bnumber\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "vin_number"
        ],
        "negativeExamples": [
          "vendor_number"
        ]
      },
      {
        "regExp": "(?i).*\\b(vehicle|auto|car)\\b[_\\s-]*\\bvin\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "car_vin"
        ],
        "negativeExamples": [
          "vehicle_id"
        ]
      },
      {
        "regExp": "(?i).*\\bchassis\\b[_\\s-]*\\bnumber\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "chassis_number"
        ],
        "negativeExamples": [
          "engine_number"
        ]
      },
      {
        "regExp": "(?i).*\\bvin\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "vin"
        ],
        "negativeExamples": [
          "serial"
        ]
      }
    ],
    "positiveContentExamples": [
      "1HGCM82633A004352",
      "JHMFA16586S000123",
      "WDBUF56X98B123456",
      "3FAHP0HA6AR123456",
      "SALWR2VF4FA123456",
      "5YJSA1E26FF101234",
      "WAUZZZ8V2JA123456",
      "ZFAE356000L123456"
    ],
    "negativeContentExamples": [
      "1HGCM82633A00435",
      "1HGCM82633A0043527",
      "1HGIM82633A004352",
      "JHMFA16586Q000123",
      "3FAHP0HA6AR12O456",
      "WDBUF56X98B-23456",
      "SALWR2VF4FA12!456",
      "VIN12345678901234"
    ],
    "positiveHeaderExamples": [
      "vehicle_identification_number",
      "vin_number",
      "car_vin",
      "chassis_number",
      "vehicle_vin",
      "vin"
    ],
    "negativeHeaderExamples": [
      "vehicle_registration_number",
      "vendor_number",
      "vehicle_id",
      "engine_number",
      "serial",
      "invoice_number"
    ],
    "explanation": "This semantic type targets automotive Vehicle Identification Numbers (VINs). It validates 17-character alphanumeric identifiers that exclude the letters I, O, and Q, aligning with international VIN formatting. It is intended for datasets involving vehicles, registrations, manufacturing, logistics, or compliance where VINs are recorded or validated.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:05:49.507050"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.LAST_FIRST",
    "description": "This type represents full personal names in the formal last name, first name format commonly used in official documents, directories, and alphabetical listings. The values combine family names and given names with a comma and space separator in the surname-first ordering convention.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z][a-z]{1,}(['-][A-Z][a-z]{1,})?)( ([A-Z][a-z]{1,}(['-][A-Z][a-z]{1,})?)){0,2}, ([A-Z][a-z]{1,}(['-][A-Z][a-z]{1,})?)( ([A-Z][a-z]{1,}(['-][A-Z][a-z]{1,})?)){0,2}( [A-Z]\\.)?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4660,
    "headerPatterns": [
      {
        "regExp": "(?i).*(last|surname)[ _-]*[, ]?[ _-]*(first|given)[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "last_first_name"
        ],
        "negativeExamples": [
          "first_last_name"
        ]
      },
      {
        "regExp": "(?i).*(person|employee|customer)[ _-].*(last|surname).*[ _-].*(first|given).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_last_first"
        ],
        "negativeExamples": [
          "customer_name"
        ]
      },
      {
        "regExp": "(?i).*surname[ _-]*first.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "surname_first"
        ],
        "negativeExamples": [
          "first_surname"
        ]
      },
      {
        "regExp": "(?i).*(lname[ _-]*fname|l[ _-]*f[ _-]*name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lname_fname"
        ],
        "negativeExamples": [
          "fname_lname"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "address"
        ]
      }
    ],
    "positiveContentExamples": [
      "Smith, John",
      "O'Neil, Patrick",
      "Lopez-Aguilar, Maria",
      "De La Cruz, Juan",
      "Garcia Marquez, Gabriel",
      "Nguyen, Thi",
      "Doe, Jane A.",
      "Brown, Alex"
    ],
    "negativeContentExamples": [
      "John Smith",
      "Smith,John",
      "smith, John",
      "Smith, john",
      "Smith Jr., John",
      "O'Neil, P",
      "Garcia-Marquez Gabriel",
      "De la Cruz, Juan"
    ],
    "positiveHeaderExamples": [
      "last_first_name",
      "surname_first_name",
      "person_last_first",
      "customer_last_first_name",
      "lname_fname",
      "last_first",
      "employee_surname_first",
      "contact_last_first"
    ],
    "negativeHeaderExamples": [
      "first_last_name",
      "full_name",
      "given_surname",
      "first_name_last_name",
      "customer_name",
      "surname",
      "employee_full_name",
      "name_full"
    ],
    "explanation": "This semantic type targets person names written as Surname, Given (with an optional middle initial), enforcing a single comma followed by a space and capitalized name tokens. It accommodates multi-token surnames and given names, including common hyphen and apostrophe usage. Typical use cases include directories, rosters, and systems that sort or present names in surname-first order.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:05:50.111509"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_US",
    "description": "This type identifies US county-level administrative names used for local government identification. Values are proper-noun strings typically ending with a county-equivalent designator such as \"County\", \"Parish\", \"Borough\", or \"Census Area\", or prefixed forms like \"County of <Name>\" or \"City and County of <Name>\".",
    "pluginType": "regex",
    "regexPattern": "\\b((City and County of|County of|Parish of|Borough of|Census Area of|Municipality of) (St\\.|Saint|[A-Z][A-Za-z]+)([-' ]([A-Z][A-Za-z]+|of|and))*)\\b|\\b((St\\.|Saint|[A-Z][A-Za-z]+)([-' ]([A-Z][A-Za-z]+|of|and))* (County|Parish|Borough|Census Area|City and County|Municipality))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5090,
    "headerPatterns": [
      {
        "regExp": "(?i).*(us|usa|united states).*(county|parish|borough|census area).*(name|text).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "us_county_name"
        ],
        "negativeExamples": [
          "usa_country_name"
        ]
      },
      {
        "regExp": "(?i).*(county|parish|borough|census area).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "county_full_name"
        ],
        "negativeExamples": [
          "county_code"
        ]
      },
      {
        "regExp": "(?i).*county.*(label|desc|description|title).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "county_label"
        ],
        "negativeExamples": [
          "county_id"
        ]
      },
      {
        "regExp": "(?i).*(cnty|co)_?(name|nm).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cnty_nm"
        ],
        "negativeExamples": [
          "co_number"
        ]
      },
      {
        "regExp": "(?i).*county.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "county"
        ],
        "negativeExamples": [
          "country"
        ]
      }
    ],
    "positiveContentExamples": [
      "Orange County",
      "St. Louis County",
      "Prince George's County",
      "Miami-Dade County",
      "Orleans Parish",
      "Fairbanks North Star Borough",
      "Nome Census Area",
      "County of Los Angeles"
    ],
    "negativeContentExamples": [
      "Orange Co",
      "Los Angeles",
      "Orange County, CA",
      "City and County San Francisco",
      "County - Los Angeles",
      "St Louis County",
      "City & County of San Francisco",
      "Washington Parish LA"
    ],
    "positiveHeaderExamples": [
      "us_county_name",
      "county_name",
      "county_full_name",
      "county_label",
      "cnty_nm",
      "co_name",
      "parish_name"
    ],
    "negativeHeaderExamples": [
      "country_name",
      "region_name",
      "province_name",
      "city_name",
      "locality",
      "zip_code",
      "fips_code"
    ],
    "explanation": "This semantic type targets strings representing US county-level jurisdictions, including counties, parishes (Louisiana), boroughs and census areas (Alaska), and consolidated forms such as \"City and County of <Name>\". It is useful for normalizing, validating, and extracting county-equivalent names from address or location datasets without conflating them with codes or state/city fields.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:05:52.488189"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_UNION_NAME_IN",
    "description": "This type captures the complete names of Indian states and union territories as they are used in official documentation and government administration. The values represent full state names using proper English spelling and standard formatting as established by the Indian constitutional and administrative systems.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(Andhra Pradesh|Arunachal Pradesh|Assam|Bihar|Chhattisgarh|Goa|Gujarat|Haryana|Himachal Pradesh|Jharkhand|Karnataka|Kerala|Madhya Pradesh|Maharashtra|Manipur|Meghalaya|Mizoram|Nagaland|Odisha|Punjab|Rajasthan|Sikkim|Tamil Nadu|Telangana|Tripura|Uttar Pradesh|Uttarakhand|West Bengal|Andaman and Nicobar Islands|Chandigarh|Dadra and Nagar Haveli and Daman and Diu|Delhi|Jammu and Kashmir|Ladakh|Lakshadweep|Puducherry)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 5490,
    "headerPatterns": [
      {
        "regExp": "(?i).*(india|indian).*(state|union.*territory).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Indian state name"
        ],
        "negativeExamples": [
          "US state name"
        ]
      },
      {
        "regExp": "(?i).*(state|union.*territory).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "union territory name"
        ],
        "negativeExamples": [
          "state code"
        ]
      },
      {
        "regExp": "(?i).*(in|india).*(state|ut).*(name|nm).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IN state nm"
        ],
        "negativeExamples": [
          "EU state nm"
        ]
      },
      {
        "regExp": "(?i).*state.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state name"
        ],
        "negativeExamples": [
          "province name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Karnataka",
      "Uttar Pradesh",
      "Tamil Nadu",
      "Delhi",
      "Jammu and Kashmir",
      "Puducherry",
      "Andaman and Nicobar Islands",
      "Dadra and Nagar Haveli and Daman and Diu"
    ],
    "negativeContentExamples": [
      "TamilNadu",
      "Uttar-Pradesh",
      "NCT of Delhi",
      "Pondicherry",
      "Orissa",
      "Jammu & Kashmir",
      "Andaman & Nicobar Islands",
      "Daman and Diu"
    ],
    "positiveHeaderExamples": [
      "indian state name",
      "state or union territory name",
      "state_name_in",
      "ut_name_in",
      "state_ut_name",
      "india administrative state name",
      "full state name",
      "official union territory name"
    ],
    "negativeHeaderExamples": [
      "state code",
      "province name",
      "country name",
      "us state name",
      "state_id",
      "region",
      "state number",
      "territory code"
    ],
    "explanation": "This semantic type identifies full English names of India\u2019s states and union territories, suitable for validating or classifying administrative region name fields in datasets related to India. It is useful for standardizing location attributes, ensuring consistency with official nomenclature, and differentiating between states and union territories when the full name is provided.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:05:53.617042"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_MARKER_EN",
    "description": "This type captures street type indicators used in English-language addressing to classify different kinds of roads and thoroughfares. The values represent standard suffix terms that appear after street names to indicate the road type using common English abbreviations and full forms.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(ave|avenue|av|blvd|boulevard|boul|cir|circle|ct|court|dr|drive|expy|expressway|hwy|highway|ln|lane|pkwy|parkway|pl|place|rd|road|sq|square|st|street|trl|trail|ter|terrace|way|walk|aly|alley|cres|crescent|loop|pass|path|pike|run|view|vista|mnr|manor|gln|glen|grove|grv|pt|point|rdg|ridge|cv|cove)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 5570,
    "headerPatterns": [
      {
        "regExp": "(?i).*street.*marker.*en.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "street_marker_en"
        ],
        "negativeExamples": [
          "street_marker"
        ]
      },
      {
        "regExp": "(?i).*(street|road|thoroughfare).*(type|suffix|marker).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "thoroughfare_type"
        ],
        "negativeExamples": [
          "street_name"
        ]
      },
      {
        "regExp": "(?i).*address.*(suffix|type).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "address_suffix"
        ],
        "negativeExamples": [
          "address_line"
        ]
      },
      {
        "regExp": "(?i).*(st|rd|ave|blvd).*(type|sfx).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "st_type"
        ],
        "negativeExamples": [
          "st_name"
        ]
      },
      {
        "regExp": "(?i).*suffix.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "suffix"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "St",
      "Street",
      "Ave",
      "Avenue",
      "Rd",
      "Road",
      "Blvd",
      "Boulevard"
    ],
    "negativeContentExamples": [
      "Str",
      "Aven",
      "Rte",
      "Blv",
      "Lne",
      "Drv",
      "Crt",
      "Pkway"
    ],
    "positiveHeaderExamples": [
      "street_marker_en",
      "street_type",
      "road_suffix",
      "thoroughfare_type",
      "address_suffix",
      "st_type",
      "rd_sfx",
      "street_suffix"
    ],
    "negativeHeaderExamples": [
      "street_name",
      "road_name",
      "address_line",
      "street_number",
      "postal_code",
      "city_name",
      "highway_number",
      "thoroughfare"
    ],
    "explanation": "Use this semantic type for columns that contain only the street type indicator (suffix) in English, such as St, Ave, Rd, or their full forms. It is useful for normalizing, validating, or parsing address components where the road type is stored as a separate field.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:05:54.460744"
  },
  {
    "resultType": "generated",
    "semanticType": "PERIOD.HALF",
    "description": "This type identifies half-year period designations as they appear in business reporting, academic scheduling, and temporal data organization. The values represent standardized half-year indicators using common abbreviations or descriptive terms to denote six-month periods within annual cycles.",
    "pluginType": "regex",
    "regexPattern": "\\b(([Hh][Yy]?[12]|[12][Hh][Yy]?)([ _/-]*([Ff][Yy])?[ _/-]*((19|20)\\d\\d|\\d\\d))|((([Ff][Yy][ _-]*((19|20)\\d\\d|\\d\\d))|((19|20)\\d\\d|\\d\\d))[ _/-]*([Hh][Yy]?[12]|[12][Hh][Yy]?)))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4720,
    "headerPatterns": [
      {
        "regExp": "(?i).*(fiscal|fy)[ _-]*half[ _-]*(year|yr)[ _-]*(period|prd).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fiscal_half_year_period"
        ],
        "negativeExamples": [
          "fiscal_year"
        ]
      },
      {
        "regExp": "(?i).*(reporting|billing|calendar|academic)[ _-]*half[ _-]*(year|yr).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "reporting_half_year"
        ],
        "negativeExamples": [
          "reporting_month"
        ]
      },
      {
        "regExp": "(?i).*(fy[ _-]*\\d{2,4})[ _-]*(h1|h2|1h|2h).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "fy2024_h1"
        ],
        "negativeExamples": [
          "fy2024_q2"
        ]
      },
      {
        "regExp": "(?i).*(h1|h2|1h|2h|hy1|hy2)[ _-]*(period|prd).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "h2_period"
        ],
        "negativeExamples": [
          "q2_period"
        ]
      },
      {
        "regExp": "(?i).*period.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "period"
        ],
        "negativeExamples": [
          "date"
        ]
      }
    ],
    "positiveContentExamples": [
      "H1 2024",
      "H2-2023",
      "2024 H1",
      "FY2025 H2",
      "H1/FY24",
      "1H2022",
      "HY2 2019",
      "2H-20"
    ],
    "negativeContentExamples": [
      "Q1 2024",
      "H3 2024",
      "H 2024",
      "2024 HY",
      "2024H",
      "Half Year 2024",
      "2Q 2024",
      "2024 S1"
    ],
    "positiveHeaderExamples": [
      "fiscal_half_year_period",
      "reporting_half_year",
      "academic_half_year",
      "fy_h1_period",
      "h2_period",
      "half_year_prd",
      "calendar_half_year",
      "period"
    ],
    "negativeHeaderExamples": [
      "quarter",
      "fiscal_year",
      "reporting_month",
      "semester",
      "date",
      "invoice_number",
      "half_price",
      "fy2024_q2"
    ],
    "explanation": "PERIOD.HALF captures standardized half-year identifiers like H1/H2 or 1H/2H, optionally combined with fiscal markers (FY) and two- or four-digit years, in either order. It is useful for classifying columns and values that denote six-month reporting windows in financial, operational, or academic datasets.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:06:06.711350"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_NAME_EN",
    "description": "This type captures full English street names including both the identifying name and the street type suffix for addressing and navigation purposes. The values represent complete street designations using proper English spelling, capitalization, and standard type markers such as Street, Avenue, or Road.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Za-z][A-Za-z.'-]*\\s){0,5}[A-Za-z][A-Za-z.'-]*\\s(Street|Avenue|Road|Lane|Boulevard|Place|Court|Drive|Terrace|Way|Square|Circle|Highway|Parkway|Trail|Crescent|Close|Alley|Mews)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 5600,
    "headerPatterns": [
      {
        "regExp": "(?i).*(full[_\\s]*street[_\\s]*name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "full_street_name"
        ],
        "negativeExamples": [
          "street_code"
        ]
      },
      {
        "regExp": "(?i).*(primary[_\\s]*street).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "primary_street"
        ],
        "negativeExamples": [
          "primary_address"
        ]
      },
      {
        "regExp": "(?i).*((street|road|avenue|boulevard|drive|lane|highway)[_\\s]*name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "road_name"
        ],
        "negativeExamples": [
          "street_number"
        ]
      },
      {
        "regExp": "(?i).*((st|rd|ave|blvd|dr|ln)[_\\s]*name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "st_name"
        ],
        "negativeExamples": [
          "st_number"
        ]
      },
      {
        "regExp": "(?i).*street.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "street"
        ],
        "negativeExamples": [
          "street_number"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Main Street",
      "Oak Avenue",
      "Maple Road",
      "Queen's Road",
      "St George Street",
      "Martin Luther King Boulevard",
      "Old Mill Lane",
      "River View Drive"
    ],
    "negativeContentExamples": [
      "Main St",
      "Oak Ave",
      "123 Main Street",
      "Maple",
      "Highway 5",
      "3rd Avenue",
      "St. John's",
      "Elm Street NW"
    ],
    "positiveHeaderExamples": [
      "street_name",
      "full_street_name",
      "primary_street",
      "road_name",
      "boulevard_name",
      "st_name",
      "streetname",
      "legal_street_name"
    ],
    "negativeHeaderExamples": [
      "street_number",
      "address_line1",
      "city",
      "postal_code",
      "state",
      "route_id",
      "house_number",
      "road_code"
    ],
    "explanation": "Matches English street names composed of one to six alphabetic tokens (allowing apostrophes, periods, and hyphens) followed by a full street type suffix such as Street, Avenue, or Road. Designed to recognize complete street designations for geocoding, address normalization, and mapping while excluding abbreviations, house numbers, and extra directional or unit details.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:06:08.818342"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.LAST",
    "description": "This type captures family names or surnames as they appear in personal identification and formal documentation across different cultures. The values represent last names using standard spelling and formatting conventions without including given names, middle names, or honorific titles.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Za-z]{2,}([-' ][A-Za-z]{2,}){0,2}|[A-Za-z]'[A-Za-z]{2,}([-' ][A-Za-z]{2,}){0,1})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4650,
    "headerPatterns": [
      {
        "regExp": "(?i).*(customer|employee|user|applicant).*(last|family|surname).*(name|nm).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_last_name"
        ],
        "negativeExamples": [
          "customer_first_name"
        ]
      },
      {
        "regExp": "(?i).*(person|customer|employee|user).*(surname|family).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "person_surname"
        ],
        "negativeExamples": [
          "person_email"
        ]
      },
      {
        "regExp": "(?i).*(lname|last[_-]?nm|last[_-]?name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lname"
        ],
        "negativeExamples": [
          "fname"
        ]
      },
      {
        "regExp": "(?i).*(last.*name|family.*name|sur.*name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "family_name"
        ],
        "negativeExamples": [
          "full_name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "Smith",
      "Johnson-Smith",
      "O'Connor",
      "De la Cruz",
      "Van der Meer",
      "McMillan",
      "St John",
      "D'Amico"
    ],
    "negativeContentExamples": [
      "Smith, Jr",
      "O\u2019Connor",
      "Smith-J",
      "A",
      "Li3",
      "De  la  Cruz",
      "Smith.",
      "Van-der-"
    ],
    "positiveHeaderExamples": [
      "customer_last_name",
      "employee_last_name",
      "user_surname",
      "family_name",
      "person_family_name",
      "lname",
      "last_nm",
      "applicant_last_name"
    ],
    "negativeHeaderExamples": [
      "first_name",
      "full_name",
      "preferred_name",
      "company_name",
      "last_login",
      "surname_flag",
      "legal_name",
      "given_name"
    ],
    "explanation": "Identifies last names/surnames in datasets, accommodating common separators such as spaces, hyphens, and ASCII apostrophes. Designed for standalone surname fields, including compound family names (e.g., De la Cruz) and hyphenated forms. This type avoids matching values with digits or punctuation beyond hyphen and ASCII apostrophe, reducing false positives in general text fields. Use with high threshold and low priority due to the broad nature of name data.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:06:14.188511"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_MX",
    "description": "This type identifies Mexican municipality names used for local administrative identification within Mexico's governmental structure. The format consists of proper noun text strings representing official municipality names in Spanish without abbreviations or special formatting characters.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00fc\u00f1]+)( ([A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00fc\u00f1]+|[dD]e|[dD]el|[lL]a|[lL]as|[lL]os|[sS]an|[sS]anta|[sS]anto|[yY])){0,5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5190,
    "headerPatterns": [
      {
        "regExp": "(?i).*(municipio|municipality).*(nombre|name).*(mx|mexico).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipio_nombre_mx"
        ],
        "negativeExamples": [
          "municipio_codigo_mx"
        ]
      },
      {
        "regExp": "(?i).*(municipio|municipality).*(mx|mexico).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality_mexico"
        ],
        "negativeExamples": [
          "municipality_code"
        ]
      },
      {
        "regExp": "(?i).*(mpio|mun|muni).*(mx|mexico).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mpio_mx"
        ],
        "negativeExamples": [
          "mun_code"
        ]
      },
      {
        "regExp": "(?i).*(municipio|municipality).*(name|nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nombre_municipio"
        ],
        "negativeExamples": [
          "country_name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Benito Ju\u00e1rez",
      "San Pedro Garza Garc\u00eda",
      "Nezahualc\u00f3yotl",
      "Emiliano Zapata",
      "L\u00e1zaro C\u00e1rdenas",
      "San Andr\u00e9s Cholula",
      "Coatzacoalcos",
      "G\u00f3mez Far\u00edas"
    ],
    "negativeContentExamples": [
      "Oth\u00f3n P. Blanco",
      "Cd Ju\u00e1rez",
      "San-Andr\u00e9s Cholula",
      "L\u00e1zaro_C\u00e1rdenas",
      "benito juarez",
      "GOMEZ FARIAS",
      "Iztapalapa 2",
      "San Jos\u00e9 Iturbide."
    ],
    "positiveHeaderExamples": [
      "municipio",
      "nombre_municipio",
      "municipio_nombre_mx",
      "municipality_name_mx",
      "municipio_mexico",
      "mx_municipality",
      "mpio_nombre",
      "mun_mx"
    ],
    "negativeHeaderExamples": [
      "municipio_codigo",
      "state_name",
      "provincia",
      "ciudad",
      "colonia",
      "delegacion",
      "municipality_code",
      "postal_code"
    ],
    "explanation": "Identifies Spanish-text municipality names within Mexico, composed of alphabetic words and common Spanish connectors (e.g., de, del, la, los, y, San/Santa). It excludes abbreviations, initials with periods, digits, and special characters such as hyphens or underscores. Use this type to recognize municipal names in addresses, administrative datasets, and geographic hierarchies where municipality names are stored as clean text.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:06:21.977673"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_IE",
    "description": "This type identifies traditional Irish province names used for cultural and geographic identification within Ireland. The format consists of proper noun text strings representing historic province names in English without abbreviations or special formatting characters.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "LEINSTER",
      "MUNSTER",
      "CONNACHT",
      "CONNAUGHT",
      "ULSTER"
    ],
    "backout": "^[A-Z]{6,9}$",
    "confidenceThreshold": 98,
    "priority": 5270,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\b(ie|ireland|irish)\\b.*\\bprovince\\b.*\\bname\\b.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "ie_province_name"
        ],
        "negativeExamples": [
          "ie_province_code"
        ]
      },
      {
        "regExp": "(?i).*\\bprovince\\b.*\\bname\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "province_name"
        ],
        "negativeExamples": [
          "province_code"
        ]
      },
      {
        "regExp": "(?i).*\\b(ie|ireland|irish)\\b.*\\bprovince\\b.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "irish_province"
        ],
        "negativeExamples": [
          "irish_county"
        ]
      },
      {
        "regExp": "(?i).*\\bprov\\b.*\\bname\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "prov_name"
        ],
        "negativeExamples": [
          "prov_code"
        ]
      },
      {
        "regExp": "(?i).*\\bname\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Leinster",
      "MUNSTER",
      "Connacht",
      "ULSTER",
      "CONNAUGHT",
      "leinster",
      "connacht",
      "Munster"
    ],
    "negativeContentExamples": [
      "Leinster Province",
      "County Munster",
      "Connaght",
      "Ulster (Ireland)",
      "Connacht-Ireland",
      "Leinester",
      "Province of Ulster",
      "Munsterland"
    ],
    "positiveHeaderExamples": [
      "ie_province_name",
      "irish_province",
      "province_name",
      "province_of_ireland",
      "province_name_ie",
      "ireland_province",
      "prov_name",
      "irish_province_name"
    ],
    "negativeHeaderExamples": [
      "province_code",
      "state_province_code",
      "county_name_ie",
      "region_name",
      "country_name",
      "irish_county",
      "province_id",
      "ulster_flag"
    ],
    "explanation": "Finite, culturally defined Irish province names can be reliably identified via a small allowlist with a structured backout pattern. Use this type to normalize or validate province-level geography in Ireland, ensuring that only the historic province names (including the accepted English variants for Connacht/Connaught) are classified.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:06:32.789449"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_IT",
    "description": "This type represents official Italian province codes used for identifying provinces within Italy's administrative structure. The format consists of exactly two uppercase letters derived from the province names without spaces, numbers, or special characters.",
    "pluginType": "regex",
    "regexPattern": "\\b(AG|AL|AN|AO|AP|AQ|AR|AT|AV|BA|BG|BI|BL|BN|BO|BR|BS|BT|BZ|CA|CB|CE|CH|CL|CN|CO|CR|CS|CT|CZ|EN|FC|FE|FG|FI|FM|FR|GE|GO|GR|IM|IS|KR|LC|LE|LI|LO|LT|LU|MB|MC|ME|MI|MN|MO|MS|MT|NA|NO|NU|OR|PA|PC|PD|PE|PG|PI|PN|PO|PR|PT|PU|PV|PZ|RA|RC|RE|RG|RI|RM|RN|RO|SA|SI|SO|SP|SR|SS|SU|SV|TA|TE|TN|TO|TP|TR|TS|TV|UD|VA|VB|VC|VE|VI|VR|VT|VV)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5230,
    "headerPatterns": [
      {
        "regExp": "(?i).*italian.*province.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "italian_province_code"
        ],
        "negativeExamples": [
          "province_code"
        ]
      },
      {
        "regExp": "(?i).*(it|ita|italy|italia).*prov.*code.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "it_prov_code"
        ],
        "negativeExamples": [
          "italy_province"
        ]
      },
      {
        "regExp": "(?i).*(province|provincia).*code.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "province_code"
        ],
        "negativeExamples": [
          "provincia_name"
        ]
      },
      {
        "regExp": "(?i).*(prov|prv)\\W*code.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "prov_code"
        ],
        "negativeExamples": [
          "prov_num"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "province_name"
        ]
      }
    ],
    "positiveContentExamples": [
      "RM",
      "MI",
      "TO",
      "NA",
      "FI",
      "BO",
      "VE",
      "BZ"
    ],
    "negativeContentExamples": [
      "rm",
      "Rm",
      "ROM",
      "M1",
      "R-M",
      "LA",
      "XX",
      "R M"
    ],
    "positiveHeaderExamples": [
      "italian_province_code",
      "it_prov_code",
      "province_code",
      "provincia_code",
      "it_province_code",
      "italy_province_code",
      "prov_code",
      "prov_it_code"
    ],
    "negativeHeaderExamples": [
      "province_name",
      "it_province_name",
      "region",
      "state",
      "postal",
      "comune",
      "city_name",
      "country"
    ],
    "explanation": "This semantic type detects Italian province codes, which are standardized two-letter uppercase abbreviations uniquely identifying provinces/metropolitan cities in Italy. It is useful for normalizing location attributes, validating input, and joining datasets keyed by province codes, especially when column headers reference Italian provinces or abbreviated forms.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:06:49.009761"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_AU",
    "description": "This type captures the complete names of Australian states and territories as they are used in official documentation and government administration. The values represent full state names using proper English spelling and standard formatting as established by Australian constitutional and administrative systems.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "NEW SOUTH WALES",
      "VICTORIA",
      "QUEENSLAND",
      "SOUTH AUSTRALIA",
      "WESTERN AUSTRALIA",
      "TASMANIA",
      "NORTHERN TERRITORY",
      "AUSTRALIAN CAPITAL TERRITORY"
    ],
    "backout": "^[A-Za-z]+( [A-Za-z]+){0,3}$",
    "confidenceThreshold": 98,
    "priority": 5410,
    "headerPatterns": [
      {
        "regExp": "(?i).*(australia|au).*(state|territory).*full.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "au_state_full_name"
        ],
        "negativeExamples": [
          "australia_state_code"
        ]
      },
      {
        "regExp": "(?i).*(australia|au).*(state|territory).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "australian_state_name"
        ],
        "negativeExamples": [
          "australian_state_code"
        ]
      },
      {
        "regExp": "(?i).*(au|aus).*state.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "au_state_name"
        ],
        "negativeExamples": [
          "au_state_code"
        ]
      },
      {
        "regExp": "(?i).*(state|territory).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_or_territory_name"
        ],
        "negativeExamples": [
          "state_number"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "New South Wales",
      "Victoria",
      "Queensland",
      "South Australia",
      "Western Australia",
      "Tasmania",
      "Northern Territory",
      "Australian Capital Territory"
    ],
    "negativeContentExamples": [
      "NSW",
      "Victoria State",
      "Queensland AU",
      "South Australia,",
      "Western Australia State",
      "Northern Territory of Australia",
      "Australian Capital Terr.",
      "New South Wales (NSW)"
    ],
    "positiveHeaderExamples": [
      "australian_state_name",
      "au_state_full_name",
      "australia_territory_name",
      "state_or_territory_name_au",
      "full_state_name_au",
      "state_name_au",
      "australia_state_name",
      "au_territory_name"
    ],
    "negativeHeaderExamples": [
      "state_code_au",
      "au_state_abbrev",
      "territory_code",
      "province_name",
      "country_name_au",
      "city_name_au",
      "state_id",
      "postal_state"
    ],
    "explanation": "This semantic type identifies data fields containing the full names of Australian states and territories, suitable for datasets referencing official jurisdiction names rather than abbreviations or codes. It is useful for standardizing geographic attributes in addresses, registrations, licensing, and administrative records where complete state/territory names are required.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:06:53.896559"
  },
  {
    "resultType": "generated",
    "semanticType": "IPADDRESS.IPV6",
    "description": "This type represents IPv6 addresses, which are hexadecimal identifiers used for network device addressing in the modern Internet protocol. The address consists of eight groups of one to four hexadecimal digits separated by colons, with standard shorthand notations allowed for compression, and may include IPv4-embedded forms.",
    "pluginType": "regex",
    "regexPattern": "\\b(([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}|([0-9A-Fa-f]{1,4}:){1,7}:|:((:[0-9A-Fa-f]{1,4}){1,7}|:)|([0-9A-Fa-f]{1,4}:){1,6}:[0-9A-Fa-f]{1,4}|([0-9A-Fa-f]{1,4}:){1,5}(:[0-9A-Fa-f]{1,4}){1,2}|([0-9A-Fa-f]{1,4}:){1,4}(:[0-9A-Fa-f]{1,4}){1,3}|([0-9A-Fa-f]{1,4}:){1,3}(:[0-9A-Fa-f]{1,4}){1,4}|([0-9A-Fa-f]{1,4}:){1,2}(:[0-9A-Fa-f]{1,4}){1,5}|[0-9A-Fa-f]{1,4}:(:[0-9A-Fa-f]{1,4}){1,6}|:((:[0-9A-Fa-f]{1,4}){1,7}|:)|([0-9A-Fa-f]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1?[0-9])?[0-9])\\.){3}(25[0-5]|(2[0-4]|1?[0-9])?[0-9])|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1?[0-9])?[0-9])\\.){3}(25[0-5]|(2[0-4]|1?[0-9])?[0-9]))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4540,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bipv6\\b.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ipv6_address"
        ],
        "negativeExamples": [
          "ip_address"
        ]
      },
      {
        "regExp": "(?i).*\\bip\\b.*\\bv6\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "client_ip_v6"
        ],
        "negativeExamples": [
          "client_ip_v4"
        ]
      },
      {
        "regExp": "(?i).*internet.*protocol.*v6.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "internet_protocol_v6"
        ],
        "negativeExamples": [
          "internet_protocol_v4"
        ]
      },
      {
        "regExp": "(?i).*\\bip6\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "src_ip6"
        ],
        "negativeExamples": [
          "src_ipv4"
        ]
      },
      {
        "regExp": "(?i).*\\bip\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "ip"
        ],
        "negativeExamples": [
          "mac"
        ]
      }
    ],
    "positiveContentExamples": [
      "2001:0db8:85a3:0000:0000:8a2e:0370:7334",
      "2001:db8:85a3:0:0:8a2e:370:7334",
      "2001:db8:85a3::8a2e:370:7334",
      "::1",
      "fe80::1",
      "::ffff:192.0.2.128",
      "2001:db8::",
      "2001:0db8::1"
    ],
    "negativeContentExamples": [
      "2001:db8:85a3::8a2e:370:7334:",
      "2001:db8:85a3:8a2e:370:7334",
      "2001:db8:85a3:::8a2e:370:7334",
      "2001:db8:85a3:0000:0000:8a2e:0370:7334:1234",
      "2001:db8:85a3:0:0:8a2e:370:zzzz",
      "::ffff:999.0.2.128",
      "fe80:0000:0000:0000:0202:b3ff:fe1e:8329%eth0",
      "2001-db8-85a3-0000-0000-8a2e-0370-7334"
    ],
    "positiveHeaderExamples": [
      "ipv6_address",
      "client_ipv6",
      "source_ipv6",
      "dest_ipv6",
      "remote_ip_v6",
      "user_ip6",
      "ip6",
      "internet_protocol_v6"
    ],
    "negativeHeaderExamples": [
      "ip_address",
      "ipv4_address",
      "mac_address",
      "email",
      "hostname",
      "url",
      "gateway_ip",
      "subnet"
    ],
    "explanation": "Identifies IPv6 address values in data, covering full eight-hextet forms, compressed forms using ::, and IPv4-embedded IPv6 formats (e.g., ::ffff:192.0.2.128). This pattern avoids anchors and uses word boundaries to ensure values are recognized without overmatching. Typical use cases include parsing logs, normalizing network device fields, and validating configuration exports where IPv6 addresses appear in various notations.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:07:10.719460"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.SUBURB_AU",
    "description": "This type captures Australian suburb names as they are used in postal addressing and geographic identification systems. The values represent locality names using proper English spelling and standard formatting as established by Australian postal and administrative conventions.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z][a-z]+|St|St\\.|Mt|Mt\\.|O'[A-Z][a-z]+|Mc[A-Z][a-z]+)([- ]([A-Z][a-z]+|St|St\\.|Mt|Mt\\.|O'[A-Z][a-z]+|Mc[A-Z][a-z]+)){0,4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 5510,
    "headerPatterns": [
      {
        "regExp": "(?i).*(suburb|locality).*(au|australia).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "suburb_au_name"
        ],
        "negativeExamples": [
          "suburb_code"
        ]
      },
      {
        "regExp": "(?i).*(australia|au).*(suburb|locality).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "australian_suburb"
        ],
        "negativeExamples": [
          "au_postcode"
        ]
      },
      {
        "regExp": "(?i).*(suburb|locality).*(name|label).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "suburb_name"
        ],
        "negativeExamples": [
          "suburb_code"
        ]
      },
      {
        "regExp": "(?i).*(town|village|district).*(suburb|locality).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "town_suburb"
        ],
        "negativeExamples": [
          "town_name"
        ]
      },
      {
        "regExp": "(?i).*suburb.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "suburb"
        ],
        "negativeExamples": [
          "city"
        ]
      }
    ],
    "positiveContentExamples": [
      "St Kilda",
      "St. Ives",
      "Alice Springs",
      "Port Macquarie",
      "O'Connor",
      "North Strathfield",
      "Wagga Wagga",
      "Mount Barker"
    ],
    "negativeContentExamples": [
      "ST KILDA",
      "St Ives, NSW",
      "North Strathfield 2",
      "StIves",
      "O'connor",
      "Mcmahons Point",
      "The Rocks NSW",
      "Mount  Barker"
    ],
    "positiveHeaderExamples": [
      "suburb_au_name",
      "australian_suburb",
      "suburb_name",
      "locality_name",
      "town_suburb",
      "au_suburb",
      "residential_suburb",
      "suburb"
    ],
    "negativeHeaderExamples": [
      "state_name",
      "city_name",
      "postcode",
      "address_line",
      "region",
      "country",
      "province",
      "suburb_code"
    ],
    "explanation": "Identifies Australian suburb/locality names written in standard proper-case tokens, optionally including common prefixes like St, Mt, O' and Mc, and allowing spaces or hyphens between 1\u20135 tokens. Useful for classifying locality fields in postal addresses, geocoding inputs, and place-based analytics where the value is the suburb name rather than a code.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:07:31.981349"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.AGE_RANGE",
    "description": "This type captures age ranges as they appear in demographic analysis, marketing research, and population studies using span notation. The values represent age brackets formatted with beginning and ending ages or descriptive range indicators to categorize individuals into age-based groups.",
    "pluginType": "regex",
    "regexPattern": "\\b(age\\s*:?[- ]?)?\\d{1,3}\\s*[-\u2013\u2014]\\s*\\d{1,3}\\s*(years|yrs|yo|years old)?\\b|\\b\\d{1,3}\\s*to\\s*\\d{1,3}\\s*(years|yrs|yo|years old)?\\b|\\b\\d{1,3}\\s*\\+\\s*(years|yrs|yo)?\\b|\\b(under|below)\\s*\\d{1,3}\\s*(years|yrs|yo)?\\b|\\b(over|above)\\s*\\d{1,3}\\s*(years|yrs|yo)?\\b|\\b\\d{1,3}\\s*and\\s*(over|under)\\s*(years|yrs|yo)?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 4760,
    "headerPatterns": [
      {
        "regExp": "(?i).*age[_\\s-]*(range|bracket|band)s?.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Age Bracket"
        ],
        "negativeExamples": [
          "age"
        ]
      },
      {
        "regExp": "(?i).*(demographic|segment).*age.*(range|bracket|band).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "demographic_age_range"
        ],
        "negativeExamples": [
          "demographic_age"
        ]
      },
      {
        "regExp": "(?i).*(agegrp|age_rng|agebrkt|ageband|agerange).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "age_rng"
        ],
        "negativeExamples": [
          "age_group_id"
        ]
      },
      {
        "regExp": "(?i).*age[_\\s-]*(segment|bucket|bin)s?.*",
        "confidence": 91,
        "mandatory": true,
        "positiveExamples": [
          "age_segment"
        ],
        "negativeExamples": [
          "segment"
        ]
      },
      {
        "regExp": "(?i).*age.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "age"
        ],
        "negativeExamples": [
          "birth_year"
        ]
      }
    ],
    "positiveContentExamples": [
      "0\u20135",
      "6-12",
      "13 to 17",
      "18-24",
      "25\u201334 years",
      "35-44 yrs",
      "55+",
      "65 and over"
    ],
    "negativeContentExamples": [
      "Age 30",
      "18",
      "65 to",
      "to 24",
      "18 / 24",
      "over sixty-five",
      "18and24",
      "underage 18"
    ],
    "positiveHeaderExamples": [
      "age_range",
      "Age Bracket",
      "AGE BAND",
      "demographic_age_range",
      "age_segment",
      "agegrp",
      "age_rng",
      "customer_age_bracket"
    ],
    "negativeHeaderExamples": [
      "age",
      "min_age",
      "customer_age",
      "birth_year",
      "age_category",
      "age_group_id",
      "segment",
      "bracket"
    ],
    "explanation": "Age ranges typically appear as bounded spans (e.g., 18-24, 35\u201344), threshold-based categories (e.g., 65+, under 18), or natural-language separators (e.g., 25 to 34, 65 and over). This semantic type helps classify such bucketed demographic groupings consistently across datasets for analysis, segmentation, and reporting.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:07:34.218692"
  },
  {
    "resultType": "generated",
    "semanticType": "TELEPHONE",
    "description": "Telephone numbers used for voice communication, including landline and mobile formats with optional country and area codes. Supported formats include groups of digits separated by spaces or hyphens, optional parentheses around area codes, and optional international prefixes (+ or 00).",
    "pluginType": "regex",
    "regexPattern": "\\b((\\+|00)?[ ]?([1-9][0-9]{0,2}[ -])?(\\([0-9]{2,4}\\)|[0-9]{2,4})[ -][0-9]{3,4}[ -][0-9]{3,4}|\\([0-9]{3}\\)[ ]?[0-9]{3}[ -][0-9]{4}|[0-9]{3}[ -][0-9]{3}[ -][0-9]{4}|[0-9]{3}[ -][0-9]{4})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5620,
    "headerPatterns": [
      {
        "regExp": "(?i).*(customer|contact).*(phone|telephone).*(number|num|no).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_phone_number"
        ],
        "negativeExamples": [
          "customer_account_number"
        ]
      },
      {
        "regExp": "(?i).*(primary|main|preferred).*(phone|telephone).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "primary_phone"
        ],
        "negativeExamples": [
          "primary_email"
        ]
      },
      {
        "regExp": "(?i).*(mobile|cell|work|home|office).*(phone|telephone).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mobile_phone"
        ],
        "negativeExamples": [
          "mobile_device"
        ]
      },
      {
        "regExp": "(?i).*(contact|customer).*(phone|telephone).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "contact_telephone"
        ],
        "negativeExamples": [
          "contact_email"
        ]
      },
      {
        "regExp": "(?i).*(phone|telephone).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "phone"
        ],
        "negativeExamples": [
          "fax"
        ]
      }
    ],
    "positiveContentExamples": [
      "+1 212-555-7890",
      "(212) 555-7890",
      "212-555-7890",
      "212 555 7890",
      "1-800-555-1212",
      "+44 20 7946 0958",
      "020 7946 0958",
      "555-1234"
    ],
    "negativeContentExamples": [
      "+1 (212 555-7890",
      "212-55-7890",
      "++44 20 7946 0958",
      "1-800-555-121",
      "(020) 7946 095",
      "123.456.7890",
      "5551234",
      "00442079460958"
    ],
    "positiveHeaderExamples": [
      "customer_phone_number",
      "primary_phone",
      "mobile_phone",
      "work_telephone",
      "home_phone",
      "contact_phone",
      "billing_phone",
      "office_phone"
    ],
    "negativeHeaderExamples": [
      "account_number",
      "fax_number",
      "support_email",
      "device_id",
      "zip_code",
      "country_code",
      "contact_name",
      "extension_number"
    ],
    "explanation": "This semantic type identifies telephone numbers across common international and domestic formats. It supports optional international prefixes (+ or 00), optional country codes, area codes with or without parentheses, and separators using spaces or hyphens. Extensions and dot separators are intentionally not included to reduce false positives. Pure digit-only strings are not matched unless grouped with spaces or hyphens, improving precision in mixed numeric datasets.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:07:35.417381"
  },
  {
    "resultType": "generated",
    "semanticType": "NATIONALITY_EN",
    "description": "This type captures nationality designations as they are commonly expressed in English for identification, documentation, and demographic purposes. The values represent standard nationality terms following English language conventions and international usage without abbreviations or alternative language forms.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b([a-z]+[- ]+){0,2}(american|argentine|armenian|australian|austrian|azerbaijani|bahamian|bahraini|bangladeshi|barbadian|belarusian|belgian|bolivian|bosnian|botswanan|brazilian|british|bulgarian|burmese|cambodian|cameroonian|canadian|chadian|chilean|chinese|colombian|congolese|costa rican|croatian|cuban|cypriot|czech|danish|dutch|egyptian|emirati|english|estonian|ethiopian|fijian|filipino|finnish|french|gambian|georgian|german|ghanaian|greek|guatemalan|haitian|honduran|hungarian|icelandic|indian|indonesian|iranian|iraqi|irish|israeli|italian|ivorian|jamaican|japanese|jordanian|kazakh|kenyan|korean|kuwaiti|lao|latvian|lebanese|liberian|libyan|lithuanian|macedonian|malaysian|malian|maltese|mexican|moldovan|mongolian|moroccan|mozambican|namibian|nepalese|new zealander|nicaraguan|nigerian|norwegian|omani|pakistani|palestinian|panamanian|paraguayan|peruvian|polish|portuguese|qatari|romanian|russian|rwandan|salvadoran|saudi|saudi arabian|scottish|senegalese|serbian|singaporean|slovak|slovenian|somali|south african|spanish|sri lankan|sudanese|swedish|swiss|syrian|taiwanese|tanzanian|thai|tunisian|turkish|ugandan|ukrainian|uruguayan|uzbek|venezuelan|vietnamese|welsh|yemeni|zambian|zimbabwean)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 4700,
    "headerPatterns": [
      {
        "regExp": "(?i).*(nationality)(_en|_english| en| english).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nationality_en"
        ],
        "negativeExamples": [
          "nationality_fr"
        ]
      },
      {
        "regExp": "(?i).*(passport|applicant|customer|person|user)[ _-]*nationality.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "passport_nationality"
        ],
        "negativeExamples": [
          "passport_country"
        ]
      },
      {
        "regExp": "(?i).*(country)[ _-]*nationality.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "country_nationality"
        ],
        "negativeExamples": [
          "country_name"
        ]
      },
      {
        "regExp": "(?i).*(citizenship).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "citizenship"
        ],
        "negativeExamples": [
          "citizen_id"
        ]
      },
      {
        "regExp": "(?i).*nationality.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nationality"
        ],
        "negativeExamples": [
          "language"
        ]
      }
    ],
    "positiveContentExamples": [
      "American",
      "French",
      "South African",
      "New Zealander",
      "Brazilian",
      "Saudi Arabian",
      "Vietnamese",
      "Ivorian"
    ],
    "negativeContentExamples": [
      "United States",
      "France",
      "South Africa",
      "New Zealand",
      "UAE",
      "England",
      "Ivory Coast",
      "Congo"
    ],
    "positiveHeaderExamples": [
      "nationality_en",
      "passport_nationality",
      "customer_nationality",
      "person_nationality",
      "primary_nationality",
      "country_nationality",
      "citizenship"
    ],
    "negativeHeaderExamples": [
      "nationality_fr",
      "country",
      "language",
      "resident_country",
      "country_of_birth",
      "national_id",
      "ethnicity"
    ],
    "explanation": "This semantic type identifies English-language demonyms (nationality adjectives and forms) used to describe a person's nationality, including multi-word expressions such as South African, New Zealander, and Saudi Arabian. It excludes country names, abbreviations, and non-English or abbreviated forms, focusing strictly on standard English nationality terms found in identity and demographic datasets.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:07:44.097549"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_MX",
    "description": "This type captures the complete names of Mexican states and federal entities as they are used in official documentation and government administration. The values represent full state names using proper Spanish spelling including diacritical marks and standard formatting as established by the Mexican federal constitutional system.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(aguascalientes|baja california sur|baja california|campeche|chiapas|chihuahua|ciudad de m\u00e9xico|coahuila de zaragoza|colima|durango|guanajuato|guerrero|hidalgo|jalisco|m\u00e9xico|michoac\u00e1n de ocampo|morelos|nayarit|nuevo le\u00f3n|oaxaca|puebla|quer\u00e9taro|quintana roo|san luis potos\u00ed|sinaloa|sonora|tabasco|tamaulipas|tlaxcala|veracruz de ignacio de la llave|yucat\u00e1n|zacatecas)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5440,
    "headerPatterns": [
      {
        "regExp": "(?i).*(state|estado|entidad).*(name|nombre).*(m[e\u00e9]xico|mx).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "state name mx"
        ],
        "negativeExamples": [
          "state code mx"
        ]
      },
      {
        "regExp": "(?i).*(entidad federativa).*(name|nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "entidad federativa nombre"
        ],
        "negativeExamples": [
          "c\u00f3digo entidad federativa"
        ]
      },
      {
        "regExp": "(?i).*(state|estado|entidad).*(name|nombre).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "estado nombre"
        ],
        "negativeExamples": [
          "estado id"
        ]
      },
      {
        "regExp": "(?i).*(edo|st).*(name|nombre).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "edo nombre"
        ],
        "negativeExamples": [
          "edo c\u00f3digo"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Aguascalientes",
      "Baja California Sur",
      "Ciudad de M\u00e9xico",
      "Coahuila de Zaragoza",
      "Michoac\u00e1n de Ocampo",
      "Nuevo Le\u00f3n",
      "San Luis Potos\u00ed",
      "Veracruz de Ignacio de la Llave"
    ],
    "negativeContentExamples": [
      "Mexico",
      "Estado de M\u00e9xico",
      "Veracruz",
      "Queretaro",
      "San Luis Potosi",
      "Michoac\u00e1n",
      "Coahuila",
      "Distrito Federal"
    ],
    "positiveHeaderExamples": [
      "state name mexico",
      "nombre estado m\u00e9xico",
      "nombre entidad federativa",
      "state/province name mexico",
      "state name mx",
      "entidad federativa nombre",
      "estado name mx",
      "mx state name"
    ],
    "negativeHeaderExamples": [
      "state code mexico",
      "c\u00f3digo estado m\u00e9xico",
      "estado",
      "entidad id",
      "country name",
      "city name",
      "estado clave",
      "mx state code"
    ],
    "explanation": "Matches full official names of Mexican states and the federal entity using proper Spanish spelling and diacritics. Useful for validating and classifying administrative geography fields in datasets involving Mexican jurisdictions. The pattern enumerates the complete, official names and rejects abbreviations, outdated names, or shortened forms.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:07:44.575367"
  },
  {
    "resultType": "generated",
    "semanticType": "TIMEZONE.IANA",
    "description": "This type captures IANA time zone identifiers following the Olson database format for precise temporal coordination across global locations. The values represent hierarchical location-based identifiers using continent/city or region/city patterns with underscores replacing spaces in location names.",
    "pluginType": "regex",
    "regexPattern": "\\b(Africa|America|Antarctica|Arctic|Asia|Atlantic|Australia|Europe|Indian|Pacific|Etc|US|Canada|Brazil|Chile|Mexico|NZ)/([A-Za-z0-9][A-Za-z0-9_+\\-]*)(/([A-Za-z0-9][A-Za-z0-9_+\\-]*)){0,2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5630,
    "headerPatterns": [
      {
        "regExp": "(?i).*iana.*time.*zone.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iana_timezone"
        ],
        "negativeExamples": [
          "user_timezone"
        ]
      },
      {
        "regExp": "(?i).*(olson|tzdb).*(time.*zone|tz).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "olson_time_zone"
        ],
        "negativeExamples": [
          "timezone_id"
        ]
      },
      {
        "regExp": "(?i).*(time.*zone|timezone).*(id|identifier).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "timezone_id"
        ],
        "negativeExamples": [
          "tzid"
        ]
      },
      {
        "regExp": "(?i).*\\btzid\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "tzid"
        ],
        "negativeExamples": [
          "tz_offset"
        ]
      },
      {
        "regExp": "(?i).*time.*zone.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "time_zone"
        ],
        "negativeExamples": [
          "utc_offset"
        ]
      }
    ],
    "positiveContentExamples": [
      "America/New_York",
      "Europe/Paris",
      "Asia/Kolkata",
      "Australia/Sydney",
      "Etc/UTC",
      "Pacific/Port_Moresby",
      "America/Argentina/Buenos_Aires",
      "US/Eastern"
    ],
    "negativeContentExamples": [
      "Europe-Paris",
      "Asia/Kolkata/",
      "America New_York",
      "GMT+1",
      "America//Los_Angeles",
      "America/Los Angeles",
      "America/Port&of_Spain",
      "Timezone/America_New_York"
    ],
    "positiveHeaderExamples": [
      "iana_timezone",
      "olson_time_zone",
      "tzdb_zone",
      "timezone_id",
      "tzid",
      "time_zone",
      "iana_tzid",
      "timezone_identifier"
    ],
    "negativeHeaderExamples": [
      "tz_offset",
      "utc_offset",
      "local_time",
      "timestamp",
      "country",
      "region",
      "city"
    ],
    "explanation": "IANA time zone identifiers are standardized strings from the tz database used to unambiguously represent regional time rules for scheduling, logging, and cross-system time normalization. This type focuses on hierarchical identifiers like Continent/City and certain region-based variants, ensuring reliable detection of Olson-style time zone keys in datasets.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:08:07.909367"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_IT",
    "description": "This type identifies Italian province names used for administrative identification within Italy's governmental structure. The format consists of proper noun text strings representing official province names in Italian without abbreviations or special formatting characters.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "MILANO",
      "ROMA",
      "NAPOLI",
      "TORINO",
      "FIRENZE",
      "GENOVA",
      "BARI",
      "BOLOGNA",
      "PALERMO",
      "CAGLIARI",
      "CATANIA",
      "VENEZIA",
      "VERONA",
      "TRENTO",
      "BOLZANO",
      "L'AQUILA",
      "REGGIO EMILIA",
      "MODENA",
      "BRESCIA",
      "MONZA E DELLA BRIANZA"
    ],
    "backout": "^[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff' -]{2,40}$",
    "confidenceThreshold": 95,
    "priority": 5280,
    "headerPatterns": [
      {
        "regExp": "(?i).*(province|provincia).*(name|nome).*(italy|italia|italian|it).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province_name_it"
        ],
        "negativeExamples": [
          "province_code_it"
        ]
      },
      {
        "regExp": "(?i).*(province|provincia).*(name|nome).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "nome_provincia"
        ],
        "negativeExamples": [
          "provincia_codice"
        ]
      },
      {
        "regExp": "(?i).*(prov).*(name|nome).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "prov_name"
        ],
        "negativeExamples": [
          "prov_code"
        ]
      },
      {
        "regExp": "(?i).*(italy|italia|italian|it).*(province|provincia).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "italian_province"
        ],
        "negativeExamples": [
          "italian_region"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Milano",
      "Roma",
      "Napoli",
      "Torino",
      "L'Aquila",
      "Reggio Emilia",
      "Forl\u00ec-Cesena",
      "Monza e della Brianza"
    ],
    "negativeContentExamples": [
      "MI",
      "Milano 2019",
      "Provincia di Milano",
      "Reggio-Emilia",
      "Trentino-Alto Adige",
      "Palermo City",
      "Verbano Cusio Ossola",
      "Bolzano/Bozen"
    ],
    "positiveHeaderExamples": [
      "province_name_it",
      "nome_provincia_it",
      "italian_province_name",
      "provincia_nome",
      "it_province_name",
      "prov_name",
      "italian_province"
    ],
    "negativeHeaderExamples": [
      "region_it",
      "province_code_it",
      "provincia_codice",
      "stato_provincia",
      "prov_code",
      "country_province",
      "comune"
    ],
    "explanation": "This semantic type detects Italian province names written out fully in Italian, capturing the official administrative province names without abbreviations or extra qualifiers. It is intended for columns containing human-readable province names rather than codes, supporting spaces, hyphens, apostrophes, and accented characters common in Italian toponyms. The list plugin ensures high precision using a representative set of provinces, while the anchored backout regex provides a controlled fallback shape for broader coverage.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:09:12.476539"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_PROVINCE_NA",
    "description": "This type captures abbreviated codes for states and provinces across North America including US states, Canadian provinces, and Mexican states. The values represent standardized abbreviations using uppercase letters without periods, following each country's official abbreviation conventions.",
    "pluginType": "regex",
    "regexPattern": "\\b(AL|AK|AZ|AR|CA|CO|CT|DE|FL|GA|HI|ID|IL|IN|IA|KS|KY|LA|ME|MD|MA|MI|MN|MS|MO|MT|NE|NV|NH|NJ|NM|NY|NC|ND|OH|OK|OR|PA|RI|SC|SD|TN|TX|UT|VT|VA|WA|WV|WI|WY|DC|AB|BC|MB|NB|NL|NS|NT|NU|ON|PE|QC|SK|YT|AGU|BCN|BCS|CAM|CHH|CHP|CMX|COA|COL|DUR|GRO|GUA|HID|JAL|MEX|MIC|MOR|NAY|NLE|OAX|PUE|QUE|ROO|SLP|SIN|SON|TAB|TAM|TLA|VER|YUC|ZAC)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5460,
    "headerPatterns": [
      {
        "regExp": "(?i).*north.*america.*(state|province).*(code|abbr|abbrev).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "north_america_state_province_code"
        ],
        "negativeExamples": [
          "province_name"
        ]
      },
      {
        "regExp": "(?i).*(state.*province|province.*state).*(code|abbr|abbrev).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_province_code"
        ],
        "negativeExamples": [
          "state_province_name"
        ]
      },
      {
        "regExp": "(?i).*(us|usa|ca|can|mx|mex).*(state|prov|province).*(code|abbr|abbrev).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "us_ca_mx_state_code"
        ],
        "negativeExamples": [
          "eu_state_code"
        ]
      },
      {
        "regExp": "(?i).*st[ _-]*prov[ _-]*(cd|code|abbr|abbrev).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "st_prov_cd"
        ],
        "negativeExamples": [
          "st_prov_name"
        ]
      },
      {
        "regExp": "(?i).*(state|province)[ _-]*(code|abbr|abbrev).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province_code"
        ],
        "negativeExamples": [
          "province_label"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "CA",
      "NY",
      "TX",
      "QC",
      "ON",
      "JAL",
      "NLE",
      "CMX"
    ],
    "negativeContentExamples": [
      "ca",
      "C.A",
      "CDMX",
      "QB",
      "NYC",
      "PR",
      "B C",
      "ON."
    ],
    "positiveHeaderExamples": [
      "north_america_state_province_code",
      "state_province_code",
      "us_ca_mx_state_code",
      "st_prov_cd",
      "province_code",
      "state_abbrev"
    ],
    "negativeHeaderExamples": [
      "province_name",
      "state_full_name",
      "country_code",
      "zipcode",
      "timezone",
      "city_code",
      "region_subdivision_name"
    ],
    "explanation": "Detects standardized North American state and province abbreviations across the US, Canada, and Mexico using country-official uppercase codes without punctuation. This is useful for validation, normalization, and joining datasets on subnational administrative divisions, ensuring consistent cross-country coding with minimal ambiguity.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:09:40.938213"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_ES",
    "description": "This type identifies Spanish province names used for regional administrative identification within Spain's governmental structure. The format consists of proper noun text strings representing official province names in Spanish without abbreviations or special formatting characters.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1]+)(\\s(de|del|la|las|el|los|san|santa|santo)\\s[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1]+|\\s[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1]+){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 5260,
    "headerPatterns": [
      {
        "regExp": "(?i).*(province|provincia)[ _-]*(name|nombre)[ _-]*es.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province_name_es"
        ],
        "negativeExamples": [
          "province_code_es"
        ]
      },
      {
        "regExp": "(?i).*(provincia)[ _-]*(nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "provincia_nombre"
        ],
        "negativeExamples": [
          "provincia_codigo"
        ]
      },
      {
        "regExp": "(?i).*(province)[ _-]*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province_name"
        ],
        "negativeExamples": [
          "province_id"
        ]
      },
      {
        "regExp": "(?i).*(prov)[ _-]*(nm|nom|name|nbr|nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "prov_nm"
        ],
        "negativeExamples": [
          "prov_cd"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Madrid",
      "Barcelona",
      "Valencia",
      "Sevilla",
      "Zaragoza",
      "C\u00e1diz",
      "C\u00f3rdoba",
      "Santa Cruz de Tenerife"
    ],
    "negativeContentExamples": [
      "SANTA CRUZ DE TENERIFE",
      "Sevilla.",
      "LaRioja",
      "\u00c1vila, Espa\u00f1a",
      "C\u00f3rdoba-",
      "Soria1",
      "Sta. Cruz de Tenerife",
      "Las-Palmas"
    ],
    "positiveHeaderExamples": [
      "province_name_es",
      "nombre_provincia",
      "provincia_nombre_es",
      "province_name",
      "provincia",
      "prov_nm_es",
      "nombre_prov",
      "province_name_spanish"
    ],
    "negativeHeaderExamples": [
      "province_code_es",
      "province_id",
      "provincia_codigo",
      "region_name",
      "city_name",
      "country_name",
      "state_code",
      "prov_cd"
    ],
    "explanation": "This semantic type targets cells that contain Spanish province names as proper nouns, optionally composed of multiple capitalized words and common Spanish connectors (de, del, la, las, el, los, san, santa, santo). It is intended for classifying administrative subdivisions within Spain in datasets where values are full, non-abbreviated province names. The header patterns prioritize fields explicitly labeled as Spanish province names and back off to generic name fields only as a last resort.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:11:16.888248"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_NL",
    "description": "This type identifies Netherlands province names used for regional administrative identification within the Dutch governmental structure. The format consists of proper noun text strings representing official province names in Dutch without abbreviations.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "DRENTHE",
      "FLEVOLAND",
      "FRIESLAND",
      "GELDERLAND",
      "GRONINGEN",
      "LIMBURG",
      "NOORD-BRABANT",
      "NOORD-HOLLAND",
      "OVERIJSSEL",
      "UTRECHT",
      "ZEELAND",
      "ZUID-HOLLAND"
    ],
    "backout": "^[A-Z]{7,13}(-[A-Z]{7,8})?$",
    "confidenceThreshold": 98,
    "priority": 5290,
    "headerPatterns": [
      {
        "regExp": "(?i).*(nl|netherlands|dutch).*(provincie|province).*(naam|name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nl provincie naam"
        ],
        "negativeExamples": [
          "nl provincie code"
        ]
      },
      {
        "regExp": "(?i).*(provincie).*(naam).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "provincie naam"
        ],
        "negativeExamples": [
          "provincie type"
        ]
      },
      {
        "regExp": "(?i).*(province).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province name"
        ],
        "negativeExamples": [
          "province code"
        ]
      },
      {
        "regExp": "(?i).*(prov).*(nm|naam|name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "prov_nm"
        ],
        "negativeExamples": [
          "prov_cd"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Noord-Holland",
      "Zuid-Holland",
      "Noord-Brabant",
      "Utrecht",
      "Zeeland",
      "Limburg",
      "Drenthe",
      "Overijssel"
    ],
    "negativeContentExamples": [
      "Noord Holland",
      "Zuidholland",
      "N-Holland",
      "Provincie Utrecht",
      "Overijssel ",
      "Frysl\u00e2n",
      "North Brabant",
      "Gelderland-"
    ],
    "positiveHeaderExamples": [
      "nl provincie naam",
      "provincie naam",
      "province name",
      "prov_nm",
      "provincienaam",
      "dutch province name",
      "nl_province_name",
      "nl-provincie-naam"
    ],
    "negativeHeaderExamples": [
      "provincie code",
      "province code",
      "prov_cd",
      "country name",
      "city name",
      "region name",
      "state code",
      "province_id"
    ],
    "explanation": "This semantic type is intended to recognize official Dutch province names for datasets capturing regional administrative attributes related to the Netherlands. It is implemented as a finite list of the 12 provinces to ensure high precision and to prevent confusion with other regional or international geographies. The backout pattern offers a controlled fallback shape for uppercase tokens with an optional single hyphen, reflecting the observed forms of these names.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:11:29.911495"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS4_EN",
    "description": "This type captures specialized addressing information for complex facilities requiring detailed location specifications beyond standard address components. The values represent wing names, entrance types, dock numbers, or other facility-specific identifiers using standard English addressing conventions.",
    "pluginType": "regex",
    "regexPattern": "\\b(Wing\\s[A-Z0-9]{1,3}|(North|South|East|West)\\sWing|Entrance\\s[0-9]{1,3}|(Main|North|South|East|West)\\sEntrance|Gate\\s[0-9]{1,3}[A-Z]?|(Loading|Receiving|Shipping)\\sDock\\s[A-Z0-9]{1,3}|Dock\\s[A-Z0-9]{1,3}|Bay\\s[0-9]{1,3}|Pod\\s[A-Z]|Unit\\s[A-Z0-9]{1,4}|Level\\s[0-9]{1,2}|Floor\\s[0-9]{1,2}|Block\\s[A-Z0-9]{1,2}|Tower\\s[A-Z])\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 92,
    "priority": 5540,
    "headerPatterns": [
      {
        "regExp": "(?i).*(address[_\\s]?line[_\\s]?4|address4|addr4).*(wing|entrance|dock|gate|bay|pod|unit|level|floor|tower|block).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "address_line_4_wing"
        ],
        "negativeExamples": [
          "delivery_instructions"
        ]
      },
      {
        "regExp": "(?i).*(facility|building|site).*(address[_\\s]?line[_\\s]?4|address4|addr4).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "facility_address4_detail"
        ],
        "negativeExamples": [
          "site_notes"
        ]
      },
      {
        "regExp": "(?i).*(addr[_\\s]?4|address4|addrline4|a4).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "addr4_dock"
        ],
        "negativeExamples": [
          "gate_status"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "address4_location_detail"
        ],
        "negativeExamples": [
          "unit_price"
        ]
      }
    ],
    "positiveContentExamples": [
      "Wing A",
      "North Wing",
      "Entrance 3",
      "Main Entrance",
      "Gate 12B",
      "Loading Dock 7",
      "Pod C",
      "Unit A3"
    ],
    "negativeContentExamples": [
      "Entrance-3",
      "Dock 1234",
      "Wing AB12",
      "Loading Dock Seven",
      "Gate12B",
      "UnitA3",
      "Pod 3",
      "Level G"
    ],
    "positiveHeaderExamples": [
      "address_line_4_wing",
      "facility_address4_detail",
      "addr4_dock",
      "site_addr4",
      "building_address_line4",
      "address4_location_detail",
      "address_line4_gate"
    ],
    "negativeHeaderExamples": [
      "delivery_instructions",
      "site_notes",
      "building_section",
      "entrance_time",
      "gate_status",
      "load_bay_count",
      "unit_price"
    ],
    "explanation": "This semantic type is designed for the fourth address line that captures facility-specific location qualifiers such as wings, docks, gates, and entrances in English-language addressing. It helps disambiguate delivery or access points within complex campuses, warehouses, hospitals, airports, and similar large sites where standard street, city, and postal elements are insufficient.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:11:50.987721"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_NAME_BARE_<LANGUAGE>",
    "description": "Captures the core identifying portion of street names without street type markers or suffixes in a specified language context. Values represent the primary street name component, typically capitalized words and allowed connectors, following the linguistic conventions of the target locale.",
    "pluginType": "regex",
    "regexPattern": "\\b(?!.*\\b(St|Street|Ave|Avenue|Rd|Road|Blvd|Boulevard|Ln|Lane|Dr|Drive|Ct|Court|Way|Ter|Terrace|Pl|Place|Pkwy|Parkway|Cir|Circle)\\b)([A-Z][a-z]+|[A-Z][a-z]*'[A-Za-z]+|[A-Z][a-z]*-[A-Z][a-z]+|[0-9]{1,4}(st|nd|rd|th))(\\s+(of|and|de|del|la|da|do|di|du|y|the|van|von|der|den|san|santa|santo))?(\\s+([A-Z][a-z]+|[A-Z][a-z]*'[A-Za-z]+|[A-Z][a-z]*-[A-Z][a-z]+|[0-9]{1,4}(st|nd|rd|th))){0,4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 5580,
    "headerPatterns": [
      {
        "regExp": "(?i).*street.*name.*bare.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "street_name_bare_en"
        ],
        "negativeExamples": [
          "street_name"
        ]
      },
      {
        "regExp": "(?i).*(street|thoroughfare).*name.*(core|primary).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "primary_street_name"
        ],
        "negativeExamples": [
          "street_type"
        ]
      },
      {
        "regExp": "(?i).*(st|rd).*name.*(core|bare).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "st_name_core"
        ],
        "negativeExamples": [
          "addr_street"
        ]
      },
      {
        "regExp": "(?i).*(streetname|street_label).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "streetname"
        ],
        "negativeExamples": [
          "name_street_type"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 89,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "address"
        ]
      }
    ],
    "positiveContentExamples": [
      "Main",
      "King George",
      "O'Connell",
      "Seven Oaks",
      "Van Buren",
      "Prince Edward",
      "47th",
      "Santa Clara"
    ],
    "negativeContentExamples": [
      "Main Street",
      "Elm St",
      "King George Road",
      "47th Ave",
      "Queen's Rd",
      "Oak-Lane",
      "main",
      "12th Street"
    ],
    "positiveHeaderExamples": [
      "street_name_bare_en",
      "primary_street_name",
      "street_core_name",
      "thoroughfare_name_core",
      "st_name_core",
      "streetname",
      "street_primary_name",
      "roadway_name_primary"
    ],
    "negativeHeaderExamples": [
      "street_type",
      "address_line1",
      "city_name",
      "full_address",
      "postal_code",
      "street_code",
      "road_class",
      "country_name"
    ],
    "explanation": "This semantic type identifies bare street names without type suffixes or prefixes, focusing on the main naming tokens (e.g., 'Main', 'King George', 'O'Connell') and allowing connectors common in names while rejecting values that include street-type markers (e.g., 'Street', 'Rd', 'Avenue'). It is useful when extracting standardized street name cores for geocoding, deduplication, or normalization across address datasets in a specific language context.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:11:57.763786"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS3_EN",
    "description": "Additional addressing details for complex buildings or facilities in English, such as building identifiers, floors/levels, suites/units/rooms, wings/towers, entrances, and similar internal location qualifiers. Typical tokens include Building/Bldg, Floor/Fl/Level/Lvl with numbers, Suite/Ste/Apt/Unit/Rm/Room with numbers, directional wings (e.g., East Wing), towers/blocks, sections/phases, and specific facility elements like Loading Dock.\nThese values do not include street names or primary address lines and are intended as an address line 3 component with English conventions.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b((Bldg|Building)[ -][A-Za-z0-9]{1,4}|(Tower|Block|Wing|Entrance|Gate|Bay|Dock|Loading[ -]Dock)[ -][A-Za-z0-9]{1,4}|(East|West|North|South|NE|NW|SE|SW)[ -](Wing|Tower|Entrance)|(Floor|Fl|Level|Lvl)[ -][0-9]{1,2}[A-Za-z]?|(Suite|Ste|Apt|Apartment|Unit|Rm|Room|Office)[ -][0-9]{1,4}[A-Za-z]?|(Section|Phase)[ -]([A-Za-z0-9]{1,3}|[IVX]{1,5})|Mezzanine|Penthouse|Basement)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 5530,
    "headerPatterns": [
      {
        "regExp": "(?i).*(address[ _-]*line[ _-]*3|addr[ _-]*line[ _-]*3|street[ _-]*address[ _-]*3)[ _-]*en.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "address_line_3_en"
        ],
        "negativeExamples": [
          "address_line_3_fr"
        ]
      },
      {
        "regExp": "(?i).*(address[ _-]*3)[ _-]*en.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "address3_en"
        ],
        "negativeExamples": [
          "address2_en"
        ]
      },
      {
        "regExp": "(?i).*(address|addr).*(line|ln)[ _-]*3.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "addr_line3_en"
        ],
        "negativeExamples": [
          "addr_line2_en"
        ]
      },
      {
        "regExp": "(?i).*(building|bldg).*(floor|fl|level|lvl).*(room|rm).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "building_floor_room"
        ],
        "negativeExamples": [
          "building_name"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "additional_address_details"
        ],
        "negativeExamples": [
          "location"
        ]
      }
    ],
    "positiveContentExamples": [
      "Building A",
      "Bldg 5",
      "West Tower",
      "East Wing",
      "Floor 12",
      "Lvl 2",
      "Suite 204",
      "Loading Dock 2"
    ],
    "negativeContentExamples": [
      "PO Box 123",
      "Main Lobby",
      "Unit#3",
      "Department Finance",
      "Level Twelve",
      "Tower-",
      "Room#22",
      "Building"
    ],
    "positiveHeaderExamples": [
      "street_address3_en",
      "address_line_3_en",
      "addr_line3_en",
      "address3_en",
      "additional_address_details",
      "building_floor_room",
      "unit_suite_room",
      "address_detail3"
    ],
    "negativeHeaderExamples": [
      "street_address2_en",
      "address_line_3_fr",
      "addr_line_3",
      "street_address",
      "po_box",
      "city",
      "postal_code",
      "country_name"
    ],
    "explanation": "This semantic type identifies English-language address line 3 content that provides internal location detail within a site or complex. It is intended to capture tokens like building identifiers, floors/levels, suites/units/rooms, directional wings, towers, entrances, docks, sections, and phases. Use this to enrich geocoding and delivery workflows by distinguishing intra-building location details from primary street address lines.",
    "description_pattern": "P2",
    "generated_at": "2025-08-10T17:12:15.906987"
  }
]
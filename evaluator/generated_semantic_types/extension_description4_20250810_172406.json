[
  {
    "resultType": "generated",
    "semanticType": "AIRLINE.IATA_CODE",
    "description": "A text field containing airline codes that follow the pattern ^[A-Z]{2}$ where exactly two uppercase alphabetic characters represent the carrier. Each code consists of exactly two uppercase letters with no numeric digits, punctuation, or spacing allowed.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2500,
    "headerPatterns": [
      {
        "regExp": "(?i).*(airline|carrier).*iata.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Airline IATA Code"
        ],
        "negativeExamples": [
          "Airline Name"
        ]
      },
      {
        "regExp": "(?i).*iata.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IATA Code"
        ],
        "negativeExamples": [
          "Airport Code"
        ]
      },
      {
        "regExp": "(?i).*(airline|carrier).*(code|cd).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Carrier Code"
        ],
        "negativeExamples": [
          "Carrier Name"
        ]
      },
      {
        "regExp": "(?i).*(airline|carrier).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Carrier"
        ],
        "negativeExamples": [
          "Flight Number"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Airline Code"
        ],
        "negativeExamples": [
          "Carrier"
        ]
      }
    ],
    "positiveContentExamples": [
      "AA",
      "BA",
      "LH",
      "AF",
      "DL",
      "UA",
      "QF",
      "EK"
    ],
    "negativeContentExamples": [
      "A1",
      "AAA",
      "A",
      "AB ",
      "ab",
      "A-B",
      "A_B",
      "Aa"
    ],
    "positiveHeaderExamples": [
      "Airline Code",
      "IATA Code",
      "Carrier",
      "Airline IATA Code",
      "Carrier Code",
      "IATA Airline Code",
      "Air Carrier Code"
    ],
    "negativeHeaderExamples": [
      "Airline Name",
      "Flight Number",
      "Airport Code",
      "IATA Number",
      "Airline ID",
      "Carrier Name",
      "Airport IATA Code"
    ],
    "explanation": "Identifies two-letter IATA airline carrier codes and validates that values are exactly two uppercase alphabetic characters with no digits, punctuation, or spaces. Useful for recognizing and validating carrier fields in flight, reservation, or scheduling datasets while avoiding confusion with airport codes, which are typically three-letter codes.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:24:40.705755"
  },
  {
    "resultType": "generated",
    "semanticType": "EPOCH.SECONDS",
    "description": "A numeric field containing timestamp values that are 10-digit integers representing seconds since the Unix epoch (1970-01-01T00:00:00Z). This format provides second-precision timing commonly used in Unix systems, APIs, and standard timestamp applications.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{10}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 2940,
    "headerPatterns": [
      {
        "regExp": "(?i).*unix.*timestamp.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Unix Timestamp"
        ],
        "negativeExamples": [
          "Formatted Date"
        ]
      },
      {
        "regExp": "(?i).*epoch.*seconds?.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Epoch Seconds"
        ],
        "negativeExamples": [
          "Epoch Milliseconds"
        ]
      },
      {
        "regExp": "(?i).*epoch.*time.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Epoch Time"
        ],
        "negativeExamples": [
          "ISO Date"
        ]
      },
      {
        "regExp": "(?i).*unix.*time.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Server Unix Time"
        ],
        "negativeExamples": [
          "Unix Date"
        ]
      },
      {
        "regExp": "(?i).*timestamp.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Timestamp"
        ],
        "negativeExamples": [
          "Time"
        ]
      }
    ],
    "positiveContentExamples": [
      "1609459200",
      "1700000000",
      "1451606400",
      "1234567890",
      "2147483647",
      "0999999999",
      "0000000000",
      "1893456000"
    ],
    "negativeContentExamples": [
      "1609459200000",
      "160945920",
      "16094592000",
      "-1609459200",
      "1,609,459,200",
      "1609459200.0",
      "160945 9200",
      "160945920O"
    ],
    "positiveHeaderExamples": [
      "Timestamp",
      "Unix Timestamp",
      "Epoch Time",
      "Epoch Seconds",
      "Event Timestamp",
      "Server Timestamp",
      "Created Timestamp",
      "Login Timestamp"
    ],
    "negativeHeaderExamples": [
      "Date",
      "Time",
      "Formatted Date",
      "ISO Date",
      "Local Time",
      "Epoch Milliseconds",
      "Datetime",
      "Timestamp Offset"
    ],
    "explanation": "This semantic type detects 10-digit Unix epoch timestamps expressed in seconds, constrained to a single numeric token using word boundaries. It is useful for identifying second-precision timestamps in logs, telemetry, and API payloads where values appear as integers rather than formatted dates.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:24:45.766974"
  },
  {
    "resultType": "generated",
    "semanticType": "CURRENCY_CODE.ISO-4217",
    "description": "A text field containing currency codes that follow the pattern ^[A-Z]{3}$ consisting of exactly three consecutive uppercase letters. The format represents internationally standardized currency identification as mandated by ISO 4217 specifications for financial transactions.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 2870,
    "headerPatterns": [
      {
        "regExp": "(?i).*iso.*4217.*currency.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "ISO 4217 Currency Code"
        ],
        "negativeExamples": [
          "ISO Currency"
        ]
      },
      {
        "regExp": "(?i).*iso.*currency.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "ISO Currency"
        ],
        "negativeExamples": [
          "Currency Code"
        ]
      },
      {
        "regExp": "(?i).*currency.*code.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Currency Code"
        ],
        "negativeExamples": [
          "Currency Name"
        ]
      },
      {
        "regExp": "(?i).*ccy.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CCY Code"
        ],
        "negativeExamples": [
          "Currency Symbol"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "USD",
      "EUR",
      "JPY",
      "GBP",
      "AUD",
      "CAD",
      "CNY",
      "INR"
    ],
    "negativeContentExamples": [
      "usd",
      "US D",
      "US$",
      "EURO",
      "US",
      "US2",
      "\u00d1RD",
      "EU R"
    ],
    "positiveHeaderExamples": [
      "Currency Code",
      "ISO Currency",
      "Currency Symbol",
      "ISO 4217 Currency Code",
      "CCY Code",
      "Currency Alpha Code",
      "ISO4217"
    ],
    "negativeHeaderExamples": [
      "Currency Name",
      "Exchange Rate",
      "Country",
      "Currency Amount",
      "Language Code",
      "Account Code",
      "ISO Country Code"
    ],
    "explanation": "This semantic type detects ISO 4217 currency codes formatted as exactly three uppercase letters. It is useful for identifying standardized currency fields in financial, accounting, and payment datasets where codes like USD, EUR, and JPY are expected. Header patterns prioritize explicit ISO 4217 and currency code labels, with a primitive fallback on generic 'code'. The value regex is strict to reduce false positives while remaining general enough for the full ISO code list.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:24:46.108824"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.ISBN",
    "description": "A hyphenated numeric string for ISBN-13 that starts with 978 or 979 and consists of five numeric groups separated by hyphens, where the final group is a single check digit. The format is 97x-<registration group>-<registrant>-<publication>-<check digit>, using only digits in each group.",
    "pluginType": "regex",
    "regexPattern": "\\b97[89]-[0-9]+-[0-9]+-[0-9]+-[0-9]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 2570,
    "headerPatterns": [
      {
        "regExp": "(?i).*book.*isbn.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Book ISBN"
        ],
        "negativeExamples": [
          "Book Title"
        ]
      },
      {
        "regExp": "(?i).*isbn[-_ ]?13.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISBN-13"
        ],
        "negativeExamples": [
          "ISBN-10"
        ]
      },
      {
        "regExp": "(?i).*international.*standard.*book.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "International Standard Book Number"
        ],
        "negativeExamples": [
          "International Standard Serial Number"
        ]
      },
      {
        "regExp": "(?i).*isbn.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISBN Number"
        ],
        "negativeExamples": [
          "Customer Number"
        ]
      },
      {
        "regExp": "(?i).*isbn.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISBN"
        ],
        "negativeExamples": [
          "ISSN"
        ]
      }
    ],
    "positiveContentExamples": [
      "978-0-306-40615-7",
      "978-1-4028-9462-6",
      "978-3-16-148410-0",
      "979-10-90636-07-1",
      "979-1-2345-6789-3",
      "978-0-545-01022-1",
      "979-12-200-1234-8",
      "978-4-87311-336-4"
    ],
    "negativeContentExamples": [
      "978-0-306-40615-77",
      "978-0-306-40615-",
      "978-0-306-406157",
      "980-0-306-40615-7",
      "978 0 306 40615 7",
      "978-0-306-40615-X",
      "979-0-306-4061-57",
      "97-89-0-306-40615-7"
    ],
    "positiveHeaderExamples": [
      "ISBN",
      "Book ISBN",
      "ISBN-13",
      "International Standard Book Number",
      "ISBN Number",
      "ISBN No"
    ],
    "negativeHeaderExamples": [
      "Book Title",
      "Author",
      "Publication Year",
      "ISSN",
      "Library of Congress Number",
      "SKU"
    ],
    "explanation": "This semantic type targets ISBN-13 values formatted with hyphens, enforcing the 978/979 prefix and a final single-digit check digit. It is suitable for cataloging, publishing, and library datasets where standardized ISBN-13 strings appear in hyphenated form. The pattern is strict to avoid confusion with ISBN-10, ISSN, or unhyphenated identifiers.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:24:46.540629"
  },
  {
    "resultType": "generated",
    "semanticType": "CREDIT_CARD_TYPE",
    "description": "A text field containing credit card brand names that follow standard payment industry terminology and proper capitalization. Values represent established payment network brands as seen in commercial transactions (e.g., Visa, Mastercard, American Express), not card numbers or codes.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "VISA",
      "MASTERCARD",
      "AMERICAN EXPRESS",
      "DISCOVER",
      "JCB",
      "DINERS CLUB",
      "UNIONPAY",
      "MAESTRO",
      "MIR",
      "RUPAY",
      "CARTE BANCAIRE",
      "INTERAC",
      "ELO",
      "HIPERCARD",
      "TROY",
      "VERVE",
      "DANKORT",
      "NAPAS",
      "CARNET",
      "BC CARD"
    ],
    "backout": "^[A-Z][A-Z ]{1,18}[A-Z]$",
    "confidenceThreshold": 95,
    "priority": 2840,
    "headerPatterns": [
      {
        "regExp": "(?i).*credit.*card.*type.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Credit Card Type"
        ],
        "negativeExamples": [
          "Credit Card Number"
        ]
      },
      {
        "regExp": "(?i).*card.*brand.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Card Brand"
        ],
        "negativeExamples": [
          "Brand"
        ]
      },
      {
        "regExp": "(?i).*card.*network.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Card Network"
        ],
        "negativeExamples": [
          "Network Type"
        ]
      },
      {
        "regExp": "(?i).*payment.*card.*type.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Payment Card Type"
        ],
        "negativeExamples": [
          "Payment Type"
        ]
      },
      {
        "regExp": "(?i).*cc.*type.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CC Type"
        ],
        "negativeExamples": [
          "AC Type"
        ]
      },
      {
        "regExp": "(?i).*type.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Type"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "Visa",
      "Mastercard",
      "American Express",
      "Discover",
      "JCB",
      "Diners Club",
      "UnionPay",
      "RuPay"
    ],
    "negativeContentExamples": [
      "Amex",
      "Visa Card",
      "Master Card",
      "American Expres",
      "Discover Network",
      "Union Pay",
      "J C B",
      "Rupayy"
    ],
    "positiveHeaderExamples": [
      "Card Type",
      "Credit Card Type",
      "Card Brand",
      "Payment Card Type",
      "Card Network",
      "CC Type",
      "Card Brand Name",
      "Type"
    ],
    "negativeHeaderExamples": [
      "Card Number",
      "Cardholder Name",
      "Expiration Date",
      "Payment Type",
      "Brand",
      "Issuer",
      "CVV",
      "Billing Zip Code"
    ],
    "explanation": "This semantic type identifies fields where values are the brand names of payment card networks (e.g., Visa, Mastercard). It is useful for analytics, fraud rules, routing, and reporting where a standardized card network label is required. Values are matched against a curated list of well-known networks, with a conservative backout shape to prevent over-broad matches.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:24:49.394108"
  },
  {
    "resultType": "generated",
    "semanticType": "FREE_TEXT",
    "description": "A text field containing unrestricted content that may include any combination of letters, numbers, punctuation, and whitespace. The format allows complete freedom in content structure and length, accommodating narrative descriptions, comments, and explanatory text as needed.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z][A-Za-z0-9,.;:'\"()!?/\\-]* [A-Za-z0-9 ,.;:'\"()!?/\\-]{9,}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2970,
    "headerPatterns": [
      {
        "regExp": "(?i).*(free[_\\s]*text|unstructured[_\\s]*text|comment[_\\s]*text).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Unstructured Text"
        ],
        "negativeExamples": [
          "Price"
        ]
      },
      {
        "regExp": "(?i).*(detailed|additional|summary)[_\\s-]*(description|notes|comments).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Detailed Description"
        ],
        "negativeExamples": [
          "Date"
        ]
      },
      {
        "regExp": "(?i).*(description|comments|notes).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Comments"
        ],
        "negativeExamples": [
          "ID"
        ]
      },
      {
        "regExp": "(?i).*(desc|cmts|cmnt|note).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "desc"
        ],
        "negativeExamples": [
          "Code"
        ]
      },
      {
        "regExp": "(?i).*(message|remarks|feedback|observations).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Remarks"
        ],
        "negativeExamples": [
          "Quantity"
        ]
      },
      {
        "regExp": "(?i).*text.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Text"
        ],
        "negativeExamples": [
          "Number"
        ]
      }
    ],
    "positiveContentExamples": [
      "Provide additional details about the incident and next steps.",
      "Customer reported intermittent failures during overnight processing.",
      "Please verify the shipping address and confirm delivery preferences.",
      "This field captures any remarks, context, or clarifications from users.",
      "Steps taken include rebooting the server, clearing cache, and retesting.",
      "Notes indicate that approval was granted pending final documentation.",
      "A brief narrative summarizing key decisions and outstanding questions.",
      "Enter any comments relevant to the record, including caveats or assumptions."
    ],
    "negativeContentExamples": [
      "OK",
      "N/A",
      "None",
      "2025-08-11",
      "$19.99",
      "ID12345",
      "12345 comment",
      "No issues"
    ],
    "positiveHeaderExamples": [
      "Description",
      "Notes",
      "Comments",
      "Detailed Description",
      "Additional Notes",
      "User Comments",
      "Comment Text",
      "Unstructured Text"
    ],
    "negativeHeaderExamples": [
      "ID",
      "Date",
      "Price",
      "Status",
      "Code",
      "Quantity",
      "Email",
      "Address"
    ],
    "explanation": "This semantic type targets narrative, free-form fields where users provide descriptions, comments, or remarks. The content regex prefers multi-word, letter-led text with sufficient length to avoid short codes, dates, or numeric-only entries. Header patterns progress from specific variants (free/unstructured text) to general terms (text) to help match a wide range of descriptive columns while minimizing conflicts with structured types.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:24:50.817820"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.EASTING",
    "description": "A numeric value representing the X-axis distance in a projected coordinate system, typically expressed in meters, allowing an optional leading minus sign and optional decimal fraction. Values are plain numerics without units or thousands separators.",
    "pluginType": "regex",
    "regexPattern": "\\b-?[0-9]{1,8}(\\.[0-9]{1,3})?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 2700,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\beasting\\b.*value.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Easting Value"
        ],
        "negativeExamples": [
          "Easting Range"
        ]
      },
      {
        "regExp": "(?i).*\\bx[_ ]?coord(inate)?\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "X Coordinate"
        ],
        "negativeExamples": [
          "Z Coordinate"
        ]
      },
      {
        "regExp": "(?i).*\\beasting\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Easting"
        ],
        "negativeExamples": [
          "Longitude"
        ]
      },
      {
        "regExp": "(?i).*\\bX\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "X"
        ],
        "negativeExamples": [
          "XCoordinate"
        ]
      },
      {
        "regExp": "(?i).*\\bcoordinate\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Coordinate"
        ],
        "negativeExamples": [
          "Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "500000",
      "412345.25",
      "-12345.6",
      "2000000",
      "0",
      "99999999",
      "3456789.123"
    ],
    "negativeContentExamples": [
      "+500000",
      "500,000",
      "123 456",
      "12.34.56",
      "500000m",
      "N500000",
      "500000-"
    ],
    "positiveHeaderExamples": [
      "Easting",
      "X Coordinate",
      "Easting Value",
      "X",
      "Projected X",
      "Map Easting"
    ],
    "negativeHeaderExamples": [
      "Longitude",
      "Latitude",
      "Address",
      "Y Coordinate",
      "UTM Zone",
      "Postal Code"
    ],
    "explanation": "This semantic type identifies numeric easting values commonly used as the X component in projected coordinate systems (e.g., UTM, State Plane). It matches plain signed or unsigned numerics with an optional decimal fraction, excluding units, thousands separators, and other adornments. Typical use cases include GIS datasets where easting pairs with northing to represent positions in a projected grid.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:24:51.095326"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.CUSIP",
    "description": "An alphanumeric string of nine characters where the first eight are uppercase letters or digits and the ninth is a numeric check digit.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9A-Z]{8}[0-9]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 2540,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bcusip\\b.*\\bcode\\b.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "CUSIP Code"
        ],
        "negativeExamples": [
          "Security Code"
        ]
      },
      {
        "regExp": "(?i).*\\bcusip\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "CUSIP"
        ],
        "negativeExamples": [
          "Security ID"
        ]
      },
      {
        "regExp": "(?i).*\\bsecurity\\b.*\\bidentifier\\b.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Security Identifier"
        ],
        "negativeExamples": [
          "Ticker Symbol"
        ]
      },
      {
        "regExp": "(?i).*\\bsecid\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "SecID"
        ],
        "negativeExamples": [
          "Security Name"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "037833100",
      "17275R102",
      "594918104",
      "G1151C101",
      "40434L105",
      "20030N101",
      "30231G102",
      "62944T105"
    ],
    "negativeContentExamples": [
      "03783310A",
      "0378331000",
      "03783310",
      "0378-33100",
      "17275R10",
      "g1151c101",
      "G1151C10X",
      "17275R10 2"
    ],
    "positiveHeaderExamples": [
      "CUSIP",
      "Security ID",
      "CUSIP Code",
      "CUSIP Number",
      "Security Identifier",
      "SecID"
    ],
    "negativeHeaderExamples": [
      "Ticker Symbol",
      "Company Name",
      "Stock Price",
      "Security Code",
      "Instrument Code",
      "ISIN"
    ],
    "explanation": "CUSIP values are nine-character identifiers where the first eight positions are uppercase letters or digits and the final position is a numeric check digit. This semantic type focuses on the canonical shape and placement of the check digit, enabling accurate recognition of CUSIP-like codes in datasets. Validation of the actual check digit value is not performed by this regex-based classifier.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:24:51.421294"
  },
  {
    "resultType": "generated",
    "semanticType": "DAY.FULL_<LOCALE>",
    "description": "A text field containing full weekday names that follow locale-specific linguistic patterns and typically use proper case formatting. The format consists of alphabetic characters appropriate to the specified language and may include diacritical marks or special characters based on linguistic requirements. This variant targets the English (EN) locale using the seven full weekday names.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "MONDAY",
      "TUESDAY",
      "WEDNESDAY",
      "THURSDAY",
      "FRIDAY",
      "SATURDAY",
      "SUNDAY"
    ],
    "backout": "^[A-Za-z]{6,9}$",
    "confidenceThreshold": 97,
    "priority": 2900,
    "headerPatterns": [
      {
        "regExp": "(?i).*day.*of.*week.*name.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Day of Week Name"
        ],
        "negativeExamples": [
          "Day of Week Number"
        ]
      },
      {
        "regExp": "(?i).*weekday.*name.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Weekday Name"
        ],
        "negativeExamples": [
          "Weekend Name"
        ]
      },
      {
        "regExp": "(?i).*day.*name.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Day Name"
        ],
        "negativeExamples": [
          "Day Number"
        ]
      },
      {
        "regExp": "(?i).*day.*of.*week.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Day of Week"
        ],
        "negativeExamples": [
          "Day of Month"
        ]
      },
      {
        "regExp": "(?i).*wkday.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "WKDAY"
        ],
        "negativeExamples": [
          "Weekday Count"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Date"
        ]
      }
    ],
    "positiveContentExamples": [
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday",
      "Sunday"
    ],
    "negativeContentExamples": [
      "Mon",
      "Tues",
      "Thur",
      "Sundaye",
      "Monday!",
      "Sun day",
      "Lundi",
      "2Monday"
    ],
    "positiveHeaderExamples": [
      "Day Name",
      "Day of Week",
      "Weekday",
      "Day of Week Name",
      "Weekday Name",
      "DOW",
      "WKDAY",
      "DayName"
    ],
    "negativeHeaderExamples": [
      "Day Number",
      "Month",
      "Year",
      "Day Index",
      "Day of Month",
      "Weekend",
      "Date",
      "DOM"
    ],
    "explanation": "Identifies columns containing the full English weekday names. Useful for normalizing or validating day-of-week text values, supporting lookups, grouping, and standardization in data pipelines that expect complete weekday names rather than abbreviations.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:24:52.620782"
  },
  {
    "resultType": "generated",
    "semanticType": "FILENAME_EXT",
    "description": "A text field containing file extensions that start with a mandatory period followed by one or more letters or numbers (e.g., .pdf, .DOCX, .7z). The format represents standard file type indicators as commonly used in operating systems and applications for file format identification.",
    "pluginType": "regex",
    "regexPattern": "\\.[A-Za-z0-9]{1,16}",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 2960,
    "headerPatterns": [
      {
        "regExp": "(?i).*file.*extension.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "File Extension"
        ],
        "negativeExamples": [
          "File Size"
        ]
      },
      {
        "regExp": "(?i).*file.*type.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "File Type"
        ],
        "negativeExamples": [
          "File Path"
        ]
      },
      {
        "regExp": "(?i).*file.*ext.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "File Ext"
        ],
        "negativeExamples": [
          "Filename"
        ]
      },
      {
        "regExp": "(?i).*suffix.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "File Suffix"
        ],
        "negativeExamples": [
          "Prefix"
        ]
      },
      {
        "regExp": "(?i).*extension.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Extension"
        ],
        "negativeExamples": [
          "MIME Type"
        ]
      }
    ],
    "positiveContentExamples": [
      ".pdf",
      ".TXT",
      ".jpg",
      ".tar",
      ".gz",
      ".docx",
      ".7z",
      ".json5"
    ],
    "negativeContentExamples": [
      "pdf",
      ".tar.gz",
      ".mp3?",
      ".xlsx ",
      " .docx",
      ".jpg-",
      "file.txt",
      ".csv/"
    ],
    "positiveHeaderExamples": [
      "File Extension",
      "Extension",
      "File Type",
      "File Ext",
      "File Suffix",
      "Type Extension"
    ],
    "negativeHeaderExamples": [
      "Filename",
      "File Size",
      "File Path",
      "Content Type",
      "MIME Type",
      "Directory",
      "External ID"
    ],
    "explanation": "This semantic type identifies standalone file extensions, ensuring the value is only the extension token (a leading dot followed by alphanumeric characters) rather than a full filename or path. Use it to validate or standardize columns that store just the file format suffix.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:24:53.565664"
  },
  {
    "resultType": "generated",
    "semanticType": "COLOR.HEX",
    "description": "A string matching the pattern ^#[0-9A-F]{6}$ consisting of a hash prefix followed by six hexadecimal digits for RGB values.",
    "pluginType": "regex",
    "regexPattern": "#[0-9A-F]{6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2630,
    "headerPatterns": [
      {
        "regExp": "(?i).*hex.*color.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Hex Color Code"
        ],
        "negativeExamples": [
          "Color Code"
        ]
      },
      {
        "regExp": "(?i).*color.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Color Code"
        ],
        "negativeExamples": [
          "Product Code"
        ]
      },
      {
        "regExp": "(?i).*hex.*color.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Hex Color"
        ],
        "negativeExamples": [
          "Color Name"
        ]
      },
      {
        "regExp": "(?i).*hex.*value.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Hex Value"
        ],
        "negativeExamples": [
          "Color Value"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "#A1B2C3",
      "#FFFFFF",
      "#000000",
      "#12AB34",
      "#ABCDEF",
      "#09F0A1",
      "#90C0DE",
      "#1E2D3C"
    ],
    "negativeContentExamples": [
      "#FFF",
      "#ABCDE",
      "#A1B2C",
      "#A1B2C3D",
      "A1B2C3",
      "#abc123",
      "#12345G",
      "#12-3456"
    ],
    "positiveHeaderExamples": [
      "Color Code",
      "Hex Color",
      "Color Value",
      "Hex Color Code",
      "Color Hex",
      "CLR Code",
      "Hex Value",
      "Color Hex Code"
    ],
    "negativeHeaderExamples": [
      "Color Name",
      "RGB Values",
      "Brand Color",
      "Product Code",
      "Hexadecimal Color",
      "Area Code",
      "Color ID",
      "Theme Name"
    ],
    "explanation": "Identifies six-digit RGB hex color literals with a leading hash and uppercase hexadecimal digits. Use for columns storing canonical hex color codes in design, UI, or styling datasets.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:24:53.622949"
  },
  {
    "resultType": "generated",
    "semanticType": "CONTINENT.CODE_EN",
    "description": "A two-letter uppercase code representing a continent. Values are restricted to a small, known set of continent abbreviations.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AF",
      "AN",
      "AS",
      "EU",
      "NA",
      "OC",
      "SA"
    ],
    "backout": "^[A-Z]{2}$",
    "confidenceThreshold": 98,
    "priority": 2680,
    "headerPatterns": [
      {
        "regExp": "(?i).*continent[ _-]*code.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Continent Code"
        ],
        "negativeExamples": [
          "Continent Name"
        ]
      },
      {
        "regExp": "(?i).*continent[ _-]*(abbr|abbrev|abbreviation).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Continent Abbr"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*region[ _-]*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Region Code"
        ],
        "negativeExamples": [
          "Region Name"
        ]
      },
      {
        "regExp": "(?i).*(cont)[ _-]*(cd|code).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "cont_cd"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "AF",
      "AN",
      "AS",
      "EU",
      "NA",
      "OC",
      "SA"
    ],
    "negativeContentExamples": [
      "Eu",
      "EU1",
      "E U",
      "Eur",
      "E",
      "OCN",
      " SA ",
      "ASIA"
    ],
    "positiveHeaderExamples": [
      "Continent Code",
      "Continent Abbr",
      "Region Code",
      "continent_abbreviation",
      "continent_cd",
      "cont_code",
      "region_abbr"
    ],
    "negativeHeaderExamples": [
      "Continent Name",
      "Country",
      "Location",
      "Region Name",
      "Country Code",
      "Language Code",
      "Time Zone"
    ],
    "explanation": "This type identifies two-letter continent abbreviations using a finite controlled list to avoid false positives from arbitrary two-letter strings. Use when a field stores continent codes rather than full names, supporting validation, normalization, and consistent joins across datasets.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:24:53.781870"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.LATITUDE_DMS",
    "description": "A string representing latitude in degrees, minutes, and seconds followed by a cardinal direction (N or S). Format uses the degree symbol, apostrophe for minutes, double-quote for seconds, and an uppercase N/S with no spaces between tokens.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{1,2}\u00b0\\d{1,2}'\\d{1,2}\\\"[NS]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 2720,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\blatitude\\b.*\\bdms\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Latitude DMS"
        ],
        "negativeExamples": [
          "Decimal Latitude"
        ]
      },
      {
        "regExp": "(?i).*\\blat\\b.*\\b(deg|degrees)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Lat Degrees"
        ],
        "negativeExamples": [
          "Longitude Degrees"
        ]
      },
      {
        "regExp": "(?i).*\\blatitude\\b.*\\b(coords|coordinates)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Latitude Coords"
        ],
        "negativeExamples": [
          "Location Coordinates"
        ]
      },
      {
        "regExp": "(?i).*\\b(coordinate|coordinates|coords)\\b.*\\blat\\b.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Coordinate Lat"
        ],
        "negativeExamples": [
          "Coordinates Long"
        ]
      },
      {
        "regExp": "(?i).*\\blatitude\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Latitude"
        ],
        "negativeExamples": [
          "Longitude"
        ]
      }
    ],
    "positiveContentExamples": [
      "0\u00b00'0\"N",
      "7\u00b05'3\"S",
      "12\u00b034'56\"N",
      "23\u00b00'0\"S",
      "45\u00b030'15\"N",
      "89\u00b059'59\"S",
      "90\u00b00'0\"N",
      "08\u00b005'09\"S"
    ],
    "negativeContentExamples": [
      "12\u00b034'56\" E",
      "12\u00b034'56\"",
      "-12\u00b034'56\"N",
      "N12\u00b034'56\"",
      "12 34'56\"N",
      "12\u00b034 56\"N",
      "12\u00b034'56\"n",
      "12.5823N"
    ],
    "positiveHeaderExamples": [
      "Latitude DMS",
      "Lat Degrees",
      "Latitude Coords",
      "Lat DMS",
      "Lat Deg Min Sec",
      "Geographic Latitude DMS",
      "Latitude (DMS)",
      "Coordinate Lat"
    ],
    "negativeHeaderExamples": [
      "Longitude",
      "Decimal Latitude",
      "Location",
      "Latitude Decimal Degrees",
      "Lat/Long",
      "Coordinates",
      "Easting",
      "Longitude DMS"
    ],
    "explanation": "Identifies latitude values expressed in DMS with explicit symbols and an uppercase N/S suffix. Useful for datasets where latitude is recorded in a strict degrees\u2013minutes\u2013seconds format and must be distinguished from decimal degrees or longitude.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:24:54.131679"
  },
  {
    "resultType": "generated",
    "semanticType": "AIRPORT_CODE.IATA",
    "description": "A code consisting of exactly three consecutive uppercase letters (A\u2013Z) representing an IATA airport/location code. No digits, spaces, or separators are permitted.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 2520,
    "headerPatterns": [
      {
        "regExp": "(?i).*airport.*iata.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "airport_iata_code"
        ],
        "negativeExamples": [
          "airport_code_type"
        ]
      },
      {
        "regExp": "(?i).*iata.*airport.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iata_airport_code"
        ],
        "negativeExamples": [
          "airport_iata"
        ]
      },
      {
        "regExp": "(?i).*airport.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "airport code"
        ],
        "negativeExamples": [
          "airport name"
        ]
      },
      {
        "regExp": "(?i).*iata.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iata"
        ],
        "negativeExamples": [
          "icao"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "JFK",
      "LAX",
      "CDG",
      "HND",
      "DXB",
      "SIN",
      "SYD",
      "GRU"
    ],
    "negativeContentExamples": [
      "JFK1",
      "jfK",
      "LA-X",
      "LAXS",
      "LA",
      "123",
      "J4K",
      "\u00d1AX"
    ],
    "positiveHeaderExamples": [
      "Airport Code",
      "IATA Code",
      "Airport",
      "Airport IATA Code",
      "IATA",
      "IATA Airport Code",
      "IATA Location Code",
      "Airport Location Code"
    ],
    "negativeHeaderExamples": [
      "Airport Name",
      "City",
      "Airline Code",
      "ICAO Code",
      "Airline",
      "Port Code",
      "Terminal Code",
      "Airport Number"
    ],
    "explanation": "This type identifies IATA airport/location codes, which are exactly three uppercase letters. It is useful for validating and classifying fields that store standardized airport codes in travel, logistics, and aviation datasets.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:24:55.011734"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.TEXT_EN",
    "description": "A text string containing English letters and spaces representing proper country names in English language.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z]+( [A-Za-z]+){0,6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2810,
    "headerPatterns": [
      {
        "regExp": "(?i).*country.*name.*english.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "English Country Name"
        ],
        "negativeExamples": [
          "Country Name"
        ]
      },
      {
        "regExp": "(?i).*(english|en).*country.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Country Name EN"
        ],
        "negativeExamples": [
          "Country Name Full"
        ]
      },
      {
        "regExp": "(?i).*country.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Country Name"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*(nation|ctry).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Nation Name"
        ],
        "negativeExamples": [
          "ctry_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Canada",
      "United States",
      "United Kingdom",
      "New Zealand",
      "South Africa",
      "Saudi Arabia",
      "Bosnia and Herzegovina",
      "United States of America"
    ],
    "negativeContentExamples": [
      "United-States",
      "Cote d'Ivoire",
      "Trinidad & Tobago",
      "Hong Kong, China",
      "St. Vincent and the Grenadines",
      "Democratic Republic of the Congo (DRC)",
      "Korea, Republic of",
      "Timor-Leste"
    ],
    "positiveHeaderExamples": [
      "Country",
      "Country Name",
      "Nation",
      "English Country Name",
      "Country English Name",
      "Country Full Name",
      "Country Text",
      "Country Name EN"
    ],
    "negativeHeaderExamples": [
      "Country Code",
      "State",
      "City",
      "Country ISO Code",
      "Province",
      "Country Abbreviation",
      "Country Number",
      "Location"
    ],
    "explanation": "This semantic type identifies full country names written with English alphabetic characters and spaces only, excluding punctuation, digits, and symbols. Use it to distinguish natural-language country names from codes or abbreviations in datasets, especially when paired with headers that reference country and name.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:24:55.181381"
  },
  {
    "resultType": "generated",
    "semanticType": "COLOR.TEXT_EN",
    "description": "A text string matching basic color vocabulary patterns in English as a single lowercase word (e.g., red, blue, green). It targets simple, canonical color names and excludes codes, multi-word shades, and formatted values.",
    "pluginType": "regex",
    "regexPattern": "\\b(red|green|blue|yellow|orange|purple|pink|black|white|brown|gray|grey|beige|magenta|cyan|violet|indigo|teal|maroon|navy|olive|turquoise|lavender|fuchsia|gold|silver|tan|peach|plum)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2640,
    "headerPatterns": [
      {
        "regExp": "(?i).*primary.*color.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Primary Color Name"
        ],
        "negativeExamples": [
          "Color Code"
        ]
      },
      {
        "regExp": "(?i).*color.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Color Name"
        ],
        "negativeExamples": [
          "Customer Name"
        ]
      },
      {
        "regExp": "(?i).*primary.*color.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Primary Color"
        ],
        "negativeExamples": [
          "Primary Key"
        ]
      },
      {
        "regExp": "(?i).*(clr|colr|colour).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Clr Name"
        ],
        "negativeExamples": [
          "RGB"
        ]
      },
      {
        "regExp": "(?i).*color.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Color"
        ],
        "negativeExamples": [
          "Hex Value"
        ]
      }
    ],
    "positiveContentExamples": [
      "red",
      "blue",
      "green",
      "yellow",
      "orange",
      "purple",
      "black",
      "white"
    ],
    "negativeContentExamples": [
      "Red",
      "blue-green",
      "navy blue",
      "lightblue",
      "green2",
      "blu",
      "white.",
      "greyish"
    ],
    "positiveHeaderExamples": [
      "Color",
      "Color Name",
      "Primary Color",
      "Base Color",
      "Dominant Color",
      "Product Color Name"
    ],
    "negativeHeaderExamples": [
      "Color Code",
      "Hex Value",
      "RGB",
      "RGBA",
      "Paint Code",
      "Pantone"
    ],
    "explanation": "This semantic type identifies single-word, lowercase English color names from a common vocabulary. It is useful for columns storing human-readable color descriptors rather than programmatic color encodings. It explicitly excludes hex color codes, RGB/HSL values, multi-word or hyphenated shades, and values with capitalization, digits, or punctuation.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:24:55.708874"
  },
  {
    "resultType": "generated",
    "semanticType": "DIRECTION",
    "description": "A text field containing compass directions that follow standard navigational terminology and typically match patterns like ^(North|South|East|West|Northeast|Northwest|Southeast|Southwest)$. The format uses proper capitalization for established directional terms as commonly recognized in geographic and navigational contexts.",
    "pluginType": "regex",
    "regexPattern": "\\b(North|South|East|West|Northeast|Northwest|Southeast|Southwest)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 2910,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\b(compass|cardinal)\\b.*\\bdirection\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Compass Direction"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*\\b(compass|cardinal)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Cardinal"
        ],
        "negativeExamples": [
          "Location"
        ]
      },
      {
        "regExp": "(?i).*\\bdir\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "dir"
        ],
        "negativeExamples": [
          "Distance"
        ]
      },
      {
        "regExp": "(?i).*\\bdirection\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Direction"
        ],
        "negativeExamples": [
          "Orientation"
        ]
      }
    ],
    "positiveContentExamples": [
      "North",
      "South",
      "East",
      "West",
      "Northeast",
      "Northwest",
      "Southeast",
      "Southwest"
    ],
    "negativeContentExamples": [
      "north",
      "N",
      "NE",
      "North East",
      "North-East",
      "Northeastward",
      "ESE",
      "Norht"
    ],
    "positiveHeaderExamples": [
      "Direction",
      "Cardinal Direction",
      "Compass Direction",
      "Wind Direction",
      "Travel Direction",
      "Dir",
      "Navigation Direction"
    ],
    "negativeHeaderExamples": [
      "Address",
      "Location",
      "Distance",
      "Orientation",
      "Bearing",
      "Heading",
      "Latitude",
      "Timezone"
    ],
    "explanation": "This semantic type identifies canonical compass directions expressed as properly capitalized words corresponding to the eight principal directions. It is useful for datasets capturing orientation, movement, or geographic descriptors where the direction is recorded as a textual field.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:24:55.862835"
  },
  {
    "resultType": "generated",
    "semanticType": "DAY.DIGITS",
    "description": "A numeric field containing day values from 1 to 31 representing valid calendar days for a day-of-month component. Values are plain integers without leading zeros (e.g., 1\u201331). Month-specific limits are not enforced by this type and should be validated in context with a month field.",
    "pluginType": "regex",
    "regexPattern": "\\b(3[01]|[12][0-9]|[1-9])\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 2890,
    "headerPatterns": [
      {
        "regExp": "(?i).*day.*of.*month.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Day of Month"
        ],
        "negativeExamples": [
          "Day Name"
        ]
      },
      {
        "regExp": "(?i).*day.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Day Number"
        ],
        "negativeExamples": [
          "Month Number"
        ]
      },
      {
        "regExp": "(?i).*date.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Date Number"
        ],
        "negativeExamples": [
          "Date Name"
        ]
      },
      {
        "regExp": "(?i).*calendar.*day.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Calendar Day"
        ],
        "negativeExamples": [
          "Business Day"
        ]
      },
      {
        "regExp": "(?i).*dom.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "DOM"
        ],
        "negativeExamples": [
          "DOY"
        ]
      },
      {
        "regExp": "(?i).*day.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Day"
        ],
        "negativeExamples": [
          "Date"
        ]
      }
    ],
    "positiveContentExamples": [
      "1",
      "2",
      "9",
      "10",
      "15",
      "28",
      "30",
      "31"
    ],
    "negativeContentExamples": [
      "0",
      "32",
      "07",
      "00",
      "3.0",
      "1st",
      "-1",
      "001"
    ],
    "positiveHeaderExamples": [
      "Day",
      "Day of Month",
      "Date Number",
      "DOM",
      "Calendar Day",
      "Day Number",
      "Day Index",
      "Billing Day"
    ],
    "negativeHeaderExamples": [
      "Month",
      "Year",
      "Day Name",
      "Due Date",
      "Day of Year",
      "Weekday",
      "Hour",
      "Business Day"
    ],
    "explanation": "This type identifies numeric day-of-month values in the range 1\u201331, suitable for datasets where the day component is stored independently as an integer. It avoids leading zeros and non-integer formats, and is intended to complement a separate month/year context for full date validation.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:24:58.239579"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.NORTHING",
    "description": "A numeric value representing a distance measurement on the Y axis in projected coordinate systems. Values may be negative and may include a fractional part.",
    "pluginType": "regex",
    "regexPattern": "\\b-?\\d+(\\.\\d+)?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 2750,
    "headerPatterns": [
      {
        "regExp": "(?i).*(northing).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Northing Value"
        ],
        "negativeExamples": [
          "Latitude"
        ]
      },
      {
        "regExp": "(?i).*(y[ _-]?coordinate).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Y Coordinate"
        ],
        "negativeExamples": [
          "X Coordinate"
        ]
      },
      {
        "regExp": "(?i).*(y[ _-]?coord).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Y Coord"
        ],
        "negativeExamples": [
          "X Coord"
        ]
      },
      {
        "regExp": "(?i).*coordinate.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Coordinate"
        ],
        "negativeExamples": [
          "Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "5234567",
      "-12345.678",
      "0",
      "987654.0",
      "450000.25",
      "-0.75",
      "1000000",
      "234.567"
    ],
    "negativeContentExamples": [
      "1,234.56",
      "+123.45",
      "N 567890",
      "123m",
      "12.",
      "1.2.3",
      "45\u00b0",
      "1e5"
    ],
    "positiveHeaderExamples": [
      "Northing",
      "Y Coordinate",
      "Northing Value",
      "Grid Northing",
      "Y Coord",
      "Map Y Coordinate",
      "Northing_m",
      "Y Axis Coordinate"
    ],
    "negativeHeaderExamples": [
      "Latitude",
      "Longitude",
      "Address",
      "Easting",
      "X Coordinate",
      "Postal Code",
      "Country",
      "Street Address"
    ],
    "explanation": "This semantic type identifies northing values, which are Y-axis distances in projected coordinate systems. It targets plain numeric tokens with an optional leading minus sign and optional decimal fraction. Use this type to classify columns labeled as northing or Y coordinate in grid-based spatial data.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:03.912556"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.LONGITUDE_DMS",
    "description": "A string representing longitude in degrees-minutes-seconds (DMS) format with a degree symbol (\u00b0), minutes (') and seconds (\") followed by an east/west indicator (E or W). Example shape: D{1-3}\u00b0M{1-2}'S{1-2}\"[E|W], with minutes and seconds in the 0\u201359 range and no spaces.",
    "pluginType": "regex",
    "regexPattern": "\\b(1?\\d{1,2})\u00b0([0-5]?\\d)'([0-5]?\\d)\"([EW])\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2740,
    "headerPatterns": [
      {
        "regExp": "(?i).*longitude.*dms.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Longitude DMS"
        ],
        "negativeExamples": [
          "Decimal Longitude"
        ]
      },
      {
        "regExp": "(?i).*(long|lng).*(deg|degrees).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Long Degrees"
        ],
        "negativeExamples": [
          "Longitude Coords"
        ]
      },
      {
        "regExp": "(?i).*longitude.*coord.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Longitude Coords"
        ],
        "negativeExamples": [
          "Location"
        ]
      },
      {
        "regExp": "(?i).*(lng|long).*dms.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Lng DMS"
        ],
        "negativeExamples": [
          "Latitude"
        ]
      },
      {
        "regExp": "(?i).*longitude.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "Longitude"
        ],
        "negativeExamples": [
          "Latitude"
        ]
      }
    ],
    "positiveContentExamples": [
      "73\u00b059'59\"W",
      "0\u00b00'0\"E",
      "123\u00b05'9\"E",
      "180\u00b00'0\"W",
      "9\u00b059'59\"E",
      "45\u00b030'15\"W",
      "100\u00b000'01\"E",
      "15\u00b07'0\"W"
    ],
    "negativeContentExamples": [
      "73\u00b059'59\"N",
      "73\u00b059'W",
      "073\u00b059'59\"W",
      "73 59'59\"W",
      "73\u00b060'00\"W",
      "73\u00b059'60\"W",
      "73\u00b059'59.5\"W",
      "73.9999W"
    ],
    "positiveHeaderExamples": [
      "Longitude DMS",
      "Long Degrees",
      "Longitude Coords",
      "DMS Longitude",
      "Lng DMS",
      "East/West DMS Longitude",
      "Longitude D-M-S"
    ],
    "negativeHeaderExamples": [
      "Latitude",
      "Decimal Longitude",
      "Location",
      "Longitude DD",
      "Long Decimal",
      "GPS Long",
      "Coordinate"
    ],
    "explanation": "This semantic type detects longitude values expressed in DMS form using the exact symbols for degrees, minutes, and seconds, and requiring a terminal E or W direction. It is useful for datasets storing geographic longitudes in traditional DMS notation and helps differentiate from decimal-degree longitude fields.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:07.805429"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE_PAIR.DECIMAL_PAREN",
    "description": "A string representing a latitude-longitude pair in decimal degrees enclosed in parentheses, with a comma separator and optional spaces, such as (12.34, -56.78). Latitude allows 1\u20132 digits with optional decimals and an optional leading minus; longitude allows an optional leading minus and 2\u20133 digits (3 digits only when starting with 1), with optional decimals.",
    "pluginType": "regex",
    "regexPattern": "\\(\\s*-?\\d{1,2}(\\.\\d+)?\\s*,\\s*-?1?\\d{1,2}(\\.\\d+)?\\s*\\)",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 2770,
    "headerPatterns": [
      {
        "regExp": "(?i).*gps.*position.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "GPS Position"
        ],
        "negativeExamples": [
          "Longitude"
        ]
      },
      {
        "regExp": "(?i).*location.*coords.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Location Coords"
        ],
        "negativeExamples": [
          "Street Address"
        ]
      },
      {
        "regExp": "(?i).*geo.*coordinates.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Geo Coordinates"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*lat.*long.*pair.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Lat Long Pair"
        ],
        "negativeExamples": [
          "Latitude"
        ]
      },
      {
        "regExp": "(?i).*coordinate.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Coordinates"
        ],
        "negativeExamples": [
          "Timezone"
        ]
      }
    ],
    "positiveContentExamples": [
      "(12.34, -56.78)",
      "(-45.0, 170.25)",
      "(0, 0)",
      "(89.999, -179.5)",
      "( 7.5 , 12 )",
      "(-9, 123)",
      "(10, -1.23)",
      "( -0.01 , 180 )"
    ],
    "negativeContentExamples": [
      "12.34, -56.78",
      "(-123.4, 45.6)",
      "(12.34 -56.78)",
      "[12.34, -56.78]",
      "(12.34; -56.78)",
      "(12.34, -256.78)",
      "(12.34,)",
      "(N12.34, E56.78)"
    ],
    "positiveHeaderExamples": [
      "GPS Position",
      "Location Coords",
      "Coordinates",
      "Geo Coordinates",
      "Lat/Long Coordinates",
      "Lat Long Pair",
      "Location Coordinate Pair"
    ],
    "negativeHeaderExamples": [
      "Latitude",
      "Longitude",
      "Street Address",
      "Postal Code",
      "City",
      "Geo Hash",
      "Timezone",
      "Country Code"
    ],
    "explanation": "This semantic type captures coordinate pairs formatted as decimal latitude and longitude within parentheses, separated by a comma, and permitting optional whitespace and negative signs. It is useful for identifying compact geospatial fields that store a single combined lat-long value rather than separate latitude and longitude columns.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:08.907350"
  },
  {
    "resultType": "generated",
    "semanticType": "CRYPTOCURRENCY.TEXT_EN",
    "description": "Text values representing the proper names of cryptocurrencies, using standard capitalization (Title Case words and occasional short uppercase acronyms) and limited to alphabetic tokens separated by spaces or hyphens. Typical examples include single-word names (e.g., Bitcoin) or multi-word names such as Bitcoin Cash or USD Coin; symbols/tickers are excluded.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z][a-z]{2,}([ -]([A-Z][a-z]{2,}|[A-Z]{2,4})){0,3}|[A-Z]{2,4}[ -]([A-Z][a-z]{2,}|[A-Z]{2,4})([ -]([A-Z][a-z]{2,}|[A-Z]{2,4})){0,2})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 2850,
    "headerPatterns": [
      {
        "regExp": "(?i).*(cryptocurrency[ _-]*name).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Cryptocurrency Name"
        ],
        "negativeExamples": [
          "Crypto Symbol"
        ]
      },
      {
        "regExp": "(?i).*(crypto[ _-]*name).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Crypto Name"
        ],
        "negativeExamples": [
          "Crypto Symbol"
        ]
      },
      {
        "regExp": "(?i).*(digital[ _-]*currency[ _-]*name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Digital Currency Name"
        ],
        "negativeExamples": [
          "Digital Currency"
        ]
      },
      {
        "regExp": "(?i).*(cryptocurrency|digital[ _-]*currency).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Cryptocurrency"
        ],
        "negativeExamples": [
          "Wallet Address"
        ]
      },
      {
        "regExp": "(?i).*(crypto).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Crypto Name"
        ],
        "negativeExamples": [
          "Price"
        ]
      },
      {
        "regExp": "(?i).*(name).*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Bitcoin",
      "Ethereum",
      "Monero",
      "Binance Coin",
      "Bitcoin Cash",
      "Bitcoin SV",
      "USD Coin",
      "Polkadot"
    ],
    "negativeContentExamples": [
      "bitcoin",
      "BTC",
      "Bitcoin2",
      "USD coin",
      "TetherUSD",
      "eCash",
      "Monero!",
      "0x"
    ],
    "positiveHeaderExamples": [
      "Cryptocurrency",
      "Crypto Name",
      "Digital Currency",
      "Cryptocurrency Name",
      "Digital Currency Name",
      "Crypto Currency Name",
      "Coin Name"
    ],
    "negativeHeaderExamples": [
      "Crypto Symbol",
      "Price",
      "Wallet Address",
      "Currency Code",
      "Amount",
      "Exchange",
      "Hash"
    ],
    "explanation": "This semantic type identifies properly capitalized cryptocurrency names composed of alphabetic tokens separated by spaces or hyphens. It excludes symbols/tickers, codes, numbers, underscores, and punctuation, focusing on human-readable currency names commonly used in financial and trading contexts.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:09.605420"
  },
  {
    "resultType": "generated",
    "semanticType": "EMAIL",
    "description": "A string representing an email address consisting of a local username, an @ separator, and a domain with a top-level domain. The username allows letters, digits, and the characters . _ % + -, while the domain allows letters, digits, dots, and hyphens, and ends with a dot followed by 2 or more letters.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z0-9._%+\\-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 2920,
    "headerPatterns": [
      {
        "regExp": "(?i).*primary.*email.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Primary Email Address"
        ],
        "negativeExamples": [
          "Email Primary Address"
        ]
      },
      {
        "regExp": "(?i).*(contact|customer).*email.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Contact Email"
        ],
        "negativeExamples": [
          "Customer Phone"
        ]
      },
      {
        "regExp": "(?i).*(user|account).*email.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "User Email"
        ],
        "negativeExamples": [
          "Account Number"
        ]
      },
      {
        "regExp": "(?i).*email.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Email Address"
        ],
        "negativeExamples": [
          "Postal Address"
        ]
      },
      {
        "regExp": "(?i).*email.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Email"
        ],
        "negativeExamples": [
          "Website"
        ]
      }
    ],
    "positiveContentExamples": [
      "john.doe@example.com",
      "jane_doe+news@sub.example.co.uk",
      "user123@domain.io",
      "support.team@service-mail.org",
      "a.b-c_d%test@dept.company.travel",
      "firstname.lastname@university.edu",
      "alerts+prod@notify.example.tech",
      "sales@shop-online.net"
    ],
    "negativeContentExamples": [
      "john.doe@domain",
      "john@domain.c",
      "@example.com",
      "john.doe example.com",
      "john@exa mple.com",
      "john@domain.c_m",
      "john.doe@example,com",
      "john.doe@ex\u00e4mple.com"
    ],
    "positiveHeaderExamples": [
      "Email",
      "Email Address",
      "Contact Email",
      "Primary Email Address",
      "Customer Email",
      "User Email",
      "Account Email",
      "Work Email"
    ],
    "negativeHeaderExamples": [
      "Phone Number",
      "Name",
      "Website",
      "Contact Phone",
      "Postal Address",
      "Username",
      "URL",
      "Fax Number"
    ],
    "explanation": "This semantic type identifies email addresses in text fields and column values using a pattern that captures a username, an @ symbol, and a domain with a top-level domain. It is suitable for detecting customer contact emails, account emails, and similar identifiers across datasets.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:09.635984"
  },
  {
    "resultType": "generated",
    "semanticType": "COLOR.TEXT_NL",
    "description": "Dutch color names expressed as plain words (basic vocabulary) without numbers or symbols. Intended for single-token color names commonly used in Dutch (e.g., rood, blauw, groen) and closely related base hues.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "ROOD",
      "BLAUW",
      "GROEN",
      "GEEL",
      "ZWART",
      "WIT",
      "GRIJS",
      "BRUIN",
      "ORANJE",
      "PAARS",
      "ROZE",
      "BEIGE",
      "MAGENTA",
      "CYAAN",
      "TURKOOIS",
      "INDIGO",
      "ZILVER",
      "GOUD",
      "OKER",
      "OLIJF",
      "LILA",
      "FUCHSIA",
      "ANTRACIET",
      "AUBERGINE"
    ],
    "backout": "^[A-Z]{3,10}$",
    "confidenceThreshold": 97,
    "priority": 2660,
    "headerPatterns": [
      {
        "regExp": "(?i).*(primaire|basis).*kleurnaam.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Primaire Kleurnaam"
        ],
        "negativeExamples": [
          "Primaire Kleurcode"
        ]
      },
      {
        "regExp": "(?i).*(kleur).*naam.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Kleurnaam"
        ],
        "negativeExamples": [
          "Kleurcode"
        ]
      },
      {
        "regExp": "(?i).*(primaire).*kleur.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Primaire Kleur"
        ],
        "negativeExamples": [
          "Primaire Kleurcode"
        ]
      },
      {
        "regExp": "(?i).*hoofdkleur.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Hoofdkleur"
        ],
        "negativeExamples": [
          "Hoofdkleurcode"
        ]
      },
      {
        "regExp": "(?i).*(kleur).*(tekst|naam).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Kleur Tekst"
        ],
        "negativeExamples": [
          "Kleur Hex"
        ]
      },
      {
        "regExp": "(?i).*kleur.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Kleur"
        ],
        "negativeExamples": [
          "RGB"
        ]
      }
    ],
    "positiveContentExamples": [
      "rood",
      "blauw",
      "groen",
      "geel",
      "zwart",
      "wit",
      "grijs",
      "oranje"
    ],
    "negativeContentExamples": [
      "rood1",
      "lichtblauw",
      "#FF0000",
      "rood-",
      "gr1js",
      "groen_",
      "kleur",
      "olijf groen"
    ],
    "positiveHeaderExamples": [
      "Kleur",
      "Kleurnaam",
      "Primaire Kleur",
      "Kleur NL",
      "Kleur Tekst",
      "Basiskleurnaam",
      "Hoofdkleur",
      "Kleur Omschrijving"
    ],
    "negativeHeaderExamples": [
      "Kleurcode",
      "Hex Waarde",
      "RGB",
      "CMYK",
      "Kleur-ID",
      "Pantone",
      "Kleurnummer",
      "Color"
    ],
    "explanation": "This semantic type identifies basic Dutch color names represented as single words, excluding numeric codes, symbols, or multi-word/compound shades. It is suitable for columns storing human-readable color names in Dutch rather than technical color specifications.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:11.163495"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.LONGITUDE_DECIMAL",
    "description": "A numeric value representing longitude in decimal degrees, ranging from -180 to 180. Fractional parts are allowed, but 180 may only have zero decimals (e.g., 180, 180.0, 180.00).",
    "pluginType": "regex",
    "regexPattern": "\\b-?(180(\\.0+)?|1[0-7]\\d(\\.\\d+)?|\\d{1,2}(\\.\\d+)?)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 2730,
    "headerPatterns": [
      {
        "regExp": "(?i).*longitude.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Longitude"
        ],
        "negativeExamples": [
          "Latitude"
        ]
      },
      {
        "regExp": "(?i).*\\blong\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Long"
        ],
        "negativeExamples": [
          "Length"
        ]
      },
      {
        "regExp": "(?i).*x[ _-]*coordinate.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "X Coordinate"
        ],
        "negativeExamples": [
          "X Axis"
        ]
      },
      {
        "regExp": "(?i).*coordinate.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Coordinate"
        ],
        "negativeExamples": [
          "Location"
        ]
      }
    ],
    "positiveContentExamples": [
      "-73.985656",
      "0",
      "12.5",
      "179.9999",
      "-0.0001",
      "180",
      "-180.0",
      "150.25"
    ],
    "negativeContentExamples": [
      "180.0001",
      "-180.1",
      "200",
      "-200",
      "090.123",
      "1e3",
      "45\u00b0",
      "123W"
    ],
    "positiveHeaderExamples": [
      "Longitude",
      "Long",
      "X Coordinate",
      "Geo Longitude",
      "Lon",
      "Coordinate X",
      "Map Long"
    ],
    "negativeHeaderExamples": [
      "Latitude",
      "Address",
      "City",
      "Lat",
      "Length",
      "X Axis",
      "Geo Code",
      "Street"
    ],
    "explanation": "This semantic type captures decimal-degree longitude values, enforcing the valid numeric range [-180, 180] and allowing fractional parts, with 180 restricted to zero-only decimals. It is useful for geospatial datasets, mapping applications, and coordinate pairs where the X axis represents longitude.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:12.376217"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.EAN13",
    "description": "A numeric string of exactly thirteen consecutive digits representing an EAN-13 (including ISBN-13) code with a trailing checksum computed by the EAN weighting algorithm. Values must be uninterrupted digits with no spaces or separators.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{13}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 2550,
    "headerPatterns": [
      {
        "regExp": "(?i).*ean[-_ ]?13.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "EAN13"
        ],
        "negativeExamples": [
          "Product Name"
        ]
      },
      {
        "regExp": "(?i).*isbn[-_ ]?13.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISBN-13"
        ],
        "negativeExamples": [
          "UPC Code"
        ]
      },
      {
        "regExp": "(?i).*barcode.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Barcode"
        ],
        "negativeExamples": [
          "Price"
        ]
      },
      {
        "regExp": "(?i).*ean.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "EAN"
        ],
        "negativeExamples": [
          "Serial"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "5901234123457",
      "4006381333931",
      "9780306406157",
      "4901234567894",
      "5012345678900",
      "0001234567895",
      "3600029145002",
      "7312345678909"
    ],
    "negativeContentExamples": [
      "590123412345",
      "59012341234570",
      "978030640615X",
      "9780306406O57",
      "400638133393-1",
      "4901 234567894",
      "5012345678900A",
      "000123456789-5"
    ],
    "positiveHeaderExamples": [
      "EAN13",
      "Barcode",
      "ISBN-13",
      "EAN 13",
      "EAN_13",
      "ISBN13",
      "Product Barcode",
      "EAN"
    ],
    "negativeHeaderExamples": [
      "Product Name",
      "Price",
      "UPC Code",
      "SKU",
      "Order Number",
      "Serial",
      "QR Code",
      "Item Description"
    ],
    "explanation": "This semantic type detects EAN-13 identifiers, including ISBN-13, as a contiguous 13-digit token with a final check digit. It is suitable for classifying retail barcodes and book identifiers stored without separators. The pattern intentionally excludes values with spaces, hyphens, or embedded letters to reduce ambiguity with other numeric identifiers.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:13.340767"
  },
  {
    "resultType": "generated",
    "semanticType": "COLOR.TEXT_ES",
    "description": "A text string matching basic Spanish color vocabulary patterns, typically following the pattern ^[a-z]+$ with Spanish phonetic structure.",
    "pluginType": "regex",
    "regexPattern": "\\b[a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00fc\u00f1]{2,11}[aeiou\u00e1\u00e9\u00ed\u00f3\u00falnrs]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 2650,
    "headerPatterns": [
      {
        "regExp": "(?i).*nombre.*del.*color.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Nombre del Color"
        ],
        "negativeExamples": [
          "Valor Hexadecimal"
        ]
      },
      {
        "regExp": "(?i).*color.*primario.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Color Primario"
        ],
        "negativeExamples": [
          "C\u00f3digo de Color"
        ]
      },
      {
        "regExp": "(?i).*texto.*color.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Texto de Color"
        ],
        "negativeExamples": [
          "RGB"
        ]
      },
      {
        "regExp": "(?i).*col.*nombre.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "col_nombre"
        ],
        "negativeExamples": [
          "Modelo RGB"
        ]
      },
      {
        "regExp": "(?i).*color.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Color"
        ],
        "negativeExamples": [
          "RGB Valor"
        ]
      }
    ],
    "positiveContentExamples": [
      "rojo",
      "azul",
      "verde",
      "amarillo",
      "negro",
      "blanco",
      "marr\u00f3n",
      "violeta"
    ],
    "negativeContentExamples": [
      "Rojo",
      "azul-marino",
      "verde2",
      "negro.",
      "#000000",
      "rgb(0,0,0)",
      "marr\u00f3n claro",
      "AZUL"
    ],
    "positiveHeaderExamples": [
      "Color",
      "Nombre del Color",
      "Color Primario",
      "Nombre Color",
      "Texto de Color",
      "Descripci\u00f3n del Color",
      "Etiqueta Color",
      "Color Base"
    ],
    "negativeHeaderExamples": [
      "C\u00f3digo de Color",
      "Valor Hexadecimal",
      "RGB",
      "C\u00f3digo Hex",
      "Color ID",
      "CMYK",
      "Modelo RGB",
      "C\u00f3digo de Tono"
    ],
    "explanation": "This semantic type targets lowercase Spanish color names written as a single word, allowing common Spanish diacritics and ensuring natural endings typical of Spanish lexicon. It is intended to capture textual color labels in Spanish rather than coded representations such as hex, RGB, or CMYK.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:16.183215"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.UPC",
    "description": "A numeric string of exactly twelve consecutive digits representing a UPC-A value that includes a trailing check digit. Only digits are allowed with no spaces, hyphens, or other separators.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{12}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 2610,
    "headerPatterns": [
      {
        "regExp": "(?i).*upc.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "UPC Code"
        ],
        "negativeExamples": [
          "Product code"
        ]
      },
      {
        "regExp": "(?i).*upc.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "UPC Number"
        ],
        "negativeExamples": [
          "Customer number"
        ]
      },
      {
        "regExp": "(?i).*product.*upc.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Product UPC"
        ],
        "negativeExamples": [
          "Product ID"
        ]
      },
      {
        "regExp": "(?i).*bar.?code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Barcode"
        ],
        "negativeExamples": [
          "QR code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Item code"
        ],
        "negativeExamples": [
          "Item name"
        ]
      }
    ],
    "positiveContentExamples": [
      "012345678905",
      "036000291452",
      "123456789012",
      "042100005264",
      "639382000393",
      "725272730706",
      "043000322354",
      "681131090025"
    ],
    "negativeContentExamples": [
      "12345678901",
      "1234567890123",
      "1234 5678 9012",
      "123-456-789012",
      "12345678901A",
      "A123456789012",
      "01234567890",
      "\uff11\uff12\uff13\uff14\uff15\uff16\uff17\uff18\uff19\uff10\uff11\uff12"
    ],
    "positiveHeaderExamples": [
      "UPC",
      "Barcode",
      "UPC Code",
      "Product UPC",
      "UPC Number",
      "Item UPC",
      "Universal Product Code",
      "UPC12"
    ],
    "negativeHeaderExamples": [
      "Product Name",
      "Price",
      "Brand",
      "EAN",
      "SKU",
      "Serial Number",
      "GTIN",
      "ISBN"
    ],
    "explanation": "This semantic type targets UPC-A values stored as exactly 12 ASCII digits with no separators. It is suited for barcode fields where the value includes the check digit; the regex enforces length and digit-only constraints but does not compute or validate the checksum. The header patterns prioritize explicit UPC signals (e.g., 'UPC Code', 'Product UPC') and fall back to generic 'code' only as a last resort. Priority is set lower than national identity types to avoid conflicts, consistent with check-digit numeric categories.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:16.591230"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.ISIN",
    "description": "An alphanumeric string with a two-letter country prefix, followed by nine alphanumeric characters and a final check digit. Structure: CCXXXXXXXXXD where C are uppercase letters, X are uppercase letters or digits, and D is a single digit.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2}[A-Z0-9]{9}\\d\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 2580,
    "headerPatterns": [
      {
        "regExp": "(?i).*international.*securit.*identification.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "International Securities Identification Number"
        ],
        "negativeExamples": [
          "International Security ID"
        ]
      },
      {
        "regExp": "(?i).*security.*isin.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Security ISIN"
        ],
        "negativeExamples": [
          "Security ID"
        ]
      },
      {
        "regExp": "(?i).*international.*security.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "International Security ID"
        ],
        "negativeExamples": [
          "Company Name"
        ]
      },
      {
        "regExp": "(?i).*isin.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISIN"
        ],
        "negativeExamples": [
          "CUSIP"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISIN Code"
        ],
        "negativeExamples": [
          "Stock Price"
        ]
      }
    ],
    "positiveContentExamples": [
      "US1234567890",
      "GB00ABCD1234",
      "DE000A1BCDE5",
      "FR0A1B2C3D45",
      "JP9ABCDE1236",
      "AU1B2C3D4E58",
      "CAABC1234D70",
      "CH00XYZ78912"
    ],
    "negativeContentExamples": [
      "us1234567890",
      "US123456789A",
      "U11234567890",
      "GB12345678",
      "FR12345678901",
      "JP1234-67890",
      "CH12345678_90",
      "123456789012"
    ],
    "positiveHeaderExamples": [
      "ISIN",
      "Security ISIN",
      "International Security ID",
      "International Securities Identification Number",
      "ISIN Code",
      "ISIN Number"
    ],
    "negativeHeaderExamples": [
      "Company Name",
      "Ticker Symbol",
      "Stock Price",
      "CUSIP",
      "SEDOL",
      "Security ID"
    ],
    "explanation": "This semantic type identifies International Securities Identification Numbers (ISINs), which are 12-character identifiers consisting of a two-letter country code, nine alphanumeric characters, and a final check digit. It is useful for validating and classifying security identifiers in financial datasets, ensuring consistent recognition of ISIN-formatted values in columns labeled with ISIN-related terms.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:18.587003"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.ABA",
    "description": "A numeric string matching the pattern ^\\d{9}$ consisting of exactly nine consecutive digits with embedded checksum validation.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{9}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 2530,
    "headerPatterns": [
      {
        "regExp": "(?i).*aba.*routing.*number.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "ABA Routing Number"
        ],
        "negativeExamples": [
          "ABA Code"
        ]
      },
      {
        "regExp": "(?i).*routing.*transit.*number.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Routing Transit Number"
        ],
        "negativeExamples": [
          "Transit Account Number"
        ]
      },
      {
        "regExp": "(?i).*(aba|rtn).*(number|no|nbr|#).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ABA Number"
        ],
        "negativeExamples": [
          "Bank Name"
        ]
      },
      {
        "regExp": "(?i).*(aba|rtn).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "RTN"
        ],
        "negativeExamples": [
          "RTO"
        ]
      },
      {
        "regExp": "(?i).*routing.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Routing"
        ],
        "negativeExamples": [
          "Route ID"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Number"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "011000015",
      "021000021",
      "123456780",
      "876543212",
      "110000000",
      "314159265",
      "987654320",
      "042000013"
    ],
    "negativeContentExamples": [
      "123456781",
      "876543210",
      "021000022",
      "011000016",
      "12345678",
      "1234567890",
      "12345678A",
      "123-456-789"
    ],
    "positiveHeaderExamples": [
      "ABA Number",
      "Routing Number",
      "RTN",
      "ABA Routing Number",
      "Routing Transit Number",
      "Bank RTN",
      "ABA RTN",
      "Routing"
    ],
    "negativeHeaderExamples": [
      "Account Number",
      "Bank Name",
      "SWIFT Code",
      "Route Number",
      "Transit Time",
      "RTO",
      "IBAN",
      "Branch Name"
    ],
    "explanation": "This semantic type represents a 9-digit ABA routing transit number with checksum validation (3-7-1 weighted sum rule) and is used to identify US bank routing numbers. The value regex ensures exactly nine consecutive digits while the type logic should apply the check digit algorithm to confirm validity. Header patterns progress from very specific forms (e.g., ABA Routing Number) through common abbreviations (RTN) to the primitive term (number) to robustly capture real-world column naming variations while avoiding over-broad value matching.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:18.738676"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.LATITUDE_DECIMAL",
    "description": "A numeric value representing latitude coordinates in decimal degrees, in the inclusive range -90 to 90. An optional fractional part is allowed; values of 90 and -90 may only be followed by .0... to remain within bounds.",
    "pluginType": "regex",
    "regexPattern": "\\b-?(90(\\.0+)?|[0-8]?\\d(\\.\\d+)?)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 2710,
    "headerPatterns": [
      {
        "regExp": "(?i).*latitude.*decimal.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "latitude_decimal"
        ],
        "negativeExamples": [
          "longitude_decimal"
        ]
      },
      {
        "regExp": "(?i).*lat[_\\-\\s]*dd.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "lat_dd"
        ],
        "negativeExamples": [
          "lat_dms"
        ]
      },
      {
        "regExp": "(?i).*(y[_\\-\\s]*coordinate|coordinate[_\\-\\s]*y).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Y Coordinate"
        ],
        "negativeExamples": [
          "X Coordinate"
        ]
      },
      {
        "regExp": "(?i).*(latitude|\\blat\\b).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Lat"
        ],
        "negativeExamples": [
          "Long"
        ]
      },
      {
        "regExp": "(?i).*coordinate.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Coordinate"
        ],
        "negativeExamples": [
          "Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "0",
      "0.0",
      "12",
      "-45.123456",
      "89.9999",
      "-89.5",
      "90",
      "-90.0"
    ],
    "negativeContentExamples": [
      "90.0001",
      "-90.1",
      "91",
      "-100",
      "45.",
      "+45.0",
      "45.0N",
      "90."
    ],
    "positiveHeaderExamples": [
      "Latitude",
      "Lat",
      "Y Coordinate",
      "Latitude Decimal",
      "Lat DD",
      "Lat_deg",
      "Latitude (deg)",
      "Geo Latitude"
    ],
    "negativeHeaderExamples": [
      "Longitude",
      "Address",
      "City",
      "Longitude Decimal",
      "Lng",
      "X Coordinate",
      "Lon DD",
      "Geo Longitude"
    ],
    "explanation": "This semantic type identifies decimal-degree latitude values, constrained to the valid geographic range of -90 through 90 inclusive, with an optional fractional part. It is useful for validating and classifying fields containing latitude coordinates stored as numeric strings, ensuring out-of-range or non-decimal formats are excluded.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:19.219979"
  },
  {
    "resultType": "generated",
    "semanticType": "AIRLINE.TEXT_EN",
    "description": "A text string representing an airline\u2019s English name made of letters, spaces, and common punctuation (apostrophes, periods, hyphens, ampersands), typically ending with airline-specific suffixes such as Airlines, Airways, Airline, Air Lines, or Air. The preceding part must be alphabetic text and may include internal spaces and simple punctuation.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z][A-Za-z&' .-]{1,60}\\s+(Airlines|Airways|Airline|Air Lines|Air)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2510,
    "headerPatterns": [
      {
        "regExp": "(?i).*airline.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Airline Name"
        ],
        "negativeExamples": [
          "Airline Code"
        ]
      },
      {
        "regExp": "(?i).*carrier.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Carrier Name"
        ],
        "negativeExamples": [
          "Carrier Code"
        ]
      },
      {
        "regExp": "(?i).*airline.*company.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Airline Company"
        ],
        "negativeExamples": [
          "Aircraft Company"
        ]
      },
      {
        "regExp": "(?i).*(airline|carrier).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Primary Airline"
        ],
        "negativeExamples": [
          "Aircraft Type"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Air Carrier Name"
        ],
        "negativeExamples": [
          "Flight Number"
        ]
      }
    ],
    "positiveContentExamples": [
      "Pacifica Airlines",
      "Northern Sky Airways",
      "Meridian Air",
      "Continental Air",
      "Atlas Airways",
      "Horizon Airlines",
      "Summit Airways",
      "Sky & Sea Airlines"
    ],
    "negativeContentExamples": [
      "Airlines",
      "Sky-Airways",
      "360 Airlines",
      "SkyAirlines",
      "A\u00e9ro Airways",
      "123 Air",
      "BlueAir",
      "Air Lines"
    ],
    "positiveHeaderExamples": [
      "Airline Name",
      "Carrier Name",
      "Airline Company",
      "Air Carrier Name",
      "Operating Airline Name",
      "Marketing Carrier Name",
      "Primary Airline",
      "Preferred Airline Name"
    ],
    "negativeHeaderExamples": [
      "Airline Code",
      "Flight Number",
      "Aircraft Type",
      "Carrier Code",
      "Flight ID",
      "Aircraft Model",
      "Airport Name",
      "Tail Number"
    ],
    "explanation": "This semantic type targets English airline organization names that end with common airline suffixes (Airlines, Airways, Airline, Air Lines, or Air). It accepts letters and simple punctuation in the leading name segment and requires a space before the final suffix. It is intended for classifying columns containing airline names, not codes or identifiers, and is conservative to reduce false positives for unrelated company names.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:19.329772"
  },
  {
    "resultType": "generated",
    "semanticType": "CURRENCY.TEXT_EN",
    "description": "A text field containing currency names that follow standard English financial terminology with proper capitalization. Values are alphabetic words that represent established monetary units, optionally preceded by region or qualifier terms, written in English.",
    "pluginType": "regex",
    "regexPattern": "\\b(([A-Z]{2,4}|and|[A-Z][a-z]+(-[A-Z][a-z]+)?) ){0,4}[A-Z][a-z]+(-[A-Z][a-z]+)?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 2860,
    "headerPatterns": [
      {
        "regExp": "(?i).*(currency.*name|name.*currency).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Currency Name"
        ],
        "negativeExamples": [
          "Currency Code"
        ]
      },
      {
        "regExp": "(?i).*(currency.*text|text.*currency).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Currency Text"
        ],
        "negativeExamples": [
          "Currency"
        ]
      },
      {
        "regExp": "(?i).*(money.*name|name.*money).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Money Name"
        ],
        "negativeExamples": [
          "Money Market"
        ]
      },
      {
        "regExp": "(?i).*currency.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Currency"
        ],
        "negativeExamples": [
          "Exchange Rate"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Euro",
      "United States Dollar",
      "Japanese Yen",
      "British Pound Sterling",
      "Swiss Franc",
      "Brazilian Real",
      "South African Rand",
      "Trinidad and Tobago Dollar"
    ],
    "negativeContentExamples": [
      "USD",
      "EUR",
      "us dollar",
      "United States $ Dollar",
      "Trinidad & Tobago Dollar",
      "U.A.E. Dirham",
      "CFAFRANC",
      "Swiss franc"
    ],
    "positiveHeaderExamples": [
      "Currency",
      "Currency Name",
      "Money",
      "Currency Text",
      "Money Name",
      "Full Currency Name",
      "Official Currency",
      "Currency Description"
    ],
    "negativeHeaderExamples": [
      "Currency Code",
      "Exchange Rate",
      "Country",
      "Amount",
      "Price",
      "ISO Code",
      "Monetary Code",
      "Currency Symbol"
    ],
    "explanation": "This semantic type identifies strings that represent English currency names, written in proper title case and composed of alphabetic tokens. It accommodates regional qualifiers, common conjunctions like 'and', and leading acronyms such as 'UAE' or 'CFA' before the monetary unit name, while excluding currency codes, symbols, and malformed cases.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:22.330672"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.ISO-3166-2",
    "description": "A string of exactly two consecutive uppercase letters used for international country identification. This corresponds to the ISO alpha-2 country code format.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2780,
    "headerPatterns": [
      {
        "regExp": "(?i).*iso.*country.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISO Country Code"
        ],
        "negativeExamples": [
          "ISO Country Name"
        ]
      },
      {
        "regExp": "(?i).*iso.*country.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISO Country"
        ],
        "negativeExamples": [
          "ISO State"
        ]
      },
      {
        "regExp": "(?i).*(country|ctry).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Country Code"
        ],
        "negativeExamples": [
          "Country Name"
        ]
      },
      {
        "regExp": "(?i).*(country|ctry).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Country"
        ],
        "negativeExamples": [
          "State"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "US",
      "GB",
      "DE",
      "FR",
      "CN",
      "IN",
      "BR",
      "ZA"
    ],
    "negativeContentExamples": [
      "usa",
      "us",
      "U1",
      "1U",
      "US-CA",
      "GBR",
      "U.S.",
      "Ru"
    ],
    "positiveHeaderExamples": [
      "Country Code",
      "ISO Country",
      "Country",
      "ISO Country Code",
      "CTRY Code",
      "Country ISO2",
      "country_alpha2",
      "country_iso"
    ],
    "negativeHeaderExamples": [
      "Country Name",
      "State",
      "Language",
      "Province Code",
      "Alpha3 Code",
      "ISO Subdivision",
      "Country Numeric Code",
      "Region"
    ],
    "explanation": "This semantic type detects two-letter uppercase country identifiers in the ISO alpha-2 style. It is useful for standardizing and validating country code columns, especially when codes are provided as compact two-letter tokens rather than names.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:23.101091"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.LUHN",
    "description": "A numeric string following the pattern ^\\d+$ where the last digit validates the entire sequence using modulo-10 checksum calculation.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{10,19}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 2590,
    "headerPatterns": [
      {
        "regExp": "(?i).*(credit[ _]?card|debit[ _]?card|payment[ _]?card|pan|imei|luhn).*(number|no|num).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Credit Card Number"
        ],
        "negativeExamples": [
          "Cardholder Name"
        ]
      },
      {
        "regExp": "(?i).*(card).*(number|no|num).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Card Number"
        ],
        "negativeExamples": [
          "Card Type"
        ]
      },
      {
        "regExp": "(?i).*\\b(imei|pan|cc)\\b.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "IMEI"
        ],
        "negativeExamples": [
          "Expiration Date"
        ]
      },
      {
        "regExp": "(?i).*(primary).*(account).*(number|no|num).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Primary Account Number"
        ],
        "negativeExamples": [
          "Account Type"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Number"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "79927398713",
      "49927398716",
      "4242424242424242",
      "4012888888881881",
      "5555555555554444",
      "378282246310005",
      "3530111333300000",
      "490154203237518"
    ],
    "negativeContentExamples": [
      "79927398714",
      "49927398717",
      "4242424242424241",
      "4012888888881882",
      "5555555555554440",
      "378282246310006",
      "4242 4242 4242 4242",
      "490154203237517"
    ],
    "positiveHeaderExamples": [
      "Credit Card Number",
      "Card Number",
      "IMEI",
      "PAN",
      "Primary Account Number",
      "CC Number",
      "Payment Card Number",
      "IMEI Number"
    ],
    "negativeHeaderExamples": [
      "Card Type",
      "Cardholder Name",
      "Expiration Date",
      "Security Code",
      "Billing Zip",
      "Account Name",
      "Issuer",
      "Currency"
    ],
    "explanation": "Identifies digit-only strings of plausible length for Luhn-based identifiers (e.g., payment card PANs, IMEIs) and relies on a Luhn modulo-10 checksum to confirm validity. Use this type to flag, validate, or mask Luhn-governed account and device identifiers in datasets while avoiding false positives from arbitrary numeric fields.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:25.367378"
  },
  {
    "resultType": "generated",
    "semanticType": "GUID",
    "description": "A string matching the pattern ^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$ with specific hyphen placement for UUID format.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3020,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\b(uuid|guid)\\b.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "UUID"
        ],
        "negativeExamples": [
          "Unique ID"
        ]
      },
      {
        "regExp": "(?i).*\\b(unique|global)\\b.*\\b(id|identifier)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Unique Identifier"
        ],
        "negativeExamples": [
          "Customer ID"
        ]
      },
      {
        "regExp": "(?i).*\\b(record|entity|primary)\\b.*\\b(uuid|guid)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Record UUID"
        ],
        "negativeExamples": [
          "Record ID"
        ]
      },
      {
        "regExp": "(?i).*\\bidentifier\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Identifier"
        ],
        "negativeExamples": [
          "Identity"
        ]
      },
      {
        "regExp": "(?i).*\\bid\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "ID"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "123e4567-e89b-12d3-a456-426614174000",
      "f47ac10b-58cc-4372-a567-0e02b2c3d479",
      "550e8400-e29b-41d4-a716-446655440000",
      "3fa85f64-5717-4562-b3fc-2c963f66afa6",
      "d9428888-122b-11e1-b85c-61cd3cbb3210",
      "9b2e5a10-3c43-4df2-8558-a3c2b7c1b9f0",
      "a8098c1a-f86e-11da-bd1a-00112444be1e",
      "252b7f4e-3d1a-4c2a-8f2e-1a3b4c5d6e7f"
    ],
    "negativeContentExamples": [
      "123e4567-e89b-12d3-a456-42661417400",
      "123e4567e89b-12d3-a456-426614174000",
      "123e4567-e89b-12d3-a4567-426614174000",
      "123e4567-e89b-12d3-a456-4266141740000",
      "123e4567-e89b-12d3-a456-42661417400z",
      "{123e4567-e89b-12d3-a456-426614174000}",
      "123e4567-e89b-12d3a456-426614174000",
      "123e4567-e89b12d3-a456-426614174000"
    ],
    "positiveHeaderExamples": [
      "GUID",
      "UUID",
      "Unique ID",
      "Unique Identifier",
      "Global Unique ID",
      "Record UUID",
      "Primary GUID",
      "Entity ID"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Description",
      "Created Date",
      "Title",
      "Email",
      "Country",
      "Status",
      "Address"
    ],
    "explanation": "This semantic type identifies globally unique identifiers (GUID/UUID) consisting of hexadecimal characters with hyphens in the 8-4-4-4-12 layout. It is useful for detecting key columns and references where records are uniquely identified using UUIDs across systems.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:26.267012"
  },
  {
    "resultType": "generated",
    "semanticType": "FILENAME",
    "description": "A text field containing filenames that typically follow patterns like ^[\\w\\-. ]+\\.[a-zA-Z0-9]+$ with a base name, dot separator, and file extension. The format includes alphanumeric characters, hyphens, underscores, and spaces in the filename with a period-separated extension indicating file type.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z0-9][A-Za-z0-9 _.-]*\\.[A-Za-z0-9]{1,10}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2950,
    "headerPatterns": [
      {
        "regExp": "(?i).*(document|attachment|export)[_ -]*file[_ -]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Document File Name"
        ],
        "negativeExamples": [
          "Document Name"
        ]
      },
      {
        "regExp": "(?i).*file[_ -]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "File Name"
        ],
        "negativeExamples": [
          "File Path"
        ]
      },
      {
        "regExp": "(?i).*filename.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Filename"
        ],
        "negativeExamples": [
          "Folder"
        ]
      },
      {
        "regExp": "(?i).*(doc[_ -]*name|fname|file[_ -]*nm).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fname"
        ],
        "negativeExamples": [
          "Extension"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Document Name"
        ],
        "negativeExamples": [
          "Extension"
        ]
      }
    ],
    "positiveContentExamples": [
      "report-2024-06.csv",
      "Invoice_12345.pdf",
      "presentation final.pptx",
      "archive.tar.gz",
      "data_01.json",
      "README.md",
      "photo-IMG_3456.JPG",
      "budget Q3.xlsx"
    ],
    "negativeContentExamples": [
      ".gitignore",
      "report",
      "report.",
      "Q1/Report.pdf",
      "invoice pdf",
      "file@name.txt",
      "summary,txt",
      "project:plan.docx"
    ],
    "positiveHeaderExamples": [
      "Filename",
      "File Name",
      "Document Name",
      "Attachment File Name",
      "Export Filename",
      "Report File Name"
    ],
    "negativeHeaderExamples": [
      "File Path",
      "Folder",
      "Extension",
      "Directory",
      "Mime Type",
      "Document Type"
    ],
    "explanation": "This semantic type detects standalone filenames composed of an ASCII base name followed by a dot and an alphanumeric extension. It supports spaces, underscores, hyphens, and additional dots in the base name while excluding paths, URLs, and names without extensions. Typical uses include identifying document or attachment filename fields in datasets.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:26.444456"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.TEXT_NL",
    "description": "A text field containing Dutch country names that follow proper Dutch linguistic patterns and use appropriate capitalization. The format consists of alphabetic characters representing established country designations as commonly used in Dutch-speaking contexts and official documentation.",
    "pluginType": "regex",
    "regexPattern": "\\b((Verenigd|Verenigde|Democratische|Federale|Koninkrijk|Republiek|Emiraten)([ -][A-Z\u00c0-\u00d6\u00d8-\u00de][a-z\u00e0-\u00f6\u00f8-\u00ff]+){1,3}|(Bosni\u00eb[ -]en[ -]Herzegovina|Papoea[ -]Nieuw[ -]Guinea|Zuid[ -]Afrika|Sao Tom\u00e9[ -]en[ -]Principe|Verenigde[ -]Staten|Verenigd[ -]Koninkrijk|Oost[ -]Timor|Trinidad[ -]en[ -]Tobago|Antigua[ -]en[ -]Barbuda)|(Nederland|Belgi\u00eb|Duitsland|Frankrijk|Spanje|Itali\u00eb|Portugal|Zweden|Noorwegen|Finland|Denemarken|Polen|Ierland|IJsland|Zwitserland|Oostenrijk|Griekenland|Canada|Mexico|Brazili\u00eb|Argentini\u00eb|China|Japan|India|Rusland|Tsjechi\u00eb|Suriname))\\b",
    "regexPatternFlags": null,
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 2830,
    "headerPatterns": [
      {
        "regExp": "(?i).*(country|land)[ _-]*(name|naam).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Landnaam"
        ],
        "negativeExamples": [
          "Landcode"
        ]
      },
      {
        "regExp": "(?i).*(country|land|natie|nation).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Land"
        ],
        "negativeExamples": [
          "Provincie"
        ]
      },
      {
        "regExp": "(?i).*(ctry|ctr)[ _-]*(name|naam).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ctry_name"
        ],
        "negativeExamples": [
          "city"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "country_name"
        ],
        "negativeExamples": [
          "Landcode"
        ]
      }
    ],
    "positiveContentExamples": [
      "Nederland",
      "Belgi\u00eb",
      "Duitsland",
      "Frankrijk",
      "Verenigd Koninkrijk",
      "Verenigde Staten",
      "Bosni\u00eb en Herzegovina",
      "Tsjechi\u00eb"
    ],
    "negativeContentExamples": [
      "nederland",
      "DE",
      "VerenigdKoninkrijk",
      "Verenigd koninkrijk",
      "Parijs",
      "Provincie Noord-Holland",
      "Bosni\u00eb & Herzegovina",
      "tsjechi\u00eb"
    ],
    "positiveHeaderExamples": [
      "Land",
      "Landnaam",
      "Natie",
      "country_name",
      "ctry_name",
      "Nation"
    ],
    "negativeHeaderExamples": [
      "Landcode",
      "Provincie",
      "Stad",
      "country_code",
      "state",
      "city",
      "regio",
      "land_id"
    ],
    "explanation": "This semantic type identifies values that are Dutch-language country names with correct capitalization and common multi-word constructions (e.g., 'Verenigde Staten', 'Bosni\u00eb en Herzegovina'). It avoids codes and abbreviations, focusing on human-readable, official-style country designations typically seen in Dutch datasets and documents. The pattern includes common multi-word structures and a representative set of single-word country names to balance precision with coverage; header patterns help disambiguate from other geographic entities.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:27.096104"
  },
  {
    "resultType": "generated",
    "semanticType": "COMPANY_NAME",
    "description": "A text string containing letters, spaces, and punctuation marks representing proper corporate names with legal entity suffixes.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b[A-Za-z0-9][A-Za-z0-9&'.,\\-() ]{1,100}\\s+(Co|Co\\.|Co Ltd|Co\\. Ltd\\.|Corporation|Corp|Corp\\.|Incorporated|Inc|Inc\\.|Limited|Ltd|Ltd\\.|LLC|LLP|PLC|GmbH|AG|BV|NV|B\\.V\\.|N\\.V\\.|S\\.A\\.|SAS|S\\.A\\.S\\.|Pte Ltd|Pty Ltd|K\\.K\\.|Oy|AB|AS|SRL|S\\.r\\.l\\.)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2670,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\b(company|corporate|business)\\b.*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Company Name"
        ],
        "negativeExamples": [
          "Company Code"
        ]
      },
      {
        "regExp": "(?i).*\\b(organization|organisation)\\b.*\\bname\\b.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Organization Name"
        ],
        "negativeExamples": [
          "Organization Code"
        ]
      },
      {
        "regExp": "(?i).*\\b(co|corp|org|inc|ltd|plc|llc|llp)\\b.*\\bname\\b.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Corp Name"
        ],
        "negativeExamples": [
          "Corp Number"
        ]
      },
      {
        "regExp": "(?i).*\\b(company|organization|organisation|corporation|business|firm)\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Corporation"
        ],
        "negativeExamples": [
          "Employee Count"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Acme, Inc.",
      "Global Tech LLC",
      "Northern Lights Ltd.",
      "Blue River Corporation",
      "Sunrise Co. Ltd",
      "Atlas GmbH",
      "Pacific Ventures Pte Ltd",
      "Summit Foods Corp."
    ],
    "negativeContentExamples": [
      "Acme Incorporated Division",
      "Global Tech Holdings",
      "Northern Lights Limited Partnership",
      "Blue River Corporate",
      "Atlas GMB",
      "Pacific Ventures Pte Limited",
      "Orion A.G.",
      "Summit Foods LLC Dept."
    ],
    "positiveHeaderExamples": [
      "Company Name",
      "Organization",
      "Corporation",
      "Corp Name",
      "Business Name",
      "Legal Entity Name",
      "Supplier Name"
    ],
    "negativeHeaderExamples": [
      "Stock Symbol",
      "Industry",
      "Employee Count",
      "Company Code",
      "Org ID",
      "Corporation Number",
      "Ticker",
      "Registration Code"
    ],
    "explanation": "This semantic type identifies company or organization names that include a legal entity designator (e.g., Inc., LLC, Ltd, Corp, GmbH). It expects a readable name portion followed by a recognized suffix token and accommodates common punctuation found in corporate names. It is useful for distinguishing canonical company name fields from other identifiers such as codes or numeric IDs.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:28.341206"
  },
  {
    "resultType": "generated",
    "semanticType": "GENDER.TEXT_JA",
    "description": "A text field containing Japanese gender terms that follow standard Japanese linguistic patterns using hiragana, katakana, or kanji characters. The format represents established gender classification terminology as commonly used in Japanese demographic and official documentation contexts.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "\u7537\u6027",
      "\u5973\u6027",
      "\u7537",
      "\u5973",
      "\u305d\u306e\u4ed6",
      "\u4e0d\u660e",
      "\u7121\u56de\u7b54",
      "\u672a\u56de\u7b54",
      "\u4e0d\u8a73",
      "\u8a72\u5f53\u306a\u3057",
      "\u4e2d\u6027",
      "\u4e21\u6027",
      "\u30ce\u30f3\u30d0\u30a4\u30ca\u30ea\u30fc",
      "\u30b8\u30a7\u30f3\u30c0\u30fc\u30ec\u30b9",
      "\u30c8\u30e9\u30f3\u30b9\u30b8\u30a7\u30f3\u30c0\u30fc",
      "\u30a2\u30b8\u30a7\u30f3\u30c0\u30fc",
      "\u30b8\u30a7\u30f3\u30c0\u30fc\u30d5\u30eb\u30a4\u30c9",
      "X",
      "FTM",
      "MTF"
    ],
    "backout": "^[A-Z\u0000-\u0000\u0000-\u0000\u0000-\u0000\u0000-\u0000\u0000-\u0000\u0000-\u0000\u0000-\u0000\u0000-\u0000\u0000-\u0000\u0000-\u0000\u0000-\u0000\u0000-\u0000\u0000-\u0000\u0000-\u0000\u0000-\u0000\u0000-\u0000\u0000-\u0000\u0000-\u0000\u0000-\u0000\u0000-\u0000\u0000-\u0000\u0000-\u0000\u0000-\u0000\u0000-\u0000]{1,12}$",
    "confidenceThreshold": 94,
    "priority": 3000,
    "headerPatterns": [
      {
        "regExp": "(?i).*(\u6027\u5225|\u30b8\u30a7\u30f3\u30c0\u30fc).*(\u533a\u5206|\u5206\u985e|\u7a2e\u5225|\u30bf\u30a4\u30d7).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u6027\u5225\u533a\u5206"
        ],
        "negativeExamples": [
          "\u56fd\u7c4d\u533a\u5206"
        ]
      },
      {
        "regExp": "(?i).*(\u6027\u5225).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u6027\u5225"
        ],
        "negativeExamples": [
          "\u540d\u524d"
        ]
      },
      {
        "regExp": "(?i).*(\u30b8\u30a7\u30f3\u30c0\u30fc).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u30b8\u30a7\u30f3\u30c0\u30fc"
        ],
        "negativeExamples": [
          "\u5e74\u9f62"
        ]
      },
      {
        "regExp": "(?i).*(sex).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "sex"
        ],
        "negativeExamples": [
          "\u56fd\u7c4d"
        ]
      },
      {
        "regExp": "(?i).*(\u6027).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u6027"
        ],
        "negativeExamples": [
          "\u540d\u524d"
        ]
      }
    ],
    "positiveContentExamples": [
      "\u7537\u6027",
      "\u5973\u6027",
      "\u7537",
      "\u5973",
      "\u305d\u306e\u4ed6",
      "\u4e0d\u660e",
      "\u7121\u56de\u7b54",
      "\u672a\u56de\u7b54"
    ],
    "negativeContentExamples": [
      "\u7537\u306e\u5b50",
      "\u5973\u306e\u5b50",
      "\u5973\u60271",
      "\u7537\u6027(\u65e2\u5a5a)",
      "\u6027",
      "\u30b8\u30a7\u30f3\u30c0\u30fcID",
      "\u672a\u8a2d\u5b9a",
      "\u7537/\u5973"
    ],
    "positiveHeaderExamples": [
      "\u6027\u5225",
      "\u30b8\u30a7\u30f3\u30c0\u30fc",
      "\u6027",
      "\u6027\u5225\u533a\u5206",
      "\u6027\u5225\u5206\u985e",
      "\u6027\u5225\u7a2e\u5225",
      "\u6027\u5225\u30bf\u30a4\u30d7"
    ],
    "negativeHeaderExamples": [
      "\u540d\u524d",
      "\u5e74\u9f62",
      "\u56fd\u7c4d",
      "\u6027\u683c",
      "\u59d3",
      "\u6027\u80fd",
      "\u751f\u6210\u65e5"
    ],
    "explanation": "This semantic type captures common Japanese gender indicators used in datasets, particularly those employing kanji, hiragana, katakana, or concise Latin abbreviations such as FTM/MTF and X for self-described identifiers. It is appropriate for columns labeled with gender-related terms and for values representing male, female, other, unknown, or broader gender identity categories.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:30.522462"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE_PAIR.DECIMAL",
    "description": "A string representing a latitude and longitude in decimal degrees separated by a comma, allowing optional leading minus signs and optional fractional parts. The first value is one or two digits with optional decimal fraction; the second value is optionally prefixed by a single '1' followed by one or two digits, also with optional decimal fraction.",
    "pluginType": "regex",
    "regexPattern": "-?\\d{1,2}(\\.\\d+)?,\\s*-?1?\\d{1,2}(\\.\\d+)?",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 2760,
    "headerPatterns": [
      {
        "regExp": "(?i).*gps.*coordinate.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "GPS Coordinates"
        ],
        "negativeExamples": [
          "GPS Device"
        ]
      },
      {
        "regExp": "(?i).*lat.*[\\s,/_-]+.*long.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Lat Long"
        ],
        "negativeExamples": [
          "Longitude"
        ]
      },
      {
        "regExp": "(?i).*latitude.*longitude.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Latitude Longitude"
        ],
        "negativeExamples": [
          "Latitude"
        ]
      },
      {
        "regExp": "(?i).*coordinate.*pair.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Coordinate Pair"
        ],
        "negativeExamples": [
          "Coordinate System"
        ]
      },
      {
        "regExp": "(?i).*coordinate.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Coordinates"
        ],
        "negativeExamples": [
          "Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "40.7128,-74.0060",
      "-33.8688,151.2093",
      "12.5, -98.75",
      "0,0",
      "-7.5, 179.999",
      "45, -120",
      "89.999, 179.5",
      "9, -10.25"
    ],
    "negativeContentExamples": [
      "40.7128 -74.0060",
      "40.7128; -74.0060",
      "40.7128|-74.0060",
      "40.7128 / -74.0060",
      "N40.7128, W74.0060",
      "45.0, 281.0",
      "40.7128,- 74.0060",
      "40.7128,-074.0060"
    ],
    "positiveHeaderExamples": [
      "Coordinates",
      "Lat Long",
      "GPS Coordinates",
      "Latitude Longitude",
      "Lat/Long",
      "Coordinate Pair",
      "Geo Coordinates",
      "GPS Lat Long"
    ],
    "negativeHeaderExamples": [
      "Latitude",
      "Longitude",
      "Address",
      "Location",
      "GeoHash",
      "Postal Code",
      "Coordinate System",
      "City"
    ],
    "explanation": "This semantic type identifies decimal latitude-longitude coordinate pairs separated by a comma, optionally including spaces, negative signs, and fractional parts. It targets general GPS-like coordinate text fields without directional letters or alternative separators. Typical use cases include geospatial datasets where positions are stored as a single string field in decimal degrees.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:30.992844"
  },
  {
    "resultType": "generated",
    "semanticType": "FULL_ADDRESS_EN",
    "description": "A text field containing complete US-style mailing addresses in a consistent order: street number and street name with a street type, optional unit, followed by city, two-letter state code, and a 5-digit ZIP or ZIP+4, typically separated by commas.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{1,6}\\s+((N|S|E|W|NE|NW|SE|SW)\\s+)?[A-Za-z0-9.'-]{2,}(\\s+[A-Za-z0-9.'-]{2,}){0,3}\\s+(Ave|Avenue|St|Street|Rd|Road|Blvd|Boulevard|Ln|Lane|Dr|Drive|Ct|Court|Pl|Place|Pkwy|Parkway|Ter|Terrace|Hwy|Highway|Way|Loop)\\b(\\s+(N|S|E|W|NE|NW|SE|SW))?(\\s+(Apt|Unit|Suite|Ste|Fl|Floor|Bldg)\\s*[A-Za-z0-9-]{1,6})?,\\s+[A-Za-z .'-]{2,30},\\s+[A-Z]{2}\\s+\\d{5}(-\\d{4})?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 2980,
    "headerPatterns": [
      {
        "regExp": "(?i).*(full|complete).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Full Address"
        ],
        "negativeExamples": [
          "Street Address"
        ]
      },
      {
        "regExp": "(?i).*(mailing|postal).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Mailing Address"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      },
      {
        "regExp": "(?i).*(recipient|delivery).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Delivery Address"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*mail.*addr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mail_addr"
        ],
        "negativeExamples": [
          "Street Address"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address"
        ],
        "negativeExamples": [
          "City"
        ]
      }
    ],
    "positiveContentExamples": [
      "742 Evergreen Terrace, Springfield, IL 62704",
      "1600 Pennsylvania Ave NW, Washington, DC 20500",
      "350 Fifth Avenue, New York, NY 10118",
      "1 Infinite Loop, Cupertino, CA 95014",
      "600 Montgomery St, San Francisco, CA 94111",
      "123 Elm Street Apt 4B, Denver, CO 80203",
      "500 S Buena Vista St, Burbank, CA 91521",
      "455 Massachusetts Ave, Cambridge, MA 02139"
    ],
    "negativeContentExamples": [
      "742 Evergreen Terrace Springfield IL 62704",
      "Evergreen Terrace, Springfield, IL 62704",
      "742 Evergreen Terrace, IL 62704",
      "742 Evergreen Terrace, Springfield, Illinois 62704",
      "742 Evergreen Terrace, Springfield, IL",
      "742 Evergreen Terrace, Springfield, IL 6270",
      "PO Box 123, Springfield, IL 62704",
      "123 Main St"
    ],
    "positiveHeaderExamples": [
      "Full Address",
      "Mailing Address",
      "Complete Address",
      "Recipient Address",
      "Delivery Address",
      "Full Mailing Address",
      "Shipping Address",
      "Address"
    ],
    "negativeHeaderExamples": [
      "Street Address",
      "City",
      "ZIP Code",
      "Address Line 1",
      "Postal Code",
      "State",
      "Billing Zip",
      "City_State"
    ],
    "explanation": "This semantic type targets complete US mailing addresses formatted with street number and name, a recognized street type, optional unit, then city, state code, and ZIP or ZIP+4, with comma separators. It is useful for validating and classifying full address fields intended for mailing or geocoding where all key components are present in a single string.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:31.923091"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.SEDOL",
    "description": "An alphanumeric security identifier consisting of six uppercase letters/digits followed by a single numeric check digit. The overall token length is 7 characters, with the final character always a digit.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9A-Z]{6}[0-9]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2600,
    "headerPatterns": [
      {
        "regExp": "(?i).*sedol.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SEDOL Code"
        ],
        "negativeExamples": [
          "Company Code"
        ]
      },
      {
        "regExp": "(?i).*uk.*security.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "UK Security ID"
        ],
        "negativeExamples": [
          "Security ID (US)"
        ]
      },
      {
        "regExp": "(?i).*primary.*sedol.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Primary SEDOL"
        ],
        "negativeExamples": [
          "Primary ISIN"
        ]
      },
      {
        "regExp": "(?i).*sedol.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SEDOL"
        ],
        "negativeExamples": [
          "CUSIP"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "B0YBKJ7",
      "0263494",
      "2000019",
      "BF0ZP04",
      "A1B2C33",
      "ZZZZZZ0",
      "H4K2M35",
      "G3L5NN2"
    ],
    "negativeContentExamples": [
      "b0ybkj7",
      "B0YBKJX",
      "B0YBKJ77",
      "B0YBKJ",
      "B0YB KJ7",
      "B0YBKJ-7",
      "AB12C3D",
      "12AB34"
    ],
    "positiveHeaderExamples": [
      "SEDOL",
      "SEDOL Code",
      "UK Security ID",
      "Primary SEDOL",
      "SEDOL Number",
      "Security Identifier (SEDOL)",
      "UK SEDOL",
      "SEDOL Ref"
    ],
    "negativeHeaderExamples": [
      "Company Name",
      "Stock Price",
      "Exchange",
      "ISIN Code",
      "CUSIP",
      "Ticker",
      "Security Name",
      "Account Code"
    ],
    "explanation": "This semantic type identifies SEDOL-style security identifiers: a single 7-character token where the first six are uppercase alphanumeric and the final character is a numeric check digit. It is useful for extracting or validating UK/SEDOL security identifiers from mixed datasets, distinguishing them from other security codes by their strict 6+1 structure.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:36.148588"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.DUNS",
    "description": "A business identification number consisting of exactly nine consecutive numerical digits (0\u20139) with no separators or additional characters. The value is strictly nine digits long and contains digits only.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{9}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3090,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bd[-_ ]?u[-_ ]?n[-_ ]?s\\b.*\\bnumber\\b.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "DUNS Number"
        ],
        "negativeExamples": [
          "Customer Number"
        ]
      },
      {
        "regExp": "(?i).*\\bd[-_ ]?u[-_ ]?n[-_ ]?s\\b.*\\bid\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "DUNS ID"
        ],
        "negativeExamples": [
          "Vendor ID"
        ]
      },
      {
        "regExp": "(?i).*\\bd[-_ ]?u[-_ ]?n[-_ ]?s\\b.*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "DUNS Code"
        ],
        "negativeExamples": [
          "Account Code"
        ]
      },
      {
        "regExp": "(?i).*\\bd[-_ ]?u[-_ ]?n[-_ ]?s\\b.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "D-U-N-S"
        ],
        "negativeExamples": [
          "Industry"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "123456789",
      "000123456",
      "555000777",
      "987654321",
      "010203040",
      "765432109",
      "100200300",
      "999999999"
    ],
    "negativeContentExamples": [
      "12345678",
      "1234567890",
      "123-456-789",
      "123 456 789",
      "123456789A",
      "A123456789",
      "DUNS123456789",
      "0012345678"
    ],
    "positiveHeaderExamples": [
      "DUNS Number",
      "DUNS",
      "D-U-N-S",
      "DUNS ID",
      "DUNS No",
      "DUNS Code",
      "DUNS Identifier"
    ],
    "negativeHeaderExamples": [
      "Company Name",
      "Industry",
      "Revenue",
      "Tax ID",
      "Customer Number",
      "Account Code",
      "Vendor ID"
    ],
    "explanation": "This semantic type identifies DUNS (Data Universal Numbering System) identifiers: exactly nine digits with no separators or prefixes. It is suitable for validating and classifying columns that store DUNS numbers in raw numeric form and for distinguishing them from other organization identifiers.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:37.149977"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.NHS_UK",
    "description": "A healthcare identifier that follows the pattern of exactly ten numerical digits. The format often displays with spaces in a 3-3-4 digit grouping for readability but the core pattern remains ten consecutive digits.",
    "pluginType": "regex",
    "regexPattern": "\\b(\\d{10}|\\d{3}\\s\\d{3}\\s\\d{4})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 3120,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bnhs\\b.*\\b(number|no|id)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "NHS Number"
        ],
        "negativeExamples": [
          "Name"
        ]
      },
      {
        "regExp": "(?i).*\\bhealth\\b.*\\b(number|id)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Health Number"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*\\bnhs\\b.*\\b(no|num)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "NHS No"
        ],
        "negativeExamples": [
          "Date of Birth"
        ]
      },
      {
        "regExp": "(?i).*\\bnumber\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Number"
        ],
        "negativeExamples": [
          "Date of Birth"
        ]
      }
    ],
    "positiveContentExamples": [
      "9434765919",
      "943 476 5919",
      "1234567890",
      "000 123 4567",
      "987 654 3210",
      "0123456789",
      "321 654 0987",
      "6501234567"
    ],
    "negativeContentExamples": [
      "123456789",
      "12345678901",
      "123-456-7890",
      "123 4567 890",
      "1234 567 890",
      "123 45 67890",
      "123456789O",
      "A1234567890"
    ],
    "positiveHeaderExamples": [
      "NHS Number",
      "NHS ID",
      "Health Number",
      "NHS No",
      "UK NHS Number",
      "Patient NHS Number",
      "National Health Number"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Address",
      "Date of Birth",
      "Phone Number",
      "Account Number",
      "Medical Record Number",
      "Insurance Number"
    ],
    "explanation": "IDENTITY.NHS_UK represents the United Kingdom NHS Number format used to uniquely identify patients. It matches either a contiguous 10-digit string or a 3-3-4 digit grouping separated by single spaces. This type is useful for detecting and validating UK healthcare identifiers in datasets where NHS numbers are recorded.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:37.481293"
  },
  {
    "resultType": "generated",
    "semanticType": "HONORIFIC_EN",
    "description": "A text field containing English honorific titles that typically follow established patterns for formal address, with optional periods where appropriate. Includes common traditional and professional prefixes used in formal correspondence and official documents.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(Mr|Mrs|Ms|Miss|Mx|Master|Madam|Doctor|Dr|Professor|Prof|Sir|Dame|Lord|Lady|Reverend|Rev|Captain|Capt|Colonel|Col|General|Gen|Lieutenant|Lt|Major|Maj|Sergeant|Sgt|Corporal|Cpl|Admiral|Adm|Ambassador|Amb|Senator|Sen|Representative|Rep|Governor|Gov|President|Pres)\\.\\b|(?i)\\b(Mr|Mrs|Ms|Miss|Mx|Master|Madam|Doctor|Dr|Professor|Prof|Sir|Dame|Lord|Lady|Reverend|Rev|Captain|Capt|Colonel|Col|General|Gen|Lieutenant|Lt|Major|Maj|Sergeant|Sgt|Corporal|Cpl|Admiral|Adm|Ambassador|Amb|Senator|Sen|Representative|Rep|Governor|Gov|President|Pres)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 3050,
    "headerPatterns": [
      {
        "regExp": "(?i).*honorific.*title.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Honorific Title"
        ],
        "negativeExamples": [
          "Job Title"
        ]
      },
      {
        "regExp": "(?i).*(name|person).*(prefix|title).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name Prefix"
        ],
        "negativeExamples": [
          "Person Suffix"
        ]
      },
      {
        "regExp": "(?i).*honou?rific.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Honorific"
        ],
        "negativeExamples": [
          "Honoraria"
        ]
      },
      {
        "regExp": "(?i).*prefix.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Prefix"
        ],
        "negativeExamples": [
          "Suffix"
        ]
      },
      {
        "regExp": "(?i).*title.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Title"
        ],
        "negativeExamples": [
          "Page Title"
        ]
      }
    ],
    "positiveContentExamples": [
      "Mr.",
      "Mrs.",
      "Ms.",
      "Miss",
      "Mx.",
      "Dr.",
      "Prof.",
      "Sir"
    ],
    "negativeContentExamples": [
      "Mrr.",
      "Mrs-",
      "Ms;",
      "Misses",
      "Mix.",
      "Drs.",
      "Mister",
      "Proff."
    ],
    "positiveHeaderExamples": [
      "Title",
      "Honorific",
      "Prefix",
      "Honorific Title",
      "Name Prefix",
      "Person Title",
      "Formal Title",
      "Title Prefix"
    ],
    "negativeHeaderExamples": [
      "First Name",
      "Last Name",
      "Full Name",
      "Job Title",
      "Suffix",
      "Page Title",
      "Middle Name",
      "Given Name"
    ],
    "explanation": "This semantic type identifies English honorific prefixes used before personal names in formal and professional contexts (e.g., Mr., Dr., Prof., Sir). It is useful for normalizing, validating, or extracting title fields separate from given/family names in contact, directory, and identity datasets.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:38.662371"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.NPI_US",
    "description": "A healthcare provider identifier that follows the exact pattern ^\\d{10}$ consisting of ten consecutive numerical digits. The format is regulated by CMS and includes a built-in checksum algorithm for validation purposes.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{10}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3140,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bnpi\\b.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "NPI Number"
        ],
        "negativeExamples": [
          "Provider Number"
        ]
      },
      {
        "regExp": "(?i).*\\bnpi\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "NPI"
        ],
        "negativeExamples": [
          "API Key"
        ]
      },
      {
        "regExp": "(?i).*provider.*\\bid\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Provider ID"
        ],
        "negativeExamples": [
          "Provider Name"
        ]
      },
      {
        "regExp": "(?i).*prov.*\\bid\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Prov ID"
        ],
        "negativeExamples": [
          "Prov Name"
        ]
      },
      {
        "regExp": "(?i).*identifier.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Provider Identifier"
        ],
        "negativeExamples": [
          "Index"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Number"
        ]
      }
    ],
    "positiveContentExamples": [
      "1234567893",
      "5478291036",
      "0098765432",
      "8301257694",
      "2719453806",
      "6654432210",
      "4029183756",
      "1102983475"
    ],
    "negativeContentExamples": [
      "123456789",
      "12345678901",
      "123-456-7890",
      "12345 67890",
      "12345678O0",
      "O123456789",
      "1234567 890",
      "00000000000"
    ],
    "positiveHeaderExamples": [
      "NPI",
      "Provider ID",
      "NPI Number",
      "Provider Number",
      "Prov ID",
      "NPI ID",
      "Provider Identifier"
    ],
    "negativeHeaderExamples": [
      "Provider Name",
      "Specialty",
      "Address",
      "Phone Number",
      "Taxonomy",
      "Enrollment Status",
      "Department"
    ],
    "explanation": "This semantic type identifies U.S. National Provider Identifier (NPI) values used to uniquely identify healthcare providers. Values are exactly ten consecutive digits and typically incorporate an internal checksum as defined by CMS. Use this type to validate and detect NPI fields in provider datasets and claims data where the value appears as a contiguous 10-digit number.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:38.771991"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.TEXT_DE",
    "description": "A text string containing German letters, spaces, and diacritical marks representing proper country names in German language.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z\u00c4\u00d6\u00dc][A-Za-z\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff.]*([ '-][A-Za-z\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff.]+){0,4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 2800,
    "headerPatterns": [
      {
        "regExp": "(?i).*(l\u00e4ndername|staatsname|herkunftsland).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "L\u00e4ndername"
        ],
        "negativeExamples": [
          "L\u00e4ndercode"
        ]
      },
      {
        "regExp": "(?i).*(land|staat).*(bezeichnung|text).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Landbezeichnung"
        ],
        "negativeExamples": [
          "Landescode"
        ]
      },
      {
        "regExp": "(?i).*(l\u00e4nder|staaten).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "L\u00e4nder"
        ],
        "negativeExamples": [
          "L\u00e4ndercode"
        ]
      },
      {
        "regExp": "(?i).*(land|staat).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Staat"
        ],
        "negativeExamples": [
          "Stadt"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Deutschland",
      "\u00d6sterreich",
      "Schweiz",
      "Vereinigte Staaten",
      "Vereinigtes K\u00f6nigreich",
      "Elfenbeink\u00fcste",
      "S\u00e3o Tom\u00e9 und Pr\u00edncipe",
      "Bosnien und Herzegowina"
    ],
    "negativeContentExamples": [
      "deutschland",
      "\u00d6sterreich1",
      "Schweiz-",
      "S\u00e3o Tom\u00e9 & Pr\u00edncipe",
      "Vereinigte Staaten (USA)",
      "Deutschland/\u00d6sterreich",
      "Vereinigtes K\u00f6nigreich: Wales",
      "Kongo, Demokratische Republik"
    ],
    "positiveHeaderExamples": [
      "Land",
      "Staat",
      "L\u00e4nder",
      "L\u00e4ndername",
      "Landbezeichnung",
      "Staatsname",
      "Herkunftsland",
      "Staaten"
    ],
    "negativeHeaderExamples": [
      "L\u00e4ndercode",
      "Stadt",
      "Sprache",
      "Bundesland",
      "L\u00e4nder-ISO",
      "W\u00e4hrung",
      "Kontinent",
      "Staatscode"
    ],
    "explanation": "This semantic type targets cells containing country names written in German, allowing uppercase-initial alphabetic words (including umlauts and \u00df), with up to five tokens separated by spaces, hyphens, or apostrophes. It avoids matching codes or numeric-laden values and is suitable for classifying columns holding human-readable German country names.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:39.169518"
  },
  {
    "resultType": "generated",
    "semanticType": "DAY.ABBR_<LOCALE>",
    "description": "Text field containing weekday abbreviations that are typically three alphabetic characters and may optionally include a trailing period. Intended for locale-specific 3-letter weekday forms (e.g., Mon, Tue, Wed) with optional punctuation, using header context to disambiguate from other 3-letter tokens.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(MON|TUE|WED|THU|FRI|SAT|SUN)\\.?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2880,
    "headerPatterns": [
      {
        "regExp": "(?i).*(weekday|week_day|day)[ _-]*(abbr|abbrev|abbreviation).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Day Abbr"
        ],
        "negativeExamples": [
          "Day Name"
        ]
      },
      {
        "regExp": "(?i).*day[ _-]*of[ _-]*week.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Day of Week"
        ],
        "negativeExamples": [
          "Date of Birth"
        ]
      },
      {
        "regExp": "(?i).*(dow|wkday)[ _-]*(abbr|abbrev).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "DOW Abbr"
        ],
        "negativeExamples": [
          "DOW Index"
        ]
      },
      {
        "regExp": "(?i).*(weekday|wkday|dow).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Weekday Abbr"
        ],
        "negativeExamples": [
          "Month"
        ]
      },
      {
        "regExp": "(?i).*day.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Day"
        ],
        "negativeExamples": [
          "Date"
        ]
      }
    ],
    "positiveContentExamples": [
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat",
      "Sun",
      "Fri."
    ],
    "negativeContentExamples": [
      "Monn",
      "Tu",
      "Thurs",
      "Sun-",
      "Wed/",
      "FRI1",
      "Mon Tue",
      "Mo."
    ],
    "positiveHeaderExamples": [
      "Day Abbr",
      "Day of Week",
      "Weekday Abbr",
      "Day Abbrev",
      "dow abbr",
      "weekday abbreviation",
      "day_of_week_abbr",
      "wkday_abbr"
    ],
    "negativeHeaderExamples": [
      "Day Name",
      "Month",
      "Date",
      "Week Number",
      "Day Index",
      "Holiday",
      "Timestamp",
      "Time of Day"
    ],
    "explanation": "This semantic type identifies fields containing 3-letter weekday abbreviations with an optional trailing period, constrained to the canonical seven day tokens. It is useful for standardizing and validating columns that store weekday short forms, aiding downstream parsing and grouping by weekday. Header patterns are designed to anchor classification to day/weekday abbreviation contexts to avoid false positives from arbitrary 3-letter codes.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:39.326310"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.AADHAAR_IN",
    "description": "An Indian Aadhaar identifier consisting of exactly 12 digits, optionally formatted with single spaces separating it into three groups of four digits (e.g., 1234 5678 9012 or 123456789012). Only numeric digits 0\u20139 are allowed and no other separators or characters are permitted.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{4}[ ]?\\d{4}[ ]?\\d{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3070,
    "headerPatterns": [
      {
        "regExp": "(?i).*aadhaar.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Aadhaar Number"
        ],
        "negativeExamples": [
          "Aadhaar ID"
        ]
      },
      {
        "regExp": "(?i).*aadhaar.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Aadhaar ID"
        ],
        "negativeExamples": [
          "UID"
        ]
      },
      {
        "regExp": "(?i).*(uid|aadhaar).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "UID"
        ],
        "negativeExamples": [
          "User ID"
        ]
      },
      {
        "regExp": "(?i).*(identity|id).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Identity Number"
        ],
        "negativeExamples": [
          "Phone Number"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Number"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "123456789012",
      "2345 6789 0123",
      "0000 1111 2222",
      "987654321098",
      "1020 3040 5060",
      "4500 1200 9900",
      "5555 6666 7777",
      "0192 8374 6510"
    ],
    "negativeContentExamples": [
      "12345678901",
      "1234567890123",
      "1234 567 89012",
      "1234  5678 9012",
      "1234-5678-9012",
      "1234 5678 90I2",
      "12345 6789 012",
      "UID 1234 5678 9012"
    ],
    "positiveHeaderExamples": [
      "Aadhaar Number",
      "Aadhaar ID",
      "UID",
      "UID Number",
      "Unique Identification Number",
      "National ID (Aadhaar)",
      "Aadhaar No",
      "Identity Number"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Address",
      "Phone Number",
      "Voter ID",
      "PAN Number",
      "Passport Number",
      "Customer ID",
      "Employee Number"
    ],
    "explanation": "This semantic type detects Indian Aadhaar numbers that are exactly 12 digits, allowing either a contiguous 12-digit sequence or a presentation with single spaces separating three groups of four digits. It rejects values with non-digit characters, dashes, multiple spaces, or incorrect digit counts. Use this for columns containing national identity numbers in datasets where the Aadhaar format is expected.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:40.050876"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.EIN_US",
    "description": "A tax identification string consisting of two digits, a hyphen, and seven digits (format: 00-0000000). The format is standardized by the IRS and requires the hyphen separator between the second and third digits.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{2}-\\d{7}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3100,
    "headerPatterns": [
      {
        "regExp": "(?i).*employer.*identification.*number.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Employer Identification Number"
        ],
        "negativeExamples": [
          "Employee Identification Number"
        ]
      },
      {
        "regExp": "(?i).*employer.*id.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Employer ID"
        ],
        "negativeExamples": [
          "Employee ID"
        ]
      },
      {
        "regExp": "(?i).*ein.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "EIN"
        ],
        "negativeExamples": [
          "SSN"
        ]
      },
      {
        "regExp": "(?i).*tax.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Tax ID"
        ],
        "negativeExamples": [
          "Tax Code"
        ]
      },
      {
        "regExp": "(?i).*id.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "ID"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "12-3456789",
      "01-2345678",
      "27-1234567",
      "65-4321098",
      "98-7654321",
      "00-0000000",
      "73-0098765",
      "10-0000001"
    ],
    "negativeContentExamples": [
      "123-45-6789",
      "12 3456789",
      "12-345678",
      "12-34567890",
      "1-23456789",
      "12.3456789",
      "12-3456A89",
      "AB-3456789"
    ],
    "positiveHeaderExamples": [
      "EIN",
      "Employer ID",
      "Tax ID",
      "Employer Identification Number",
      "Business Tax ID",
      "Federal EIN",
      "Employer Tax ID"
    ],
    "negativeHeaderExamples": [
      "Company Name",
      "SSN",
      "Employee Count",
      "Tax Code",
      "VAT Number",
      "Company ID",
      "Business Name"
    ],
    "explanation": "This semantic type identifies U.S. Employer Identification Numbers in the canonical NN-NNNNNNN format, ensuring the presence of exactly two digits, a mandatory hyphen, and seven trailing digits. It is useful for validating and classifying employer tax identifiers in datasets, especially when columns are labeled with EIN-related terms.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:41.372358"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTIFIER",
    "description": "A unique string following a pattern that typically combines letters and numbers in various formats to ensure distinctiveness. The pattern generally allows alphanumeric characters with optional separators like underscores or hyphens.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z0-9][A-Z0-9_-]*[A-Z0-9]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3060,
    "headerPatterns": [
      {
        "regExp": "(?i).*unique.*identifier.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Unique Identifier"
        ],
        "negativeExamples": [
          "User ID"
        ]
      },
      {
        "regExp": "(?i).*unique.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Unique ID"
        ],
        "negativeExamples": [
          "Description"
        ]
      },
      {
        "regExp": "(?i).*record.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Record ID"
        ],
        "negativeExamples": [
          "Record Name"
        ]
      },
      {
        "regExp": "(?i).*identifier.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Identifier"
        ],
        "negativeExamples": [
          "Name"
        ]
      },
      {
        "regExp": "(?i).*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ID"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "ABC123",
      "USER_00123",
      "INV-2023-0007",
      "X9Z_77",
      "ORDER-ABC_123",
      "A1B2C3D4",
      "ACCNT-0001",
      "PROD_2024-05"
    ],
    "negativeContentExamples": [
      "abc123",
      "USER 00123",
      "-ID123",
      "ID123-",
      "ID.123",
      "Id_123",
      "123#ABC",
      "\u00c4ID123"
    ],
    "positiveHeaderExamples": [
      "ID",
      "Identifier",
      "Unique ID",
      "Record ID",
      "Customer Identifier",
      "Unique Identifier",
      "User ID",
      "Entity ID"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Description",
      "Date",
      "Code",
      "Reference",
      "Record Count",
      "Status",
      "Account Name"
    ],
    "explanation": "This semantic type captures generic identifiers that consist of uppercase letters and digits, optionally separated by underscores or hyphens, with an alphanumeric start and end. It is suitable for record keys, user IDs, and similar fields where the value is an opaque unique token rather than human-readable text.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:41.900493"
  },
  {
    "resultType": "generated",
    "semanticType": "GENDER.TEXT_<LANGUAGE>",
    "description": "Free-text gender identity labels in a specific language, including common full-word terms such as male, female, nonbinary, transgender, genderqueer, agender, intersex, two-spirit, and similar phrases. This type focuses on human-readable descriptors rather than codes or single-letter abbreviations.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(male|female|man|woman|transgender|trans\\s+male|trans\\s+female|trans\\s+man|trans\\s+woman|non[-\\s]?binary|gender\\s*queer|gender\\s*fluid|agender|intersex|two[-\\s]?spirit|prefer\\s+not\\s+to\\s+say|prefer\\s+not\\s+to\\s+disclose)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 2990,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bgender\\b.*\\bidentity\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Gender Identity"
        ],
        "negativeExamples": [
          "Gender"
        ]
      },
      {
        "regExp": "(?i).*\\b(customer|user|patient|employee|applicant)\\b.*\\b(gender|sex)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Customer Gender"
        ],
        "negativeExamples": [
          "Nationality"
        ]
      },
      {
        "regExp": "(?i).*\\b(biological|legal|assigned)\\b.*\\b(sex|gender)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Assigned Sex"
        ],
        "negativeExamples": [
          "Sexual Orientation"
        ]
      },
      {
        "regExp": "(?i).*\\b(gndr|gend|sx)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SX"
        ],
        "negativeExamples": [
          "Age"
        ]
      },
      {
        "regExp": "(?i).*\\bsex\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Sex"
        ],
        "negativeExamples": [
          "Sexual Orientation"
        ]
      },
      {
        "regExp": "(?i).*\\bgender\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Gender"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "Male",
      "female",
      "Woman",
      "Trans man",
      "Trans woman",
      "Non-binary",
      "Genderqueer",
      "Agender"
    ],
    "negativeContentExamples": [
      "M",
      "F",
      "Masculine",
      "Feminine",
      "Trans",
      "MtF",
      "Enby",
      "Unknown"
    ],
    "positiveHeaderExamples": [
      "Gender",
      "Sex",
      "Gender Identity",
      "Customer Gender",
      "Biological Sex",
      "Assigned Sex",
      "User Gender Identity",
      "Applicant Gender"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Age",
      "Nationality",
      "Sexual Orientation",
      "Title",
      "Marital Status",
      "Given Name",
      "Preferred Language"
    ],
    "explanation": "This semantic type identifies textual gender identity values written out in a specific language rather than coded abbreviations. It is designed to recognize common descriptors such as male, female, nonbinary, transgender variants, genderqueer, agender, intersex, two-spirit, and explicit opt-out phrases like prefer not to say/disclose. Typical use cases include form responses, demographic fields, and profile attributes where users provide their gender in words.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:45.245003"
  },
  {
    "resultType": "generated",
    "semanticType": "CITY",
    "description": "A text string containing letters, spaces, and occasional punctuation marks representing proper nouns for municipal locations.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z][a-z]+\\.?([ \\-'][A-Z][a-z]+){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 2620,
    "headerPatterns": [
      {
        "regExp": "(?i).*(shipping|billing|residence|home|current|birth).*city.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "billing_city"
        ],
        "negativeExamples": [
          "billing_country"
        ]
      },
      {
        "regExp": "(?i).*(origin|destination).*city.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "origin_city"
        ],
        "negativeExamples": [
          "destination_country"
        ]
      },
      {
        "regExp": "(?i).*(city|town|municipality).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "city_name"
        ],
        "negativeExamples": [
          "country_name"
        ]
      },
      {
        "regExp": "(?i).*(cty|muni|municipal).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "muni"
        ],
        "negativeExamples": [
          "zip"
        ]
      },
      {
        "regExp": "(?i).*city.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "City"
        ],
        "negativeExamples": [
          "State"
        ]
      }
    ],
    "positiveContentExamples": [
      "New York",
      "Los Angeles",
      "St. Louis",
      "Ho Chi Minh City",
      "Winston-Salem",
      "Abu Dhabi",
      "San Jose",
      "Santa Monica"
    ],
    "negativeContentExamples": [
      "New York, NY",
      "Los Angeles 90001",
      "san Jose",
      "NYC",
      "Lake-wood",
      "St.Louis",
      "Rio de Janeiro",
      "Dublin 2"
    ],
    "positiveHeaderExamples": [
      "City",
      "Town",
      "Location",
      "Billing City",
      "Residence City",
      "Destination City",
      "Home Town",
      "Current Location"
    ],
    "negativeHeaderExamples": [
      "Country",
      "State",
      "ZIP Code",
      "County",
      "Street Address",
      "Province",
      "Latitude",
      "Airport Code"
    ],
    "explanation": "This type identifies municipal place names made up of capitalized words possibly separated by spaces, hyphens, or apostrophes, and may include brief abbreviations with a trailing period (e.g., St.). It is intended for columns that contain standalone city or town names without appended postal codes or country/state qualifiers.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:47.445062"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.SIN_CA",
    "description": "Canadian Social Insurance Number consisting of exactly nine numerical digits. It may appear as a contiguous 9-digit string or with single spaces in the XXX XXX XXX presentation form. Checksum validation exists in the originating standard; this pattern targets structural recognition (digits and optional single spaces) rather than algorithmic checksum verification.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{3}\\s?\\d{3}\\s?\\d{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3160,
    "headerPatterns": [
      {
        "regExp": "(?i).*social.*insurance.*number.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Social Insurance Number"
        ],
        "negativeExamples": [
          "Insurance Number"
        ]
      },
      {
        "regExp": "(?i).*sin.*number.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Customer SIN Number"
        ],
        "negativeExamples": [
          "Serial Number"
        ]
      },
      {
        "regExp": "(?i).*social.*insurance.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Social Insurance"
        ],
        "negativeExamples": [
          "Health Insurance"
        ]
      },
      {
        "regExp": "(?i).*sin.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SIN ID"
        ],
        "negativeExamples": [
          "Tax ID"
        ]
      },
      {
        "regExp": "(?i).*sin.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SIN"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "123456789",
      "123 456 789",
      "987654321",
      "000123456",
      "741 852 963",
      "562739184",
      "321 654 987",
      "859374120"
    ],
    "negativeContentExamples": [
      "123-456-789",
      "12345678",
      "1234 56789",
      "123 4567 89",
      "A23 456 789",
      "1234567890",
      "123 456 78A",
      "12 345 6789"
    ],
    "positiveHeaderExamples": [
      "SIN",
      "Social Insurance Number",
      "SIN Number",
      "Social Insurance",
      "SIN ID",
      "Employee SIN",
      "Gov SIN",
      "Customer SIN Number"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Address",
      "Employer",
      "Serial Number",
      "Insurance Number",
      "National Identifier",
      "Tax Number",
      "Customer ID"
    ],
    "explanation": "This semantic type identifies Canadian Social Insurance Numbers in datasets, accommodating both contiguous 9-digit values and values separated by single spaces in the XXX XXX XXX format. It is intended for identity verification and normalization tasks; the pattern emphasizes structural conformity while header cues help disambiguate from other numeric identifiers.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:48.176755"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.SSN_FR",
    "description": "A social security identifier following the pattern ^[12]\\d{14}$ where the first digit indicates gender and the remaining fourteen digits encode birth and location information. The format consists of exactly fifteen consecutive digits with embedded demographic data and includes a two-digit validation key at the end.",
    "pluginType": "regex",
    "regexPattern": "\\b[12][0-9]{14}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3180,
    "headerPatterns": [
      {
        "regExp": "(?i).*num[e\u00e9]ro.*insee.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Num\u00e9ro INSEE"
        ],
        "negativeExamples": [
          "Adresse"
        ]
      },
      {
        "regExp": "(?i).*num[e\u00e9]ro.*s[e\u00e9]curit[e\u00e9].*sociale.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Num\u00e9ro S\u00e9curit\u00e9 Sociale"
        ],
        "negativeExamples": [
          "Nom"
        ]
      },
      {
        "regExp": "(?i).*(insee|nir).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "INSEE"
        ],
        "negativeExamples": [
          "Date de Naissance"
        ]
      },
      {
        "regExp": "(?i).*(s[e\u00e9]curit[e\u00e9].*sociale|ssn).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "S\u00e9curit\u00e9 Sociale"
        ],
        "negativeExamples": [
          "Code INSEE"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "112345678901234",
      "200010203040506",
      "166052345678912",
      "191122334455667",
      "207112345678934",
      "123456789012345",
      "298765432109876",
      "145678901234567"
    ],
    "negativeContentExamples": [
      "312345678901234",
      "012345678901234",
      "21234567890123",
      "1123456789012345",
      "1 23456789012345",
      "2-12345678901234",
      "1A2345678901234",
      "2234567890123O4"
    ],
    "positiveHeaderExamples": [
      "Num\u00e9ro INSEE",
      "S\u00e9curit\u00e9 Sociale",
      "INSEE",
      "Num\u00e9ro S\u00e9curit\u00e9 Sociale",
      "NIR",
      "N\u00b0 INSEE",
      "SSN"
    ],
    "negativeHeaderExamples": [
      "Nom",
      "Adresse",
      "Date de Naissance",
      "Code INSEE",
      "Code Postal",
      "Num\u00e9ro de client",
      "Identifiant fiscal"
    ],
    "explanation": "This type identifies French national social security numbers (NIR/INSEE) appearing as a continuous 15-digit string where the first digit is 1 or 2. It is suited for datasets storing unformatted French SSNs without spaces or separators and helps distinguish them from other numeric identifiers.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:48.427795"
  },
  {
    "resultType": "generated",
    "semanticType": "EPOCH.MILLISECONDS",
    "description": "A numeric field containing timestamp values that follow the pattern of 13 consecutive digits representing milliseconds since Unix epoch as 13-digit integers. The format provides millisecond precision timing commonly used in JavaScript, databases, and high-precision logging applications.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{13}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2930,
    "headerPatterns": [
      {
        "regExp": "(?i).*epoch.*millis.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "epoch_millis"
        ],
        "negativeExamples": [
          "epoch_seconds"
        ]
      },
      {
        "regExp": "(?i).*timestamp.*millis.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "transaction_timestamp_millis"
        ],
        "negativeExamples": [
          "timestamp_seconds"
        ]
      },
      {
        "regExp": "(?i).*time.*millis.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Time Millis"
        ],
        "negativeExamples": [
          "time nanos"
        ]
      },
      {
        "regExp": "(?i).*timestamp.*ms.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "timestamp_ms"
        ],
        "negativeExamples": [
          "time_ms"
        ]
      },
      {
        "regExp": "(?i).*unix.*timestamp.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Unix Timestamp"
        ],
        "negativeExamples": [
          "Unix Time"
        ]
      },
      {
        "regExp": "(?i).*timestamp.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Timestamp"
        ],
        "negativeExamples": [
          "Date"
        ]
      }
    ],
    "positiveContentExamples": [
      "1000000000000",
      "1500000000123",
      "1609459200000",
      "1625097600456",
      "1672531200000",
      "1704067200123",
      "1735689600789",
      "1893456000000"
    ],
    "negativeContentExamples": [
      "162509760045",
      "16250976004567",
      "1,625,097,600,456",
      "162509760 0456",
      "162509760045-6",
      "1625097600456ms",
      "ms1625097600456",
      "169704000000O"
    ],
    "positiveHeaderExamples": [
      "Timestamp",
      "Unix Timestamp",
      "Time Millis",
      "epoch_millis",
      "timestamp_ms",
      "event_timestamp_ms",
      "unix_time_ms",
      "epoch_time_millis"
    ],
    "negativeHeaderExamples": [
      "Date",
      "Time",
      "Formatted Date",
      "timestamp_seconds",
      "epoch",
      "time_nanos",
      "created_at",
      "datetime"
    ],
    "explanation": "This semantic type identifies 13-digit numeric tokens representing milliseconds since the Unix epoch (1970-01-01T00:00:00Z). It is useful for detecting high-precision timestamps commonly produced by JavaScript runtimes, logging systems, and event streams.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:52.307278"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.SSN_CH",
    "description": "Swiss social security number (AHV/AVS) formatted with mandatory dot separators as 756.XXXX.XXXX.XX. The value must begin with the fixed country prefix 756, followed by three digit groups of 4, 4, and 2 digits respectively, for exactly 13 digits total in the pattern 756.1234.5678.90.",
    "pluginType": "regex",
    "regexPattern": "\\b756\\.[0-9]{4}\\.[0-9]{4}\\.[0-9]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3170,
    "headerPatterns": [
      {
        "regExp": "(?i).*(sozialversicherungsnummer|ahv[ _-]*nummer).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Sozialversicherungsnummer"
        ],
        "negativeExamples": [
          "Sozialversicherung"
        ]
      },
      {
        "regExp": "(?i).*(swiss|ch)[ _-]*(ssn|social[ _-]*security).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CH SSN"
        ],
        "negativeExamples": [
          "US SSN"
        ]
      },
      {
        "regExp": "(?i).*(ahv|avs)[ _-]*(id|no|nr|nummer|number).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "AHV Nummer"
        ],
        "negativeExamples": [
          "AVS Beitrag"
        ]
      },
      {
        "regExp": "(?i).*ssn.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SSN"
        ],
        "negativeExamples": [
          "SIN"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Number"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "756.1234.5678.90",
      "756.0001.2345.67",
      "756.9876.5432.10",
      "756.1357.2468.99",
      "756.1111.2222.33",
      "756.4321.8765.44",
      "756.2468.1357.08"
    ],
    "negativeContentExamples": [
      "756-1234-5678-90",
      "756.1234.5678.9",
      "756.1234.5678.900",
      "757.1234.5678.90",
      "756.12345.678.90",
      "756.1234.5678.9A",
      "756.1234.5678.90.",
      "7561234567890"
    ],
    "positiveHeaderExamples": [
      "AHV Nummer",
      "SSN",
      "Sozialversicherungsnummer",
      "CH SSN",
      "Swiss Social Security Number",
      "Versicherungsnummer",
      "AHV No"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Adresse",
      "Telefon",
      "Customer ID",
      "Tax Code",
      "Invoice Number",
      "IBAN",
      "Passport Number"
    ],
    "explanation": "IDENTITY.SSN_CH identifies Swiss social security numbers (AHV/AVS) that strictly follow the dotted format 756.XXXX.XXXX.XX. It enforces the fixed 756 country prefix and exact group sizes with dot separators, making it suitable for validating or classifying Swiss personal insurance numbers in datasets.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:55.282022"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.ISO-3166-3",
    "description": "A three-character uppercase alphabetic code used for international country identification, consisting of exactly three consecutive letters A\u2013Z.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 2790,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\biso[^a-z0-9]*3\\b.*\\bcountry\\b.*\\bcode\\b.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "ISO3 Country Code"
        ],
        "negativeExamples": [
          "ISO2 Country Code"
        ]
      },
      {
        "regExp": "(?i).*\\balpha[^a-z0-9]*3\\b.*\\bcountry\\b.*\\bcode\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Alpha-3 Country Code"
        ],
        "negativeExamples": [
          "Alpha-2 Country Code"
        ]
      },
      {
        "regExp": "(?i).*\\bthree\\b.*\\bletter\\b.*\\bcountry\\b.*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Three Letter Country Code"
        ],
        "negativeExamples": [
          "Three Letter Language Code"
        ]
      },
      {
        "regExp": "(?i).*\\bcountry\\b.*\\biso[^a-z0-9]*3\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Country ISO3"
        ],
        "negativeExamples": [
          "Country ISO2"
        ]
      },
      {
        "regExp": "(?i).*\\bcountry\\b.*\\bcode\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Country Code"
        ],
        "negativeExamples": [
          "Region Code"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "USA",
      "GBR",
      "FRA",
      "DEU",
      "JPN",
      "BRA",
      "IND",
      "ZAF"
    ],
    "negativeContentExamples": [
      "US",
      "GB",
      "FRA1",
      "UsA",
      "usa",
      "U5A",
      "U-SA",
      "FR A"
    ],
    "positiveHeaderExamples": [
      "Country Code",
      "ISO3 Country",
      "Three Letter Country",
      "ISO3 Country Code",
      "Alpha-3 Country Code",
      "ISO Alpha-3 Code",
      "Country ISO3 Code",
      "Country ISO3"
    ],
    "negativeHeaderExamples": [
      "Country Name",
      "Two Letter Code",
      "Continent",
      "Country ISO2 Code",
      "Region Code",
      "Language Code",
      "Three Digit Code",
      "Country Abbreviation"
    ],
    "explanation": "This type identifies three-letter uppercase country codes, suitable for columns storing ISO-style alpha-3 country identifiers. It uses a conservative value regex focusing on exactly three uppercase letters and relies on header cues such as ISO3 and Alpha-3 to reduce ambiguity. Use when data fields contain three-letter country codes rather than names or two-letter codes.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:56.028713"
  },
  {
    "resultType": "generated",
    "semanticType": "CONTINENT.TEXT_EN",
    "description": "A text string containing letters and spaces representing proper names of continental regions in English.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AFRICA",
      "ANTARCTICA",
      "ASIA",
      "EUROPE",
      "NORTH AMERICA",
      "SOUTH AMERICA",
      "OCEANIA",
      "AUSTRALIA",
      "EURASIA",
      "AMERICAS",
      "AUSTRALASIA",
      "LATIN AMERICA",
      "INDIAN SUBCONTINENT"
    ],
    "backout": "^[A-Z][A-Z ]{2,29}$",
    "confidenceThreshold": 93,
    "priority": 2690,
    "headerPatterns": [
      {
        "regExp": "(?i).*continent.*name.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Continent Name"
        ],
        "negativeExamples": [
          "Continent Code"
        ]
      },
      {
        "regExp": "(?i).*continental.*region.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Continental Region"
        ],
        "negativeExamples": [
          "Country Region"
        ]
      },
      {
        "regExp": "(?i).*\\bcontinent\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Continent"
        ],
        "negativeExamples": [
          "Content Type"
        ]
      },
      {
        "regExp": "(?i).*\\bcont\\b.*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Cont Name"
        ],
        "negativeExamples": [
          "Content Name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Europe",
      "North America",
      "South America",
      "Asia",
      "Africa",
      "Oceania",
      "Antarctica",
      "Australia"
    ],
    "negativeContentExamples": [
      "EU",
      "United States",
      "N. America",
      "Europe/Asia",
      "Asia-Pacific",
      "NorthAmerica",
      "Continent",
      "AFRICA1"
    ],
    "positiveHeaderExamples": [
      "Continent",
      "Continent Name",
      "Continental Region",
      "Geographic Continent Name",
      "Primary Continent",
      "Target Continental Region",
      "Home Continent",
      "Customer Continent Name"
    ],
    "negativeHeaderExamples": [
      "Country",
      "City",
      "Continent Code",
      "Region Code",
      "Country Name",
      "Content Name",
      "Subregion",
      "Planet"
    ],
    "explanation": "This semantic type identifies English names of continents and closely related continental regions. It is useful for classifying fields that store the continent associated with an entity such as a customer, location, or event. The list-based approach ensures precise matching to well-known continent and continental region names while avoiding overly broad text matches.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:57.094950"
  },
  {
    "resultType": "generated",
    "semanticType": "HASH.SHA256_HEX",
    "description": "A text field containing SHA-256 hashes encoded as exactly 64 lowercase hexadecimal characters (a\u2013f, 0\u20139). This format represents cryptographic hash digests commonly used for data integrity verification and digital authentication.",
    "pluginType": "regex",
    "regexPattern": "\\b[a-f0-9]{64}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3040,
    "headerPatterns": [
      {
        "regExp": "(?i).*sha[-_ ]?256.*hash.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SHA256 Hash"
        ],
        "negativeExamples": [
          "File Hash"
        ]
      },
      {
        "regExp": "(?i).*sha[-_ ]?256.*digest.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SHA-256 Digest"
        ],
        "negativeExamples": [
          "MD5 Digest"
        ]
      },
      {
        "regExp": "(?i).*sha2.*hash.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SHA2 Hash"
        ],
        "negativeExamples": [
          "SHA1 Hash"
        ]
      },
      {
        "regExp": "(?i).*file.*hash.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "File Hash"
        ],
        "negativeExamples": [
          "File Size"
        ]
      },
      {
        "regExp": "(?i).*content.*hash.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Content Hash"
        ],
        "negativeExamples": [
          "Content Type"
        ]
      },
      {
        "regExp": "(?i).*hash.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Hash"
        ],
        "negativeExamples": [
          "Password"
        ]
      }
    ],
    "positiveContentExamples": [
      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad",
      "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824",
      "9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08",
      "5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8",
      "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
      "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
      "0000000000000000000000000000000000000000000000000000000000000000"
    ],
    "negativeContentExamples": [
      "E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855",
      "E3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "g3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b85",
      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b8550",
      "e3b0c442-98fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b8 5",
      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852bz55"
    ],
    "positiveHeaderExamples": [
      "SHA256 Hash",
      "Hash",
      "File Hash",
      "SHA-256 Digest",
      "Content Hash",
      "SHA2 Hash"
    ],
    "negativeHeaderExamples": [
      "Filename",
      "File Size",
      "Password",
      "File Path",
      "Digest Algorithm",
      "Signature"
    ],
    "explanation": "This semantic type targets SHA-256 digests formatted as exactly 64 lowercase hexadecimal characters, typical for file integrity checks and cryptographic verification. It uses a strict value regex to avoid false positives, and flexible yet prioritized header patterns that recognize both specific SHA-256 terminology and generic hash column names.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:59.168036"
  },
  {
    "resultType": "generated",
    "semanticType": "INDUSTRY_EN",
    "description": "A text field containing industry names that typically match common business sector terminology and may follow patterns like proper case formatting. The format allows alphabetic characters, spaces, and common punctuation such as apostrophes, slashes, periods, and hyphens, but excludes numerical codes or specialized formatting symbols.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z][A-Za-z'./-]*( (and|of|for|in|&) [A-Za-z][A-Za-z'./-]*){0,6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3220,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bindustry\\b.*\\bname\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Industry Name"
        ],
        "negativeExamples": [
          "NAICS Code"
        ]
      },
      {
        "regExp": "(?i).*\\bbusiness\\b.*\\bsector\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Business Sector"
        ],
        "negativeExamples": [
          "Company Name"
        ]
      },
      {
        "regExp": "(?i).*\\bindustry\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Industry"
        ],
        "negativeExamples": [
          "Revenue"
        ]
      },
      {
        "regExp": "(?i).*\\bsector\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Sector"
        ],
        "negativeExamples": [
          "Company Name"
        ]
      },
      {
        "regExp": "(?i).*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Financial Services",
      "Information Technology",
      "Healthcare",
      "Real Estate",
      "Consumer Goods",
      "Energy & Utilities",
      "Media and Entertainment",
      "Transportation and Logistics"
    ],
    "negativeContentExamples": [
      "Manufacturing 2.0",
      "NAICS 541511",
      "Oil & Gas #1",
      "Retail/Wholesale (B2B)",
      "SaaS-Software_Industry",
      "Finance, 2023",
      "Healthcare & Life-Sciences!",
      "Tech*Hardware"
    ],
    "positiveHeaderExamples": [
      "Industry",
      "Industry Name",
      "Business Sector",
      "Sector",
      "Industry Category",
      "Primary Industry",
      "Industry Type"
    ],
    "negativeHeaderExamples": [
      "NAICS Code",
      "Company Name",
      "Revenue",
      "SIC Code",
      "Employee Count",
      "Country",
      "Invoice Number",
      "Business Unit"
    ],
    "explanation": "This semantic type targets textual industry names and sector descriptors written in natural language without numeric codes. It is useful for identifying columns that store business sector names to support normalization, categorization, or mapping to standardized taxonomies while avoiding code-based identifiers.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:25:59.387970"
  },
  {
    "resultType": "generated",
    "semanticType": "INDUSTRY_CODE.NAICS",
    "description": "An industry classification code consisting of exactly six numerical digits, representing a hierarchical structure where the first two digits identify the sector and subsequent digits provide increasingly detailed subcategories.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 3210,
    "headerPatterns": [
      {
        "regExp": "(?i).*naics.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "NAICS Code"
        ],
        "negativeExamples": [
          "Industry Name"
        ]
      },
      {
        "regExp": "(?i).*industry.*classification.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Industry Classification Code"
        ],
        "negativeExamples": [
          "Company Code"
        ]
      },
      {
        "regExp": "(?i).*industry.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Industry Code"
        ],
        "negativeExamples": [
          "Business Type"
        ]
      },
      {
        "regExp": "(?i).*naics.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "NAICS"
        ],
        "negativeExamples": [
          "Company Name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "541611",
      "311811",
      "236115",
      "221114",
      "523920",
      "325510",
      "423450",
      "713940"
    ],
    "negativeContentExamples": [
      "54161",
      "2361157",
      "54-1611",
      "54 1611",
      "5416A1",
      "A541611B",
      "541_611",
      "5416.11"
    ],
    "positiveHeaderExamples": [
      "NAICS Code",
      "Industry Code",
      "NAICS",
      "Industry Classification Code",
      "NAICS_Code",
      "industry_code",
      "naics",
      "industry classification code"
    ],
    "negativeHeaderExamples": [
      "Industry Name",
      "Business Type",
      "Company Name",
      "SIC Code",
      "Category",
      "Industry Description",
      "Account Code",
      "Department Code"
    ],
    "explanation": "This type targets NAICS-style industry codes represented as exactly six digits. It is suitable for classifying columns that contain standardized 6-digit industry identifiers and is guided by both value shape and header cues to avoid misclassification.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:03.113411"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.PERSONNUMMER_SE",
    "description": "A Swedish personal identifier where the first six digits are a birth date in YYMMDD format and the final four digits are an individual sequence. The value may optionally include a hyphen after the sixth digit (YYMMDD-XXXX), but the core pattern is ten consecutive digits.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{2}(0[1-9]|1[0-2])(0[1-9]|[12][0-9]|3[01])-?\\d{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3150,
    "headerPatterns": [
      {
        "regExp": "(?i).*swedish.*personnummer.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Swedish Personnummer"
        ],
        "negativeExamples": [
          "Personal ID"
        ]
      },
      {
        "regExp": "(?i).*(swedish|sweden|se).*(personnummer|personal id|person id).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "SE Personal ID"
        ],
        "negativeExamples": [
          "Personnummer"
        ]
      },
      {
        "regExp": "(?i).*(personnummer|national id|personal id).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Personnummer"
        ],
        "negativeExamples": [
          "Swedish ID"
        ]
      },
      {
        "regExp": "(?i).*(pnr|persnr|pid|se id).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "SE ID"
        ],
        "negativeExamples": [
          "Customer ID"
        ]
      },
      {
        "regExp": "(?i).*id.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "ID"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "8507314821",
      "850731-4821",
      "000229-1230",
      "740215-0047",
      "9601010001",
      "120312-7890",
      "9009302211",
      "991231-9999"
    ],
    "negativeContentExamples": [
      "850731+4821",
      "19850731-4821",
      "850731 4821",
      "850731-482",
      "850732-4821",
      "851331-4821",
      "850700-4821",
      "850731--4821"
    ],
    "positiveHeaderExamples": [
      "Personnummer",
      "Personal ID",
      "Swedish ID",
      "SE Personnummer",
      "Sweden Personal ID",
      "National ID (SE)",
      "Person ID Sweden",
      "Personnummer SE"
    ],
    "negativeHeaderExamples": [
      "Namn",
      "Adress",
      "Telefon",
      "Customer ID",
      "Passport Number",
      "Tax ID",
      "Birthdate",
      "Employee Number"
    ],
    "explanation": "This semantic type identifies Swedish personal identity numbers composed of YYMMDD followed by a sequence of four digits, optionally separated by a hyphen after the date. The regex validates plausible month and day ranges, while allowing both compact and hyphenated formats. It is useful for recognizing and validating Swedish personal identifiers in datasets, improving data quality and enabling privacy controls.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:09.062023"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.NI_UK",
    "description": "A UK National Insurance identifier consisting of two uppercase letters, six digits, and a final uppercase letter, with no spaces or punctuation. The value is exactly nine characters in the form AA999999A.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2}\\d{6}[A-Z]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3130,
    "headerPatterns": [
      {
        "regExp": "(?i).*national[ _-]*insurance[ _-]*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "National Insurance Number"
        ],
        "negativeExamples": [
          "National Insurance"
        ]
      },
      {
        "regExp": "(?i).*(\\bni\\b|\\bnino\\b)[ _-]*(number|no|#|id).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "NI No"
        ],
        "negativeExamples": [
          "NI Rate"
        ]
      },
      {
        "regExp": "(?i).*national[ _-]*insurance.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "National Insurance"
        ],
        "negativeExamples": [
          "Insurance Number"
        ]
      },
      {
        "regExp": "(?i).*(\\bnino\\b|\\bni\\b).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "NINO"
        ],
        "negativeExamples": [
          "NIA Code"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Number"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "AB123456C",
      "QQ112233D",
      "CD987654A",
      "ZX000001B",
      "LM765432Z",
      "GH246810K",
      "RT135791P",
      "WB555555Q"
    ],
    "negativeContentExamples": [
      "AB1234567C",
      "AB12345C",
      "ab123456C",
      "AB123456",
      "A123456C",
      "ABC123456D",
      "AB 123456 C",
      "AB1234567"
    ],
    "positiveHeaderExamples": [
      "NI Number",
      "National Insurance",
      "NINO",
      "National Insurance No",
      "NI No",
      "National Insurance ID",
      "National Insurance #",
      "NI Identifier"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Address",
      "Employer",
      "Insurance Number",
      "Tax Number",
      "National ID",
      "NIA Code",
      "Payroll Number"
    ],
    "explanation": "This semantic type identifies UK National Insurance numbers in free text or structured fields based on a strict nine-character format of two letters, six digits, and a trailing letter. It is well-suited for validating and classifying government identity fields labeled with terms like NI Number, NINO, or National Insurance.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:09.986034"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.INDIVIDUAL_NUMBER_JA",
    "description": "A personal identification number consisting of exactly twelve consecutive digits 0-9 with no separators, letters, or special characters. Commonly referred to as Japan's \"My Number,\" it is a strict fixed-length numeric identifier.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{12}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3110,
    "headerPatterns": [
      {
        "regExp": "(?i).*(\u500b\u4eba\u756a\u53f7|\u30de\u30a4\u30ca\u30f3\u30d0\u30fc|my[ _-]*number).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u500b\u4eba\u756a\u53f7"
        ],
        "negativeExamples": [
          "\u6c0f\u540d"
        ]
      },
      {
        "regExp": "(?i).*(\u65e5\u672c|jp|japan).*(\u500b\u4eba\u756a\u53f7|\u30de\u30a4\u30ca\u30f3\u30d0\u30fc|my[ _-]*number).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "JP My Number"
        ],
        "negativeExamples": [
          "\u4f4f\u6240"
        ]
      },
      {
        "regExp": "(?i).*(individual[ _-]*number|personal[ _-]*number|my[ _-]*no|my[ _-]*num|mynumber).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Individual Number"
        ],
        "negativeExamples": [
          "\u96fb\u8a71\u756a\u53f7"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "123456789012",
      "000000000000",
      "001234567890",
      "987654321098",
      "555555555555",
      "810234567890",
      "070809101112",
      "123123123123"
    ],
    "negativeContentExamples": [
      "12345678901",
      "1234567890123",
      "1234-5678-9012",
      "123 456 789 012",
      "A23456789012",
      "12345678901A",
      "1234567890.12",
      "00123456789"
    ],
    "positiveHeaderExamples": [
      "\u30de\u30a4\u30ca\u30f3\u30d0\u30fc",
      "\u500b\u4eba\u756a\u53f7",
      "My Number",
      "JP My Number",
      "\u65e5\u672c\u500b\u4eba\u756a\u53f7",
      "Individual Number",
      "Personal Number (Japan)",
      "Japan My Number"
    ],
    "negativeHeaderExamples": [
      "\u6c0f\u540d",
      "\u4f4f\u6240",
      "\u96fb\u8a71\u756a\u53f7",
      "\u793e\u54e1\u756a\u53f7",
      "\u9867\u5ba2\u756a\u53f7",
      "Tax Number",
      "Passport Number",
      "ID Code"
    ],
    "explanation": "This semantic type targets the Japanese Individual Number (\"My Number\"), which must be exactly twelve ASCII digits with no separators or other characters. It is designed for datasets where the column header clearly references My Number or individual/personal number in a Japanese context, and where values strictly adhere to a 12-digit numeric format.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:11.237757"
  },
  {
    "resultType": "generated",
    "semanticType": "LANGUAGE.ISO-639-2",
    "description": "A language identifier following the pattern ^[a-z]{3}$ consisting of exactly three lowercase alphabetic characters. The format provides extended language coverage beyond the two-letter ISO standard and includes separate codes for bibliographic and terminology applications.",
    "pluginType": "regex",
    "regexPattern": "\\b[a-z]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 3270,
    "headerPatterns": [
      {
        "regExp": "(?i).*iso.*639.*2.*language.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISO 639-2 Language Code"
        ],
        "negativeExamples": [
          "Language Code"
        ]
      },
      {
        "regExp": "(?i).*language.*iso.*639.*2.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Language ISO 639-2"
        ],
        "negativeExamples": [
          "ISO Language"
        ]
      },
      {
        "regExp": "(?i).*iso.*language.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISO Language"
        ],
        "negativeExamples": [
          "ISO Country"
        ]
      },
      {
        "regExp": "(?i).*lang.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Lang Code"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*language.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Language"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "eng",
      "spa",
      "fra",
      "deu",
      "por",
      "rus",
      "ara",
      "zho"
    ],
    "negativeContentExamples": [
      "en",
      "ENG",
      "EnG",
      "eng1",
      "en-GB",
      "fr a",
      "de_u",
      "zh0"
    ],
    "positiveHeaderExamples": [
      "Language Code",
      "ISO Language",
      "Lang Code",
      "ISO 639-2 Language Code",
      "Language ISO 639-2",
      "ISO Language Code",
      "639-2 Lang Code",
      "ISO Lang Code"
    ],
    "negativeHeaderExamples": [
      "Language Name",
      "Country",
      "Two Letter Code",
      "ISO 639-1 Language Code",
      "Country Code",
      "Locale Code",
      "Dialect",
      "Script Code"
    ],
    "explanation": "This type detects ISO 639-2 language identifiers consisting of exactly three lowercase letters, enabling recognition of bibliographic and terminology-oriented language codes. It is useful for validating and classifying columns that store standardized three-letter language codes, especially when paired with headers indicating ISO and language context.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:11.579011"
  },
  {
    "resultType": "generated",
    "semanticType": "MONTH.FULL_<LOCALE>",
    "description": "A text field containing full month names that follow locale-specific linguistic patterns and typically use proper case formatting. The format consists of alphabetic characters appropriate to the specified language and may include diacritical marks or special characters based on linguistic requirements.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "JANUARY",
      "FEBRUARY",
      "MARCH",
      "APRIL",
      "MAY",
      "JUNE",
      "JULY",
      "AUGUST",
      "SEPTEMBER",
      "OCTOBER",
      "NOVEMBER",
      "DECEMBER"
    ],
    "backout": "^[\\p{L}][\\p{L}\\p{M}\\s\\-\\.']{2,20}$",
    "confidenceThreshold": 98,
    "priority": 3320,
    "headerPatterns": [
      {
        "regExp": "(?i).*full.*month.*name.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Full Month Name"
        ],
        "negativeExamples": [
          "Month Number"
        ]
      },
      {
        "regExp": "(?i).*(month_name|monthname).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "month_name"
        ],
        "negativeExamples": [
          "day_name"
        ]
      },
      {
        "regExp": "(?i).*full.*month.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Full Month"
        ],
        "negativeExamples": [
          "Month Abbrev"
        ]
      },
      {
        "regExp": "(?i).*month.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Month"
        ],
        "negativeExamples": [
          "Season"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Date"
        ]
      }
    ],
    "positiveContentExamples": [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August"
    ],
    "negativeContentExamples": [
      "Jan",
      "SEPTEMBER 2024",
      "Sept",
      "September.",
      "02",
      "Monday",
      "Septembre",
      "Septembe"
    ],
    "positiveHeaderExamples": [
      "Month Name",
      "Month",
      "Full Month",
      "Full Month Name",
      "Month Full Name",
      "month_name"
    ],
    "negativeHeaderExamples": [
      "Month Number",
      "Day",
      "Season",
      "Month Abbrev",
      "Short Month",
      "Month Code"
    ],
    "explanation": "This semantic type represents full English month names. It is suitable for columns containing complete month names used in reporting, logs, and time-based categorizations where the textual month is stored instead of a numeric value or abbreviation. The list approach ensures strict matching to the 12 valid values, while the backout pattern provides a safety net shape for preliminary filtering.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:12.159341"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.SUFFIX",
    "description": "A text field containing name suffixes that typically follow patterns like generational designations (Jr, Sr), Roman numerals (II, III, IV, V, etc.), or ordinal numbers (1st, 2nd, 3rd, 4th, etc.), with optional periods consistent with conventional suffix formatting.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b((jr|sr)\\.?|[ivx]{1,5}|([1-9][0-9]?)(st|nd|rd|th)\\.?)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3390,
    "headerPatterns": [
      {
        "regExp": "(?i).*name.*suffix.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Name Suffix"
        ],
        "negativeExamples": [
          "Full Name"
        ]
      },
      {
        "regExp": "(?i).*suffix.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Suffix"
        ],
        "negativeExamples": [
          "Prefix"
        ]
      },
      {
        "regExp": "(?i).*generation.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Generation"
        ],
        "negativeExamples": [
          "General Notes"
        ]
      },
      {
        "regExp": "(?i).*sfx.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Name SFX"
        ],
        "negativeExamples": [
          "Ref"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Title"
        ]
      }
    ],
    "positiveContentExamples": [
      "Jr",
      "Sr.",
      "II",
      "III",
      "IV",
      "2nd",
      "21st",
      "X"
    ],
    "negativeContentExamples": [
      "Jnr",
      "Junior",
      "Sr-1",
      "1 st",
      "2-nd",
      "V.",
      "XI I",
      "IXO"
    ],
    "positiveHeaderExamples": [
      "Name Suffix",
      "Suffix",
      "Generation",
      "Person Suffix",
      "Generational Suffix",
      "Family Generation",
      "Name SFX"
    ],
    "negativeHeaderExamples": [
      "First Name",
      "Last Name",
      "Full Name",
      "Middle Name",
      "Title",
      "Prefix",
      "File Name"
    ],
    "explanation": "This semantic type targets short generational or honorific suffix tokens that follow personal names, such as Jr, Sr, Roman numerals (II, III, IV, V, X), or ordinal forms (2nd, 3rd, 21st). It is useful for parsing or normalizing personal name components where the suffix is stored in a dedicated field.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:13.362495"
  },
  {
    "resultType": "generated",
    "semanticType": "LANGUAGE.ISO-639-1",
    "description": "A language identifier consisting of exactly two lowercase alphabetic characters. The format is standardized by ISO and represents the most commonly used languages with officially assigned two-letter codes.",
    "pluginType": "regex",
    "regexPattern": "\\b[a-z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3260,
    "headerPatterns": [
      {
        "regExp": "(?i).*iso[-_ ]?639[-_ ]?1.*(language|lang).*(code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISO 639-1 Language Code"
        ],
        "negativeExamples": [
          "ISO 3166-1 Country Code"
        ]
      },
      {
        "regExp": "(?i).*(iso).*(language|lang).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISO Language"
        ],
        "negativeExamples": [
          "ISO Country"
        ]
      },
      {
        "regExp": "(?i).*(language|lang).*(iso).*(code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Language ISO Code"
        ],
        "negativeExamples": [
          "ISO Country Code"
        ]
      },
      {
        "regExp": "(?i).*(language).*(code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Language Code"
        ],
        "negativeExamples": [
          "Language Name"
        ]
      },
      {
        "regExp": "(?i).*(lang).*(code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Lang Code"
        ],
        "negativeExamples": [
          "Long Code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "en",
      "fr",
      "es",
      "de",
      "it",
      "pt",
      "ru",
      "zh"
    ],
    "negativeContentExamples": [
      "EN",
      "eng",
      "e",
      "fr1",
      "1e",
      "pt_br",
      "zhCN",
      "deAT"
    ],
    "positiveHeaderExamples": [
      "Language Code",
      "ISO Language",
      "Lang Code",
      "ISO 639-1 Language Code",
      "ISO Language Code",
      "Language ISO Code",
      "ISO Lang Code",
      "Primary Language Code"
    ],
    "negativeHeaderExamples": [
      "Language Name",
      "Country",
      "Three Letter Code",
      "Country Code",
      "ISO Country",
      "Locale",
      "Dialect",
      "Region Name"
    ],
    "explanation": "This semantic type identifies ISO 639-1 two-letter language codes such as en, fr, or zh. It is intended for datasets where language information is stored as standardized two-letter lowercase identifiers. The header matching patterns cover common column naming conventions including explicit references to ISO 639-1, generic 'language code' labels, and common abbreviations like 'lang code'. The regex pattern is constrained to exactly two lowercase letters with word boundaries to minimize false positives in free-text or composite values.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:14.794219"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.BSN_NL",
    "description": "A string representing a Dutch citizen service number (BSN) containing exactly 9 digits. The value consists only of numeric characters 0\u20139 and is expected to pass the BSN checksum (11-proef variant with last digit weight \u22121).",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{9}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3080,
    "headerPatterns": [
      {
        "regExp": "(?i).*burgerservicenummer.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Burgerservicenummer"
        ],
        "negativeExamples": [
          "Naam"
        ]
      },
      {
        "regExp": "(?i).*\\bbsn\\b.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "BSN"
        ],
        "negativeExamples": [
          "Adres"
        ]
      },
      {
        "regExp": "(?i).*citizen.*number.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Citizen Number"
        ],
        "negativeExamples": [
          "Telefoon"
        ]
      },
      {
        "regExp": "(?i).*citizen.*id.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Citizen ID"
        ],
        "negativeExamples": [
          "Postcode"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Number"
        ],
        "negativeExamples": [
          "Naam"
        ]
      }
    ],
    "positiveContentExamples": [
      "123456782",
      "001234560",
      "246813477",
      "111222333",
      "780123463",
      "529874131",
      "350807528"
    ],
    "negativeContentExamples": [
      "123456789",
      "12345678",
      "1234567890",
      "123-456782",
      "12 3456782",
      "12345678A",
      "987654321",
      "001234561"
    ],
    "positiveHeaderExamples": [
      "BSN",
      "Burgerservicenummer",
      "Citizen Number",
      "NL BSN",
      "Dutch Citizen Number",
      "Citizen No"
    ],
    "negativeHeaderExamples": [
      "Naam",
      "Adres",
      "Telefoon",
      "Email",
      "Postcode",
      "Geboortedatum"
    ],
    "explanation": "This semantic type identifies Dutch BSN values in datasets by matching a strict 9-digit token and leveraging header cues such as 'Burgerservicenummer' and 'BSN'. It is suitable for columns containing personal identifiers for Dutch citizens, where values are expected to satisfy the BSN checksum. The regex enforces the exact digit count and numeric character set; checksum validation is expected to be applied by higher-level validation logic.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:15.697275"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.FIRST",
    "description": "A text field containing personal given names that typically follow proper name formatting conventions and use alphabetic characters with possible apostrophes or hyphens. The format allows international characters and diacritical marks but excludes numerical digits, titles, or multiple name components.",
    "pluginType": "regex",
    "regexPattern": "\\b[\\p{L}]{2,}([-'\u2019][\\p{L}]{2,})?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3330,
    "headerPatterns": [
      {
        "regExp": "(?i).*first.*name.*",
        "confidence": 99,
        "mandatory": true,
        "positiveExamples": [
          "First Name"
        ],
        "negativeExamples": [
          "Last Name"
        ]
      },
      {
        "regExp": "(?i).*given.*name.*",
        "confidence": 99,
        "mandatory": true,
        "positiveExamples": [
          "Given Name"
        ],
        "negativeExamples": [
          "Full Name"
        ]
      },
      {
        "regExp": "(?i).*forename.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Forename"
        ],
        "negativeExamples": [
          "Surname"
        ]
      },
      {
        "regExp": "(?i).*(person|user|contact).*(first|given).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "User First"
        ],
        "negativeExamples": [
          "Account Given Name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "Liam",
      "\u00c9lodie",
      "D'Andre",
      "Jean-Luc",
      "Ji-woo",
      "\u00c1lvaro",
      "Zo\u00eb",
      "Li"
    ],
    "negativeContentExamples": [
      "Mary Jane",
      "J.",
      "Mr John",
      "John3",
      "-Anna",
      "Anna-",
      "D''Andre",
      "A"
    ],
    "positiveHeaderExamples": [
      "First Name",
      "Given Name",
      "Forename",
      "User First Name",
      "Person Given Name",
      "Primary Forename",
      "Employee First Name",
      "Contact Given Name"
    ],
    "negativeHeaderExamples": [
      "Last Name",
      "Full Name",
      "Middle Name",
      "Surname",
      "Nickname",
      "Account Name",
      "Legal Name",
      "Display Name"
    ],
    "explanation": "This semantic type identifies a single personal given name consisting only of letters, with an optional internal hyphen or apostrophe. It intentionally excludes titles, initials, numerals, and multi-part names containing spaces.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:16.261179"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.VAT_<COUNTRY>",
    "description": "A tax registration identifier that varies by country but typically follows patterns like ^[A-Z]{2}[A-Z0-9]+$ with country code prefixes or purely numeric sequences. The format depends on national tax authority requirements and may include letters, numbers, and specific formatting characters unique to each jurisdiction.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z]{2}\\s?([A-Z0-9]{8,15}|[A-Z0-9]{2,4}([ -]?[A-Z0-9]{2,4}){1,4})|\\d{3,4}([ -]?\\d{3,4}){2,3})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 3190,
    "headerPatterns": [
      {
        "regExp": "(?i).*vat.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "VAT Number"
        ],
        "negativeExamples": [
          "Company Name"
        ]
      },
      {
        "regExp": "(?i).*vat.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "VAT ID"
        ],
        "negativeExamples": [
          "User ID"
        ]
      },
      {
        "regExp": "(?i).*tax.*registration.*(number|id).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Tax Registration Number"
        ],
        "negativeExamples": [
          "Tax Rate"
        ]
      },
      {
        "regExp": "(?i).*tax.*(id|identifier|number).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Tax ID"
        ],
        "negativeExamples": [
          "Invoice Number"
        ]
      },
      {
        "regExp": "(?i).*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ID"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "DE123456789",
      "FR12A3456789",
      "IT12345678901",
      "ESX1234567R",
      "GB123 4567 89",
      "NL123456789B01",
      "PL1234 567 890",
      "RO123 456 7890"
    ],
    "negativeContentExamples": [
      "de12345678",
      "PL_1234567890",
      "GB/123456789",
      "NL12.345.678.B01",
      "IT1234567890123456",
      "DE12345",
      "ESX12345R",
      "123 45 678"
    ],
    "positiveHeaderExamples": [
      "VAT Number",
      "Tax ID",
      "VAT ID",
      "Tax Registration Number",
      "VAT Registration ID",
      "Value Added Tax Number",
      "VAT No",
      "Tax Identifier"
    ],
    "negativeHeaderExamples": [
      "Company Name",
      "Revenue",
      "Country",
      "Invoice Number",
      "Customer ID",
      "Tax Rate",
      "Postal Code",
      "Account Number"
    ],
    "explanation": "This semantic type identifies country-specific VAT registration numbers used for tax purposes. It supports formats with a two-letter country prefix followed by alphanumeric sequences with optional spaces or hyphens, as well as prefix-less numeric formats grouped in 3\u20134 digit blocks totaling 9\u201312 digits. Use when extracting or validating VAT identifiers across multiple jurisdictions, especially in finance, billing, and compliance contexts.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:18.475009"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.LAST_FIRST",
    "description": "A text field containing complete names in the format LastName, FirstName where both components consist of alphabetic characters and may include internal apostrophes or hyphens. The separator is a comma followed by a single space, and each component must start and end with a letter.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z][A-Za-z'-]*[A-Za-z], [A-Za-z][A-Za-z'-]*[A-Za-z]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 3360,
    "headerPatterns": [
      {
        "regExp": "(?i).*last.*first.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Last First Name"
        ],
        "negativeExamples": [
          "Full Name"
        ]
      },
      {
        "regExp": "(?i).*full[_ -]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Full Name"
        ],
        "negativeExamples": [
          "Email Address"
        ]
      },
      {
        "regExp": "(?i).*(last[_ -]*first|lname[_ -]*fname).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Lname_Fname"
        ],
        "negativeExamples": [
          "First Name"
        ]
      },
      {
        "regExp": "(?i).*(person|customer).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Customer Name"
        ],
        "negativeExamples": [
          "Last Name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Email Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "O'Connor, Mary",
      "Smith-Jones, Anne",
      "McDonald, John",
      "D'Amico, Luca",
      "Li, Wei",
      "Nguyen, An",
      "Brown, Amy-Lou",
      "Garcia-Lopez, Pedro"
    ],
    "negativeContentExamples": [
      "John Smith",
      "Smith,John",
      "O'Connor Mary",
      "Smith , John",
      "Smith, J",
      "S, John",
      "Smith, John-Paul-",
      "Smith, John 3"
    ],
    "positiveHeaderExamples": [
      "Full Name",
      "Name",
      "Last First Name",
      "Customer Name",
      "Employee Full Name",
      "Lname_Fname",
      "Person Name"
    ],
    "negativeHeaderExamples": [
      "First Name",
      "Last Name",
      "Email Address",
      "Username",
      "Contact",
      "First Middle Last",
      "Given Name"
    ],
    "explanation": "Identifies two-part personal names written with surname first, followed by a comma and single space, then the given name. Internal hyphens and apostrophes are allowed within each name component, but components must start and end with a letter. This is useful for datasets that store names in 'Last, First' format and need consistent parsing and validation.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:19.752974"
  },
  {
    "resultType": "generated",
    "semanticType": "IPADDRESS.IPV4",
    "description": "A network address in dotted-decimal notation with four decimal octets separated by dots. Each octet is an integer from 0 to 255, and multi-digit octets must not have leading zeros.",
    "pluginType": "regex",
    "regexPattern": "\\b(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])(\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])){3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3230,
    "headerPatterns": [
      {
        "regExp": "(?i).*ipv4.*address.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "IPv4 Address"
        ],
        "negativeExamples": [
          "Domain Name"
        ]
      },
      {
        "regExp": "(?i).*ipv4.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "IPv4"
        ],
        "negativeExamples": [
          "IP Address"
        ]
      },
      {
        "regExp": "(?i).*ip.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IP Address"
        ],
        "negativeExamples": [
          "MAC Address"
        ]
      },
      {
        "regExp": "(?i).*ipaddr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ipaddr"
        ],
        "negativeExamples": [
          "Port Number"
        ]
      },
      {
        "regExp": "(?i).*ip.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IP"
        ],
        "negativeExamples": [
          "Domain Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "0.0.0.0",
      "255.255.255.255",
      "1.2.3.4",
      "10.0.0.1",
      "172.16.254.1",
      "192.168.1.1",
      "8.8.8.8",
      "123.45.67.89"
    ],
    "negativeContentExamples": [
      "256.100.50.25",
      "192.168.01.1",
      "192.168.1",
      "192.168.1.1.5",
      "192.168.-1.1",
      "192.168.1.300",
      "192.168.1.1/24",
      "01.2.3.4"
    ],
    "positiveHeaderExamples": [
      "IP Address",
      "IPv4",
      "IP",
      "IPv4 Address",
      "Client IP",
      "Source IP Address",
      "Destination IPv4"
    ],
    "negativeHeaderExamples": [
      "Domain Name",
      "MAC Address",
      "Port Number",
      "Hostname",
      "Email Address",
      "URL",
      "Gateway MAC"
    ],
    "explanation": "This semantic type detects IPv4 addresses in dotted-decimal form with strict octet validation (0\u2013255) and disallows leading zeros in multi-digit octets. It is useful for identifying network endpoint data such as client, source, or destination IPs in logs and datasets.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:21.842349"
  },
  {
    "resultType": "generated",
    "semanticType": "PERIOD.YEAR_RANGE",
    "description": "A text field containing year ranges that typically follow the pattern of two four-digit years separated by a hyphen or slash, such as 1999-2000 or 2010/2015. The format represents temporal spans using standard year notation with a consistent separator to indicate the beginning and ending years of a time period.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{4}[-/]\\d{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3440,
    "headerPatterns": [
      {
        "regExp": "(?i).*fiscal.*year.*range.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fiscal_year_range"
        ],
        "negativeExamples": [
          "fiscal_year"
        ]
      },
      {
        "regExp": "(?i).*academic.*year.*range.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "academic year range"
        ],
        "negativeExamples": [
          "academic year"
        ]
      },
      {
        "regExp": "(?i).*year[_ -]?range.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Year Range"
        ],
        "negativeExamples": [
          "Year"
        ]
      },
      {
        "regExp": "(?i).*date[_ -]?range.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Date Range"
        ],
        "negativeExamples": [
          "Date"
        ]
      },
      {
        "regExp": "(?i).*range.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Range"
        ],
        "negativeExamples": [
          "Month"
        ]
      }
    ],
    "positiveContentExamples": [
      "1999-2000",
      "2010/2015",
      "2001-2001",
      "1987/1989",
      "1990-1995",
      "2020-2021",
      "1975/1976",
      "1900-1905"
    ],
    "negativeContentExamples": [
      "1999\u20132000",
      "1999 - 2000",
      "1999/ 2000",
      "1999/2000/2001",
      "99-2000",
      "20150-2016",
      "2016/201",
      "201a-201b"
    ],
    "positiveHeaderExamples": [
      "Year Range",
      "Years",
      "Date Range",
      "Fiscal Year Range",
      "Academic Year Range",
      "Calendar Year Range",
      "Reporting Year Range"
    ],
    "negativeHeaderExamples": [
      "Year",
      "Month",
      "Single Date",
      "Start Year",
      "End Year",
      "Date",
      "Quarter"
    ],
    "explanation": "Identifies values that represent a span of years expressed as two four-digit years separated by either a hyphen or a slash, with no surrounding spaces. Useful for labeling coverage periods, reporting windows, academic or fiscal spans, and other time intervals at the year granularity.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:22.934909"
  },
  {
    "resultType": "generated",
    "semanticType": "JOB_TITLE_EN",
    "description": "A text field containing professional job titles in English that follow common occupational naming conventions. Accepts alphabetic words with spaces and common professional punctuation (periods for abbreviations, slashes, hyphens, and ampersands), and may include hierarchical or specialization terms. Digits and underscores are not permitted.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z][A-Za-z.&/\\-]{1,}( [A-Za-z][A-Za-z.&/\\-]{1,}){0,6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3250,
    "headerPatterns": [
      {
        "regExp": "(?i).*job.*title.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Job Title"
        ],
        "negativeExamples": [
          "Job Start Date"
        ]
      },
      {
        "regExp": "(?i).*employee.*position.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Employee Position"
        ],
        "negativeExamples": [
          "Position Code"
        ]
      },
      {
        "regExp": "(?i).*occupation.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Occupation"
        ],
        "negativeExamples": [
          "Work Type"
        ]
      },
      {
        "regExp": "(?i).*role.*title.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Role Title"
        ],
        "negativeExamples": [
          "User Role"
        ]
      },
      {
        "regExp": "(?i).*position.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Position"
        ],
        "negativeExamples": [
          "Job Grade"
        ]
      },
      {
        "regExp": "(?i).*title.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Title"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "Software Engineer",
      "Senior Software Engineer",
      "Chief Financial Officer",
      "VP Marketing",
      "Director of Operations",
      "Head of Sales",
      "Junior Data Analyst",
      "QA Lead"
    ],
    "negativeContentExamples": [
      "Software Engineer 2",
      "Lead_Developer",
      "Manager (Contract)",
      "Engineer 3",
      "Sr. Dev, Backend",
      "123 Manager",
      "Product Owner - L2",
      "Caf\u00e9 Manager"
    ],
    "positiveHeaderExamples": [
      "Job Title",
      "Position",
      "Occupation",
      "Employee Position",
      "Role Title",
      "Title"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Company",
      "Salary",
      "Department",
      "Project Title",
      "Start Date"
    ],
    "explanation": "This semantic type detects English job titles composed of alphabetic tokens and commonly used professional punctuation such as periods, slashes, hyphens, and ampersands. It is suitable for columns describing a person's role, position, or occupation and excludes numerical levels or codes to avoid confusion with grade or pay-scale fields.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:23.155586"
  },
  {
    "resultType": "generated",
    "semanticType": "MACADDRESS",
    "description": "A hardware identifier with six pairs of hexadecimal digits separated consistently by either colons or hyphens, representing a 48-bit network interface address. Examples include formats like 00:1A:2B:3C:4D:5E or 01-23-45-67-89-AB.",
    "pluginType": "regex",
    "regexPattern": "\\b([0-9A-Fa-f]{2}(-[0-9A-Fa-f]{2}){5}|[0-9A-Fa-f]{2}(:[0-9A-Fa-f]{2}){5})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3290,
    "headerPatterns": [
      {
        "regExp": "(?i).*(device[ _-]*)?mac[ _-]*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "MAC Address"
        ],
        "negativeExamples": [
          "IP Address"
        ]
      },
      {
        "regExp": "(?i).*hardware[ _-]*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Hardware Address"
        ],
        "negativeExamples": [
          "Hardware ID"
        ]
      },
      {
        "regExp": "(?i).*(network|adapter)[ _-]*mac.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Network MAC"
        ],
        "negativeExamples": [
          "Network Name"
        ]
      },
      {
        "regExp": "(?i).*\\bmac\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "MAC"
        ],
        "negativeExamples": [
          "Device Name"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address"
        ],
        "negativeExamples": [
          "Customer Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "00:1A:2B:3C:4D:5E",
      "01-23-45-67-89-AB",
      "aa:bb:cc:dd:ee:ff",
      "A0:B1:C2:D3:E4:F5",
      "7C-4F-34-12-00-9A",
      "12:34:56:78:9A:BC",
      "0a-1b-2c-3d-4e-5f",
      "3F:5E:7D:9C:AB:10"
    ],
    "negativeContentExamples": [
      "01:23:45:67:89",
      "01:23:45:67:89:AB:CD",
      "0123:4567:89AB",
      "01:23:45:67:89:AG",
      "01-23:45-67:89-ab",
      "01.23.45.67.89.AB",
      "1:23:45:67:89:AB",
      "01-23-45-67-89"
    ],
    "positiveHeaderExamples": [
      "MAC Address",
      "Hardware Address",
      "Network MAC",
      "Device MAC Address",
      "Adapter MAC",
      "Physical Address",
      "NIC MAC",
      "Ethernet MAC"
    ],
    "negativeHeaderExamples": [
      "IP Address",
      "Device Name",
      "Network Name",
      "MAC Code",
      "Address Line 1",
      "Email Address",
      "Hardware ID",
      "IPv6 Address"
    ],
    "explanation": "This semantic type identifies 48-bit MAC addresses comprised of six hexadecimal octets separated by either all colons or all hyphens. It is useful for classifying network interface identifiers in inventory, telemetry, security logs, and device management datasets.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:24.584139"
  },
  {
    "resultType": "generated",
    "semanticType": "LANGUAGE.TEXT_EN",
    "description": "A text field containing full language names that follow standard English language naming conventions and typically use proper case formatting. The format consists of alphabetic characters and may include spaces for compound language names but excludes numerical codes or abbreviated forms.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z][a-z]+( [A-Z][a-z]+){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 3280,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bspoken\\b.*\\blanguage\\b.*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Spoken Language Name"
        ],
        "negativeExamples": [
          "Language Code"
        ]
      },
      {
        "regExp": "(?i).*\\bspoken\\b.*\\blanguage\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Spoken Language"
        ],
        "negativeExamples": [
          "Dialect"
        ]
      },
      {
        "regExp": "(?i).*\\blanguage\\b.*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Language Name"
        ],
        "negativeExamples": [
          "Country Name"
        ]
      },
      {
        "regExp": "(?i).*\\blanguage\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Language"
        ],
        "negativeExamples": [
          "Language Code"
        ]
      },
      {
        "regExp": "(?i).*\\blang\\b.*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Lang Name"
        ],
        "negativeExamples": [
          "Language"
        ]
      },
      {
        "regExp": "(?i).*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Language"
        ]
      }
    ],
    "positiveContentExamples": [
      "English",
      "Spanish",
      "Mandarin Chinese",
      "Brazilian Portuguese",
      "American English",
      "Old Church Slavonic",
      "Modern Greek",
      "Quebec French"
    ],
    "negativeContentExamples": [
      "EN",
      "en",
      "ENGLISH",
      "English-US",
      "Portuguese (Brazilian)",
      "es-ES",
      "English2",
      "Mandarin-Chinese"
    ],
    "positiveHeaderExamples": [
      "Language",
      "Language Name",
      "Spoken Language",
      "Primary Language",
      "Preferred Language",
      "Lang Name",
      "Native Language",
      "User Language"
    ],
    "negativeHeaderExamples": [
      "Language Code",
      "Country",
      "Dialect",
      "Locale",
      "Region",
      "Script",
      "Encoding",
      "Translation"
    ],
    "explanation": "This semantic type targets columns that contain full English language names, written in proper case with alphabetic tokens separated by single spaces. It excludes abbreviations, ISO codes, and values containing digits, hyphens, or parentheses. Typical use cases include user profile preferred language, survey response language, or content language fields.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:25.355415"
  },
  {
    "resultType": "generated",
    "semanticType": "PERIOD.HALF",
    "description": "A text field containing half-year identifiers that typically follow patterns like H1, H2, HY1, or descriptive phrases such as \"First Half 2024\" or \"Second Half FY21\". The format uses standard business and academic conventions for representing six-month periods with consistent abbreviation or descriptive formatting.",
    "pluginType": "regex",
    "regexPattern": "(\\b(H[12]|HY[12]|[12]H)([ -]([Ff][Yy])?\\d{2,4})?\\b|\\b([Ff][Yy])?\\d{2,4}[ -](H[12]|HY[12]|[12]H)\\b|\\b(First|first|1st|Second|second|2nd)\\s+[Hh]alf([ -]([Ff][Yy])?\\d{2,4})?\\b)",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 3420,
    "headerPatterns": [
      {
        "regExp": "(?i).*half[ _-]?year.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Half Year"
        ],
        "negativeExamples": [
          "Full Year"
        ]
      },
      {
        "regExp": "(?i).*year.*half.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Year Half"
        ],
        "negativeExamples": [
          "Year Quarter"
        ]
      },
      {
        "regExp": "(?i).*(h1|h2|hy1|hy2|1h|2h).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "H1 Indicator"
        ],
        "negativeExamples": [
          "Q1"
        ]
      },
      {
        "regExp": "(?i).*(first|second).*(half).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Second Half Period"
        ],
        "negativeExamples": [
          "First Quarter"
        ]
      },
      {
        "regExp": "(?i).*half.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Half"
        ],
        "negativeExamples": [
          "Quarter"
        ]
      }
    ],
    "positiveContentExamples": [
      "H1",
      "H2",
      "HY1",
      "HY2",
      "H1 2024",
      "2023 H2",
      "First Half 2022",
      "Second Half FY21"
    ],
    "negativeContentExamples": [
      "Q1",
      "H3",
      "Half 2023",
      "H 1",
      "Second 2023",
      "FY21",
      "Midyear 2020",
      "First Quarter 2022"
    ],
    "positiveHeaderExamples": [
      "Half Year",
      "Half",
      "Year Half",
      "H1 Indicator",
      "Second Half Period",
      "HY Code",
      "1H Label"
    ],
    "negativeHeaderExamples": [
      "Quarter",
      "Month",
      "Full Year",
      "Q1",
      "Semester",
      "Biannual Flag"
    ],
    "explanation": "This semantic type detects half-year designations commonly used in business and academic datasets, including concise abbreviations (H1, H2, HY1, HY2, 1H, 2H) and descriptive phrases like \"First Half\" or \"Second Half\" optionally paired with a year or fiscal year (FY). It is intended for fields that label six-month periods rather than specific dates or quarters.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:27.886863"
  },
  {
    "resultType": "generated",
    "semanticType": "HASH.SHA1_HEX",
    "description": "A text field containing SHA-1 hashes that follow the pattern of exactly 40 lowercase hexadecimal characters [a-f0-9]. The format represents cryptographic hash digests using lowercase hexadecimal encoding for consistent data integrity verification and digital fingerprinting.",
    "pluginType": "regex",
    "regexPattern": "\\b[a-f0-9]{40}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 99,
    "priority": 3030,
    "headerPatterns": [
      {
        "regExp": "(?i).*sha[-_ ]?1.*hash.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SHA1 Hash"
        ],
        "negativeExamples": [
          "SHA256 Hash"
        ]
      },
      {
        "regExp": "(?i).*sha[-_ ]?1.*(checksum|digest).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SHA1 Digest"
        ],
        "negativeExamples": [
          "SHA256 Digest"
        ]
      },
      {
        "regExp": "(?i).*(secure.*hash.*algorithm|\\bsha\\b).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Secure Hash Algorithm"
        ],
        "negativeExamples": [
          "Hash Algorithm"
        ]
      },
      {
        "regExp": "(?i).*(checksum|digest).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Checksum"
        ],
        "negativeExamples": [
          "Check Sum"
        ]
      },
      {
        "regExp": "(?i).*hash.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Hash"
        ],
        "negativeExamples": [
          "Digest"
        ]
      }
    ],
    "positiveContentExamples": [
      "da39a3ee5e6b4b0d3255bfef95601890afd80709",
      "2fd4e1c67a2d28fced849ee1bb76e7391b93eb12",
      "5baa61e4c9b93f3f0682250b6cf8331b7ee68fd8",
      "a94a8fe5ccb19ba61c4c0873d391e987982fbbd3",
      "356a192b7913b04c54574d18c28d46e6395428ab",
      "1f3870be274f6c49b3e31a0c6728957f5e5f7a11",
      "aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d",
      "a9993e364706816aba3e25717850c26c9cd0d89d"
    ],
    "negativeContentExamples": [
      "DA39A3EE5E6B4B0D3255BFEF95601890AFD80709",
      "da39a3ee5e6b4b0d3255bfef95601890afd8070g",
      "da39a3ee5e6b4b0d3255bfef95601890afd8070",
      "da39a3ee5e6b4b0d3255bfef95601890afd807090",
      "2fd4e1c67a2d28fc-ed849ee1bb76e7391b93eb12",
      "5baa61e4 c9b93f3f0682250b6cf8331b7ee68fd8",
      "A94a8fe5ccb19ba61c4c0873d391e987982fbbd3",
      "7c4a8d09ca3762af61e59520943dc26494f8941B"
    ],
    "positiveHeaderExamples": [
      "SHA1 Hash",
      "Hash",
      "Checksum",
      "SHA1",
      "SHA1 Digest",
      "Secure Hash Algorithm 1",
      "SHA1 Checksum"
    ],
    "negativeHeaderExamples": [
      "Filename",
      "File Size",
      "Password",
      "MD5 Hash",
      "SHA256 Hash",
      "Hashcode",
      "Check Sum"
    ],
    "explanation": "This semantic type identifies strings that are exactly 40 characters of lowercase hexadecimal, typical of SHA-1 cryptographic digests. It is useful for validating, profiling, and linking records by cryptographic fingerprints while avoiding false positives from other hash algorithms or formats.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:30.003664"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.AGE_RANGE",
    "description": "A text field containing age ranges that typically follow patterns like 1-3 digit numeric spans separated by a hyphen or dash (e.g., 18-24) or open-ended upper categories denoted with a plus sign (e.g., 65+). These values represent age brackets using numeric ranges or a numeric value followed by a plus to indicate 65 and older.",
    "pluginType": "regex",
    "regexPattern": "\\b([0-9]{1,3}\\s*[-\u2013\u2014]\\s*[0-9]{1,3}|[0-9]{1,3}\\s*\\+)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 3460,
    "headerPatterns": [
      {
        "regExp": "(?i).*age.*range.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Age Range"
        ],
        "negativeExamples": [
          "Age"
        ]
      },
      {
        "regExp": "(?i).*age.*group.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Age Group"
        ],
        "negativeExamples": [
          "User Group"
        ]
      },
      {
        "regExp": "(?i).*age.*bracket.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Age Bracket"
        ],
        "negativeExamples": [
          "Tax Bracket"
        ]
      },
      {
        "regExp": "(?i).*age.*band.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Age Band"
        ],
        "negativeExamples": [
          "Band Name"
        ]
      },
      {
        "regExp": "(?i).*age.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Age"
        ],
        "negativeExamples": [
          "Birth Year"
        ]
      }
    ],
    "positiveContentExamples": [
      "0-4",
      "5 - 9",
      "10-14",
      "15\u201319",
      "20 \u2014 29",
      "65+",
      "85 +",
      "100+"
    ],
    "negativeContentExamples": [
      "34",
      "18 to 24",
      "Under 18",
      "65 plus",
      "+65",
      " - 65",
      "2000-2005",
      "12_17"
    ],
    "positiveHeaderExamples": [
      "Age Range",
      "Age Group",
      "Age Bracket",
      "Age Band",
      "Age Bin",
      "Age Rng"
    ],
    "negativeHeaderExamples": [
      "Age",
      "Birth Year",
      "Name",
      "DOB",
      "Year of Birth",
      "Tax Bracket",
      "User Age",
      "Age Value"
    ],
    "explanation": "This semantic type identifies age bracket values commonly expressed as numeric ranges with a hyphen or dash, or as an open-ended upper category with a plus sign (e.g., 65+). It is useful for segmenting populations into age groups for analytics, reporting, and demographic classification.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:33.107764"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.RACE_EN",
    "description": "A text field containing racial and ethnic terms that follow standard demographic category terminology and use proper case formatting for established classification systems. The format consists of alphabetic characters representing recognized racial and ethnic designations as commonly used in official demographic and census contexts.",
    "pluginType": "regex",
    "regexPattern": "\\b(American Indian or Alaska Native|Black or African American|Native Hawaiian or Other Pacific Islander|Hispanic or Latino|Not Hispanic or Latino|Two or More Races|Middle Eastern or North African|White|Asian|Asian Indian|Chinese|Filipino|Japanese|Korean|Vietnamese|Other Asian|Guamanian or Chamorro|Samoan|Other Pacific Islander|Some Other Race)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 3500,
    "headerPatterns": [
      {
        "regExp": "(?i).*(race.*ethnic|ethnic.*race).*(group|category).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Race and Ethnicity Group"
        ],
        "negativeExamples": [
          "Racial Group"
        ]
      },
      {
        "regExp": "(?i).*(racial.*group|ethnic.*group).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Racial Group"
        ],
        "negativeExamples": [
          "Race Code"
        ]
      },
      {
        "regExp": "(?i).*(race.*ethnic|ethnic.*race).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Race and Ethnicity"
        ],
        "negativeExamples": [
          "Nationality"
        ]
      },
      {
        "regExp": "(?i).*(racial|ethnic).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Ethnicity"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(race|ethnicity).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Race"
        ],
        "negativeExamples": [
          "Citizenship"
        ]
      }
    ],
    "positiveContentExamples": [
      "White",
      "Black or African American",
      "American Indian or Alaska Native",
      "Native Hawaiian or Other Pacific Islander",
      "Hispanic or Latino",
      "Not Hispanic or Latino",
      "Two or More Races",
      "Middle Eastern or North African"
    ],
    "negativeContentExamples": [
      "white",
      "BLACK",
      "White/Caucasian",
      "African-American",
      "Hispanic and Latino",
      "Not Hispanic Latino",
      "Middle Eastern & North African",
      "Native Hawaiian/Other Pacific Islander"
    ],
    "positiveHeaderExamples": [
      "Race",
      "Ethnicity",
      "Racial Group",
      "Race and Ethnicity",
      "Racial Category",
      "Ethnic Group",
      "Ethnic Origin",
      "Race Group"
    ],
    "negativeHeaderExamples": [
      "Race Code",
      "Nationality",
      "Country",
      "Citizenship",
      "Language",
      "Gender",
      "Age",
      "ISO Country Code"
    ],
    "explanation": "This semantic type identifies English-language race and ethnicity descriptors commonly used in demographic and census data collection, emphasizing proper case and standard category phrases. It is useful for classifying survey responses or master data fields that store racial or ethnic identity values.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:33.353733"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_CA",
    "description": "A postal identifier following the pattern ^[A-Z]\\d[A-Z] \\d[A-Z]\\d$ with alternating letters and numbers in a letter-digit-letter space digit-letter-digit format. The format uses uppercase letters and single digits with a mandatory space separator between the first three and last three characters.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]\\d[A-Z] \\d[A-Z]\\d\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3540,
    "headerPatterns": [
      {
        "regExp": "(?i).*(canadian postal code|canadian postcode|canadian zip).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Canadian ZIP"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*(canada|ca).*(postal|post).*code.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "CA Postal Code"
        ],
        "negativeExamples": [
          "Postcode"
        ]
      },
      {
        "regExp": "(?i).*postcode.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Postcode"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*postal.*code.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "Province"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "K1A 0B1",
      "H0H 0H0",
      "V6E 1Z4",
      "M5V 2T6",
      "T2N 1N4",
      "B3J 3X8",
      "R2C 4A7",
      "S7K 5L3"
    ],
    "negativeContentExamples": [
      "K1A0B1",
      "k1a 0b1",
      "K1 0B1",
      "K1A-0B1",
      "K1A 0BB",
      "KK1 0B1",
      "K11 0B1",
      "K1A 00B"
    ],
    "positiveHeaderExamples": [
      "Postal Code",
      "Postcode",
      "Canadian ZIP",
      "CA Postal Code",
      "Canada Postal Code",
      "Postal Code (CA)",
      "Canadian Postcode",
      "Post Code"
    ],
    "negativeHeaderExamples": [
      "City",
      "Province",
      "Address",
      "ZIP Code",
      "Country",
      "Street",
      "State",
      "Region"
    ],
    "explanation": "This semantic type identifies Canadian-style postal codes in the letter-digit-letter space digit-letter-digit format with uppercase letters and a mandatory single space separator. It is useful for validating, profiling, and standardizing postal address data fields where Canadian postal codes are expected, and for differentiating these from other postal/ZIP formats.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:37.268221"
  },
  {
    "resultType": "generated",
    "semanticType": "MONTH.ABBR_<LOCALE>",
    "description": "A text field containing English month abbreviations. Values are exactly three alphabetic characters (A\u2013Z) representing the months Jan\u2013Dec, formatted without punctuation or trailing periods. This variant follows EN locale conventions and uses strict three-letter forms (e.g., JAN, FEB, MAR).",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "JAN",
      "FEB",
      "MAR",
      "APR",
      "MAY",
      "JUN",
      "JUL",
      "AUG",
      "SEP",
      "OCT",
      "NOV",
      "DEC"
    ],
    "backout": "^[A-Za-z]{3}$",
    "confidenceThreshold": 96,
    "priority": 3300,
    "headerPatterns": [
      {
        "regExp": "(?i).*month.*abbr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Month Abbr"
        ],
        "negativeExamples": [
          "Month Name"
        ]
      },
      {
        "regExp": "(?i).*month.*abbreviation.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Month Abbreviation"
        ],
        "negativeExamples": [
          "Month Number"
        ]
      },
      {
        "regExp": "(?i).*month.*short.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Month Short"
        ],
        "negativeExamples": [
          "Short Year"
        ]
      },
      {
        "regExp": "(?i).*abbreviated.*month.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Abbreviated Month"
        ],
        "negativeExamples": [
          "Month Abbr"
        ]
      },
      {
        "regExp": "(?i).*month.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Month"
        ],
        "negativeExamples": [
          "Year"
        ]
      }
    ],
    "positiveContentExamples": [
      "JAN",
      "FEB",
      "MAR",
      "APR",
      "MAY",
      "JUN",
      "JUL",
      "AUG"
    ],
    "negativeContentExamples": [
      "SEPT",
      "JAN.",
      "FEBR",
      "MAR1",
      "AUGUST",
      "JLY",
      "DECEMBER",
      "OCT."
    ],
    "positiveHeaderExamples": [
      "Month Abbr",
      "Month",
      "Month Short",
      "Month Abbreviation",
      "Abbreviated Month",
      "Short Month",
      "Month 3-Letter"
    ],
    "negativeHeaderExamples": [
      "Month Name",
      "Day",
      "Year",
      "Month Full",
      "Month Number",
      "Weekday",
      "Date",
      "Short Year"
    ],
    "explanation": "This semantic type identifies columns that contain English three-letter month abbreviations without punctuation, suitable for datasets storing compact month labels. It uses a finite list of 12 canonical values to ensure precision, with a backout pattern that enforces the exact three-letter shape. Useful for validating, profiling, or standardizing month abbreviation fields where the EN locale is intended.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:38.047495"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_IN",
    "description": "Indian PIN codes consisting of exactly six consecutive numeric digits with no spaces, hyphens, or letters. This type identifies six-digit postal indexing numbers used in India for mail routing and address validation.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 3590,
    "headerPatterns": [
      {
        "regExp": "(?i).*india[ _-]*pin[ _-]*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "India PIN Code"
        ],
        "negativeExamples": [
          "PIN Code"
        ]
      },
      {
        "regExp": "(?i).*indian[ _-]*postal[ _-]*code.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Indian Postal Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*(pin[ _-]*code|pincode).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "PIN Code"
        ],
        "negativeExamples": [
          "ZIP"
        ]
      },
      {
        "regExp": "(?i).*postal[ _-]*code.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*zip.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "ZIP"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "110001",
      "560001",
      "400703",
      "700001",
      "226010",
      "380015",
      "641045",
      "500081"
    ],
    "negativeContentExamples": [
      "56001",
      "5600010",
      "56 0001",
      "560-001",
      "PIN560001",
      "560001A",
      "A560001",
      "560O01"
    ],
    "positiveHeaderExamples": [
      "PIN Code",
      "Postal Code",
      "ZIP",
      "India PIN Code",
      "Indian Postal Code",
      "Pincode",
      "ZIP Code",
      "Delivery Postal Code"
    ],
    "negativeHeaderExamples": [
      "City",
      "State",
      "Address",
      "Country",
      "Street Name",
      "Phone Number",
      "Customer ID",
      "Order Number"
    ],
    "explanation": "This semantic type targets Indian PIN codes, which are exactly six consecutive digits and do not include spaces, hyphens, or letters. It is useful for validating and classifying address fields related to Indian postal delivery and for normalizing location-based data used in logistics and geocoding.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:39.126734"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.RACE_ABBR_EN",
    "description": "A text field containing race abbreviations that typically follow the pattern of one or two uppercase letters. The format represents standardized racial and ethnic category codes using conventional abbreviation systems for demographic data collection and analysis.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{1,2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3490,
    "headerPatterns": [
      {
        "regExp": "(?i).*race.*abbr.*code.*",
        "confidence": 99,
        "mandatory": true,
        "positiveExamples": [
          "race_abbr_code"
        ],
        "negativeExamples": [
          "Race Code"
        ]
      },
      {
        "regExp": "(?i).*(race|ethnicity).*(abbr|abbrev).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Race Abbr"
        ],
        "negativeExamples": [
          "Ethnicity Code"
        ]
      },
      {
        "regExp": "(?i).*(race|ethnicity).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Ethnicity Code"
        ],
        "negativeExamples": [
          "Race"
        ]
      },
      {
        "regExp": "(?i).*(race|eth).*(cd|code).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "race_cd"
        ],
        "negativeExamples": [
          "Nationality Code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "W",
      "B",
      "A",
      "H",
      "N",
      "O",
      "AI",
      "PI"
    ],
    "negativeContentExamples": [
      "HIS",
      "as",
      "w",
      "A1",
      "2B",
      "A B",
      "B-",
      "\u00c9"
    ],
    "positiveHeaderExamples": [
      "Race Code",
      "Ethnicity Code",
      "Race Abbr",
      "race_abbr_code",
      "ethnicity_abbrev",
      "race_cd",
      "eth_code",
      "race abbreviation"
    ],
    "negativeHeaderExamples": [
      "Race",
      "Ethnicity",
      "Nationality",
      "race description",
      "country code",
      "gender code",
      "region code",
      "ethnicity detail"
    ],
    "explanation": "This semantic type targets compact race/ethnicity abbreviations represented by one or two uppercase letters, suitable for demographic datasets where codes are stored as concise tokens. It intentionally excludes lowercase, mixed-case, numeric, punctuated, or length >2 tokens to avoid collisions with general identifiers or free text.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:39.383689"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_AU",
    "description": "A postal identifier consisting of exactly four consecutive numerical digits, representing the Australian postcode structure. Values typically range from 1000 to 9999 depending on geographic location.",
    "pluginType": "regex",
    "regexPattern": "\\b[1-9][0-9]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 3520,
    "headerPatterns": [
      {
        "regExp": "(?i).*(australia|aus|au).*(post.?code|postcode).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "AUS Postal Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*post.*code.*au.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code AU"
        ],
        "negativeExamples": [
          "Postal Code EU"
        ]
      },
      {
        "regExp": "(?i).*(delivery|recipient|billing).*(post.?code|postcode).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Delivery Post Code"
        ],
        "negativeExamples": [
          "Delivery City"
        ]
      },
      {
        "regExp": "(?i).*(post.?code|postcode).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postcode"
        ],
        "negativeExamples": [
          "Postal Zone"
        ]
      },
      {
        "regExp": "(?i).*zip.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ZIP"
        ],
        "negativeExamples": [
          "Postcode"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "2000",
      "2150",
      "3000",
      "4067",
      "4217",
      "5000",
      "6000",
      "7000"
    ],
    "negativeContentExamples": [
      "200",
      "10000",
      "20-00",
      "20 00",
      "2O00",
      "12.34",
      "0999",
      "A200"
    ],
    "positiveHeaderExamples": [
      "Postal Code",
      "Postcode",
      "ZIP",
      "AU Postcode",
      "AUS Postal Code",
      "Delivery Postcode",
      "Recipient Post Code",
      "Billing Postcode"
    ],
    "negativeHeaderExamples": [
      "City",
      "State",
      "Address",
      "Country",
      "Region",
      "Street",
      "Province",
      "ZIP+4"
    ],
    "explanation": "This semantic type identifies Australian postcodes represented as exactly four digits in the range 1000\u20139999. It is suitable for columns containing standalone AU postal codes and can be paired with AU-specific header patterns to increase precision.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:39.476409"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_BG",
    "description": "A postal identifier following the pattern ^\\d{4}$ consisting of exactly four consecutive numerical digits. The format represents Bulgarian postal code structure with systematic numbering for different regions and municipalities throughout the country.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 3530,
    "headerPatterns": [
      {
        "regExp": "(?i).*(bg|bulgarian).*(postal|post).*(code|postcode).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postal_code_bg"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*\u043f\u043e\u0449\u0435\u043d\u0441\u043a\u0438.*\u043a\u043e\u0434.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u041f\u043e\u0449\u0435\u043d\u0441\u043a\u0438 \u043a\u043e\u0434"
        ],
        "negativeExamples": [
          "\u0413\u0440\u0430\u0434"
        ]
      },
      {
        "regExp": "(?i).*(postal|post).*(code|postcode).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*(zip|postcode|pcode).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Postcode"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "City"
        ]
      }
    ],
    "positiveContentExamples": [
      "1000",
      "1680",
      "2306",
      "4023",
      "5300",
      "7001",
      "9002",
      "0105"
    ],
    "negativeContentExamples": [
      "123",
      "12345",
      "12 34",
      "12-34",
      "12_34",
      "000a",
      "1O34",
      "000 0"
    ],
    "positiveHeaderExamples": [
      "\u041f\u043e\u0449\u0435\u043d\u0441\u043a\u0438 \u043a\u043e\u0434",
      "Postal Code",
      "Code",
      "BG Postal Code",
      "Postcode",
      "ZIP"
    ],
    "negativeHeaderExamples": [
      "\u0413\u0440\u0430\u0434",
      "City",
      "Address",
      "Country",
      "Street",
      "Region"
    ],
    "explanation": "This semantic type detects Bulgarian postal codes represented as exactly four consecutive digits. It is useful for validating and classifying columns that store Bulgaria-specific postal identifiers, aiding geocoding, address normalization, and data quality checks. The header patterns prioritize explicit Bulgarian context, followed by generic postal/postcode terms and a final primitive pattern for 'code' to ensure flexible yet controlled matching.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:40.903146"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_JA",
    "description": "This type matches the regex pattern ^[0-9]{3}-[0-9]{4}$ representing Japanese postal codes with hyphen formatting. The format consists of three digits, followed by a hyphen, then four more digits, creating a seven-digit code with mandatory hyphen separation.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{3}-[0-9]{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3600,
    "headerPatterns": [
      {
        "regExp": "(?i).*(jp|japan).*(postal|zip).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Japan Postal Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*(postal|post).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "Post Number"
        ]
      },
      {
        "regExp": "(?i).*\u90f5\u4fbf.*\u756a\u53f7.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u90f5\u4fbf\u756a\u53f7"
        ],
        "negativeExamples": [
          "\u90f5\u4fbf\u5c40"
        ]
      },
      {
        "regExp": "(?i).*zip.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ZIP"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "100-0001",
      "060-0001",
      "150-8565",
      "530-0001",
      "904-0204",
      "980-8577",
      "810-0001",
      "003-0001"
    ],
    "negativeContentExamples": [
      "1000001",
      "10-00001",
      "1000-001",
      "123\u20114567",
      "\uff11\uff12\uff13-\uff14\uff15\uff16\uff17",
      "A23-4567",
      "123-456A",
      "123 4567"
    ],
    "positiveHeaderExamples": [
      "\u90f5\u4fbf\u756a\u53f7",
      "Postal Code",
      "ZIP Code",
      "JP Postal Code",
      "Japan ZIP Code",
      "Postcode",
      "ZIP",
      "PostalCode"
    ],
    "negativeHeaderExamples": [
      "\u90fd\u5e02",
      "City",
      "Address",
      "Postal Area",
      "Post Number",
      "Country",
      "Province",
      "Location"
    ],
    "explanation": "Japanese postal codes are seven digits in a strict 3-4 format separated by a hyphen (e.g., 123-4567). This semantic type is intended to recognize columns and values that specifically contain such formatted postal codes, supporting both English and Japanese header conventions while avoiding over-broad matches.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:41.111166"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_FR",
    "description": "Identifies French postal codes consisting of exactly five digits with no separators or letters. Valid values are five consecutive numeric digits only.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 3580,
    "headerPatterns": [
      {
        "regExp": "(?i).*(france|french|fr).*(postal.*code|code.*postal).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "French Postal Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*(code.*postal|postal.*code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code Postal"
        ],
        "negativeExamples": [
          "Area Code"
        ]
      },
      {
        "regExp": "(?i).*postcode.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postcode"
        ],
        "negativeExamples": [
          "Post Code"
        ]
      },
      {
        "regExp": "(?i).*\\bcp\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CP"
        ],
        "negativeExamples": [
          "CPN"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "01000",
      "75001",
      "13008",
      "22300",
      "97100",
      "97435",
      "20090",
      "59155"
    ],
    "negativeContentExamples": [
      "7500",
      "075001",
      "75 001",
      "75-001",
      "7500A",
      "A7501",
      "75001.",
      "75001FR"
    ],
    "positiveHeaderExamples": [
      "Code Postal",
      "CP",
      "Postal Code",
      "French Postal Code",
      "FR Code Postal",
      "Postcode",
      "CodePostal",
      "FR Postal Code"
    ],
    "negativeHeaderExamples": [
      "Ville",
      "City",
      "Address",
      "Area Code",
      "Zip+4",
      "State Code",
      "Customer Code",
      "Phone Number"
    ],
    "explanation": "This semantic type detects French postal codes, which are exactly five digits with no spaces, hyphens, or letters. It is useful for validating and standardizing address-related fields specifically containing French postal codes.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:41.575088"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.YEAR_OF_BIRTH",
    "description": "A numeric field containing birth years that follow the pattern of exactly four digits representing calendar years. The format uses standard four-digit year notation typically ranging from approximately 1900 to the current year for living persons.",
    "pluginType": "regex",
    "regexPattern": "\\b(19[0-9]{2}|200[0-9]|201[0-9]|202[0-5])\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 3510,
    "headerPatterns": [
      {
        "regExp": "(?i).*(year.*of.*birth|birth.*year|year.*born|born.*year).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Year of Birth"
        ],
        "negativeExamples": [
          "Current Year"
        ]
      },
      {
        "regExp": "(?i).*(person|applicant|candidate).*(year|yr).*(birth|born).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Person Birth Year"
        ],
        "negativeExamples": [
          "Date of Birth"
        ]
      },
      {
        "regExp": "(?i).*(yob|birth[_ ]?yr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "YOB"
        ],
        "negativeExamples": [
          "Year"
        ]
      },
      {
        "regExp": "(?i).*(yr.*of.*birth|yr.*birth|birth.*yr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Yr of Birth"
        ],
        "negativeExamples": [
          "Age"
        ]
      },
      {
        "regExp": "(?i).*year.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Year"
        ],
        "negativeExamples": [
          "Age"
        ]
      }
    ],
    "positiveContentExamples": [
      "1900",
      "1935",
      "1959",
      "1978",
      "1984",
      "1999",
      "2003",
      "2024"
    ],
    "negativeContentExamples": [
      "1899",
      "0000",
      "2100",
      "2026",
      "197",
      "20015",
      "19O5",
      "98"
    ],
    "positiveHeaderExamples": [
      "Birth Year",
      "Year Born",
      "Year of Birth",
      "Birth Yr",
      "Yr of Birth",
      "YOB",
      "Person Birth Year"
    ],
    "negativeHeaderExamples": [
      "Age",
      "Date of Birth",
      "Current Year",
      "Graduation Year",
      "Fiscal Year",
      "Hire Year",
      "Manufacture Year"
    ],
    "explanation": "This semantic type identifies standalone four-digit years that represent a person's year of birth, constrained to a realistic living-person range. It is useful for validating and classifying columns that store birth year values distinctly from full dates or ages.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:42.108385"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_NL",
    "description": "Dutch postal code with mandatory space: four digits, one space, and two uppercase letters. Matches values like \"1234 AB\" only, with no additional characters or separators.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{4} [A-Z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3620,
    "headerPatterns": [
      {
        "regExp": "(?i).*(nl|dutch).*(postal|post).*(code|postcode).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "NL Postal Code"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*(postal|post).*(code|postcode).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "Postal Address"
        ]
      },
      {
        "regExp": "(?i).*zipcode.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Zipcode"
        ],
        "negativeExamples": [
          "Zip Area"
        ]
      },
      {
        "regExp": "(?i).*zip.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "ZIP"
        ],
        "negativeExamples": [
          "Zone"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "city"
        ]
      }
    ],
    "positiveContentExamples": [
      "1011 AB",
      "1234 CD",
      "5678 EF",
      "7501 GH",
      "8900 JK",
      "2302 LM",
      "4003 NP",
      "9999 ZZ"
    ],
    "negativeContentExamples": [
      "1234AB",
      "1234 ab",
      "12345 AB",
      "1234 ABC",
      "AB 1234",
      "1234-AB",
      "0123 A1",
      "123 AB"
    ],
    "positiveHeaderExamples": [
      "Postcode",
      "Postal Code",
      "ZIP",
      "Zipcode",
      "NL Postal Code",
      "Dutch Postcode",
      "PostalCode",
      "Post code"
    ],
    "negativeHeaderExamples": [
      "Stad",
      "City",
      "Address",
      "Street",
      "Province",
      "Town",
      "Region",
      "Address Line"
    ],
    "explanation": "This semantic type identifies Dutch postal codes that follow the strict pattern of four digits, a space, and two uppercase letters. It is suitable for validating and classifying columns containing Netherlands postal codes, ensuring consistent formatting with a single space separator and uppercase letters.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:42.403244"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_CO",
    "description": "A postal identifier consisting of exactly six consecutive numerical digits. The format represents Colombian postal code structure with systematic numbering for different departments and municipalities throughout the country.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 3550,
    "headerPatterns": [
      {
        "regExp": "(?i).*colombia.*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Colombia Postal Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*(c[o\u00f3]digo postal).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "C\u00f3digo Postal"
        ],
        "negativeExamples": [
          "Postal Address"
        ]
      },
      {
        "regExp": "(?i).*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*(zip).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ZIP"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CO Postal Code"
        ],
        "negativeExamples": [
          "Postal"
        ]
      }
    ],
    "positiveContentExamples": [
      "110111",
      "050020",
      "760001",
      "130005",
      "680006",
      "080020",
      "540033",
      "250001"
    ],
    "negativeContentExamples": [
      "11011",
      "1101111",
      "110 111",
      "110-111",
      "011O11",
      "A10111",
      "11,0111",
      "11011."
    ],
    "positiveHeaderExamples": [
      "C\u00f3digo Postal",
      "Postal Code",
      "ZIP",
      "CO Postal Code",
      "Codigo Postal",
      "Zip Code",
      "ZipCode",
      "Post Code"
    ],
    "negativeHeaderExamples": [
      "Ciudad",
      "City",
      "Address",
      "Postal Address",
      "Country Code",
      "Province",
      "Phone Number",
      "Region"
    ],
    "explanation": "This semantic type identifies Colombian postal codes as a six-digit numeric token, suitable for validating and classifying columns containing Colombian ZIP/postal codes. It is useful for data quality checks, normalization, and geo-enrichment workflows where postal codes need to be recognized and validated based on structure alone.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:43.950558"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.FIRST_LAST",
    "description": "A text field containing complete names that follow the pattern ^[A-Za-z'-]+ [A-Za-z'-]+$ with first and last names separated by a single space. The format allows alphabetic characters, apostrophes, and hyphens in both name components but excludes numerical digits, titles, or multiple middle names.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z]+(['-][A-Za-z]+)* [A-Za-z]+(['-][A-Za-z]+)*\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3340,
    "headerPatterns": [
      {
        "regExp": "(?i).*person.*full.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Person Full Name"
        ],
        "negativeExamples": [
          "Person Name"
        ]
      },
      {
        "regExp": "(?i).*(customer|employee|person).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Customer Name"
        ],
        "negativeExamples": [
          "Username"
        ]
      },
      {
        "regExp": "(?i).*full[ _-]?name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Full Name"
        ],
        "negativeExamples": [
          "First Name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Email Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "John Smith",
      "Anne-Marie O'Neil",
      "D'Angelo Torres",
      "Mary-Jane Carter",
      "Sean O'Connor",
      "Jean-Luc Martin",
      "Chloe-Beth Adams",
      "Erin O'Reilly"
    ],
    "negativeContentExamples": [
      "John A. Smith",
      "John  Smith",
      "Mr. John Smith",
      "Smith, John",
      "John",
      "John Smith Jr.",
      "John-Smith",
      "John Smith3"
    ],
    "positiveHeaderExamples": [
      "Full Name",
      "Name",
      "Person Name",
      "Customer Full Name",
      "Employee Name",
      "User Full Name"
    ],
    "negativeHeaderExamples": [
      "First Name",
      "Last Name",
      "Email Address",
      "Middle Name",
      "Username",
      "Company Name"
    ],
    "explanation": "This semantic type identifies two-token personal names that contain only letters with optional internal apostrophes or hyphens, separated by exactly one space. It excludes titles, suffixes, initials, middle names, extra spaces, digits, and punctuation formats like commas. Typical use cases include validating user-entered full names in forms and enforcing a consistent 'first last' format for person records.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:45.035690"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.DATE_OF_BIRTH",
    "description": "A date field containing birth dates that may follow various patterns like yyyy-mm-dd or dd/mm/yyyy depending on regional formatting conventions. The format includes complete date information with year, month, and day components using standardized separators and date ordering systems.",
    "pluginType": "regex",
    "regexPattern": "\\b((19|20)\\d{2}[-/.](0[1-9]|1[0-2])[-/.](0[1-9]|[12]\\d|3[01])|(0[1-9]|[12]\\d|3[01])[-/.](0[1-9]|1[0-2])[-/.](19|20)\\d{2})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 3470,
    "headerPatterns": [
      {
        "regExp": "(?i).*date.*of.*birth.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Date of Birth"
        ],
        "negativeExamples": [
          "Birth Year"
        ]
      },
      {
        "regExp": "(?i).*birth.*date.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Birth Date"
        ],
        "negativeExamples": [
          "Hire Date"
        ]
      },
      {
        "regExp": "(?i).*\\bdob\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "DOB"
        ],
        "negativeExamples": [
          "Job Title"
        ]
      },
      {
        "regExp": "(?i).*person.*birth.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Person Birth Date"
        ],
        "negativeExamples": [
          "Birth Date"
        ]
      },
      {
        "regExp": "(?i).*date.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Date"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "1984-07-12",
      "07/12/1984",
      "12/31/1984",
      "31-01-1999",
      "1990/12/01",
      "2001.01.09",
      "28.02.1985",
      "2015-06-30"
    ],
    "negativeContentExamples": [
      "1984-7-12",
      "7/12/1984",
      "12/31/84",
      "19840712",
      "31-13-1999",
      "00/12/1990",
      "1990-00-15",
      "1999.11.3"
    ],
    "positiveHeaderExamples": [
      "Date of Birth",
      "Birth Date",
      "DOB",
      "Birthdate",
      "Person DOB",
      "Employee Date of Birth",
      "Person Birth Date",
      "Date"
    ],
    "negativeHeaderExamples": [
      "Age",
      "Birth Year",
      "Name",
      "Hire Date",
      "Anniversary Date",
      "SSN",
      "Parent Name",
      "Start Date"
    ],
    "explanation": "This semantic type identifies fields that store a person's full date of birth in numeric formats with clear separators. It supports year-first and day/month-first conventions using -, /, or . between components, with zero-padded month and day to reduce ambiguity. Typical uses include personal records, HR datasets, and customer profiles where a complete birth date is required.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:45.680597"
  },
  {
    "resultType": "generated",
    "semanticType": "MONTH.DIGITS",
    "description": "A numeric field following the pattern 1\u201312 representing months as integers between 1 and 12. The format uses standard calendar numbering where January equals 1 and December equals 12, with no leading zeros or additional formatting.",
    "pluginType": "regex",
    "regexPattern": "\\b(1[0-2]|[1-9])\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 3310,
    "headerPatterns": [
      {
        "regExp": "(?i).*(numeric|digit|int).*month.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Numeric Month"
        ],
        "negativeExamples": [
          "Month Name"
        ]
      },
      {
        "regExp": "(?i).*month.*(number|num|#).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Month Number"
        ],
        "negativeExamples": [
          "Month Name"
        ]
      },
      {
        "regExp": "(?i).*(calendar|fiscal).*month.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Calendar Month"
        ],
        "negativeExamples": [
          "Day"
        ]
      },
      {
        "regExp": "(?i).*(mth|mnth|mon).*(num|no|#).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "mth num"
        ],
        "negativeExamples": [
          "Month Name"
        ]
      },
      {
        "regExp": "(?i).*month.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "Month"
        ],
        "negativeExamples": [
          "Year"
        ]
      }
    ],
    "positiveContentExamples": [
      "1",
      "2",
      "3",
      "4",
      "7",
      "8",
      "10",
      "12"
    ],
    "negativeContentExamples": [
      "0",
      "13",
      "01",
      "2012",
      "9am",
      "A12B",
      "Q9",
      "Jan"
    ],
    "positiveHeaderExamples": [
      "Month",
      "Month Number",
      "Numeric Month",
      "Month Num",
      "Month #",
      "Month Index",
      "Calendar Month"
    ],
    "negativeHeaderExamples": [
      "Month Name",
      "Day",
      "Year",
      "Month Text",
      "Month Label",
      "Week",
      "Quarter"
    ],
    "explanation": "Identifies numeric month values represented as integers from 1 to 12 without leading zeros or additional formatting. Useful for columns storing calendar months as plain numbers rather than names or codes. The regex uses word boundaries to ensure isolated numeric tokens and avoids matching embedded digits within larger tokens.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:45.871281"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_DE",
    "description": "A postal identifier following the pattern ^\\d{5}$ consisting of exactly five consecutive numerical digits. The format represents German postal code structure with systematic geographic numbering where the first digit indicates the postal region and subsequent digits narrow down to specific delivery areas.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3560,
    "headerPatterns": [
      {
        "regExp": "(?i).*(de|germany|german).*(postleitzahl|plz|postal.*code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "DE Postleitzahl"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*german.*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "German Postal Code"
        ],
        "negativeExamples": [
          "German City"
        ]
      },
      {
        "regExp": "(?i).*(postleitzahl|plz).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "PLZ"
        ],
        "negativeExamples": [
          "Postal Address"
        ]
      },
      {
        "regExp": "(?i).*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "Area Code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "City"
        ]
      }
    ],
    "positiveContentExamples": [
      "10115",
      "01067",
      "20095",
      "50667",
      "80331",
      "90402",
      "04109",
      "68159"
    ],
    "negativeContentExamples": [
      "1011",
      "101150",
      "10 115",
      "101-15",
      "1234A",
      "A12345",
      "12.345",
      "123 45"
    ],
    "positiveHeaderExamples": [
      "Postleitzahl",
      "PLZ",
      "Postal Code",
      "German Postal Code",
      "DE Postleitzahl",
      "PLZ DE",
      "Postleitzahl Deutschland",
      "Germany Postal Code"
    ],
    "negativeHeaderExamples": [
      "Stadt",
      "City",
      "Address",
      "Postal Address",
      "Region Code",
      "City Code",
      "Country Code",
      "ZIP"
    ],
    "explanation": "This semantic type identifies German postal codes composed of exactly five digits as a standalone token, accommodating leading zeros. It is useful for validating and classifying columns containing German PLZ values in address datasets and logistics systems.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:46.107839"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.MARITAL_STATUS_EN",
    "description": "A text field containing marital status terms that typically follow standard categorical values and use proper case formatting for relationship designations. The format consists of established marital status terminology such as standard legal and demographic categories without numerical codes or abbreviated forms.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "SINGLE",
      "NEVER MARRIED",
      "MARRIED",
      "LEGALLY SEPARATED",
      "SEPARATED",
      "DIVORCED",
      "WIDOWED",
      "CIVIL UNION",
      "DOMESTIC PARTNER",
      "DOMESTIC PARTNERSHIP",
      "REGISTERED PARTNERSHIP",
      "ANNULLED",
      "IN A RELATIONSHIP",
      "PARTNERED"
    ],
    "backout": "^\\p{IsUppercase}[A-Z ]{1,49}$",
    "confidenceThreshold": 93,
    "priority": 3480,
    "headerPatterns": [
      {
        "regExp": "(?i).*(marital|marriage).*status.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Marital Status"
        ],
        "negativeExamples": [
          "Relationship Type"
        ]
      },
      {
        "regExp": "(?i).*relationship.*status.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Relationship Status"
        ],
        "negativeExamples": [
          "Status Code"
        ]
      },
      {
        "regExp": "(?i).*(marital|marriage).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Marriage Status"
        ],
        "negativeExamples": [
          "Gender"
        ]
      },
      {
        "regExp": "(?i).*rel.*status.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Rel Status"
        ],
        "negativeExamples": [
          "Name"
        ]
      },
      {
        "regExp": "(?i).*status.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Status"
        ],
        "negativeExamples": [
          "Age"
        ]
      }
    ],
    "positiveContentExamples": [
      "Single",
      "Married",
      "Divorced",
      "Widowed",
      "Separated",
      "Never Married",
      "Civil Union",
      "Domestic Partnership"
    ],
    "negativeContentExamples": [
      "M",
      "S",
      "D",
      "Widower",
      "Single/Divorced",
      "Married (Common Law)",
      "Separated but not divorced",
      "Marital Status: Married"
    ],
    "positiveHeaderExamples": [
      "Marital Status",
      "Marriage Status",
      "Relationship Status",
      "Marital",
      "MaritalStatus",
      "Relationship_Status",
      "Employee Marital Status",
      "Customer Relationship Status"
    ],
    "negativeHeaderExamples": [
      "Age",
      "Gender",
      "Name",
      "Relationship Type",
      "Spouse Name",
      "Status Code",
      "Customer Category",
      "Account State"
    ],
    "explanation": "This semantic type identifies English-language marital or relationship status categories expressed as full words or phrases (no codes or abbreviations). It is useful for demographic profiling, HR records, and survey data where standardized categorical marital statuses are expected. The list-based approach constrains recognition to well-known categories while the backout pattern provides a safe fallback for broader uppercase word-and-space labels.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:46.855569"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_ES",
    "description": "Spanish postal code consisting of exactly five consecutive digits with no spaces, letters, or special characters. Matches a single 5-digit token such as 28013 or 08001.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3570,
    "headerPatterns": [
      {
        "regExp": "(?i).*c[o\u00f3]digo[ _]*postal.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "C\u00f3digo Postal"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*postal[ _]*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*post[ _]*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postcode"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*\\bcp\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CP"
        ],
        "negativeExamples": [
          "Ciudad"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "City"
        ]
      }
    ],
    "positiveContentExamples": [
      "28013",
      "08001",
      "41001",
      "07012",
      "03001",
      "46023",
      "15004",
      "50018"
    ],
    "negativeContentExamples": [
      "2801",
      "280130",
      "28 013",
      "2801A",
      "A8013",
      "28013-123",
      "E-28013",
      "2801 3"
    ],
    "positiveHeaderExamples": [
      "C\u00f3digo Postal",
      "CP",
      "Postal Code",
      "Postcode",
      "Cod. Postal",
      "C\u00f3digo_Postal",
      "Codigo Postal",
      "C.P."
    ],
    "negativeHeaderExamples": [
      "Ciudad",
      "City",
      "Address",
      "Province",
      "Country",
      "Area Code",
      "Street",
      "Zip Code"
    ],
    "explanation": "This semantic type identifies Spanish postal codes, which are exactly five digits with no separators. Use it to detect and validate columns containing Spain's 5-digit postal codes in datasets where headers may appear in Spanish or English.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:48.305518"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_UY",
    "description": "Uruguayan postal codes consisting of exactly five consecutive numeric digits. No spaces, hyphens, letters, or other separators are allowed.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3660,
    "headerPatterns": [
      {
        "regExp": "(?i).*(uruguay|uy).*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "uy_postal_code"
        ],
        "negativeExamples": [
          "postal code"
        ]
      },
      {
        "regExp": "(?i).*(c[o\u00f3]digo).*postal.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "C\u00f3digo Postal"
        ],
        "negativeExamples": [
          "C\u00f3digo Ciudad"
        ]
      },
      {
        "regExp": "(?i).*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "Postal City"
        ]
      },
      {
        "regExp": "(?i).*\\bcp\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CP"
        ],
        "negativeExamples": [
          "CPU"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "city"
        ]
      }
    ],
    "positiveContentExamples": [
      "11000",
      "12900",
      "20000",
      "27050",
      "30010",
      "40400",
      "50050",
      "99900"
    ],
    "negativeContentExamples": [
      "1234",
      "123456",
      "12 345",
      "12-345",
      "1234A",
      "A12345",
      "1234.5",
      "123 45"
    ],
    "positiveHeaderExamples": [
      "C\u00f3digo Postal",
      "CP",
      "Postal Code",
      "UY Postal Code",
      "Uruguay CP",
      "Postal Code UY",
      "C\u00f3digo Postal UY",
      "URUGUAY POSTAL CODE"
    ],
    "negativeHeaderExamples": [
      "Ciudad",
      "City",
      "Address",
      "Country Code",
      "Postal Area",
      "Zip Range",
      "City Code",
      "Postal Status"
    ],
    "explanation": "This semantic type detects Uruguayan postal codes, which are exactly five numeric digits without any separators or formatting characters. It is suitable for validating and profiling address-related datasets specific to Uruguay, ensuring only clean 5-digit numeric values are recognized.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:50.524033"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.MIDDLE",
    "description": "A text field containing middle names that follow proper name formatting conventions and consist of alphabetic characters with possible apostrophes or hyphens. The format allows international characters and diacritical marks representing full middle names but excludes abbreviated forms, initials, or numerical characters.",
    "pluginType": "regex",
    "regexPattern": "\\b([\\p{L}]{2,}([-'\u2019][\\p{L}]{2,})*|[\\p{L}][-'\u2019][\\p{L}]{2,}([-'\u2019][\\p{L}]{2,})*)( [\\p{L}]{2,}([-'\u2019][\\p{L}]{2,})*)?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3370,
    "headerPatterns": [
      {
        "regExp": "(?i).*middle[ _-]*name.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Middle Name"
        ],
        "negativeExamples": [
          "First Name"
        ]
      },
      {
        "regExp": "(?i).*(second|2nd)[ _-]*name.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Second Name"
        ],
        "negativeExamples": [
          "Last Name"
        ]
      },
      {
        "regExp": "(?i).*(middle|second|2nd).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Middle"
        ],
        "negativeExamples": [
          "Full Name"
        ]
      },
      {
        "regExp": "(?i).*(mname|m[ _-]*name|mid[ _-]*name).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "M Name"
        ],
        "negativeExamples": [
          "Preferred Name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "Anne-Marie",
      "Jos\u00e9 Luis",
      "O'Connor",
      "D\u2019Angelo",
      "Jean Paul",
      "Mar\u00eda-Jos\u00e9",
      "Chao",
      "Si\u00f4n"
    ],
    "negativeContentExamples": [
      "J.",
      "B",
      "O'",
      "Anne-M",
      "Mary-J",
      "Jean Paul III",
      "Li-",
      "A"
    ],
    "positiveHeaderExamples": [
      "Middle Name",
      "Second Name",
      "Middle",
      "M Name",
      "Middle Given Name",
      "Second Given Name",
      "Given Name 2",
      "Other Given Name"
    ],
    "negativeHeaderExamples": [
      "First Name",
      "Last Name",
      "Full Name",
      "Preferred Name",
      "Legal Name",
      "Nickname",
      "Display Name",
      "Primary Contact"
    ],
    "explanation": "This semantic type is intended to recognize full middle names in personal data fields. It accepts alphabetic tokens with optional internal hyphens or apostrophes, including international letters and diacritics, and may include a second middle-name token separated by a space. It explicitly excludes initials, abbreviated forms with periods, numeric characters, and trailing or leading separators.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:55.327130"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.AGE",
    "description": "A numeric field containing age values that follow the pattern of whole numbers representing years since birth. Values are integers without decimals or units, typically ranging from 0 to approximately 120 years.",
    "pluginType": "regex",
    "regexPattern": "\\b(0|[1-9]\\d?|1[01]\\d|120)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3450,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\b(person|individual|subject)\\b.*\\bage(s)?\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Person Age"
        ],
        "negativeExamples": [
          "Person Name"
        ]
      },
      {
        "regExp": "(?i).*\\byears?\\b.*\\bold\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Years Old"
        ],
        "negativeExamples": [
          "Year of Birth"
        ]
      },
      {
        "regExp": "(?i).*\\bdemograph\\w*\\b.*\\bage(s)?\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Demographic Age"
        ],
        "negativeExamples": [
          "Demographic Group"
        ]
      },
      {
        "regExp": "(?i).*\\bage\\b.*\\byrs?\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Age_yrs"
        ],
        "negativeExamples": [
          "yrs_since"
        ]
      },
      {
        "regExp": "(?i).*\\bage(s)?\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Age"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "0",
      "1",
      "5",
      "12",
      "18",
      "35",
      "64",
      "120"
    ],
    "negativeContentExamples": [
      "-1",
      "121",
      "3.5",
      "18 years",
      "018",
      "07",
      "1000",
      "12.0"
    ],
    "positiveHeaderExamples": [
      "Age",
      "Person Age",
      "Years Old",
      "User Age",
      "Subject Age",
      "Age (years)",
      "Age_yrs"
    ],
    "negativeHeaderExamples": [
      "Birth Year",
      "Date of Birth",
      "Name",
      "Year of Birth",
      "DOB",
      "Birthdate",
      "Years Since Birth"
    ],
    "explanation": "This semantic type identifies a person's age as a whole number of completed years, commonly between 0 and 120. It excludes decimals, textual units, and values outside the plausible human age range. Useful for demographic analysis, eligibility checks, and age-based segmentation.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:56.820447"
  },
  {
    "resultType": "generated",
    "semanticType": "PERIOD.QUARTER",
    "description": "A text field containing quarter identifiers that follow the pattern Q[1-4], consisting of the letter Q followed by a digit from 1 to 4. The format represents standard business and financial quarter notation where Q1\u2013Q4 correspond to the four three-month periods of a year.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "Q1",
      "Q2",
      "Q3",
      "Q4"
    ],
    "backout": "^[Q][1-4]$",
    "confidenceThreshold": 98,
    "priority": 3430,
    "headerPatterns": [
      {
        "regExp": "(?i).*fiscal.*year.*quarter.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Fiscal Year Quarter"
        ],
        "negativeExamples": [
          "Year Quarter"
        ]
      },
      {
        "regExp": "(?i).*year.*quarter.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Year Quarter"
        ],
        "negativeExamples": [
          "Year"
        ]
      },
      {
        "regExp": "(?i).*reporting.*quarter.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Reporting Quarter"
        ],
        "negativeExamples": [
          "Reporting Period"
        ]
      },
      {
        "regExp": "(?i).*fy.*qtr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "FY QTR"
        ],
        "negativeExamples": [
          "FY Period"
        ]
      },
      {
        "regExp": "(?i).*quarter.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Quarter"
        ],
        "negativeExamples": [
          "Month"
        ]
      }
    ],
    "positiveContentExamples": [
      "Q1",
      "Q2",
      "Q3",
      "Q4",
      "Q1",
      "Q4"
    ],
    "negativeContentExamples": [
      "q1",
      "Q0",
      "Q5",
      "1Q",
      "Q 3",
      "Q03",
      "QQ1",
      "Q2-2023"
    ],
    "positiveHeaderExamples": [
      "Quarter",
      "Year Quarter",
      "Quarterly Period",
      "Fiscal Year Quarter",
      "Reporting Quarter",
      "FY QTR",
      "Yearly Quarter"
    ],
    "negativeHeaderExamples": [
      "Half Year",
      "Month",
      "Full Year",
      "Semester",
      "Biannual",
      "Month Name",
      "Year"
    ],
    "explanation": "This semantic type identifies standard quarter codes limited to Q1, Q2, Q3, and Q4. Use it for fields storing normalized quarter designations in business or financial datasets. The list-based approach ensures strict matching to the four valid quarter tokens while the anchored backout pattern provides a safe fallback for broader validation.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:26:57.135052"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_PT",
    "description": "Portuguese postal code in the hyphenated format of four digits followed by a hyphen and three digits (e.g., 1000-001). The code is strictly numeric with a single hyphen separator between the two parts.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{4}-[0-9]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3630,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bc\u00f3digo postal\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "C\u00f3digo Postal"
        ],
        "negativeExamples": [
          "Cidade"
        ]
      },
      {
        "regExp": "(?i).*\\bcodigo postal\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Codigo Postal"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*\\bpostal.*code\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "Postal Address"
        ]
      },
      {
        "regExp": "(?i).*\\bcp\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CP"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "1000-001",
      "1100-485",
      "1990-099",
      "2735-021",
      "4000-123",
      "4710-001",
      "8000-456",
      "9400-123"
    ],
    "negativeContentExamples": [
      "1234 567",
      "12345-678",
      "1234-5678",
      "1234-56",
      "123-456",
      "12-345",
      "1234\u2013567",
      "1234-ABC"
    ],
    "positiveHeaderExamples": [
      "C\u00f3digo Postal",
      "CP",
      "Postal Code",
      "Codigo Postal",
      "Postcode",
      "Postal",
      "PostalCode"
    ],
    "negativeHeaderExamples": [
      "Cidade",
      "City",
      "Address",
      "Street",
      "Country",
      "Region",
      "Address Line",
      "City Code"
    ],
    "explanation": "This semantic type targets Portuguese postal codes formatted as four digits, a hyphen, and three digits. It is useful for validating and classifying address datasets where the Portuguese postal code appears as a standalone token.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:02.551134"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.CANTON_CH",
    "description": "Two-letter uppercase abbreviations identifying the 26 Swiss cantons (e.g., ZH, BE, VD). Values consist of exactly two uppercase letters with no spaces, digits, or special characters.",
    "pluginType": "regex",
    "regexPattern": "\\b(ZH|BE|LU|UR|SZ|OW|NW|GL|ZG|FR|SO|BS|BL|SH|AR|AI|SG|GR|AG|TG|TI|VD|VS|NE|GE|JU)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3720,
    "headerPatterns": [
      {
        "regExp": "(?i).*(swiss|ch).*(canton|kanton).*(code|abbr|short).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "CH Canton Code"
        ],
        "negativeExamples": [
          "Canton Code"
        ]
      },
      {
        "regExp": "(?i).*(canton|kanton).*(code|abbr).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Canton Code"
        ],
        "negativeExamples": [
          "Canton Name"
        ]
      },
      {
        "regExp": "(?i).*(ct|kt).*(code|abbr).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "CT Code"
        ],
        "negativeExamples": [
          "Kanton Name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Country"
        ]
      }
    ],
    "positiveContentExamples": [
      "ZH",
      "BE",
      "VD",
      "GE",
      "TI",
      "VS",
      "AG",
      "FR"
    ],
    "negativeContentExamples": [
      "CH",
      "ZZ",
      "ZRH",
      "Zh",
      "BE1",
      "VD-",
      "AR/AI",
      "LUU"
    ],
    "positiveHeaderExamples": [
      "Canton Code",
      "Kanton",
      "Canton",
      "CH Canton Code",
      "Kanton Code",
      "Canton Abbrev",
      "CT Code"
    ],
    "negativeHeaderExamples": [
      "Canton Name",
      "Country",
      "City",
      "Province",
      "Postal Code",
      "State Code",
      "Region"
    ],
    "explanation": "This semantic type identifies official Swiss canton abbreviations, ensuring values are valid two-letter uppercase codes and not generic two-letter tokens. It is useful for normalizing and validating administrative subdivision codes within Swiss datasets, enabling accurate joins and aggregations at the canton level.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:03.649916"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.ZIP5_US",
    "description": "US ZIP code in 5-digit format. Values consist of exactly five consecutive numeric digits with no spaces, hyphens, or additional characters.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3680,
    "headerPatterns": [
      {
        "regExp": "(?i).*us.*zip.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "US ZIP Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*zip5.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ZIP5"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      },
      {
        "regExp": "(?i).*zip.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ZIP Code"
        ],
        "negativeExamples": [
          "ZIP+4"
        ]
      },
      {
        "regExp": "(?i).*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "State"
        ]
      },
      {
        "regExp": "(?i).*\\bzip\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ZIP"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "00501",
      "02110",
      "10001",
      "30301",
      "60614",
      "85001",
      "97201",
      "99501"
    ],
    "negativeContentExamples": [
      "1234",
      "123456",
      "12345-6789",
      "1234A",
      "A12345",
      "12 345",
      "0000",
      "9876"
    ],
    "positiveHeaderExamples": [
      "ZIP Code",
      "ZIP",
      "Postal Code",
      "US ZIP Code",
      "ZIP5",
      "Shipping ZIP"
    ],
    "negativeHeaderExamples": [
      "City",
      "State",
      "ZIP+4",
      "ZIP Code +4",
      "Area Code",
      "Country Code",
      "Province",
      "Street"
    ],
    "explanation": "This semantic type identifies US ZIP codes in the 5-digit format. It is suitable for fields storing basic postal codes without the ZIP+4 extension. The value pattern enforces exactly five digits as a standalone token, preventing matches that include spaces, letters, or separators.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:11.649394"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_MX",
    "description": "Mexican postal code consisting of exactly five consecutive digits with no spaces, letters, hyphens, or other characters. Matches numeric strings that are exactly five digits long (0\u20139).",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3610,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\b(mexico|m\u00e9xico|mx)\\b.*\\b(c\u00f3digo postal|codigo postal|postal code|cp)\\b.*",
        "confidence": 99,
        "mandatory": true,
        "positiveExamples": [
          "C\u00f3digo Postal MX"
        ],
        "negativeExamples": [
          "C\u00f3digo Postal CA"
        ]
      },
      {
        "regExp": "(?i).*\\b(c\u00f3digo postal|codigo postal|postal code)\\b.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "C\u00f3digo Postal"
        ],
        "negativeExamples": [
          "Ciudad"
        ]
      },
      {
        "regExp": "(?i).*\\bpostal\\b.*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "Postal Address"
        ]
      },
      {
        "regExp": "(?i).*\\bcp\\b.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "CP"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "01000",
      "02800",
      "06500",
      "11000",
      "20010",
      "52930",
      "77000",
      "99999"
    ],
    "negativeContentExamples": [
      "1234",
      "123456",
      "12 345",
      "12-345",
      "12345-6789",
      "CP12345",
      "1234A",
      "A1234"
    ],
    "positiveHeaderExamples": [
      "C\u00f3digo Postal",
      "CP",
      "Postal Code",
      "C\u00f3digo Postal MX",
      "Mexico Postal Code",
      "MX C\u00f3digo Postal",
      "CP MX",
      "Postal Code MX"
    ],
    "negativeHeaderExamples": [
      "Ciudad",
      "City",
      "Address",
      "Province Code",
      "Country",
      "Postal Address",
      "Zip Code",
      "State"
    ],
    "explanation": "This semantic type identifies Mexican postal codes formatted as exactly five digits with no separators or additional characters. It is suitable for columns labeled with Spanish or English postal code terms, often appearing as CP, C\u00f3digo Postal, or Postal Code, including Mexico-specific variants.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:11.714799"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_UK",
    "description": "UK postal code with a mandatory single space separating outward and inward parts. Outward code: 1\u20132 letters, followed by 1\u20132 digits, and an optional letter; inward code: 1 digit followed by 2 letters. Case-insensitive and limited to letters A\u2013Z and digits 0\u20139 with exactly one space between parts.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b[A-Z]{1,2}[0-9]{1,2}[A-Z]? [0-9][A-Z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3650,
    "headerPatterns": [
      {
        "regExp": "(?i).*(uk|gb).*(post|postal).*code.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "UK Post Code"
        ],
        "negativeExamples": [
          "Postcode"
        ]
      },
      {
        "regExp": "(?i).*(uk|gb).*\\bzip\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "UK ZIP"
        ],
        "negativeExamples": [
          "ZIP"
        ]
      },
      {
        "regExp": "(?i).*(post|postal).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postcode"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*\\bpcode\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "pcode"
        ],
        "negativeExamples": [
          "bar code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "SW1A 1AA",
      "WC2N 5DU",
      "EC1A 1BB",
      "W1A 0AX",
      "M1 1AE",
      "B33 8TH",
      "CR2 6XH",
      "DN55 1PT"
    ],
    "negativeContentExamples": [
      "SW1A1AA",
      "SW1A-1AA",
      "SW1A  1AA",
      "EC 1A1BB",
      "E1 1B",
      "WC2N 5D",
      "W1A0AX",
      "DN55 11T"
    ],
    "positiveHeaderExamples": [
      "Postcode",
      "Post Code",
      "UK ZIP",
      "UK Post Code",
      "GB Postal Code",
      "Postal Code",
      "UK Postcode"
    ],
    "negativeHeaderExamples": [
      "City",
      "County",
      "Address",
      "ZIP",
      "Country Code",
      "Postal Area",
      "Street Name",
      "Region"
    ],
    "explanation": "Identifies UK postal codes that include an outward segment (area/district) and an inward segment (sector/unit) separated by exactly one space. Useful for validating and extracting UK-specific addresses in datasets while avoiding false positives from other country formats or free-text address lines.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:13.172393"
  },
  {
    "resultType": "generated",
    "semanticType": "NATIONALITY_NL",
    "description": "A text field containing nationality names in Dutch that follow standard Dutch language nationality terminology and grammatical conventions. Values are Dutch demonyms (adjectival or noun forms), using proper capitalization and spelling, and may include hyphenated compound demonyms (e.g., Bosnisch-Servisch).",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z\u00c0-\u00d6\u00d8-\u00de][a-z\u00e0-\u00f6\u00f8-\u00ff]+-)*[A-Z\u00c0-\u00d6\u00d8-\u00de][a-z\u00e0-\u00f6\u00f8-\u00ff]*(aans|aanse|eens|ense|eense|ees|ese|isch|ische|sch|sche|eeds|eedse|s|se|er|ers|aar|aarse|iaan|iaans|iaanse|man|vrouw)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3410,
    "headerPatterns": [
      {
        "regExp": "(?i).*(persoon|klant|medewerker|burger).*(nationaliteit|staatsburgerschap).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Persoon nationaliteit"
        ],
        "negativeExamples": [
          "Land"
        ]
      },
      {
        "regExp": "(?i).*(staatsburgerschap).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Staatsburgerschap"
        ],
        "negativeExamples": [
          "Etniciteit"
        ]
      },
      {
        "regExp": "(?i).*(burgerschap).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Burgerschap"
        ],
        "negativeExamples": [
          "Taal"
        ]
      },
      {
        "regExp": "(?i).*(afkomst).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Afkomst"
        ],
        "negativeExamples": [
          "Geboorteland"
        ]
      },
      {
        "regExp": "(?i).*nationaliteit.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Nationaliteit"
        ],
        "negativeExamples": [
          "Herkomstland"
        ]
      }
    ],
    "positiveContentExamples": [
      "Nederlandse",
      "Duits",
      "Belgisch",
      "Italiaanse",
      "Portugees",
      "Chinese",
      "Brits",
      "Bosnisch-Servisch"
    ],
    "negativeContentExamples": [
      "Nederland",
      "Belgi\u00eb",
      "Duitsland",
      "Frankrijk",
      "Franse Republiek",
      "Chinezen",
      "Amerikaans-",
      "Herkomst land"
    ],
    "positiveHeaderExamples": [
      "Nationaliteit",
      "Staatsburgerschap",
      "Afkomst",
      "Persoon nationaliteit",
      "Klant staatsburgerschap",
      "Burgerschap"
    ],
    "negativeHeaderExamples": [
      "Land",
      "Etniciteit",
      "Taal",
      "Geboorteland",
      "Herkomstland",
      "Moedertaal",
      "Regio"
    ],
    "explanation": "This semantic type identifies Dutch demonyms used to denote nationality, including common adjectival and noun forms and hyphenated compounds, while excluding country names, languages, and multi-word phrases that are not demonyms. It is useful for classifying person attributes representing nationality in Dutch-language datasets.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:13.529385"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_FIPS_US",
    "description": "US county FIPS code as exactly five consecutive digits used to reference counties nationwide. The format is strictly five numeric characters (0\u20139) with no spaces, letters, or symbols.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3750,
    "headerPatterns": [
      {
        "regExp": "(?i).*county.*fips.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "County FIPS Code"
        ],
        "negativeExamples": [
          "FIPS Code"
        ]
      },
      {
        "regExp": "(?i).*fips.*county.*code.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "FIPS County Code"
        ],
        "negativeExamples": [
          "County Name"
        ]
      },
      {
        "regExp": "(?i).*county.*fips.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "County FIPS"
        ],
        "negativeExamples": [
          "State FIPS"
        ]
      },
      {
        "regExp": "(?i).*(county|cnty|cty|co).*fips.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "CTY FIPS"
        ],
        "negativeExamples": [
          "City FIPS"
        ]
      },
      {
        "regExp": "(?i).*fips.*code.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "FIPS Code"
        ],
        "negativeExamples": [
          "Zip Code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "01001",
      "06037",
      "17031",
      "36061",
      "12086",
      "48201",
      "04013",
      "08031"
    ],
    "negativeContentExamples": [
      "6037",
      "060370",
      "0603A",
      "A6037",
      "06 037",
      "06-037",
      "060_37",
      "1234a"
    ],
    "positiveHeaderExamples": [
      "County FIPS",
      "FIPS Code",
      "County Code",
      "County FIPS Code",
      "FIPS County Code",
      "CTY FIPS",
      "US County FIPS"
    ],
    "negativeHeaderExamples": [
      "County Name",
      "State",
      "City",
      "FIPS State Code",
      "Zip Code",
      "Area Code",
      "Country Code"
    ],
    "explanation": "This semantic type identifies US county FIPS codes, which are standardized five-digit numeric identifiers formed by a two-digit state code followed by a three-digit county code. It is useful for joining, aggregating, and geocoding datasets at the county level and for disambiguating counties across states.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:15.861408"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.DISTRICT_NAME_IN",
    "description": "Matches Indian district names written in English with proper capitalization, consisting of one to five words where each word starts with an uppercase letter followed by lowercase letters. No abbreviations, numerals, punctuation, or lowercase connector words are allowed in the value.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z][a-z]+)(\\s[A-Z][a-z]+){0,4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3820,
    "headerPatterns": [
      {
        "regExp": "(?i).*district.*name.*india.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "District Name (India)"
        ],
        "negativeExamples": [
          "Indian District"
        ]
      },
      {
        "regExp": "(?i).*indian.*district.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Indian District"
        ],
        "negativeExamples": [
          "District Name"
        ]
      },
      {
        "regExp": "(?i).*(district|distt|dist)\\s*(name|nm).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Dist Name"
        ],
        "negativeExamples": [
          "District Code"
        ]
      },
      {
        "regExp": "(?i).*(district|dist|distt).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "District"
        ],
        "negativeExamples": [
          "State"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Bhopal",
      "North Delhi",
      "West Godavari",
      "Gautam Buddha Nagar",
      "Ahmednagar",
      "Kangra",
      "Sri Ganganagar",
      "East Khasi Hills"
    ],
    "negativeContentExamples": [
      "bhopal",
      "South-Delhi",
      "South 24 Parganas",
      "Dadra and Nagar Haveli",
      "NewDelhi",
      "GADAG",
      "Jabalpur.",
      "Thoothukudi district"
    ],
    "positiveHeaderExamples": [
      "District",
      "Indian District",
      "District Name",
      "District Name (IN)",
      "District of India",
      "IN District",
      "Administrative District",
      "District Names"
    ],
    "negativeHeaderExamples": [
      "State",
      "Country",
      "City",
      "Province",
      "County",
      "Municipality",
      "Taluka",
      "Postal Code"
    ],
    "explanation": "This semantic type identifies Indian district names formatted as properly capitalized words (1 to 5 tokens), each starting with an uppercase letter and followed by lowercase letters, separated by single spaces. It excludes values containing abbreviations, digits, punctuation, hyphens, or lowercase connector words. Use this for columns expected to contain official district names in English or transliterated without modifiers like the word 'district'. Header patterns prefer explicit references to 'district' and Indian context, with a primitive fallback to 'name' while maintaining a high detection threshold to avoid confusion with other proper nouns.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:16.207815"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.LAST",
    "description": "A text field containing family names that typically follow proper name formatting conventions and use alphabetic characters with possible apostrophes, hyphens, or spaces for compound surnames. The format allows international characters and diacritical marks but excludes numerical digits, titles, or given name components.",
    "pluginType": "regex",
    "regexPattern": "\\b([\\p{L}]{2,}|[\\p{L}]['\u2019][\\p{L}]+)(['-][\\p{L}]+)*( (([\\p{L}]{2,}|[\\p{L}]['\u2019][\\p{L}]+)(['-][\\p{L}]+)*)){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3350,
    "headerPatterns": [
      {
        "regExp": "(?i).*last.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Last Name"
        ],
        "negativeExamples": [
          "Full Name"
        ]
      },
      {
        "regExp": "(?i).*surname.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Surname"
        ],
        "negativeExamples": [
          "Middle Name"
        ]
      },
      {
        "regExp": "(?i).*family.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Family Name"
        ],
        "negativeExamples": [
          "First Name"
        ]
      },
      {
        "regExp": "(?i).*(customer|user|person).*(last.*name|surname).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Customer Last Name"
        ],
        "negativeExamples": [
          "Customer Number"
        ]
      },
      {
        "regExp": "(?i).*(lname|l_name|last_nm).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "l_name"
        ],
        "negativeExamples": [
          "full_name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Account Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "O'Connor",
      "Garc\u00eda",
      "M\u00fcller",
      "De la Cruz",
      "Van der Meer",
      "Smith-Jones",
      "D\u2019Amico",
      "Ng"
    ],
    "negativeContentExamples": [
      "Smith3",
      "O''Connor",
      "-Garcia",
      "Mc-",
      "Van_der_Meer",
      "Garc\u00eda.",
      "A",
      "St. John"
    ],
    "positiveHeaderExamples": [
      "Last Name",
      "Surname",
      "Family Name",
      "Customer Last Name",
      "User Surname",
      "LNAME",
      "Employee Last Name",
      "l_name"
    ],
    "negativeHeaderExamples": [
      "First Name",
      "Full Name",
      "Middle Name",
      "Given Name",
      "Display Name",
      "Nickname",
      "Customer Number",
      "Account Code"
    ],
    "explanation": "This semantic type identifies last names/family names, including compound surnames and common separators like spaces, hyphens, and apostrophes. It supports international letters and diacritics while excluding digits, underscores, and trailing/leading punctuation. Typical use cases include deduplication, identity resolution, and schema inference for person-related datasets where a surname field is present.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:17.661154"
  },
  {
    "resultType": "generated",
    "semanticType": "SSN",
    "description": "Structured U.S. Social Security Number in the format of three digits, a hyphen, two digits, a hyphen, and four digits (NNN-NN-NNNN). This captures the hyphenated nine-digit identifier without validating issuance rules.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{3}-\\d{2}-\\d{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3710,
    "headerPatterns": [
      {
        "regExp": "(?i).*social.*security.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Social Security Number"
        ],
        "negativeExamples": [
          "Social Security"
        ]
      },
      {
        "regExp": "(?i).*social.*security.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Social Security"
        ],
        "negativeExamples": [
          "Security Question"
        ]
      },
      {
        "regExp": "(?i).*ssn.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SSN Number"
        ],
        "negativeExamples": [
          "SSN"
        ]
      },
      {
        "regExp": "(?i).*ssn.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SSN"
        ],
        "negativeExamples": [
          "SIN"
        ]
      },
      {
        "regExp": "(?i).*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ID"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "123-45-6789",
      "219-84-0193",
      "555-12-3456",
      "746-02-9988",
      "369-74-1200",
      "820-33-7001",
      "901-55-4320",
      "132-99-0007"
    ],
    "negativeContentExamples": [
      "123456789",
      "123-456-789",
      "12-345-6789",
      "123-45-678",
      "123-45-67890",
      "123 45 6789",
      "123-4A-6789",
      "0123-45-6789"
    ],
    "positiveHeaderExamples": [
      "SSN",
      "Social Security Number",
      "Social Security",
      "SSN Number",
      "Social Sec No",
      "Employee SSN",
      "Taxpayer SSN",
      "SSN ID"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Date of Birth",
      "Tax ID",
      "National ID",
      "TIN",
      "Passport Number",
      "Employee ID",
      "Account Number"
    ],
    "explanation": "This semantic type detects hyphenated U.S. Social Security Numbers using a strict tokenized pattern with word boundaries to avoid partial matches. It is intended for columns that store SSNs in NNN-NN-NNNN format and leverages header patterns from specific phrases (e.g., Social Security Number) to generic identifiers (e.g., ID) for robust schema-driven detection.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:18.414610"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_CA",
    "description": "Two-letter uppercase codes for Canadian provinces. Exactly two alphabetic characters with no spaces, numbers, or special characters. This is a finite set of official province abbreviations (AB, BC, MB, NB, NL, NS, ON, PE, QC, SK). Territories (NT, NU, YT) are not included.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AB",
      "BC",
      "MB",
      "NB",
      "NL",
      "NS",
      "ON",
      "PE",
      "QC",
      "SK"
    ],
    "backout": "^[A-Z]{2}$",
    "confidenceThreshold": 98,
    "priority": 3920,
    "headerPatterns": [
      {
        "regExp": "(?i).*(canadian|canada|ca).*province.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Canadian Province Code"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      },
      {
        "regExp": "(?i).*(province|prov).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Province Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*(canadian|canada|ca).*province.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CA Province"
        ],
        "negativeExamples": [
          "Province"
        ]
      },
      {
        "regExp": "(?i).*\\bprov\\b.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Prov Code"
        ],
        "negativeExamples": [
          "Province Code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "AB",
      "BC",
      "MB",
      "NB",
      "NL",
      "NS",
      "ON",
      "QC"
    ],
    "negativeContentExamples": [
      "NT",
      "NU",
      "YT",
      "PQ",
      "QB",
      "CA",
      "AB1",
      "ON-"
    ],
    "positiveHeaderExamples": [
      "Province Code",
      "Canadian Province",
      "Province",
      "Canadian Province Code",
      "CA Province Code",
      "Prov Code",
      "Province Abbreviation",
      "Canada Province"
    ],
    "negativeHeaderExamples": [
      "Province Name",
      "Country",
      "Territory",
      "Postal Code",
      "State",
      "Region",
      "Country Code",
      "Province Identifier"
    ],
    "explanation": "This semantic type captures the official two-letter abbreviations for Canadian provinces using a finite allowlist for high precision. Use it to validate and normalize province fields in Canadian datasets while excluding territories. The backout pattern expresses the general two-letter shape but final matching relies on the explicit list for accuracy.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:19.567442"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_CODE_BR",
    "description": "This type matches Brazilian municipality codes represented as exactly seven consecutive digits. The format contains only numeric characters (0\u20139) with no spaces, letters, or special separators, used for standardized municipal referencing in Brazil (e.g., IBGE codes).",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{7}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3870,
    "headerPatterns": [
      {
        "regExp": "(?i).*ibge.*municip.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IBGE Municipality Code"
        ],
        "negativeExamples": [
          "IBGE Name"
        ]
      },
      {
        "regExp": "(?i).*c[o\u00f3]digo.*do.*munic[i\u00ed]pio.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "C\u00f3digo do Munic\u00edpio"
        ],
        "negativeExamples": [
          "C\u00f3digo do Estado"
        ]
      },
      {
        "regExp": "(?i).*ibge.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IBGE Code"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*municipality.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Municipality Code"
        ],
        "negativeExamples": [
          "Municipality Name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "3550308",
      "1100015",
      "1501402",
      "3304557",
      "4216602",
      "2927408",
      "3106200",
      "5300108"
    ],
    "negativeContentExamples": [
      "355030",
      "35503081",
      "35503A8",
      "355-0308",
      "3550 308",
      "A3550308",
      "3550308A",
      "012345678"
    ],
    "positiveHeaderExamples": [
      "C\u00f3digo do Munic\u00edpio",
      "Municipality Code",
      "IBGE Code",
      "IBGE Municipality Code",
      "Codigo Municipio",
      "BR Municipality Code",
      "Municipio Codigo IBGE",
      "Municipality Code (BR)"
    ],
    "negativeHeaderExamples": [
      "Municipality Name",
      "State",
      "Country",
      "City Code",
      "Postal Code",
      "Province Code",
      "IBGE Name",
      "Country Code"
    ],
    "explanation": "Brazilian municipality codes (e.g., IBGE codes) are structured as exactly seven digits with no separators. This semantic type identifies such codes in datasets and column headers, aiding geospatial and administrative data processing where municipalities are referenced by their numeric identifiers.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:20.670999"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.ZIP5_PLUS4_US",
    "description": "US ZIP+4 postal code in hyphenated form: five digits, a hyphen, then four digits (e.g., 12345-6789). This pattern represents the nine-digit ZIP+4 format with a mandatory hyphen separating the 5-digit base ZIP and the 4-digit add-on.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{5}-[0-9]{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3670,
    "headerPatterns": [
      {
        "regExp": "(?i).*zip\\s*\\+\\s*4.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ZIP+4"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      },
      {
        "regExp": "(?i).*zip[-_\\s]*plus[-_\\s]*4.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "zip_plus_4"
        ],
        "negativeExamples": [
          "zip code"
        ]
      },
      {
        "regExp": "(?i).*extended[-_\\s]*zip.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Extended ZIP"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*zip[-_\\s]*9.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ZIP9"
        ],
        "negativeExamples": [
          "State"
        ]
      },
      {
        "regExp": "(?i).*postal[-_\\s]*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "ZIP"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "00501-0001",
      "02139-1234",
      "10001-0001",
      "30301-2500",
      "60614-9876",
      "73301-0101",
      "85001-4321",
      "94105-1234"
    ],
    "negativeContentExamples": [
      "12345",
      "123456789",
      "12345 6789",
      "1234-5678",
      "12345-678",
      "A2345-6789",
      "12345-67890",
      "12345\u20136789"
    ],
    "positiveHeaderExamples": [
      "ZIP+4",
      "ZIP Code",
      "Extended ZIP",
      "ZIP9",
      "ZIP Plus 4",
      "ZIP+4 Code",
      "Postal Code (ZIP+4)",
      "US ZIP+4"
    ],
    "negativeHeaderExamples": [
      "City",
      "State",
      "ZIP Code",
      "Address",
      "ZIP",
      "Country",
      "Country Code",
      "Area Code"
    ],
    "explanation": "Identifies US ZIP+4 (ZIP9) postal codes formatted as five digits, a hyphen, and four digits. Useful for validating or extracting extended ZIP codes in US address datasets where the full 9-digit postal identifier is required.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:21.442536"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_CO",
    "description": "Properly capitalized Spanish municipality names for Colombia. Values are one or more capitalized words, optionally including lowercase connectors like de, del, la, las, los, y between capitalized tokens. No digits, punctuation, underscores, or abbreviations; only letters with Spanish diacritics and spaces are allowed.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc]+)(\\s((de|del|la|las|los|y)\\s)?[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc]+)*\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 3860,
    "headerPatterns": [
      {
        "regExp": "(?i).*(colombian|colombia|co)[ _-]*(municipality|municipio).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Colombian Municipality"
        ],
        "negativeExamples": [
          "Municipality"
        ]
      },
      {
        "regExp": "(?i).*(municipality|municipio)[ _-]*(name|nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality_name"
        ],
        "negativeExamples": [
          "department_name"
        ]
      },
      {
        "regExp": "(?i).*(municipality|municipio).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Municipio"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*(mpio|muni|mun)[ _-]*(name|nombre)?.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "mpio_nombre"
        ],
        "negativeExamples": [
          "prov_name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Medell\u00edn",
      "Bogot\u00e1",
      "Barranquilla",
      "Santa Marta",
      "San Jos\u00e9 de C\u00facuta",
      "El Carmen de Bol\u00edvar",
      "Villa de Leyva",
      "Puerto As\u00eds"
    ],
    "negativeContentExamples": [
      "san Jos\u00e9 de C\u00facuta",
      "Medell\u00edn- Antioquia",
      "Santa_Marta",
      "Cartagena (Bol\u00edvar)",
      "EL CARMEN DE BOL\u00cdVAR",
      "Villa deLeyva",
      "Santa Marta 2",
      "Guapi."
    ],
    "positiveHeaderExamples": [
      "Municipio",
      "Municipality",
      "Colombian Municipality",
      "municipio",
      "municipality_name",
      "co_municipality",
      "municipio_nombre",
      "mpio"
    ],
    "negativeHeaderExamples": [
      "Department",
      "Country",
      "City",
      "Province",
      "State",
      "Place Name",
      "District",
      "Postal Code"
    ],
    "explanation": "This semantic type targets Colombian municipality names written as properly capitalized Spanish words, permitting only letters (including diacritics) and spaces. It supports internal lowercase connectors such as de, del, la, las, los, and y, and disallows punctuation, digits, hyphens, and underscores to avoid false positives. Use this to identify columns containing municipality names within Colombian administrative data.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:23.482429"
  },
  {
    "resultType": "generated",
    "semanticType": "SPATIAL.GEOJSON",
    "description": "GeoJSON objects representing spatial geometries, features, or collections with required JSON keys such as \"type\" and either \"coordinates\", \"geometry\", \"features\", or \"geometries\". This pattern detects common GeoJSON forms including Geometry objects (Point, LineString, Polygon, Multi*), Feature, FeatureCollection, and GeometryCollection by verifying expected key/value structures without relying on anchors.",
    "pluginType": "regex",
    "regexPattern": "(\\b\\{\\s*\"type\"\\s*:\\s*\"(Point|MultiPoint|LineString|MultiLineString|Polygon|MultiPolygon)\"\\s*,\\s*\"coordinates\"\\s*:\\s*\\[|\\b\\{\\s*\"coordinates\"\\s*:\\s*\\[\\s*,\\s*\"type\"\\s*:\\s*\"(Point|MultiPoint|LineString|MultiLineString|Polygon|MultiPolygon)\"|\\b\\{\\s*\"type\"\\s*:\\s*\"GeometryCollection\"\\s*,\\s*\"geometries\"\\s*:\\s*\\[|\\b\\{\\s*\"geometries\"\\s*:\\s*\\[\\s*,\\s*\"type\"\\s*:\\s*\"GeometryCollection\"|\\b\\{\\s*\"type\"\\s*:\\s*\"Feature\"\\s*,\\s*\"geometry\"\\s*:\\s*\\{|\\b\\{\\s*\"geometry\"\\s*:\\s*\\{\\s*,\\s*\"type\"\\s*:\\s*\"Feature\"|\\b\\{\\s*\"type\"\\s*:\\s*\"FeatureCollection\"\\s*,\\s*\"features\"\\s*:\\s*\\[|\\b\\{\\s*\"features\"\\s*:\\s*\\[\\s*,\\s*\"type\"\\s*:\\s*\"FeatureCollection\")",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 3690,
    "headerPatterns": [
      {
        "regExp": "(?i).*(geojson).*(geometry|geometries).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "GeoJSON Geometry"
        ],
        "negativeExamples": [
          "Geometry Type"
        ]
      },
      {
        "regExp": "(?i).*(geojson).*(feature|features).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "GeoJSON Features"
        ],
        "negativeExamples": [
          "Feature Flags"
        ]
      },
      {
        "regExp": "(?i).*(spatial|geographic).*geojson.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Spatial GeoJSON"
        ],
        "negativeExamples": [
          "Spatial Data"
        ]
      },
      {
        "regExp": "(?i).*(geog|geo).*json.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Geog JSON"
        ],
        "negativeExamples": [
          "JSON Schema"
        ]
      },
      {
        "regExp": "(?i).*geojson.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "GeoJSON"
        ],
        "negativeExamples": [
          "Geography"
        ]
      }
    ],
    "positiveContentExamples": [
      "{\"type\":\"Point\",\"coordinates\":[100.0,0.0]}",
      "{\"type\":\"LineString\",\"coordinates\":[[100.0,0.0],[101.0,1.0]]}",
      "{\"type\":\"Polygon\",\"coordinates\":[[[100.0,0.0],[101.0,0.0],[101.0,1.0],[100.0,1.0],[100.0,0.0]]]}",
      "{\"coordinates\":[100.0,0.0],\"type\":\"MultiPoint\"}",
      "{\"type\":\"Feature\",\"geometry\":{\"type\":\"Point\",\"coordinates\":[102.0,0.5]},\"properties\":{\"name\":\"A\"}}",
      "{\"type\":\"FeatureCollection\",\"features\":[{\"type\":\"Feature\",\"geometry\":{\"type\":\"Point\",\"coordinates\":[102.0,0.5]},\"properties\":{}}]}",
      "{\"type\":\"GeometryCollection\",\"geometries\":[{\"type\":\"Point\",\"coordinates\":[100.0,0.0]}]}",
      "{\"features\":[{\"type\":\"Feature\",\"geometry\":{\"type\":\"LineString\",\"coordinates\":[[0,0],[1,1]]},\"properties\":{}}],\"type\":\"FeatureCollection\"}"
    ],
    "negativeContentExamples": [
      "{\"type\":\"point\",\"coordinates\":[100.0,0.0]}",
      "{\"type\":\"Point\",\"coords\":[100.0,0.0]}",
      "{\"type\":\"Point\",\"coordinates\":\"100,0\"}",
      "{\"type\":\"Feature\",\"geometry\":[100.0,0.0]}",
      "{\"type\":\"FeatureCollection\",\"feature\":[]}",
      "{\"coordinates\":[100.0,0.0]}",
      "{\"type\":\"GeometryCollection\",\"coordinates\":[[100.0,0.0]]}",
      "{\"type\":\"PointZ\",\"coordinates\":[100.0,0.0]}"
    ],
    "positiveHeaderExamples": [
      "GeoJSON",
      "Spatial Data",
      "Geographic Data",
      "GeoJSON Feature",
      "Spatial GeoJSON",
      "GeoJSON Geometry",
      "Geog JSON",
      "FeatureCollection GeoJSON"
    ],
    "negativeHeaderExamples": [
      "Coordinates",
      "Address",
      "Location Name",
      "JSON",
      "WKT",
      "Latitude Longitude",
      "Geometry",
      "Geo Data"
    ],
    "explanation": "This semantic type identifies values that are valid-looking GeoJSON objects for geometries, features, feature collections, or geometry collections by verifying the presence and pairing of required keys and structural markers (e.g., \"type\" with either \"coordinates\", \"geometry\", \"features\", or \"geometries\"). It is suitable for columns containing serialized GeoJSON strings representing spatial data.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:25.443867"
  },
  {
    "resultType": "generated",
    "semanticType": "NATIONALITY_EN",
    "description": "A text field containing nationality names that follow standard English-language nationality terminology and typically use proper case formatting. Values generally consist of one to three capitalized words and may include a hyphenated compound, with the final word exhibiting common demonym suffixes (for example, -an, -ian, -ese, -ish, -i, -er).",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z][a-z]+\\s){0,2}([A-Z][a-z]+-)?[A-Z][a-z]+(an|ian|ean|ese|ish|i|ite|er|ch|ss|ai|ek)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 3400,
    "headerPatterns": [
      {
        "regExp": "(?i).*(customer|user|applicant|passenger).*(nationality|citizenship).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_nationality"
        ],
        "negativeExamples": [
          "customer_country"
        ]
      },
      {
        "regExp": "(?i).*nationality.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nationality_name"
        ],
        "negativeExamples": [
          "country_name"
        ]
      },
      {
        "regExp": "(?i).*(nationality|citizenship|origin).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Citizenship"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(natl|cit|orig).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "natl"
        ],
        "negativeExamples": [
          "lang"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "citizenship_name"
        ],
        "negativeExamples": [
          "country_code"
        ]
      }
    ],
    "positiveContentExamples": [
      "American",
      "British",
      "Saudi Arabian",
      "South African",
      "New Zealander",
      "Japanese",
      "Swiss",
      "Ivorian"
    ],
    "negativeContentExamples": [
      "United States",
      "Germany",
      "Saudi Arabia",
      "Bosnia and Herzegovina",
      "England",
      "U.S.",
      "Mandarin",
      "Arab"
    ],
    "positiveHeaderExamples": [
      "Nationality",
      "Citizenship",
      "Origin",
      "nationality_name",
      "customer_nationality",
      "user_citizenship",
      "place_of_origin",
      "applicant_nationality"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Ethnicity",
      "Language",
      "country_name",
      "ethnicity_group",
      "mother_tongue",
      "country_of_residence",
      "birth_country"
    ],
    "explanation": "This semantic type detects English demonyms (nationality names) using a pattern that requires proper-case words and a final word with common nationality suffixes. It supports single- and multi-word values as well as single hyphenated compounds (e.g., Bosnian-Herzegovinian). Use this to classify fields that contain a person's nationality rather than country names, languages, or ethnicities.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:27.922421"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.TEXT_ES",
    "description": "A text field containing Spanish country names that follow proper Spanish linguistic patterns and use appropriate capitalization. The format consists of alphabetic characters representing established country designations as commonly used in Spanish-speaking contexts and official documentation.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00fc\u00f1]+)(( |-)(de|del|la|las|los|y|[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00fc\u00f1]+)){0,5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 2820,
    "headerPatterns": [
      {
        "regExp": "(?i).*nombre.*pa[i\u00ed]s.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Nombre del Pa\u00eds"
        ],
        "negativeExamples": [
          "C\u00f3digo del Pa\u00eds"
        ]
      },
      {
        "regExp": "(?i).*pa[i\u00ed]s.*nombre.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Pa\u00eds Nombre"
        ],
        "negativeExamples": [
          "Nombre del Pa\u00eds"
        ]
      },
      {
        "regExp": "(?i).*\\bnaci[o\u00f3]n\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Naci\u00f3n"
        ],
        "negativeExamples": [
          "Nacionalidad"
        ]
      },
      {
        "regExp": "(?i).*\\bpais.*nm\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "pais_nm"
        ],
        "negativeExamples": [
          "pais_id"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Espa\u00f1a",
      "M\u00e9xico",
      "Estados Unidos",
      "Reino Unido",
      "Rep\u00fablica Dominicana",
      "Costa Rica",
      "Bosnia y Herzegovina",
      "Santo Tom\u00e9 y Pr\u00edncipe"
    ],
    "negativeContentExamples": [
      "costa rica",
      "USA",
      "ReinoUnido",
      "M\u00e9xico DF",
      "C\u00d3RDOBA",
      "Guinea\u2014Bis\u00e1u",
      "Espa\u00f1a/Portugal",
      "Espa\u00f1a 2024"
    ],
    "positiveHeaderExamples": [
      "Pa\u00eds",
      "Nombre del Pa\u00eds",
      "Naci\u00f3n",
      "Pa\u00eds Nombre",
      "nombre_pais",
      "nac"
    ],
    "negativeHeaderExamples": [
      "C\u00f3digo del Pa\u00eds",
      "Estado",
      "Ciudad",
      "Pa\u00eds C\u00f3digo",
      "Country",
      "ID Pa\u00eds"
    ],
    "explanation": "This semantic type targets values that look like properly capitalized Spanish country names, allowing multi-word forms, common connectors (de, del, la, las, los, y), and standard hyphenation. It is useful for identifying columns containing country names written in Spanish rather than codes or abbreviations, supporting data quality checks, localization, and normalization workflows.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:29.149469"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COMMUNE_IT",
    "description": "Italian commune (comune) names written as proper nouns with each word capitalized and composed only of alphabetic letters, including accented Latin characters. No punctuation, digits, abbreviations, or codes are included, and multi-word names are space-separated words only.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z\u00c0-\u00d6\u00d8-\u00de][a-z\u00e0-\u00f6\u00f8-\u00ff]+( [A-Z\u00c0-\u00d6\u00d8-\u00de][a-z\u00e0-\u00f6\u00f8-\u00ff]+){0,5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 3740,
    "headerPatterns": [
      {
        "regExp": "(?i).*(comune[ _]?\\bIT\\b|italian[ _]?commune).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Comune IT"
        ],
        "negativeExamples": [
          "Municipality Name"
        ]
      },
      {
        "regExp": "(?i).*(comune|commune|municipality).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Comune"
        ],
        "negativeExamples": [
          "Province"
        ]
      },
      {
        "regExp": "(?i).*(comune|commune|municipality).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Municipality Name"
        ],
        "negativeExamples": [
          "Municipality Code"
        ]
      },
      {
        "regExp": "(?i).*(muni|mun|comm).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Muni Name"
        ],
        "negativeExamples": [
          "Comm Code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Roma",
      "Milano",
      "Firenze",
      "Torino",
      "Santa Maria Capua Vetere",
      "Castel San Pietro Terme",
      "San Giovanni Valdarno",
      "Porto Empedocle"
    ],
    "negativeContentExamples": [
      "L'Aquila",
      "Sant'Agata de' Goti",
      "San giovanni Valdarno",
      "Sesto-San Giovanni",
      "Roma RM",
      "Bologna 1",
      "Reggio nell Emilia",
      "Milano-"
    ],
    "positiveHeaderExamples": [
      "Comune",
      "Commune",
      "Municipality",
      "Italian Commune",
      "Comune Name",
      "Municipality Name",
      "Commune Name",
      "Muni Name"
    ],
    "negativeHeaderExamples": [
      "Province",
      "Region",
      "Country",
      "City Code",
      "Postal Code",
      "Province Name",
      "ISO Country Code",
      "Identifier"
    ],
    "explanation": "This semantic type targets Italian commune names as clean, capitalized proper nouns with optional multiple words, each word starting with an uppercase letter followed by lowercase letters, including accented characters. It is designed to classify columns containing official comune names without punctuation, digits, abbreviations, or appended codes.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:29.579443"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_US",
    "description": "Identifies U.S. county-level jurisdiction names that end with the designation \"County\" or \"Parish\" and are written with proper capitalization. Matches one or more capitalized words (allowing spaces or hyphens between words, and embedded apostrophes or periods in tokens like \"St.\") followed by a space and the terminal word County or Parish.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z][a-z'.]+([ -][A-Z][a-z'.]+)*\\s(County|Parish)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 3790,
    "headerPatterns": [
      {
        "regExp": "(?i).*(us|united states).*county.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "US County Name"
        ],
        "negativeExamples": [
          "US Country Name"
        ]
      },
      {
        "regExp": "(?i).*(us|united states).*county.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "US County"
        ],
        "negativeExamples": [
          "EU County"
        ]
      },
      {
        "regExp": "(?i).*(county|parish).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "County Name"
        ],
        "negativeExamples": [
          "City Name"
        ]
      },
      {
        "regExp": "(?i).*cnty.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cnty_name"
        ],
        "negativeExamples": [
          "city_name"
        ]
      },
      {
        "regExp": "(?i).*(county|parish).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "County"
        ],
        "negativeExamples": [
          "Country"
        ]
      }
    ],
    "positiveContentExamples": [
      "Los Angeles County",
      "Cook County",
      "Miami-Dade County",
      "Prince George's County",
      "St. Tammany Parish",
      "Santa Fe County",
      "Queen Anne's County",
      "San Juan County"
    ],
    "negativeContentExamples": [
      "Los Angeles",
      "Los Angeles County, CA",
      "los angeles county",
      "St Tammany Parish",
      "Bexar Co",
      "County of Los Angeles",
      "King County WA",
      "New York County #12"
    ],
    "positiveHeaderExamples": [
      "County",
      "County Name",
      "US County",
      "Parish Name",
      "County Name (US)",
      "County/Parish Name",
      "Home County",
      "County of Residence Name"
    ],
    "negativeHeaderExamples": [
      "State",
      "FIPS Code",
      "City",
      "Country",
      "Province",
      "Municipality",
      "Zip Code",
      "County Code"
    ],
    "explanation": "Use this semantic type to recognize U.S. county-level administrative area names that explicitly end with County or Parish, written in standard title case. It supports multi-word county names, hyphenated forms, apostrophes (e.g., George's), and common abbreviations like St. for Saint. Typical datasets include demographics, public health, elections, and GIS attributes where the field stores the county/parish name as text rather than a code.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:30.521563"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.DEPARTMENT_CO",
    "description": "Identifies Colombian department names written in Spanish as proper nouns. Values are composed of one or more capitalized Spanish words and may include lowercase connectors such as de, del, la, las, los, or y between capitalized tokens. Abbreviations, punctuation, digits, or formatting artifacts are not included.",
    "pluginType": "regex",
    "regexPattern": "\\b(?!Departamento\\b)(?!Department\\b)([A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc]+)(\\s(de|del|la|las|los|y)\\s[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc]+|\\s[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc]+)*\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 3800,
    "headerPatterns": [
      {
        "regExp": "(?i).*(colombia|colombian).*(department|departamento).*(name|nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Colombian department name"
        ],
        "negativeExamples": [
          "Department name"
        ]
      },
      {
        "regExp": "(?i).*(colombia|colombian).*(department|departamento).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Department of Colombia"
        ],
        "negativeExamples": [
          "Department code"
        ]
      },
      {
        "regExp": "(?i).*(department|departamento).*(name|nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Departamento Nombre"
        ],
        "negativeExamples": [
          "Department Code"
        ]
      },
      {
        "regExp": "(?i).*(dept|depto).*(name|nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Dept Name"
        ],
        "negativeExamples": [
          "Dept Code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Antioquia",
      "Atl\u00e1ntico",
      "Bol\u00edvar",
      "Boyac\u00e1",
      "Cundinamarca",
      "La Guajira",
      "Norte de Santander",
      "Valle del Cauca"
    ],
    "negativeContentExamples": [
      "Departamento de Antioquia",
      "Department Antioquia",
      "depto Antioquia",
      "Valle del-Cauca",
      "Norte Santander",
      "Antioquia 2",
      "Cundina_marca",
      "Bogot\u00e1 D.C."
    ],
    "positiveHeaderExamples": [
      "Departamento",
      "Department",
      "Colombian Department",
      "Departamento Nombre",
      "Department Name",
      "Dept Name",
      "Department of Colombia",
      "Departamento de Colombia"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Municipality",
      "City",
      "State Code",
      "Province ID",
      "Country Name",
      "City Name",
      "Department Code"
    ],
    "explanation": "This semantic type targets cells that contain only the official names of Colombia's first-level administrative divisions (departamentos). It is useful for normalizing location fields, joining with reference tables of Colombian departments, and validating that a column contains department names rather than other geographic levels or codes.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:34.526593"
  },
  {
    "resultType": "generated",
    "semanticType": "SPATIAL.WKT",
    "description": "Strings representing Well-Known Text (WKT) for basic geometry types POINT, LINESTRING, and POLYGON. The format begins with a geometry keyword followed by parentheses containing coordinate pairs separated by spaces and commas; POINT supports an optional third ordinate.",
    "pluginType": "regex",
    "regexPattern": "(\\bPOINT\\s*\\(\\s*-?\\d+(\\.\\d+)?\\s+-?\\d+(\\.\\d+)?(\\s+-?\\d+(\\.\\d+)?)?\\s*\\)|\\bLINESTRING\\s*\\(\\s*-?\\d+(\\.\\d+)?\\s+-?\\d+(\\.\\d+)?(\\s*,\\s*-?\\d+(\\.\\d+)?\\s+-?\\d+(\\.\\d+)?)+\\s*\\)|\\bPOLYGON\\s*\\(\\s*\\(\\s*-?\\d+(\\.\\d+)?\\s+-?\\d+(\\.\\d+)?(\\s*,\\s*-?\\d+(\\.\\d+)?\\s+-?\\d+(\\.\\d+)?){2,}\\s*\\)\\s*(,\\s*\\(\\s*-?\\d+(\\.\\d+)?\\s+-?\\d+(\\.\\d+)?(\\s*,\\s*-?\\d+(\\.\\d+)?\\s+-?\\d+(\\.\\d+)?){2,}\\s*\\)\\s*)*\\))",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 3700,
    "headerPatterns": [
      {
        "regExp": "(?i).*(\\bgeometry\\b|\\bspatial\\b|\\bgeom\\b).*\\bwkt\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Geometry WKT"
        ],
        "negativeExamples": [
          "Spatial Geometry"
        ]
      },
      {
        "regExp": "(?i).*\\bwell\\b.*\\bknown\\b.*\\btext\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Well Known Text"
        ],
        "negativeExamples": [
          "Well Known Types"
        ]
      },
      {
        "regExp": "(?i).*\\bwkt\\b.*\\bstring\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "WKT String"
        ],
        "negativeExamples": [
          "Geometry String"
        ]
      },
      {
        "regExp": "(?i).*\\bspatial\\b.*\\bgeometry\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Spatial Geometry"
        ],
        "negativeExamples": [
          "Spatial Index"
        ]
      },
      {
        "regExp": "(?i).*\\bwkt\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "WKT"
        ],
        "negativeExamples": [
          "WKID"
        ]
      }
    ],
    "positiveContentExamples": [
      "POINT(30 10)",
      "POINT(-73.9857 40.7484)",
      "POINT(30 10 5)",
      "LINESTRING(30 10, 10 30, 40 40)",
      "LINESTRING(-10.5 0, 20.25 35.75)",
      "POLYGON((30 10, 40 40, 20 40, 10 20, 30 10))",
      "POLYGON((-10 -10, -10 10, 10 10, 10 -10, -10 -10))",
      "POLYGON((0 0, 10 0, 10 10, 0 10, 0 0),(2 2, 8 2, 8 8, 2 8, 2 2))"
    ],
    "negativeContentExamples": [
      "POINT(30)",
      "POINT(30, 10)",
      "POINT Z (30 10 5)",
      "LINESTRING(30 10)",
      "LINESTRING(30, 10, 10, 30)",
      "POINT (30 10",
      "POLYGON(30 10, 40 40, 20 40)",
      "GEOMETRYCOLLECTION(POINT(4 6), LINESTRING(4 6,7 10))"
    ],
    "positiveHeaderExamples": [
      "WKT",
      "Well Known Text",
      "Spatial Geometry",
      "Geometry WKT",
      "WKT String",
      "Geometry Text",
      "Geom WKT",
      "Geometry"
    ],
    "negativeHeaderExamples": [
      "GeoJSON",
      "Coordinates",
      "Address",
      "Well Known Types",
      "WKID",
      "Geohash",
      "Longitude Latitude",
      "Shapefile"
    ],
    "explanation": "Identifies strings formatted as Well-Known Text (WKT) for POINT, LINESTRING, and POLYGON geometries. It expects coordinate pairs separated by spaces and commas, with POINT allowing an optional third ordinate, LINESTRING requiring two or more coordinate pairs, and POLYGON requiring rings enclosed in double parentheses with at least three coordinate pairs per ring. Typical use cases include parsing spatial geometry attributes stored as WKT in CSVs or logs.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:36.666556"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.DISTRICT_NAME_PT",
    "description": "Properly capitalized Portuguese district names. Each token starts with an uppercase letter (including Portuguese diacritics) followed by lowercase letters (including Portuguese diacritics). Tokens are separated by single spaces only; no abbreviations, digits, punctuation, or special separators are allowed.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z\u00c0\u00c1\u00c2\u00c3\u00c7\u00c9\u00ca\u00cd\u00d3\u00d4\u00d5\u00da][a-z\u00e0\u00e1\u00e2\u00e3\u00e7\u00e9\u00ea\u00ed\u00f3\u00f4\u00f5\u00fa]+)( [A-Z\u00c0\u00c1\u00c2\u00c3\u00c7\u00c9\u00ca\u00cd\u00d3\u00d4\u00d5\u00da][a-z\u00e0\u00e1\u00e2\u00e3\u00e7\u00e9\u00ea\u00ed\u00f3\u00f4\u00f5\u00fa]+){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 3830,
    "headerPatterns": [
      {
        "regExp": "(?i).*(portuguese|pt).*(district).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Portuguese District Name"
        ],
        "negativeExamples": [
          "District Name"
        ]
      },
      {
        "regExp": "(?i).*(district).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "District Name"
        ],
        "negativeExamples": [
          "District Code"
        ]
      },
      {
        "regExp": "(?i).*(distrito).*(nome).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Nome do Distrito"
        ],
        "negativeExamples": [
          "C\u00f3digo do Distrito"
        ]
      },
      {
        "regExp": "(?i).*(dist).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "dist name"
        ],
        "negativeExamples": [
          "dist code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Lisboa",
      "Porto",
      "Braga",
      "Bragan\u00e7a",
      "Castelo Branco",
      "Vila Real",
      "Viana Do Castelo",
      "\u00c9vora"
    ],
    "negativeContentExamples": [
      "Viana do Castelo",
      "Castelo-Branco",
      "LISBOA",
      "lisboa",
      "Porto 2",
      "Porto, Norte",
      "Vila  Real",
      "Santar\u00e9m."
    ],
    "positiveHeaderExamples": [
      "Distrito",
      "District",
      "Portuguese District",
      "District Name",
      "Portuguese District Name",
      "District Name PT",
      "Nome do Distrito",
      "Distrito Nome"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Region",
      "City",
      "District Code",
      "Province",
      "County",
      "Area Name",
      "State"
    ],
    "explanation": "This semantic type targets Portuguese district names written in proper title case with Portuguese diacritics, composed of 1\u20134 words separated by single spaces and containing letters only. It is useful for identifying columns storing official district names without abbreviations or punctuation, and relies on contextual header patterns emphasizing district name semantics.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:36.712063"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_ZA",
    "description": "A text field containing South African province codes that follow the pattern of exactly two uppercase letters. The format represents official provincial abbreviations as used in South African government documentation and postal addressing systems.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "EC",
      "FS",
      "GP",
      "LP",
      "MP",
      "NC",
      "NW",
      "WC",
      "ZN"
    ],
    "backout": "^[A-Z]{2}$",
    "confidenceThreshold": 98,
    "priority": 4020,
    "headerPatterns": [
      {
        "regExp": "(?i).*(south[ _-]?africa|sa|za).*(province).*(code).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "SA Province Code"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      },
      {
        "regExp": "(?i).*province.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Province Code"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*(prov|prv).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Prov Code"
        ],
        "negativeExamples": [
          "Prov Name"
        ]
      },
      {
        "regExp": "(?i).*(sa|za).*(province).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "SA Province"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Province"
        ]
      }
    ],
    "positiveContentExamples": [
      "EC",
      "FS",
      "GP",
      "LP",
      "MP",
      "NC",
      "ZN"
    ],
    "negativeContentExamples": [
      "GA",
      "WC-",
      "KZN",
      "ZN1",
      "N W",
      "gp",
      "W C",
      "G-P"
    ],
    "positiveHeaderExamples": [
      "Province Code",
      "SA Province",
      "Province",
      "South Africa Province Code",
      "ZA Province Code",
      "Prov Code",
      "Province Abbrev Code"
    ],
    "negativeHeaderExamples": [
      "Province Name",
      "Country",
      "District",
      "State Code",
      "Province ID",
      "Region Code",
      "Province Number"
    ],
    "explanation": "This semantic type identifies two-letter South African province abbreviations, suitable for validating and standardizing province code fields in datasets related to addresses, demographics, logistics, and government records. Use it to ensure values are restricted to the known finite set of province codes; the backout pattern protects against structurally similar but invalid tokens.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:38.085315"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.INSEE_CODE_FR",
    "description": "Five-digit French INSEE code used for standardized territorial referencing. Values consist of exactly five consecutive numeric digits with no spaces, letters, or punctuation.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3840,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bcode\\b.*\\binsee\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code INSEE"
        ],
        "negativeExamples": [
          "Department Code"
        ]
      },
      {
        "regExp": "(?i).*\\binsee\\b.*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "INSEE Code"
        ],
        "negativeExamples": [
          "INSEE Number"
        ]
      },
      {
        "regExp": "(?i).*\\binsee\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "INSEE"
        ],
        "negativeExamples": [
          "Department"
        ]
      },
      {
        "regExp": "(?i).*\\binsee\\b.*\\b(id|num|number)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "INSEE ID"
        ],
        "negativeExamples": [
          "INSEE Dept"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "01001",
      "75056",
      "33063",
      "13055",
      "59350",
      "97411",
      "69001",
      "06088"
    ],
    "negativeContentExamples": [
      "7505",
      "750560",
      "75 056",
      "750-56",
      "A5056",
      "7505B",
      "0075056",
      "750.56"
    ],
    "positiveHeaderExamples": [
      "Code INSEE",
      "INSEE Code",
      "INSEE",
      "INSEE ID",
      "INSEE Number",
      "code_insee",
      "insee code",
      "Code_INSEE"
    ],
    "negativeHeaderExamples": [
      "City Name",
      "Department",
      "Postal Code",
      "Region",
      "Commune Name",
      "Address",
      "City Identifier",
      "Department Name"
    ],
    "explanation": "This semantic type targets French INSEE identifiers formatted as exactly five digits, suitable for classifying columns containing commune or territorial codes. It is intended for datasets where column headers and values strongly indicate INSEE-based coding rather than generic postal or other administrative codes.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:38.345332"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_IT",
    "description": "Two-letter uppercase codes representing Italian provinces. Values consist of exactly two uppercase letters with no spaces, numbers, or special characters. This type focuses on the structural pattern of Italian province abbreviations rather than validating against a closed list.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3930,
    "headerPatterns": [
      {
        "regExp": "(?i).*(italy|italian|it).*provinc.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Italian Province Code"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      },
      {
        "regExp": "(?i).*provinc.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Province Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*provinc.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Provincia"
        ],
        "negativeExamples": [
          "Region"
        ]
      },
      {
        "regExp": "(?i).*(prov|prv|pr)[ ._-]*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Prov Code"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "RM",
      "MI",
      "TO",
      "NA",
      "FI",
      "BO",
      "VE",
      "GE"
    ],
    "negativeContentExamples": [
      "Rm",
      "MI-",
      "RM1",
      "RM ",
      " RM",
      "ROM",
      "R M",
      "M1"
    ],
    "positiveHeaderExamples": [
      "Provincia",
      "Province Code",
      "Italian Province",
      "Italian Province Code",
      "IT Province Code",
      "Prov Code",
      "Province Code (IT)"
    ],
    "negativeHeaderExamples": [
      "Province Name",
      "Region",
      "Country",
      "Postal Code",
      "State Code",
      "City",
      "County",
      "Municipality"
    ],
    "explanation": "This semantic type captures columns containing Italian province abbreviations, which are two uppercase letters (e.g., RM, MI, TO). It is suitable when the column header or surrounding context indicates province codes for Italy, and the values follow a strict two-letter format. The regex focuses on the structural pattern, while header patterns help disambiguate from other two-letter code domains.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:39.745733"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.IBAN",
    "description": "An alphanumeric string following the pattern ^[A-Z]{2}\\d{2}[A-Z0-9]+$ starting with country code, check digits, and bank-specific characters.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2}\\d{2}[A-Z0-9]{11,30}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 2560,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\binternational\\s*bank\\s*account\\s*number\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "International Bank Account Number"
        ],
        "negativeExamples": [
          "Bank Account Number"
        ]
      },
      {
        "regExp": "(?i).*\\biban\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IBAN"
        ],
        "negativeExamples": [
          "SWIFT"
        ]
      },
      {
        "regExp": "(?i).*\\binternational\\s*account\\b.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "International Account"
        ],
        "negativeExamples": [
          "Account"
        ]
      },
      {
        "regExp": "(?i).*\\bbank\\s*account\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Bank Account"
        ],
        "negativeExamples": [
          "Bank Name"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "IBAN Code"
        ],
        "negativeExamples": [
          "Account Number"
        ]
      }
    ],
    "positiveContentExamples": [
      "GB82WEST12345698765432",
      "DE89370400440532013000",
      "FR1420041010050500013M02606",
      "NL91ABNA0417164300",
      "ES9121000418450200051332",
      "IT60X0542811101000000123456",
      "BE68539007547034",
      "PT50000201231234567890154"
    ],
    "negativeContentExamples": [
      "gb82WEST12345698765432",
      "GB821234567890",
      "GB82 WEST 12345698765432",
      "DE89-37040044-0532013000",
      "FR14_20041010050500013M02606",
      "82GBWEST12345698765432",
      "GB8AWEST12345698765432",
      "GB82WEST12345698765432123456789012345"
    ],
    "positiveHeaderExamples": [
      "IBAN",
      "Bank Account",
      "International Account",
      "IBAN Number",
      "IBAN Code",
      "International Bank Account Number",
      "IBAN No"
    ],
    "negativeHeaderExamples": [
      "Account Number",
      "Bank Name",
      "Country Code",
      "SWIFT",
      "BIC",
      "Routing Number",
      "Account ID"
    ],
    "explanation": "Detects International Bank Account Numbers (IBAN), which start with a two-letter country code, followed by two check digits, and then a country-specific alphanumeric Basic Bank Account Number (BBAN). The regex focuses on structural validation (length and character classes) without enforcing checksum or formatting with spaces.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:40.519949"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_NL",
    "description": "Official Dutch province names written in Dutch with proper capitalization and required hyphenation where applicable (e.g., Noord-Holland, Zuid-Holland, Noord-Brabant). Values are single- or hyphenated proper nouns without abbreviations, extra punctuation, or diacritics not used in the Dutch spellings.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "DRENTHE",
      "FLEVOLAND",
      "FRIESLAND",
      "GELDERLAND",
      "GRONINGEN",
      "LIMBURG",
      "NOORD-BRABANT",
      "NOORD-HOLLAND",
      "OVERIJSSEL",
      "UTRECHT",
      "ZEELAND",
      "ZUID-HOLLAND"
    ],
    "backout": "^[A-Z][a-z]+(-[A-Z][a-z]+)?$",
    "confidenceThreshold": 99,
    "priority": 3990,
    "headerPatterns": [
      {
        "regExp": "(?i).*(province|provincie).*(name|naam).*(nl|nederland|netherlands|dutch).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Province Name NL"
        ],
        "negativeExamples": [
          "Province Code NL"
        ]
      },
      {
        "regExp": "(?i).*(dutch|nl|nederland|netherlands).*(province|provincie).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Dutch Province"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(province|provincie).*(name|naam).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Provincie Naam"
        ],
        "negativeExamples": [
          "Country Name"
        ]
      },
      {
        "regExp": "(?i).*\\bprov\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "prov"
        ],
        "negativeExamples": [
          "Province"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Drenthe",
      "Flevoland",
      "Friesland",
      "Gelderland",
      "Groningen",
      "Limburg",
      "Noord-Brabant",
      "Zuid-Holland"
    ],
    "negativeContentExamples": [
      "friesland",
      "Noord Holland",
      "Zuid - Holland",
      "Noord- holland",
      "NoordHolland",
      "Holland",
      "Gelder land",
      "Frysl\u00e2n"
    ],
    "positiveHeaderExamples": [
      "Provincie",
      "Province",
      "Dutch Province",
      "Province Name NL",
      "Provincie Naam",
      "Netherlands Province",
      "NL Province"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Municipality",
      "City",
      "State",
      "Region",
      "Province Code",
      "Country Name"
    ],
    "explanation": "This semantic type identifies official province names of the Netherlands in Dutch, ensuring correct capitalization and mandatory hyphenation for composite names. It uses a finite controlled list of the 12 provinces to avoid ambiguity with other proper nouns and regions.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:41.695919"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_IT",
    "description": "Italian province names written as proper nouns: one or more words, each starting with an uppercase letter followed by lowercase letters (including diacritics), separated by single spaces. No digits, punctuation, abbreviations, hyphens, or apostrophes are allowed.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u00d9\u00da\u00db\u00dc\u00dd][a-z\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00ff]+(\\s[A-Z\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u00d9\u00da\u00db\u00dc\u00dd][a-z\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00ff]+)*\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 3980,
    "headerPatterns": [
      {
        "regExp": "(?i).*(italian|it).*(province|provincia).*(name|nome).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Italian Province Name"
        ],
        "negativeExamples": [
          "Province Code"
        ]
      },
      {
        "regExp": "(?i).*(province|provincia).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Provincia"
        ],
        "negativeExamples": [
          "Region"
        ]
      },
      {
        "regExp": "(?i).*(italian|it).*(province|provincia).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Italian Province"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(prov[_\\s]*name|provincia[_\\s]*nome|prov[_\\s]*nm).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "prov_name"
        ],
        "negativeExamples": [
          "prov_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Roma",
      "Milano",
      "Torino",
      "Reggio Emilia",
      "La Spezia",
      "Forl\u00ec Cesena",
      "Massa Carrara",
      "Vibo Valentia"
    ],
    "negativeContentExamples": [
      "Monza e Brianza",
      "Forl\u00ec-Cesena",
      "L'Aquila",
      "Roma 2",
      "reggio Emilia",
      "Massa  Carrara",
      "Verbano-Cusio-Ossola",
      "La Spezia (SP)"
    ],
    "positiveHeaderExamples": [
      "Provincia",
      "Province",
      "Italian Province",
      "Provincia Italiana",
      "Province Name",
      "Italian Province Name",
      "Nome Provincia",
      "IT Province Name"
    ],
    "negativeHeaderExamples": [
      "Province Code",
      "Region",
      "Country",
      "City",
      "State",
      "Province Code IT",
      "Postal Code",
      "Province Abbreviation"
    ],
    "explanation": "Identifies Italian province names presented as clean, capitalized proper nouns with diacritics allowed and tokens separated by single spaces. Intended for columns containing full province names without abbreviations, punctuation, or codes. Useful for validating and normalizing administrative geography fields labeled in either Italian or English.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:43.145521"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_AU",
    "description": "A text field containing Australian state codes that follow established patterns typically consisting of two or three uppercase letters. The format represents official state abbreviations as used in Australian government documentation and postal addressing systems.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "NSW",
      "VIC",
      "QLD",
      "SA",
      "WA",
      "TAS",
      "NT",
      "ACT"
    ],
    "backout": "^[A-Z]{2,3}$",
    "confidenceThreshold": 98,
    "priority": 4070,
    "headerPatterns": [
      {
        "regExp": "(?i).*(australian|aus|au).*(state|st).*(code|abbr|cd).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Australian State Code"
        ],
        "negativeExamples": [
          "Australian State Name"
        ]
      },
      {
        "regExp": "(?i).*(state|st).*(code|abbr|cd).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Code"
        ],
        "negativeExamples": [
          "State Name"
        ]
      },
      {
        "regExp": "(?i).*(australian|aus|au).*(state|st).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Australian State"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*state.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State"
        ],
        "negativeExamples": [
          "Territory"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "NSW",
      "VIC",
      "QLD",
      "SA",
      "WA",
      "TAS",
      "NT",
      "ACT"
    ],
    "negativeContentExamples": [
      "NS",
      "N SW",
      "nsw",
      "QLD.",
      "WAU",
      "VIC1",
      "ACT-",
      "STATE"
    ],
    "positiveHeaderExamples": [
      "State Code",
      "Australian State",
      "State",
      "AU State Code",
      "State Abbreviation",
      "State CD",
      "AU State",
      "State Abbr"
    ],
    "negativeHeaderExamples": [
      "State Name",
      "Country",
      "Territory",
      "Postal Code",
      "Province",
      "Region",
      "Country Code",
      "US State Code"
    ],
    "explanation": "This semantic type identifies Australian state and territory abbreviations commonly used in official and postal contexts. It is modeled as a finite list to ensure high precision, with a stricter fallback pattern to capture the expected 2\u20133 uppercase letter format. Typical use cases include validating or standardizing columns storing Australian state codes and supporting header-based detection in datasets.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:45.758882"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_NL",
    "description": "Identifies Dutch municipality names written as one to four words with proper capitalization, using only basic Latin letters and single spaces between words. Each word starts with an uppercase letter followed by lowercase letters, with no digits, punctuation, hyphens, or abbreviations.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z][a-z]{2,}(\\s[A-Z][a-z]{2,}){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 3900,
    "headerPatterns": [
      {
        "regExp": "(?i).*(dutch|nl).*(municipality).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Dutch municipality name"
        ],
        "negativeExamples": [
          "Municipality Code"
        ]
      },
      {
        "regExp": "(?i).*(gemeente).*(name|naam).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Gemeente naam"
        ],
        "negativeExamples": [
          "Province name"
        ]
      },
      {
        "regExp": "(?i).*(dutch|nl).*(municipality).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Dutch Municipality"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(municipality|gemeente).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Municipality"
        ],
        "negativeExamples": [
          "Province"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Amsterdam",
      "Rotterdam",
      "Utrecht",
      "Den Haag",
      "Eindhoven",
      "Groningen",
      "Maastricht",
      "Haarlemmermeer"
    ],
    "negativeContentExamples": [
      "amsterdam",
      "Den haag",
      "Rotterdam-Noord",
      "Groningen.",
      "Delft2",
      "S Gravenhage",
      "Zwolle- Zuid",
      "Amsterdam NL"
    ],
    "positiveHeaderExamples": [
      "Gemeente",
      "Municipality",
      "Dutch Municipality",
      "Municipality Name",
      "Gemeente Naam",
      "NL Municipality",
      "Dutch Municipality Name"
    ],
    "negativeHeaderExamples": [
      "Province",
      "Country",
      "Municipality Code",
      "City",
      "Region",
      "Postal Code",
      "County",
      "State Code"
    ],
    "explanation": "This semantic type targets Dutch municipality names formatted as properly capitalized words using only letters and spaces. It is suitable for columns containing municipality names in the Netherlands and relies on header cues to disambiguate from other name-like fields.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:46.303154"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_SE",
    "description": "Swedish postal code in space-separated format: three digits, a single space, then two digits. No hyphens, periods, or additional characters are allowed, and exactly one space must separate the digit groups.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{3} [0-9]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3640,
    "headerPatterns": [
      {
        "regExp": "(?i).*(se|sweden).*postal.*code.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "SE Postal Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*postnummer.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postnummer"
        ],
        "negativeExamples": [
          "Stad"
        ]
      },
      {
        "regExp": "(?i).*postal.*code.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "Postal Address"
        ]
      },
      {
        "regExp": "(?i).*(zip code|zipcode|zip|post code).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "ZIP"
        ],
        "negativeExamples": [
          "City Code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "City"
        ]
      }
    ],
    "positiveContentExamples": [
      "111 22",
      "413 19",
      "972 33",
      "984 31",
      "831 34",
      "215 65",
      "752 36",
      "602 18"
    ],
    "negativeContentExamples": [
      "11122",
      "111-22",
      "11 122",
      "111 2",
      "11 22",
      "111 222",
      "111 2A",
      "111  22"
    ],
    "positiveHeaderExamples": [
      "Postnummer",
      "Postal Code",
      "ZIP",
      "SE Postal Code",
      "Sweden Postal Code",
      "Zip Code",
      "Post Code",
      "Postnr"
    ],
    "negativeHeaderExamples": [
      "Stad",
      "City",
      "Address",
      "Postal Address",
      "Area Code",
      "Country Code",
      "ZIP+4",
      "Postleitzahl"
    ],
    "explanation": "This semantic type identifies Swedish postal codes formatted as three digits, a single space, then two digits (e.g., 111 22). It is intended for datasets where the value strictly uses one space as the separator and contains only digits with no extra symbols. Header patterns prioritize Swedish-specific labels and postal code terminology, then back off to common abbreviations and, finally, the primitive concept of a code.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:47.593144"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_CODE_NL",
    "description": "Dutch municipality code represented as exactly four consecutive digits. Matches a standalone four-digit numeric token without letters, spaces inside the token, or special characters, used for standardized municipal referencing.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3880,
    "headerPatterns": [
      {
        "regExp": "(?i).*(nl|nld).*(municipality|gemeente).*(code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "NL Municipality Code"
        ],
        "negativeExamples": [
          "Municipality Code"
        ]
      },
      {
        "regExp": "(?i).*(cbs).*(municipality|gemeente).*(code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CBS Municipality Code"
        ],
        "negativeExamples": [
          "CBS Code"
        ]
      },
      {
        "regExp": "(?i).*(gemeentecode|gemeente.*code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Gemeentecode"
        ],
        "negativeExamples": [
          "Gemeente Naam"
        ]
      },
      {
        "regExp": "(?i).*(municipality).*(code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Municipality Code"
        ],
        "negativeExamples": [
          "Municipality Name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Province"
        ]
      }
    ],
    "positiveContentExamples": [
      "0001",
      "0045",
      "1234",
      "4321",
      "5678",
      "9012",
      "2749",
      "8190"
    ],
    "negativeContentExamples": [
      "12345",
      "123",
      "12 34",
      "A123",
      "1234A",
      "12-34",
      "1 234",
      "00000"
    ],
    "positiveHeaderExamples": [
      "Gemeente Code",
      "Municipality Code",
      "CBS Code",
      "NL Municipality Code",
      "Gemeentecode",
      "CBS Municipality Code",
      "Municipality Code (NL)",
      "CBS Gemeente Code"
    ],
    "negativeHeaderExamples": [
      "Municipality Name",
      "Province",
      "Country",
      "ZIP Code",
      "Area Code",
      "City Code",
      "Province Code",
      "Municipality Number"
    ],
    "explanation": "This semantic type identifies Dutch municipality codes consisting of exactly four digits, suitable for datasets containing standardized municipality identifiers. It is useful for validating and classifying columns that store municipality codes in Dutch administrative data.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:48.138368"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_UK",
    "description": "Properly capitalized UK county names composed of one to five words, where each word starts with an uppercase letter followed by lowercase letters, separated by single spaces, and without punctuation, digits, or abbreviations. Examples include forms like \"Greater London\", \"East Sussex\", and \"Isle Of Wight\".",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z][a-z]{1,20}(\\s[A-Z][a-z]{1,20}){0,4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 3780,
    "headerPatterns": [
      {
        "regExp": "(?i).*(uk|united\\s*kingdom).*county.*name.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "UK County Name"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(uk|united\\s*kingdom).*county.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "UK County"
        ],
        "negativeExamples": [
          "Region"
        ]
      },
      {
        "regExp": "(?i).*(uk|united\\s*kingdom).*cty.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "UK Cty"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*county.*name.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "County Name"
        ],
        "negativeExamples": [
          "Country Name"
        ]
      },
      {
        "regExp": "(?i).*county.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "County"
        ],
        "negativeExamples": [
          "Country"
        ]
      }
    ],
    "positiveContentExamples": [
      "Greater London",
      "West Yorkshire",
      "East Sussex",
      "Isle Of Wight",
      "County Durham",
      "Powys",
      "County Antrim",
      "North Lanarkshire"
    ],
    "negativeContentExamples": [
      "Isle of Wight",
      "west Yorkshire",
      "East  Sussex",
      "Greater-London",
      "County  Durham",
      "DURHAM",
      "Bristol ",
      "North Yorkshire1"
    ],
    "positiveHeaderExamples": [
      "County",
      "UK County",
      "County Name",
      "UK County Name",
      "County (UK)",
      "United Kingdom County",
      "UK Cty"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Region",
      "City",
      "Province",
      "State",
      "Borough",
      "Parish"
    ],
    "explanation": "This semantic type targets UK county names written as clean proper nouns with each word capitalized and separated by single spaces, without abbreviations, punctuation, or digits. It is useful for validating and classifying administrative geography columns labeled as county-level entities across the UK.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:50.317774"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_MX",
    "description": "Identifies official Mexican municipality names written in Spanish as proper-noun strings. Names consist of one or more capitalized words optionally linked by Spanish connectors such as de, del, de la, de las, de los, la, las, los, or y. Only letters (including Spanish diacritics) and spaces are allowed; no abbreviations, punctuation, digits, or special symbols.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc]+(\\s(de la|de las|de los|del|de|la|las|los|y)\\s[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc]+|\\s[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc]+)*\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 3890,
    "headerPatterns": [
      {
        "regExp": "(?i).*(municipio|munic\u00edpio|municipality).*(mx|mexico|m\u00e9xico).*(name|nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality_mx_name"
        ],
        "negativeExamples": [
          "Municipality Code MX"
        ]
      },
      {
        "regExp": "(?i).*(municipio|munic\u00edpio|municipality).*(name|nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Municipality Name"
        ],
        "negativeExamples": [
          "State Name"
        ]
      },
      {
        "regExp": "(?i).*(mexican|m\u00e9xico|mexico).*(municipality|municipio|munic\u00edpio).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Mexican Municipality"
        ],
        "negativeExamples": [
          "State of Mexico"
        ]
      },
      {
        "regExp": "(?i).*(mun|muni|mpio).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mpio"
        ],
        "negativeExamples": [
          "province"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Benito Ju\u00e1rez",
      "Villa de \u00c1lvarez",
      "San Andr\u00e9s Tuxtla",
      "Ecatepec de Morelos",
      "Mineral de la Reforma",
      "San Pedro Cholula",
      "Jos\u00e9 Azueta",
      "Solidaridad"
    ],
    "negativeContentExamples": [
      "benito ju\u00e1rez",
      "Benito Ju\u00e1rez CDMX",
      "Othon P Blanco",
      "San Pedro-Cholula",
      "San Andr\u00e9s Tuxtla 2",
      "Mineral de la Reforma y",
      "Jos\u00e9 Azueta.",
      "123 Benito Ju\u00e1rez"
    ],
    "positiveHeaderExamples": [
      "Munic\u00edpio",
      "Municipality",
      "Mexican Municipality",
      "municipality_mx_name",
      "Municipality Name",
      "Municipio Nombre",
      "Municipio MX",
      "Nombre de Municipio"
    ],
    "negativeHeaderExamples": [
      "State",
      "Country",
      "City",
      "Province",
      "County",
      "Municipality Code",
      "State Name",
      "Postal Code"
    ],
    "explanation": "This semantic type targets Spanish-language municipality names within Mexico, ensuring proper-noun capitalization and allowing common Spanish connectors (de, del, de la, de las, de los, la, las, los, y). It excludes abbreviations, punctuation, digits, and special characters to avoid conflation with codes or descriptions. Typical use cases include identifying columns that store official municipality names for geographic normalization, address validation, and regional aggregation.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:50.583750"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_BR",
    "description": "Proper noun strings representing official Brazilian municipality names in Portuguese, composed of one to five words. Each word begins with an uppercase letter (including Portuguese diacritics) followed by lowercase letters, and optional lowercase connectors \"de\", \"da\", \"do\", \"das\", or \"dos\" may appear between words. Only letters and single spaces are allowed; no abbreviations, punctuation, or special formatting characters.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z\u00c1\u00c0\u00c2\u00c3\u00c4\u00c7\u00c9\u00ca\u00cd\u00d3\u00d4\u00d5\u00d6\u00da\u00dc][a-z\u00e1\u00e0\u00e2\u00e3\u00e4\u00e7\u00e9\u00ea\u00ed\u00f3\u00f4\u00f5\u00f6\u00fa\u00fc]+( ((de|da|do|das|dos) )?[A-Z\u00c1\u00c0\u00c2\u00c3\u00c4\u00c7\u00c9\u00ca\u00cd\u00d3\u00d4\u00d5\u00d6\u00da\u00dc][a-z\u00e1\u00e0\u00e2\u00e3\u00e4\u00e7\u00e9\u00ea\u00ed\u00f3\u00f4\u00f5\u00f6\u00fa\u00fc]+){0,4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3850,
    "headerPatterns": [
      {
        "regExp": "(?i).*(brazilian|brasil|br).*\\smunicipality.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Brazilian Municipality"
        ],
        "negativeExamples": [
          "Municipality Code"
        ]
      },
      {
        "regExp": "(?i).*\\b(municipality|munic[i\u00ed]pio)\\b.*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Municipality Name"
        ],
        "negativeExamples": [
          "Municipality Code"
        ]
      },
      {
        "regExp": "(?i).*\\b(municipality|munic[i\u00ed]pio)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Munic\u00edpio"
        ],
        "negativeExamples": [
          "State"
        ]
      },
      {
        "regExp": "(?i).*\\b(mun|munic|muni)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mun_name"
        ],
        "negativeExamples": [
          "state_code"
        ]
      },
      {
        "regExp": "(?i).*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "state"
        ]
      }
    ],
    "positiveContentExamples": [
      "S\u00e3o Paulo",
      "Rio de Janeiro",
      "Belo Horizonte",
      "Porto Alegre",
      "Juiz de Fora",
      "S\u00e3o Jos\u00e9 dos Campos",
      "Foz do Igua\u00e7u",
      "Chapec\u00f3"
    ],
    "negativeContentExamples": [
      "sao paulo",
      "S\u00e3o-Paulo",
      "Rio de Janeiro 2",
      "S\u00c3O PAULO",
      "Sant'Ana do Livramento",
      "Porto Alegre/RS",
      "S\u00e3o  Jos\u00e9",
      "Jo\u00e3o Pessoa,"
    ],
    "positiveHeaderExamples": [
      "Munic\u00edpio",
      "Municipality",
      "Brazilian Municipality",
      "Municipality Name",
      "Nome do Munic\u00edpio",
      "Munic\u00edpio BR"
    ],
    "negativeHeaderExamples": [
      "State",
      "Country",
      "Municipality Code",
      "City",
      "Province",
      "State Name",
      "City Code",
      "County"
    ],
    "explanation": "This semantic type identifies Brazilian municipality names written in Portuguese as proper nouns, allowing one to five capitalized words separated by single spaces, with optional lowercase connectors de/da/do/das/dos. It excludes abbreviations, punctuation, digits, underscores, and hyphens to avoid false positives. Use this type to classify columns containing municipality names in Brazil, especially when paired with headers referring to municipalities.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:51.019316"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.REGION_NAME_IT",
    "description": "A text field containing Italian regional names that follow standard Italian linguistic patterns with proper capitalization and spelling. The format represents official territorial designations as used in Italian administrative and legal documentation systems.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "ABRUZZO",
      "BASILICATA",
      "CALABRIA",
      "CAMPANIA",
      "EMILIA-ROMAGNA",
      "FRIULI-VENEZIA GIULIA",
      "LAZIO",
      "LIGURIA",
      "LOMBARDIA",
      "MARCHE",
      "MOLISE",
      "PIEMONTE",
      "PUGLIA",
      "SARDEGNA",
      "SICILIA",
      "TOSCANA",
      "TRENTINO-ALTO ADIGE",
      "UMBRIA",
      "VALLE D'AOSTA",
      "VENETO"
    ],
    "backout": "^[A-Z][A-Z \\-']{2,30}$",
    "confidenceThreshold": 98,
    "priority": 4040,
    "headerPatterns": [
      {
        "regExp": "(?i).*(italian).*region.*name.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Italian Region Name"
        ],
        "negativeExamples": [
          "Italian Region Code"
        ]
      },
      {
        "regExp": "(?i).*(italian).*region.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Italian Region"
        ],
        "negativeExamples": [
          "Italian Province"
        ]
      },
      {
        "regExp": "(?i).*(region|regione).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Region Name"
        ],
        "negativeExamples": [
          "Country Name"
        ]
      },
      {
        "regExp": "(?i).*(regione|region|reg|rgn).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Regione"
        ],
        "negativeExamples": [
          "Region Code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Lombardia",
      "Lazio",
      "Emilia-Romagna",
      "Friuli-Venezia Giulia",
      "Trentino-Alto Adige",
      "Valle d'Aosta",
      "Sicilia",
      "Toscana"
    ],
    "negativeContentExamples": [
      "Lombardy",
      "Sardinia",
      "Apulia",
      "Emilia Romagna",
      "Trentino Alto Adige",
      "Valle d\u2019Aosta",
      "Friuli Venezia Giulia",
      "Lazio Region"
    ],
    "positiveHeaderExamples": [
      "Regione",
      "Region",
      "Italian Region",
      "Region Name",
      "Regione Name",
      "Name of Region",
      "IT Region",
      "Italian Region Name"
    ],
    "negativeHeaderExamples": [
      "Province",
      "Country",
      "City",
      "Region Code",
      "State",
      "County",
      "Province Name",
      "Municipality"
    ],
    "explanation": "This semantic type identifies Italian region names as officially used in administrative contexts. It is suitable for columns where values are the proper names of Italy's 20 regions and should be distinguished from codes or translated forms.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:51.757371"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_CA",
    "description": "Full English names of Canadian provinces written in proper capitalization (Title Case). This type includes only the official province names and excludes abbreviations, codes, punctuation, and qualifiers.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "ALBERTA",
      "BRITISH COLUMBIA",
      "MANITOBA",
      "NEW BRUNSWICK",
      "NEWFOUNDLAND AND LABRADOR",
      "NOVA SCOTIA",
      "ONTARIO",
      "PRINCE EDWARD ISLAND",
      "QUEBEC",
      "SASKATCHEWAN"
    ],
    "backout": "^[A-Za-z]+( [A-Za-z]+){0,3}$",
    "confidenceThreshold": 98,
    "priority": 3940,
    "headerPatterns": [
      {
        "regExp": "(?i).*(canadian|canada).*province.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Canadian Province Name"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      },
      {
        "regExp": "(?i).*province.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Province Name"
        ],
        "negativeExamples": [
          "Province Code"
        ]
      },
      {
        "regExp": "(?i).*(canadian|canada).*province.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Canadian Province"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*prov.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Prov Name"
        ],
        "negativeExamples": [
          "Territory"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Province Name"
        ],
        "negativeExamples": [
          "Country"
        ]
      }
    ],
    "positiveContentExamples": [
      "Ontario",
      "Quebec",
      "British Columbia",
      "Alberta",
      "Manitoba",
      "Saskatchewan",
      "New Brunswick",
      "Newfoundland and Labrador"
    ],
    "negativeContentExamples": [
      "QC",
      "Ont.",
      "Ontario, Canada",
      "Newfoundland & Labrador",
      "Qu\u00e9bec",
      "Yukon",
      "British Columbia.",
      "Nova  Scotia"
    ],
    "positiveHeaderExamples": [
      "Province",
      "Province Name",
      "Canadian Province",
      "Canadian Province Name",
      "Province (Canada)",
      "Canada Province",
      "Prov Name"
    ],
    "negativeHeaderExamples": [
      "Province Code",
      "Country",
      "Territory",
      "State",
      "Region",
      "Province/State",
      "Territory Name"
    ],
    "explanation": "This semantic type identifies full Canadian province names in English, ensuring values are complete names rather than abbreviations or codes. It excludes Canadian territories and any entries with punctuation, qualifiers, or appended country labels.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:52.186096"
  },
  {
    "resultType": "generated",
    "semanticType": "GENDER.TEXT_ZH",
    "description": "A text field containing Chinese gender terms that follow standard Chinese linguistic patterns using traditional or simplified Chinese characters. The format represents established gender classification terminology as commonly used in Chinese demographic and official documentation contexts.",
    "pluginType": "regex",
    "regexPattern": "(?<![\u4e00-\u9fa5A-Za-z0-9])(\u7537\u6027|\u5973\u6027|\u7537\u58eb|\u5973\u58eb|\u7537|\u5973|\u4e2d\u6027|\u5176\u4ed6|\u672a\u77e5|\u4e0d\u8be6|\u4e0d\u8a73|\u672a\u8bf4\u660e|\u672a\u8aaa\u660e|\u672a\u63d0\u4f9b|\u4fdd\u5bc6)(?![\u4e00-\u9fa5A-Za-z0-9])",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 3010,
    "headerPatterns": [
      {
        "regExp": "(?i).*(\u7528\u6237|\u5ba2\u6237|\u6703\u54e1|\u5458\u5de5|\u54e1\u5de5|\u4eba\u5458|\u5b78\u751f|\u5b66\u751f).*(\u6027\u522b|\u6027\u5225).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "\u5ba2\u6237\u6027\u522b"
        ],
        "negativeExamples": [
          "\u5ba2\u6237\u5e74\u9f84"
        ]
      },
      {
        "regExp": "(?i).*(\u751f\u7406|\u6cd5\u5b9a|\u6236\u7c4d|\u6237\u7c4d).*(\u6027\u522b|\u6027\u5225).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "\u6cd5\u5b9a\u6027\u522b"
        ],
        "negativeExamples": [
          "\u6cd5\u5b9a\u59d3\u540d"
        ]
      },
      {
        "regExp": "(?i).*(\u6027\u522b|\u6027\u5225).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u6027\u522b"
        ],
        "negativeExamples": [
          "\u59d3\u540d"
        ]
      },
      {
        "regExp": "(?i).*(\u7537\u5973).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "\u7537\u5973"
        ],
        "negativeExamples": [
          "\u56fd\u7c4d"
        ]
      },
      {
        "regExp": "(?i).*(\u6027).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "\u6027"
        ],
        "negativeExamples": [
          "\u5e74\u9f84"
        ]
      },
      {
        "regExp": "(?i).*gender.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "gender"
        ],
        "negativeExamples": [
          "age"
        ]
      }
    ],
    "positiveContentExamples": [
      "\u7537",
      "\u5973",
      "\u7537\u6027",
      "\u5973\u6027",
      "\u7537\u58eb",
      "\u5973\u58eb",
      "\u5176\u4ed6",
      "\u672a\u77e5"
    ],
    "negativeContentExamples": [
      "\u7537\u5b69",
      "\u5973\u751f",
      "\u5973\u88c5",
      "\u6027\u522b",
      "\u7537\u5973\u6df7\u5408",
      "\u5973\u6027\u5411",
      "\u7537\u58eb\u670d\u88c5",
      "\u8001\u5e74\u5973\u6027"
    ],
    "positiveHeaderExamples": [
      "\u6027\u522b",
      "\u6027",
      "\u7537\u5973",
      "\u5ba2\u6237\u6027\u522b",
      "\u6cd5\u5b9a\u6027\u522b",
      "gender",
      "\u7528\u6237\u6027\u5225",
      "\u4eba\u5458\u6027\u522b"
    ],
    "negativeHeaderExamples": [
      "\u59d3\u540d",
      "\u5e74\u9f84",
      "\u56fd\u7c4d",
      "\u5ba2\u6237\u5e74\u9f84",
      "\u6027\u80fd\u8bc4\u5206",
      "\u804c\u4f4d",
      "\u56fd\u7c4d\u4ee3\u7801",
      "\u51fa\u751f\u65e5\u671f"
    ],
    "explanation": "This semantic type identifies cells containing established Chinese gender terms typically used in demographic records, such as male/female and common administrative statuses (unknown, other, confidential). It supports both simplified and traditional characters and attempts to avoid accidental matches within longer non-gender phrases.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:27:53.377541"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_ZA",
    "description": "This type follows text patterns like ^[A-Z][a-z]+(\\s[A-Z][a-z]+)*(-[A-Z][a-z]+)*$ for South African province names with proper capitalization. The format consists of proper noun text strings representing official province names in English without abbreviations or special formatting characters.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "EASTERN CAPE",
      "FREE STATE",
      "GAUTENG",
      "KWAZULU-NATAL",
      "LIMPOPO",
      "MPUMALANGA",
      "NORTH WEST",
      "NORTHERN CAPE",
      "WESTERN CAPE"
    ],
    "backout": "^[A-Z]+( [A-Z]+)*(-[A-Z]+)?$",
    "confidenceThreshold": 98,
    "priority": 4010,
    "headerPatterns": [
      {
        "regExp": "(?i).*(south[ _-]*africa|za).*[ _-]*province[ _-]*name.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Province Name ZA"
        ],
        "negativeExamples": [
          "Country Name ZA"
        ]
      },
      {
        "regExp": "(?i).*(province|prov)[ _-]*name.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Province Name"
        ],
        "negativeExamples": [
          "Province Code"
        ]
      },
      {
        "regExp": "(?i).*(south[ _-]*africa|za).*[ _-]*province.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "South African Province"
        ],
        "negativeExamples": [
          "South African City"
        ]
      },
      {
        "regExp": "(?i).*(province|prov).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Province"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Eastern Cape",
      "Free State",
      "Gauteng",
      "KwaZulu-Natal",
      "Limpopo",
      "Mpumalanga",
      "North West",
      "Western Cape"
    ],
    "negativeContentExamples": [
      "eastern cape",
      "KwaZulu Natal",
      "North-West",
      "Western cape",
      "KZN",
      "Gauteng Province",
      "Northern-Cape",
      "Northwest"
    ],
    "positiveHeaderExamples": [
      "Province",
      "South African Province",
      "Province Name",
      "Province Name ZA",
      "South African Province Name",
      "Province of South Africa",
      "ZA Province",
      "Province ZA"
    ],
    "negativeHeaderExamples": [
      "Country",
      "District",
      "City",
      "Province Code",
      "Province ID",
      "Region",
      "State",
      "County"
    ],
    "explanation": "Identifies official South African province names written in English with proper capitalization and standard tokenization (spaces and the single hyphen in KwaZulu-Natal). Use for columns that store the province name as a full text label, not abbreviations or codes.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:28:01.133316"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_BR",
    "description": "A text field containing Brazilian state abbreviations, each exactly two uppercase letters, representing the 27 federative units used in official Brazilian government and postal contexts. Values are expected to be isolated two-letter tokens, not embedded within longer strings.",
    "pluginType": "regex",
    "regexPattern": "\\b(AC|AL|AP|AM|BA|CE|DF|ES|GO|MA|MT|MS|MG|PA|PB|PR|PE|PI|RJ|RN|RO|RS|RR|SC|SE|SP|TO)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4080,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\b(br|brazil|brasil|brazilian)\\b.*\\bstate\\b.*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Brazilian State Code"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*\\bestado\\b.*\\bcodigo\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Estado Codigo"
        ],
        "negativeExamples": [
          "Estado Nome"
        ]
      },
      {
        "regExp": "(?i).*\\bstate\\b.*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Code"
        ],
        "negativeExamples": [
          "State Name"
        ]
      },
      {
        "regExp": "(?i).*\\bst\\b.*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ST Code"
        ],
        "negativeExamples": [
          "ST Name"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "SP",
      "RJ",
      "MG",
      "BA",
      "RS",
      "SC",
      "DF",
      "AM"
    ],
    "negativeContentExamples": [
      "XX",
      "Sp",
      "RJS",
      "R-J",
      "RJ1",
      "BR",
      "ACRE",
      "S P"
    ],
    "positiveHeaderExamples": [
      "Estado",
      "State Code",
      "Brazilian State",
      "Brazilian State Code",
      "BR State Code",
      "Estado Codigo",
      "ST Code"
    ],
    "negativeHeaderExamples": [
      "State Name",
      "Country",
      "Region",
      "Province",
      "Territory",
      "Postal Code",
      "Country Code",
      "State"
    ],
    "explanation": "This semantic type identifies Brazilian state codes as two-letter uppercase abbreviations and is intended for datasets containing standardized BR state identifiers (e.g., SP, RJ). It is useful for validating location attributes, normalizing regional data, and joining against reference tables keyed by Brazilian state abbreviations.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:28:03.500391"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_IE",
    "description": "Properly capitalized Irish county names (Republic of Ireland), written in English without prefixes, abbreviations, punctuation, or extra qualifiers. Values are single or compound words with leading capitals that exactly match official county names.",
    "pluginType": "regex",
    "regexPattern": "\\b(Carlow|Cavan|Clare|Cork|Donegal|Dublin|Galway|Kerry|Kildare|Kilkenny|Laois|Leitrim|Limerick|Longford|Louth|Mayo|Meath|Monaghan|Offaly|Roscommon|Sligo|Tipperary|Waterford|Westmeath|Wexford|Wicklow)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 3770,
    "headerPatterns": [
      {
        "regExp": "(?i).*(irish|ie).*(county).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Irish County Name"
        ],
        "negativeExamples": [
          "Irish Country Name"
        ]
      },
      {
        "regExp": "(?i).*(county).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "County Name"
        ],
        "negativeExamples": [
          "County Code"
        ]
      },
      {
        "regExp": "(?i).*(county).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "County"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(cty|cnty).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cty_name"
        ],
        "negativeExamples": [
          "company_name"
        ]
      },
      {
        "regExp": "(?i).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Cork",
      "Dublin",
      "Galway",
      "Kerry",
      "Kildare",
      "Tipperary",
      "Westmeath",
      "Wexford"
    ],
    "negativeContentExamples": [
      "County Cork",
      "Cork.",
      "DUBLIN",
      "Co Cork",
      "South Dublin",
      "West Meath",
      "Limerick City",
      "Offaly-"
    ],
    "positiveHeaderExamples": [
      "County",
      "Irish County",
      "County Name",
      "IE County",
      "County (IE)",
      "County of Residence"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Province",
      "City",
      "County Code",
      "Company",
      "State",
      "Region"
    ],
    "explanation": "This semantic type is intended to recognize Irish counties in the Republic of Ireland as clean, properly capitalized English names with no prefixes (e.g., no \"County\" or \"Co\"), suffixes, punctuation, or additional qualifiers. It uses a strict alternation of official county names to minimize false positives and relies on informative header patterns to disambiguate from countries, provinces, or generic names.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:28:04.726357"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_AU",
    "description": "A text field containing Australian state names that follow standard English linguistic conventions with proper capitalization and spacing. The format represents official territorial designations as used in Australian government documentation and legal systems.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "NEW SOUTH WALES",
      "VICTORIA",
      "QUEENSLAND",
      "WESTERN AUSTRALIA",
      "SOUTH AUSTRALIA",
      "TASMANIA"
    ],
    "backout": "^\\b[A-Z][A-Z ]{2,24}\\b$",
    "confidenceThreshold": 98,
    "priority": 4110,
    "headerPatterns": [
      {
        "regExp": "(?i).*(australian|aus|au)[ _-]*state[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Australian State Name"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*(australian|aus|au)[ _-]*state.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Australian State"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*state[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Name"
        ],
        "negativeExamples": [
          "Territory Name"
        ]
      },
      {
        "regExp": "(?i).*state.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State"
        ],
        "negativeExamples": [
          "Territory"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "New South Wales",
      "Victoria",
      "Queensland",
      "Western Australia",
      "South Australia",
      "Tasmania"
    ],
    "negativeContentExamples": [
      "Northern Territory",
      "Australian Capital Territory",
      "New South Wale",
      "NewSouth Wales",
      "South Australia.",
      "Western Australia - WA",
      "Queensland Region",
      "Victoria State"
    ],
    "positiveHeaderExamples": [
      "State",
      "Australian State",
      "State Name",
      "AU State",
      "AUS State Name",
      "State (Australia)"
    ],
    "negativeHeaderExamples": [
      "State Code",
      "Country",
      "Territory",
      "Province",
      "Region",
      "State Abbreviation",
      "County",
      "Subdivision"
    ],
    "explanation": "This semantic type identifies full Australian state names as they would appear in datasets using official or common English naming. It is intended for columns containing the complete state name, not abbreviations or codes, and excludes Australian territories.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:28:05.801848"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.REGION_NAME_FR",
    "description": "A text field containing French regional names that follow standard French linguistic conventions including proper capitalization and diacritical marks. The format represents official territorial designations as used in French administrative documentation and geographic identification systems.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AUVERGNE-RH\u00d4NE-ALPES",
      "BOURGOGNE-FRANCHE-COMT\u00c9",
      "BRETAGNE",
      "CENTRE-VAL DE LOIRE",
      "CORSE",
      "GRAND EST",
      "HAUTS-DE-FRANCE",
      "\u00ceLE-DE-FRANCE",
      "NORMANDIE",
      "NOUVELLE-AQUITAINE",
      "OCCITANIE",
      "PAYS DE LA LOIRE",
      "PROVENCE-ALPES-C\u00d4TE D'AZUR",
      "GUADELOUPE",
      "MARTINIQUE",
      "GUYANE",
      "LA R\u00c9UNION",
      "MAYOTTE"
    ],
    "backout": "^[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff][A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff' -]{1,40}$",
    "confidenceThreshold": 98,
    "priority": 4030,
    "headerPatterns": [
      {
        "regExp": "(?i).*region[_ ]?name[_ ]?(fr|french).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "region_name_fr"
        ],
        "negativeExamples": [
          "region_code_fr"
        ]
      },
      {
        "regExp": "(?i).*(nom|name)[_ ]?(r\u00e9gion|region)[_ ]?(fr|french).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nom_region_fr"
        ],
        "negativeExamples": [
          "region_name"
        ]
      },
      {
        "regExp": "(?i).*(french|fr).*(r\u00e9gion|region).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "French Region"
        ],
        "negativeExamples": [
          "Region Code"
        ]
      },
      {
        "regExp": "(?i).*(reg|rgn)[_ ]?name.*fr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "reg_name_fr"
        ],
        "negativeExamples": [
          "reg_code_fr"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "region"
        ]
      }
    ],
    "positiveContentExamples": [
      "\u00cele-de-France",
      "Auvergne-Rh\u00f4ne-Alpes",
      "Bourgogne-Franche-Comt\u00e9",
      "Grand Est",
      "Hauts-de-France",
      "Provence-Alpes-C\u00f4te d'Azur",
      "La R\u00e9union",
      "Nouvelle-Aquitaine"
    ],
    "negativeContentExamples": [
      "Ile-de-France",
      "Provence-Alpes-Cote d'Azur",
      "Bourgogne Franche Comte",
      "Languedoc-Roussillon",
      "Paris",
      "Corse.",
      "Grand-Est",
      "Auvergne Rh\u00f4ne Alpes"
    ],
    "positiveHeaderExamples": [
      "R\u00e9gion",
      "Region",
      "French Region",
      "Region Name FR",
      "Nom R\u00e9gion",
      "FR Region",
      "Region Name"
    ],
    "negativeHeaderExamples": [
      "Department",
      "Country",
      "City",
      "Region Code",
      "Area",
      "County",
      "Province Name"
    ],
    "explanation": "This semantic type identifies official names of the administrative regions of France (m\u00e9tropole and overseas), preserving accents, hyphens, spaces, and apostrophes exactly as used in authoritative sources. It is best used to validate or classify columns containing French regional designations and to standardize geographic attributes in datasets.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:28:09.831569"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_HU",
    "description": "Properly capitalized Hungarian county names (megye) using correct Hungarian diacritics and official hyphenation. Values are the official county names in Hungarian without abbreviations, suffixes (e.g., \"megye\", \"county\"), or extra punctuation.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "B\u00c1CS-KISKUN",
      "BARANYA",
      "B\u00c9K\u00c9S",
      "BORSOD-ABA\u00daJ-ZEMPL\u00c9N",
      "CSONGR\u00c1D-CSAN\u00c1D",
      "FEJ\u00c9R",
      "GY\u0150R-MOSON-SOPRON",
      "HAJD\u00da-BIHAR",
      "HEVES",
      "J\u00c1SZ-NAGYKUN-SZOLNOK",
      "KOM\u00c1ROM-ESZTERGOM",
      "N\u00d3GR\u00c1D",
      "PEST",
      "SOMOGY",
      "SZABOLCS-SZATM\u00c1R-BEREG",
      "TOLNA",
      "VAS",
      "VESZPR\u00c9M",
      "ZALA"
    ],
    "backout": "^[A-Z\u00c1\u00c9\u00cd\u00d3\u00d6\u0150\u00da\u00dc\u0170]+(-[A-Z\u00c1\u00c9\u00cd\u00d3\u00d6\u0150\u00da\u00dc\u0170]+){0,3}$",
    "confidenceThreshold": 98,
    "priority": 3760,
    "headerPatterns": [
      {
        "regExp": "(?i).*hungarian.*county.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Hungarian County"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*county.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "County Name"
        ],
        "negativeExamples": [
          "Country Name"
        ]
      },
      {
        "regExp": "(?i).*megye.*n\u00e9v.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Megye n\u00e9v"
        ],
        "negativeExamples": [
          "Megye k\u00f3d"
        ]
      },
      {
        "regExp": "(?i).*(cnty|cty).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cty"
        ],
        "negativeExamples": [
          "city"
        ]
      },
      {
        "regExp": "(?i).*(county|megye).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "County"
        ],
        "negativeExamples": [
          "Region"
        ]
      }
    ],
    "positiveContentExamples": [
      "B\u00e1cs-Kiskun",
      "Baranya",
      "B\u00e9k\u00e9s",
      "Borsod-Aba\u00faj-Zempl\u00e9n",
      "Csongr\u00e1d-Csan\u00e1d",
      "Gy\u0151r-Moson-Sopron",
      "Hajd\u00fa-Bihar",
      "J\u00e1sz-Nagykun-Szolnok"
    ],
    "negativeContentExamples": [
      "Pest megye",
      "Bacs-Kiskun",
      "B\u00e1cs Kiskun",
      "Budapest",
      "Csongr\u00e1d\u2013Csan\u00e1d",
      "Gyor-Moson-Sopron",
      "Veszpr\u00e9m County",
      "Szabolcs Szatm\u00e1r Bereg"
    ],
    "positiveHeaderExamples": [
      "Megye",
      "County",
      "Hungarian County",
      "County Name",
      "Megye n\u00e9v",
      "HU County",
      "cty"
    ],
    "negativeHeaderExamples": [
      "Country",
      "City",
      "Region",
      "Country Name",
      "City Name",
      "Province",
      "State"
    ],
    "explanation": "This semantic type identifies official Hungarian county names (megye) using a finite, authoritative list. It is well-suited for columns containing county values in Hungarian without suffixes or added descriptors, ensuring precise classification in administrative geography datasets.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:28:09.841355"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.REGION_NAME_PE",
    "description": "A text field containing official names of Peru\u2019s first-level administrative regions, written with Spanish capitalization and diacritics (e.g., San Mart\u00edn, La Libertad, Madre de Dios). Values are limited to the recognized regional designations used in Peruvian government and administrative systems.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(amazonas|\u00e1ncash|apur\u00edmac|arequipa|ayacucho|cajamarca|callao|cusco|huancavelica|hu\u00e1nuco|ica|jun\u00edn|la libertad|lambayeque|lima|loreto|madre de dios|moquegua|pasco|piura|puno|san mart\u00edn|tacna|tumbes|ucayali)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4050,
    "headerPatterns": [
      {
        "regExp": "(?i).*(peruvian|peru|pe).*(regi\u00f3n|region).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Peruvian Region"
        ],
        "negativeExamples": [
          "Region Code"
        ]
      },
      {
        "regExp": "(?i).*(regi\u00f3n|region).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Region Name"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      },
      {
        "regExp": "(?i).*(regi\u00f3n|region).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Regi\u00f3n"
        ],
        "negativeExamples": [
          "Province"
        ]
      },
      {
        "regExp": "(?i).*\\breg\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "reg"
        ],
        "negativeExamples": [
          "registration"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Amazonas",
      "\u00c1ncash",
      "Apur\u00edmac",
      "Arequipa",
      "La Libertad",
      "Madre de Dios",
      "San Mart\u00edn",
      "Cusco"
    ],
    "negativeContentExamples": [
      "Ancash",
      "Junin",
      "Cuzco",
      "Lima Metropolitana",
      "Callao Province",
      "San Martin",
      "Madre deDios",
      "Libertad"
    ],
    "positiveHeaderExamples": [
      "Regi\u00f3n",
      "Region",
      "Peruvian Region",
      "Region Name",
      "PE Region",
      "Peru Region"
    ],
    "negativeHeaderExamples": [
      "Province",
      "Country",
      "City",
      "Region Code",
      "Registration",
      "State"
    ],
    "explanation": "This semantic type identifies official Peruvian region names and is intended for columns containing the canonical region designation (e.g., San Mart\u00edn, La Libertad). It is useful for geographic normalization, validation, and join keys when working with Peruvian administrative divisions. The pattern is strict to avoid false positives, requiring correct Spanish diacritics and spacing.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:28:13.165925"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_FIPS_US",
    "description": "A text field containing US state FIPS codes that follow the pattern ^\\d{2}$ consisting of exactly two digits with leading zeros when necessary. The format represents federal standard codes as used in government databases and statistical reporting systems.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4090,
    "headerPatterns": [
      {
        "regExp": "(?i).*state.*fips.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "State FIPS Code"
        ],
        "negativeExamples": [
          "County FIPS"
        ]
      },
      {
        "regExp": "(?i).*state.*fips.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "State FIPS"
        ],
        "negativeExamples": [
          "County FIPS Code"
        ]
      },
      {
        "regExp": "(?i).*state.*code.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "State Code"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      },
      {
        "regExp": "(?i).*fips.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "FIPS Code"
        ],
        "negativeExamples": [
          "State Name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "01",
      "02",
      "04",
      "06",
      "12",
      "36",
      "48",
      "53"
    ],
    "negativeContentExamples": [
      "7",
      "071",
      "1a",
      "a1",
      "5 6",
      "AB",
      "1-2",
      "2/3"
    ],
    "positiveHeaderExamples": [
      "State FIPS",
      "FIPS Code",
      "State Code",
      "State FIPS Code",
      "US State FIPS",
      "FIPS State Code",
      "State FIPS ID"
    ],
    "negativeHeaderExamples": [
      "State Name",
      "Country",
      "County FIPS",
      "ZIP Code",
      "Area Code",
      "Province Code",
      "FIPS County Code",
      "County FIPS Code"
    ],
    "explanation": "This semantic type identifies US state FIPS codes represented as exactly two digits, including leading zeros. It is intended for datasets where the column holds standardized state identifiers used in government and statistical systems. The detection emphasizes a strict two-digit token and leverages header cues containing 'state' and 'fips' to avoid confusion with other two-digit numeric fields.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:28:15.881245"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS3_EN",
    "description": "A text field containing tertiary address components that typically include building identifiers, floor numbers, or room designations with associated alphanumeric codes. The format follows extended postal addressing conventions for complex facilities and multi-building locations.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(building|bldg|block|tower|level|floor|fl|unit|suite|room|rm|wing|section)\\b[ \\t-]*[A-Z0-9]+([ \\t\\-\\/,][A-Z0-9]+){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 92,
    "priority": 4230,
    "headerPatterns": [
      {
        "regExp": "(?i).*address.*line.*3.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address Line 3"
        ],
        "negativeExamples": [
          "Address Line 2"
        ]
      },
      {
        "regExp": "(?i).*(addr.*line.*3|addr.*3|address3).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Addr Line 3"
        ],
        "negativeExamples": [
          "Addr Line 1"
        ]
      },
      {
        "regExp": "(?i).*(building|bldg).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Building"
        ],
        "negativeExamples": [
          "Billing"
        ]
      },
      {
        "regExp": "(?i).*(floor|level|fl|room|rm|suite|unit).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Floor"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Building A",
      "Bldg 7",
      "Tower 2, Floor 14",
      "Block C - Unit 12B",
      "Level 5 Room 504",
      "Wing East Floor 4",
      "Section D / Room 210",
      "Suite 3A"
    ],
    "negativeContentExamples": [
      "Address Line 3",
      "Building",
      "Apt 5B",
      "Street Level",
      "Floorplan 2",
      "UnitNumber 12",
      "Rm-",
      "Office 12B"
    ],
    "positiveHeaderExamples": [
      "Address Line 3",
      "Building",
      "Floor",
      "Address3",
      "Addr Line 3",
      "Unit",
      "Room",
      "Suite"
    ],
    "negativeHeaderExamples": [
      "Street Address",
      "Apt",
      "ZIP Code",
      "City",
      "State",
      "Country",
      "Address Line 2",
      "PO Box"
    ],
    "explanation": "This semantic type targets tertiary address lines used to capture complex facility details such as building identifiers, floors, wings, sections, rooms, suites, and units, typically paired with alphanumeric designations. It is useful for normalizing and validating 'Address Line 3' content in multi-structure campuses, large complexes, and high-density buildings.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:28:16.004343"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_DE",
    "description": "A text field containing German state names that follow German linguistic conventions with proper capitalization, hyphenation, and special characters. The format represents official federal state designations as used in German government documentation and legal systems.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "BADEN-W\u00dcRTTEMBERG",
      "BAYERN",
      "BERLIN",
      "BRANDENBURG",
      "BREMEN",
      "HAMBURG",
      "HESSEN",
      "MECKLENBURG-VORPOMMERN",
      "NIEDERSACHSEN",
      "NORDRHEIN-WESTFALEN",
      "RHEINLAND-PFALZ",
      "SAARLAND",
      "SACHSEN",
      "SACHSEN-ANHALT",
      "SCHLESWIG-HOLSTEIN",
      "TH\u00dcRINGEN"
    ],
    "backout": "^[A-Z\u00c4\u00d6\u00dc][A-Z\u00c4\u00d6\u00dc \\-]{0,28}[A-Z\u00c4\u00d6\u00dc]$",
    "confidenceThreshold": 97,
    "priority": 4130,
    "headerPatterns": [
      {
        "regExp": "(?i).*(german|de).*state.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "German State Name"
        ],
        "negativeExamples": [
          "German State Code"
        ]
      },
      {
        "regExp": "(?i).*bundesland.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Bundesland Name"
        ],
        "negativeExamples": [
          "Bundesland Code"
        ]
      },
      {
        "regExp": "(?i).*(german|de).*state.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "German State"
        ],
        "negativeExamples": [
          "German Country"
        ]
      },
      {
        "regExp": "(?i).*bundesland.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Bundesland"
        ],
        "negativeExamples": [
          "Bundesliga"
        ]
      },
      {
        "regExp": "(?i).*\\bstate\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State"
        ],
        "negativeExamples": [
          "Estate"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Baden-W\u00fcrttemberg",
      "Niedersachsen",
      "Nordrhein-Westfalen",
      "Rheinland-Pfalz",
      "Sachsen-Anhalt",
      "Schleswig-Holstein",
      "Mecklenburg-Vorpommern",
      "Th\u00fcringen"
    ],
    "negativeContentExamples": [
      "Baden W\u00fcrttemberg",
      "Nordrhein Westfalen",
      "Rheinland Pfalz",
      "Sachsen Anhalt",
      "Schleswig Holstein",
      "Thueringen",
      "Lower Saxony",
      "Bavaria"
    ],
    "positiveHeaderExamples": [
      "Bundesland",
      "State",
      "German State",
      "Bundesland Name",
      "DE State",
      "German State Name",
      "State Name"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Region",
      "City",
      "Province",
      "State Code",
      "County",
      "Country Code"
    ],
    "explanation": "This semantic type identifies German federal state names (Bundesl\u00e4nder) as officially written in German, including required hyphenation and diacritics. It is useful for validating address components, administrative divisions, and ensuring standardized state naming in datasets. The list plugin enforces the finite, canonical set of 16 states, while the backout pattern provides a controlled structural fallback.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:28:16.045117"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_MX",
    "description": "A text field containing Mexican state codes that typically follow patterns of two or three uppercase letters derived from state names. The format represents official state abbreviations as used in Mexican government documentation and postal addressing systems.",
    "pluginType": "regex",
    "regexPattern": "\\b(AGS|BC|BCS|CAM|COA|COL|CHH|CHI|DGO|GTO|GRO|HGO|JAL|MEX|MIC|MOR|NAY|NL|OAX|PUE|QRO|ROO|SLP|SIN|SON|TAB|TAM|TLA|VER|YUC|ZAC)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4100,
    "headerPatterns": [
      {
        "regExp": "(?i).*mexic.*state.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Mexican State Code"
        ],
        "negativeExamples": [
          "State Name"
        ]
      },
      {
        "regExp": "(?i).*mx.*state.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "MX State Code"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*(state|estado).*abbr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Abbr"
        ],
        "negativeExamples": [
          "State Name"
        ]
      },
      {
        "regExp": "(?i).*(mx|mexic).*state.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "MX State"
        ],
        "negativeExamples": [
          "Province"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "AGS",
      "BC",
      "BCS",
      "GTO",
      "JAL",
      "NL",
      "OAX",
      "ROO"
    ],
    "negativeContentExamples": [
      "CDMX",
      "QROO",
      "TAMPS",
      "CHIS",
      "SLP-",
      "ags",
      "BC1",
      "B.C."
    ],
    "positiveHeaderExamples": [
      "Estado",
      "State Code",
      "Mexican State",
      "MX State Code",
      "Estado Code",
      "State Abbreviation",
      "MX State"
    ],
    "negativeHeaderExamples": [
      "State Name",
      "Country",
      "Municipality",
      "Postal Code",
      "Province",
      "Region",
      "Country Code"
    ],
    "explanation": "This semantic type targets two- to three-letter uppercase abbreviations used for Mexico's states in administrative and postal datasets. It relies on a constrained set of known abbreviations while header patterns emphasize Mexican context to reduce false positives. Typical use cases include standardizing and validating state fields in Mexican addresses, geospatial attributes, and government records.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:28:18.763246"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.DEPARTMENT_NAME_FR",
    "description": "Proper-noun strings representing official French department names written out in full, using capitalization and French diacritics, with optional spaces or hyphens and common French connectors (de, du, des, la, le, les, et, d', l'). Examples include single-word names (Ain) and multi-token names (C\u00f4tes-d'Armor, Territoire de Belfort, Ille-et-Vilaine). Abbreviations or numerical department codes are not included.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u00d9\u00da\u00db\u00dc\u00dd][a-z\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00ff]+)(-[A-Z\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u00d9\u00da\u00db\u00dc\u00dd][a-z\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f2\u00f3\u00f4\u00f5\u00f6\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00ff]+)*((\\s(de|du|des|la|le|les|et)\\s|\\sd'|\\sl'| |-)[A-Z\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u00d9\u00da\u00db\u00dc\u00dd][a-z\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f3\u00f4\u00f5\u00f6\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00ff]+(-[A-Z\u00c0\u00c1\u00c2\u00c3\u00c4\u00c5\u00c6\u00c7\u00c8\u00c9\u00ca\u00cb\u00cc\u00cd\u00ce\u00cf\u00d0\u00d1\u00d2\u00d3\u00d4\u00d5\u00d6\u00d8\u00d9\u00da\u00db\u00dc\u00dd][a-z\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5\u00e6\u00e7\u00e8\u00e9\u00ea\u00eb\u00ec\u00ed\u00ee\u00ef\u00f0\u00f1\u00f3\u00f4\u00f5\u00f6\u00f8\u00f9\u00fa\u00fb\u00fc\u00fd\u00ff]+)*){0,4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 3810,
    "headerPatterns": [
      {
        "regExp": "(?i).*(french|fr).*(d\u00e9partement|department).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "FR Department Name"
        ],
        "negativeExamples": [
          "French Department Code"
        ]
      },
      {
        "regExp": "(?i).*(d\u00e9partement|department).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Department Name"
        ],
        "negativeExamples": [
          "Department Code"
        ]
      },
      {
        "regExp": "(?i).*(dept|dep).*(name).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Dept Name"
        ],
        "negativeExamples": [
          "Dept Code"
        ]
      },
      {
        "regExp": "(?i).*(d\u00e9partement|department).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "French Department"
        ],
        "negativeExamples": [
          "Region"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Ain",
      "Alpes-Maritimes",
      "C\u00f4tes-d'Armor",
      "Val-d'Oise",
      "Ille-et-Vilaine",
      "Loir-et-Cher",
      "Territoire de Belfort",
      "Seine-Saint-Denis"
    ],
    "negativeContentExamples": [
      "alpes-maritimes",
      "AIN",
      "Val d Oise",
      "Alpes--Maritimes",
      "Ille-etVilaine",
      "Seine-Saint -Denis",
      "d'Armor",
      "C\u00f4te d' Or"
    ],
    "positiveHeaderExamples": [
      "D\u00e9partement",
      "Department",
      "French Department",
      "Department Name",
      "FR Department Name",
      "D\u00e9partement Name",
      "Dept Name",
      "French D\u00e9partement"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Region",
      "City",
      "Department Code",
      "Province",
      "State Name",
      "Dept ID",
      "Postal Code"
    ],
    "explanation": "This semantic type identifies full French department names as proper nouns, allowing for common connectors and hyphenation used in official naming. It excludes numeric department codes and abbreviations to avoid confusion with code or identifier fields and to keep focus on the full textual department names.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:28:21.142577"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS2_EN",
    "description": "A text field containing secondary address components that typically include apartment, suite, unit, building, floor, room, or department designations with associated alphanumeric identifiers. Values often use common abbreviations and postal conventions, and may include symbols like # or hyphens alongside short alphanumeric IDs.",
    "pluginType": "regex",
    "regexPattern": "\\b(apt\\.?|apartment|ste\\.?|suite|unit|bldg\\.?|building|fl\\.?|floor|rm\\.?|room|dept\\.?|department|lot|trlr|trailer)\\s*[#\\-]?\\s*[A-Z0-9\\-]{1,6}\\b|\\b#[A-Z0-9\\-]{1,6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 4220,
    "headerPatterns": [
      {
        "regExp": "(?i).*address.*line.*2.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address Line 2"
        ],
        "negativeExamples": [
          "Street Address"
        ]
      },
      {
        "regExp": "(?i).*(addr2|address2|addr_2|address_2).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address2"
        ],
        "negativeExamples": [
          "Address Line 1"
        ]
      },
      {
        "regExp": "(?i).*(apartment|apt|suite|ste|unit|bldg|building|floor|fl|room|rm|dept).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Apt"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*(secondary|supplemental).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Secondary Address"
        ],
        "negativeExamples": [
          "Primary Address"
        ]
      },
      {
        "regExp": "(?i).*addr.*2.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Addr2"
        ],
        "negativeExamples": [
          "Addr"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Apt 5B",
      "Suite 120",
      "Unit C-3",
      "Bldg 2 Apt 301",
      "Floor 3",
      "Room 210",
      "Dept 4A",
      "#4B"
    ],
    "negativeContentExamples": [
      "123 Main St",
      "PO Box 45",
      "Building",
      "Suite",
      "Apt.",
      "Unit #",
      "Floor",
      "Rm A&B"
    ],
    "positiveHeaderExamples": [
      "Address Line 2",
      "Apt",
      "Suite",
      "Address2",
      "Secondary Address",
      "Unit",
      "Addr2"
    ],
    "negativeHeaderExamples": [
      "Street Address",
      "City",
      "ZIP Code",
      "Address Line 1",
      "Country",
      "State",
      "PO Box"
    ],
    "explanation": "This semantic type targets secondary address line fields that capture sub-premise designations such as apartments, suites, units, buildings, floors, rooms, and departments with short alphanumeric identifiers. It is intended to help identify address line 2 style columns and values that refine a primary street address for accurate postal formatting and geocoding.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:28:23.295549"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PREFECTURE_NAME_JA",
    "description": "This type follows text patterns for Japanese prefecture names using kanji characters with appropriate prefecture suffixes (\u90fd, \u9053, \u5e9c, \u770c). The format consists of proper noun text strings representing official prefecture names in Japanese characters without abbreviations or romanization.",
    "pluginType": "regex",
    "regexPattern": "(\u5317\u6d77\u9053|\u9752\u68ee\u770c|\u5ca9\u624b\u770c|\u5bae\u57ce\u770c|\u79cb\u7530\u770c|\u5c71\u5f62\u770c|\u798f\u5cf6\u770c|\u8328\u57ce\u770c|\u6803\u6728\u770c|\u7fa4\u99ac\u770c|\u57fc\u7389\u770c|\u5343\u8449\u770c|\u6771\u4eac\u90fd|\u795e\u5948\u5ddd\u770c|\u65b0\u6f5f\u770c|\u5bcc\u5c71\u770c|\u77f3\u5ddd\u770c|\u798f\u4e95\u770c|\u5c71\u68a8\u770c|\u9577\u91ce\u770c|\u5c90\u961c\u770c|\u9759\u5ca1\u770c|\u611b\u77e5\u770c|\u4e09\u91cd\u770c|\u6ecb\u8cc0\u770c|\u4eac\u90fd\u5e9c|\u5927\u962a\u5e9c|\u5175\u5eab\u770c|\u5948\u826f\u770c|\u548c\u6b4c\u5c71\u770c|\u9ce5\u53d6\u770c|\u5cf6\u6839\u770c|\u5ca1\u5c71\u770c|\u5e83\u5cf6\u770c|\u5c71\u53e3\u770c|\u5fb3\u5cf6\u770c|\u9999\u5ddd\u770c|\u611b\u5a9b\u770c|\u9ad8\u77e5\u770c|\u798f\u5ca1\u770c|\u4f50\u8cc0\u770c|\u9577\u5d0e\u770c|\u718a\u672c\u770c|\u5927\u5206\u770c|\u5bae\u5d0e\u770c|\u9e7f\u5150\u5cf6\u770c|\u6c96\u7e04\u770c)",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3910,
    "headerPatterns": [
      {
        "regExp": "(?i).*(japanese|ja|jp).*(prefecture).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "prefecture_name_ja"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*\u90fd\u9053\u5e9c\u770c.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u90fd\u9053\u5e9c\u770c"
        ],
        "negativeExamples": [
          "\u56fd"
        ]
      },
      {
        "regExp": "(?i).*(japanese).*prefecture.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Japanese Prefecture"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*(prefecture).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Prefecture"
        ],
        "negativeExamples": [
          "Province"
        ]
      },
      {
        "regExp": "(?i).*\\bpref\\b.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "pref_name"
        ],
        "negativeExamples": [
          "prefix"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "\u6771\u4eac\u90fd",
      "\u5317\u6d77\u9053",
      "\u4eac\u90fd\u5e9c",
      "\u5927\u962a\u5e9c",
      "\u795e\u5948\u5ddd\u770c",
      "\u9e7f\u5150\u5cf6\u770c",
      "\u548c\u6b4c\u5c71\u770c",
      "\u6c96\u7e04\u770c"
    ],
    "negativeContentExamples": [
      "\u6771\u4eac",
      "\u4eac\u90fd",
      "\u5927\u962a\u5e02",
      "\u795e\u5948\u5ddd",
      "\u9e7f\u5150\u5cf6",
      "\u770c",
      "\u5317\u6d77\u5ea6",
      "\u90fd\u9053\u5e9c\u770c"
    ],
    "positiveHeaderExamples": [
      "\u90fd\u9053\u5e9c\u770c",
      "Prefecture",
      "Japanese Prefecture",
      "prefecture_name_ja",
      "ja_prefecture",
      "prefecture_name"
    ],
    "negativeHeaderExamples": [
      "\u56fd",
      "Country",
      "City",
      "State",
      "Province",
      "Region",
      "Address",
      "Postal Code"
    ],
    "explanation": "Identifies values that are official Japanese prefecture names written in kanji and ending with one of the proper suffixes: \u90fd, \u9053, \u5e9c, or \u770c. This is useful for normalizing location data, validating administrative division fields, and disambiguating prefecture names from cities, wards, and other geographic terms.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:28:24.219179"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_IE",
    "description": "English names of the four historic provinces of Ireland represented as single-word proper nouns without abbreviations, punctuation, or special characters. Expected values are the canonical province names in English with standard capitalization.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "LEINSTER",
      "MUNSTER",
      "CONNACHT",
      "ULSTER"
    ],
    "backout": "^[A-Za-z]{6,8}$",
    "confidenceThreshold": 97,
    "priority": 3970,
    "headerPatterns": [
      {
        "regExp": "(?i).*irish.*province.*name.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Irish Province Name"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      },
      {
        "regExp": "(?i).*province.*name.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Province Name"
        ],
        "negativeExamples": [
          "Province Code"
        ]
      },
      {
        "regExp": "(?i).*irish.*province.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Irish Province"
        ],
        "negativeExamples": [
          "Irish County"
        ]
      },
      {
        "regExp": "(?i).*prov.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Prov"
        ],
        "negativeExamples": [
          "County"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Title"
        ]
      }
    ],
    "positiveContentExamples": [
      "Leinster",
      "Munster",
      "Connacht",
      "Ulster",
      "LEINSTER",
      "MUNSTER",
      "CONNACHT",
      "ULSTER"
    ],
    "negativeContentExamples": [
      "Connaught",
      "Province of Ulster",
      "Ulsters",
      "Munster County",
      "Leinster.",
      "Conacht",
      "Leinster-",
      "Mun ster"
    ],
    "positiveHeaderExamples": [
      "Province",
      "Irish Province",
      "Province Name",
      "Prov Name",
      "Prov",
      "Province (IE)",
      "ProvinceName"
    ],
    "negativeHeaderExamples": [
      "County",
      "Country",
      "Region",
      "State",
      "Territory",
      "Province Code",
      "County Name"
    ],
    "explanation": "This semantic type identifies Irish province names in English. It is a small, finite set and is best recognized via a curated list to avoid false positives from generic proper nouns. Typical use cases include validating geographic dimension columns or standardizing province fields in Irish datasets.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:28:29.367046"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS_EN",
    "description": "A text field containing English street addresses that typically follow patterns combining numeric house numbers with street names and type designators. The format represents standard English postal addressing with consistent component ordering and common abbreviations.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{1,6}\\s+[A-Za-z]+(\\s+[A-Za-z0-9]+){0,3}\\s+(Street|St|Road|Rd|Avenue|Ave|Boulevard|Blvd|Drive|Dr|Court|Ct|Lane|Ln|Place|Pl|Terrace|Ter|Way|Parkway|Pkwy|Circle|Cir)\\b(\\s+(North|South|East|West|N|S|E|W|NE|NW|SE|SW))?(\\s+(Apt|Apartment|Unit|Ste|Suite|#)\\s*[A-Za-z0-9\\-]+)?",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4260,
    "headerPatterns": [
      {
        "regExp": "(?i).*(shipping|billing|mailing).*(street).*(address).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Shipping Street Address"
        ],
        "negativeExamples": [
          "Billing City"
        ]
      },
      {
        "regExp": "(?i).*(street).*(address|addr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street Address"
        ],
        "negativeExamples": [
          "Street Name"
        ]
      },
      {
        "regExp": "(?i).*(home|residential|service).*(address|addr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Residential Address"
        ],
        "negativeExamples": [
          "Service ZIP Code"
        ]
      },
      {
        "regExp": "(?i).*(addr|address1|addr1|address_line1).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "addr_line1"
        ],
        "negativeExamples": [
          "addr_count"
        ]
      },
      {
        "regExp": "(?i).*(street|\\bst\\b).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street"
        ],
        "negativeExamples": [
          "Station"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address"
        ],
        "negativeExamples": [
          "Email"
        ]
      }
    ],
    "positiveContentExamples": [
      "123 Main St",
      "742 Evergreen Terrace",
      "1600 Pennsylvania Ave NW",
      "10 Downing Street",
      "55 E 52nd St",
      "500 Park Ave Apt 12B",
      "88 Ocean Blvd Suite 300",
      "1234 W Cedar Ln #5"
    ],
    "negativeContentExamples": [
      "Main Street",
      "123",
      "123 Main",
      "123 Main Str",
      "123 Mainstra\u00dfe",
      "Apt 5 123 Main St",
      "1600 Pennsylvania Avenue Northwest, Washington",
      "PO Box 123"
    ],
    "positiveHeaderExamples": [
      "Street Address",
      "Address",
      "Street",
      "Shipping Street Address",
      "Residential Address",
      "addr_line1",
      "Mailing Address"
    ],
    "negativeHeaderExamples": [
      "City",
      "ZIP Code",
      "Country",
      "Station",
      "Email",
      "PO Box",
      "Street Name"
    ],
    "explanation": "This semantic type identifies English street addresses formatted as a house number followed by one to four street name tokens and a recognized street type (e.g., St, Ave, Rd), with optional directional suffixes and unit designators (Apt, Ste, #). It is useful for extracting or validating address line 1 fields in customer, shipping, or location datasets where English-language conventions are expected.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:28:32.803127"
  },
  {
    "resultType": "generated",
    "semanticType": "VIN",
    "description": "A text field containing vehicle identification numbers consisting of exactly 17 characters drawn from A\u2013H, J\u2013N, P, R\u2013Z, and 0\u20139 (letters I, O, and Q are excluded). This standardized automotive identifier encodes manufacturer, model, and vehicle attributes in fixed positions.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-HJ-NPR-Z0-9]{17}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4350,
    "headerPatterns": [
      {
        "regExp": "(?i).*vehicle.*identification.*number.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Vehicle Identification Number"
        ],
        "negativeExamples": [
          "Vehicle Registration Number"
        ]
      },
      {
        "regExp": "(?i).*\\bvin\\b.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "VIN Number"
        ],
        "negativeExamples": [
          "Vineyard Number"
        ]
      },
      {
        "regExp": "(?i).*vehicle.*id.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Vehicle ID"
        ],
        "negativeExamples": [
          "Account ID"
        ]
      },
      {
        "regExp": "(?i).*\\bvin\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "VIN"
        ],
        "negativeExamples": [
          "VinValue"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Number"
        ]
      }
    ],
    "positiveContentExamples": [
      "1HGCM82633A004352",
      "JHMFA16586S012345",
      "2FTRX18L1XCA12345",
      "WDBUF56J46A123456",
      "5YJ3E1EA7HF000337",
      "SALWR2VF4FA123456",
      "ZFAAXX00C0E123456",
      "KM8JU3AC7AU123456"
    ],
    "negativeContentExamples": [
      "1HGCM82633A00435O",
      "1HGCM82633A00435I",
      "1HGCM82633A00435Q",
      "1HG CM82633A004352",
      "1HGCM82633A00435",
      "1HGCM82633A0043527",
      "1hgcm82633a004352",
      "1HGCM82633A00435#"
    ],
    "positiveHeaderExamples": [
      "VIN",
      "Vehicle ID",
      "VIN Number",
      "Vehicle Identification Number",
      "VIN No",
      "Vehicle Identifier",
      "Chassis Number",
      "Vehicle Chassis ID"
    ],
    "negativeHeaderExamples": [
      "License Plate",
      "Model",
      "Make",
      "Engine Number",
      "Registration ID",
      "Serial Number",
      "Order Number",
      "Customer ID"
    ],
    "explanation": "This semantic type identifies automotive Vehicle Identification Numbers (VINs). It validates strings that are exactly 17 characters long and composed only of the allowed VIN character set (A\u2013H, J\u2013N, P, R\u2013Z, 0\u20139), ensuring exclusion of the ambiguous letters I, O, and Q. Use this type to detect and validate VIN fields in vehicle datasets, manufacturing records, and automotive service systems.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:28:33.223519"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_US",
    "description": "A text field containing US state codes that follow the pattern of exactly two uppercase letters. The format represents official state abbreviations as used in US government documentation and postal addressing systems.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 4200,
    "headerPatterns": [
      {
        "regExp": "(?i).*us.*state.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "US State Code"
        ],
        "negativeExamples": [
          "State Name"
        ]
      },
      {
        "regExp": "(?i).*state.*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Postal Code"
        ],
        "negativeExamples": [
          "Postal Country Code"
        ]
      },
      {
        "regExp": "(?i).*state.*abbr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Abbr"
        ],
        "negativeExamples": [
          "Street Abbr"
        ]
      },
      {
        "regExp": "(?i).*us.*state.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "US State"
        ],
        "negativeExamples": [
          "State Name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "CA",
      "NY",
      "TX",
      "FL",
      "WA",
      "IL",
      "OH",
      "NJ"
    ],
    "negativeContentExamples": [
      "ca",
      "Tx",
      "CAL",
      "C4",
      "N Y",
      "N-Y",
      "CA1",
      "1CA"
    ],
    "positiveHeaderExamples": [
      "State Code",
      "US State",
      "State",
      "State Abbr",
      "US State Code",
      "State Postal Code",
      "State Abbreviation",
      "State Abbrev"
    ],
    "negativeHeaderExamples": [
      "State Name",
      "Country",
      "County",
      "Postal Code",
      "Province",
      "Street",
      "Zip Code",
      "Country Code"
    ],
    "explanation": "This semantic type targets two-letter uppercase US state abbreviations as commonly used in postal addresses and official records. It uses a strict token-level pattern to reduce false positives and relies on state-related header context for disambiguation from other two-letter codes.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:28:35.587061"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_EC",
    "description": "Official province names of Ecuador in Spanish, written as proper nouns with correct capitalization and diacritics, without abbreviations, codes, or extra qualifiers. Accepts single- and multi-word names (e.g., with internal articles such as de, del, los, las) when they are part of the official name.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AZUAY",
      "BOL\u00cdVAR",
      "CA\u00d1AR",
      "CARCHI",
      "CHIMBORAZO",
      "COTOPAXI",
      "EL ORO",
      "ESMERALDAS",
      "GAL\u00c1PAGOS",
      "GUAYAS",
      "IMBABURA",
      "LOJA",
      "LOS R\u00cdOS",
      "MANAB\u00cd",
      "MORONA SANTIAGO",
      "NAPO",
      "ORELLANA",
      "PASTAZA",
      "PICHINCHA",
      "SANTA ELENA",
      "SANTO DOMINGO DE LOS TS\u00c1CHILAS",
      "SUCUMB\u00cdOS",
      "TUNGURAHUA",
      "ZAMORA CHINCHIPE"
    ],
    "backout": "^[- A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc]{2,}( [-A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc]{2,})*$",
    "confidenceThreshold": 98,
    "priority": 3950,
    "headerPatterns": [
      {
        "regExp": "(?i).*(ecuador|ec).*province.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Ecuador Province Name"
        ],
        "negativeExamples": [
          "Ecuador Country Name"
        ]
      },
      {
        "regExp": "(?i).*(ecuador|ec).*provincia.*nombre.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nombre_provincia_ecuador"
        ],
        "negativeExamples": [
          "nombre_region_ecuador"
        ]
      },
      {
        "regExp": "(?i).*(ecuador|ec).*(province|provincia).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Province (EC)"
        ],
        "negativeExamples": [
          "Region EC"
        ]
      },
      {
        "regExp": "(?i).*(prov|provincia|province).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "prov_name"
        ],
        "negativeExamples": [
          "prov_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Pichincha",
      "Guayas",
      "Azuay",
      "Santo Domingo de los Ts\u00e1chilas",
      "Los R\u00edos",
      "El Oro",
      "Zamora Chinchipe",
      "Gal\u00e1pagos"
    ],
    "negativeContentExamples": [
      "Provincia de Pichincha",
      "Pichincha Province",
      "Sto. Domingo de los Ts\u00e1chilas",
      "Santa-Elena",
      "El Oro, Ecuador",
      "Los Rios",
      "Galapagos",
      "Zamora-Chinchipe"
    ],
    "positiveHeaderExamples": [
      "Provincia",
      "Province",
      "Ecuadorian Province",
      "Ecuador Province Name",
      "Nombre Provincia Ecuador",
      "EC Province",
      "Province (EC)"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Region",
      "City",
      "Province Code",
      "State Name",
      "Department",
      "Region EC"
    ],
    "explanation": "This semantic type identifies Ecuadorian province names and is intended for columns that store the official province name values in Spanish. It uses a finite, authoritative list of 24 provinces to maximize precision, with a broader backout pattern for basic shape validation when list matching is unavailable.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:28:39.741266"
  },
  {
    "resultType": "generated",
    "semanticType": "IMEI",
    "description": "A device identifier following the strict pattern ^\\d{15}$ consisting of fifteen consecutive numerical digits. The format includes embedded codes for Type Allocation Code, Final Assembly Code, and Serial Number with a check digit, all regulated by the GSMA.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{15}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3200,
    "headerPatterns": [
      {
        "regExp": "(?i).*device[ _-]*imei.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Device IMEI"
        ],
        "negativeExamples": [
          "Device ID"
        ]
      },
      {
        "regExp": "(?i).*phone[ _-]*imei.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Phone IMEI"
        ],
        "negativeExamples": [
          "Phone Number"
        ]
      },
      {
        "regExp": "(?i).*handset[ _-]*imei.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Handset IMEI"
        ],
        "negativeExamples": [
          "Model"
        ]
      },
      {
        "regExp": "(?i).*imei[ _-]*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IMEI Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*imei.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IMEI"
        ],
        "negativeExamples": [
          "IMSI"
        ]
      }
    ],
    "positiveContentExamples": [
      "490154203237518",
      "356938035643809",
      "861234050123456",
      "351756051523999",
      "359881030314356",
      "013554006297015",
      "864234030123450",
      "352099001761481"
    ],
    "negativeContentExamples": [
      "49015420323751",
      "4901542032375187",
      "49015420323751A",
      "49 0154203237518",
      "490-154203237518",
      "49015420323751.8",
      "IMEI490154203237518",
      "49015420323"
    ],
    "positiveHeaderExamples": [
      "IMEI",
      "Device IMEI",
      "Phone IMEI",
      "Handset IMEI",
      "IMEI Code",
      "Mobile IMEI",
      "Device_IMEI"
    ],
    "negativeHeaderExamples": [
      "Phone Number",
      "Model",
      "Brand",
      "Device ID",
      "IMSI",
      "ICCID",
      "MEID"
    ],
    "explanation": "This semantic type identifies IMEI values in datasets using a strict 15-digit token pattern. It is suited for telecom, mobile device inventory, and customer support data where device identifiers must be recognized. The regex enforces a single 15-digit token without separators; downstream systems may apply optional Luhn validation if required.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:28:41.516312"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_NAME_EN",
    "description": "A text field containing complete English street names that follow standard formatting patterns combining the base name with appropriate type suffixes. The format represents standard English street naming conventions used in postal addressing and navigation systems.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Za-z0-9]+('[A-Za-z0-9]+)?)([- ][A-Za-z0-9]+('[A-Za-z0-9]+)?){0,3} (Street|St|Road|Rd|Avenue|Ave|Boulevard|Blvd|Lane|Ln|Drive|Dr|Court|Ct|Place|Pl|Terrace|Ter|Way|Plaza|Circle|Cir|Parkway|Pkwy|Trail|Trl|Square|Sq|Alley|Aly|Crescent|Cres|Row|View|Walk|Point|Pt)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 4300,
    "headerPatterns": [
      {
        "regExp": "(?i).*street.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street Name"
        ],
        "negativeExamples": [
          "Street Number"
        ]
      },
      {
        "regExp": "(?i).*(road|rd|avenue|ave|boulevard|blvd|lane|ln|drive|dr).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Road Name"
        ],
        "negativeExamples": [
          "Road Code"
        ]
      },
      {
        "regExp": "(?i).*(street|road|avenue|boulevard|lane|drive|court|place|terrace|way|plaza|circle).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*(\\bst\\b|\\brd\\b|\\bave\\b|\\bblvd\\b|\\bln\\b|\\bdr\\b|\\bct\\b|\\bpl\\b|\\bter\\b|\\bcir\\b).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "St"
        ],
        "negativeExamples": [
          "Std Dev"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Number"
        ]
      }
    ],
    "positiveContentExamples": [
      "Main Street",
      "North Avenue",
      "3rd Street",
      "Old Mill Road",
      "O'Connor Drive",
      "Cedar View Court",
      "Maple-Crest Lane",
      "Martin Luther King Jr Blvd"
    ],
    "negativeContentExamples": [
      "123 Main Street",
      "Avenue of the Americas",
      "Main St.",
      "Elm Street NE",
      "Route 66",
      "Main-Street",
      "Street",
      "2nd Ave Apt 5"
    ],
    "positiveHeaderExamples": [
      "Street Name",
      "Road Name",
      "Street",
      "Street Label",
      "Avenue Name",
      "Boulevard Name"
    ],
    "negativeHeaderExamples": [
      "House Number",
      "City",
      "ZIP Code",
      "Street Number",
      "Address Line",
      "Country"
    ],
    "explanation": "This semantic type targets full English street names as standalone values without house numbers or trailing qualifiers, ensuring the presence of a valid street type suffix (e.g., Street, Ave, Rd). It is useful for normalizing and validating roadway names in address datasets separate from other address components like numbers, units, or cities.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:28:46.005856"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_US",
    "description": "A text field containing US state names that follow standard English linguistic conventions with proper capitalization and spacing. The format represents official state designations as used in US government documentation and legal systems.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(alabama|alaska|arizona|arkansas|california|colorado|connecticut|delaware|florida|georgia|hawaii|idaho|illinois|indiana|iowa|kansas|kentucky|louisiana|maine|maryland|massachusetts|michigan|minnesota|mississippi|missouri|montana|nebraska|nevada|new hampshire|new jersey|new mexico|new york|north carolina|north dakota|ohio|oklahoma|oregon|pennsylvania|rhode island|south carolina|south dakota|tennessee|texas|utah|vermont|virginia|washington|west virginia|wisconsin|wyoming)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4150,
    "headerPatterns": [
      {
        "regExp": "(?i).*united.*states.*state.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "United States State Name"
        ],
        "negativeExamples": [
          "United States State Code"
        ]
      },
      {
        "regExp": "(?i).*us.*state.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "US State Name"
        ],
        "negativeExamples": [
          "US State Code"
        ]
      },
      {
        "regExp": "(?i).*state.*full.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Full Name"
        ],
        "negativeExamples": [
          "State Short Name"
        ]
      },
      {
        "regExp": "(?i).*us.*state.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "US State"
        ],
        "negativeExamples": [
          "State"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "California",
      "New York",
      "Rhode Island",
      "North Dakota",
      "Washington",
      "Hawaii",
      "Wyoming",
      "Massachusetts"
    ],
    "negativeContentExamples": [
      "NewYork",
      "N. Carolina",
      "N Dakota",
      "North-Dakota",
      "Puerto Rico",
      "District of Columbia",
      "Washinton",
      "Massachusets"
    ],
    "positiveHeaderExamples": [
      "State",
      "State Name",
      "US State",
      "United States State Name",
      "US State Name",
      "State Full Name",
      "State (USA) Name",
      "Resident State Name"
    ],
    "negativeHeaderExamples": [
      "State Code",
      "Country",
      "County",
      "Province",
      "US State Code",
      "State Abbrev",
      "City",
      "Region"
    ],
    "explanation": "This semantic type recognizes full US state names, including multi-word names like New Hampshire and North Carolina, using a case-insensitive, word-boundary-aware pattern. It is intended for columns containing the spelled-out state name rather than abbreviations or codes, and helps distinguish state names from similarly named entities such as cities, territories, or abbreviations.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:28:46.814648"
  },
  {
    "resultType": "generated",
    "semanticType": "IPADDRESS.IPV6",
    "description": "A network identifier using 128-bit hexadecimal notation with groups of one to four hex digits separated by colons. Supports zero-compression using double colons and abbreviated forms while preserving valid IPv6 structures.",
    "pluginType": "regex",
    "regexPattern": "\\b(([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}|([0-9A-Fa-f]{1,4}:){1,6}:[0-9A-Fa-f]{1,4}|([0-9A-Fa-f]{1,4}:){1,5}(:[0-9A-Fa-f]{1,4}){1,2}|([0-9A-Fa-f]{1,4}:){1,4}(:[0-9A-Fa-f]{1,4}){1,3}|([0-9A-Fa-f]{1,4}:){1,3}(:[0-9A-Fa-f]{1,4}){1,4}|([0-9A-Fa-f]{1,4}:){1,2}(:[0-9A-Fa-f]{1,4}){1,5}|[0-9A-Fa-f]{1,4}(:[0-9A-Fa-f]{1,4}){1,6}|::([0-9A-Fa-f]{1,4}(:[0-9A-Fa-f]{1,4}){0,6})?|([0-9A-Fa-f]{1,4}(:[0-9A-Fa-f]{1,4}){0,6})::|([0-9A-Fa-f]{1,4}(:[0-9A-Fa-f]{1,4}){0,5})::([0-9A-Fa-f]{1,4}(:[0-9A-Fa-f]{1,4}){0,5}))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3240,
    "headerPatterns": [
      {
        "regExp": "(?i).*ipv6.*address.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "IPv6 Address"
        ],
        "negativeExamples": [
          "IPv4 Address"
        ]
      },
      {
        "regExp": "(?i).*ip.*v6.*address.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "IP v6 Address"
        ],
        "negativeExamples": [
          "IP v4 Address"
        ]
      },
      {
        "regExp": "(?i).*ip.*address.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "IP Address"
        ],
        "negativeExamples": [
          "Postal Address"
        ]
      },
      {
        "regExp": "(?i).*ipv6.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "IPv6"
        ],
        "negativeExamples": [
          "IPv4"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Address"
        ],
        "negativeExamples": [
          "Domain Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "2001:0db8:85a3:0000:0000:8a2e:0370:7334",
      "2001:db8:85a3::8a2e:370:7334",
      "2001:db8::",
      "::1",
      "fe80::1ff:fe23:4567:890a",
      "::",
      "2001:0db8:0:0:0:0:1428:57ab",
      "2001:db8:0:0:8d3:0:0:0"
    ],
    "negativeContentExamples": [
      "192.168.1.1",
      "2001:db8:85a3::8a2e:370:7334:",
      "2001:db8:85a3::8a2e:370:7334::",
      "2001:db8:85a3:0000:0000:8a2e:0370:7334:1234",
      "2001:db8:85a3:0:0:8a2e:370:7334g",
      "fe80::1ff:fe23:4567:890ab",
      "2001-db8-85a3::8a2e:370:7334",
      "::ffff:192.168.0.1"
    ],
    "positiveHeaderExamples": [
      "IPv6 Address",
      "IPv6",
      "IP Address",
      "IP v6 Address",
      "Source IPv6",
      "Destination IPv6",
      "Client IPv6",
      "Remote IPv6 Address"
    ],
    "negativeHeaderExamples": [
      "IPv4 Address",
      "Domain Name",
      "MAC Address",
      "IPv4",
      "IP v4 Address",
      "Postal Address",
      "Server IP",
      "Hostname"
    ],
    "explanation": "This semantic type identifies IPv6 addresses, including full eight-group forms and compressed representations using double colons. It enforces hexadecimal groups of one to four digits separated by colons, with optional zero-compression at the start, middle, or end. Typical use cases include classifying network logs, connection records, and configuration data where IPv6 endpoints must be recognized.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:28:52.420128"
  },
  {
    "resultType": "generated",
    "semanticType": "URI.URL",
    "description": "A text field containing URLs that follow RFC 3986 standards with protocol schemes, domain names, and optional paths or parameters. The format represents complete web addresses using standard URI syntax for resource identification and access across internet and network systems.",
    "pluginType": "regex",
    "regexPattern": "\\b(http|https|ftp)://([A-Za-z0-9-]+\\.)+[A-Za-z]{2,}(:[0-9]{2,5})?(/[A-Za-z0-9._~%!$&'()*+,;=:@/-]*)?(\\?[A-Za-z0-9._~%!$&'()*+,;=:@/-]*)?(#[A-Za-z0-9._~%!$&'()*+,;=:@/-]*)?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4340,
    "headerPatterns": [
      {
        "regExp": "(?i).*(landing|target|page|source)[ _-]*url.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Landing Page URL"
        ],
        "negativeExamples": [
          "File Path"
        ]
      },
      {
        "regExp": "(?i).*(web|website)[ _-]*(address|url).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Web Address"
        ],
        "negativeExamples": [
          "Domain Name"
        ]
      },
      {
        "regExp": "(?i).*(home|homepage|site)[ _-]*url.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Homepage URL"
        ],
        "negativeExamples": [
          "Email Address"
        ]
      },
      {
        "regExp": "(?i).*\\buri\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Product URI"
        ],
        "negativeExamples": [
          "Duration"
        ]
      },
      {
        "regExp": "(?i).*url.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "URL"
        ],
        "negativeExamples": [
          "User ID"
        ]
      }
    ],
    "positiveContentExamples": [
      "https://example.com",
      "http://www.example.org",
      "https://sub.domain.co.uk/path/to/page",
      "ftp://ftp.example.com/resource.zip",
      "https://example.com:8080/app/index.html",
      "https://example.com/search?q=fta+library",
      "https://www.example.com/docs/readme.md#intro",
      "https://xn--bcher-kva.example/path/%E2%9C%93"
    ],
    "negativeContentExamples": [
      "www.example.com",
      "http:/example.com",
      "https://example",
      "https://example..com",
      "https://example,com",
      "mailto:user@example.com",
      "https//example.com",
      "https://example.com/a b"
    ],
    "positiveHeaderExamples": [
      "URL",
      "Website",
      "Web Address",
      "Page URL",
      "Target URL",
      "Landing Page URL",
      "Homepage URL",
      "Website URL"
    ],
    "negativeHeaderExamples": [
      "Domain Name",
      "Email Address",
      "File Path",
      "IP Address",
      "Resource ID",
      "Link Text",
      "Download Path",
      "File Name"
    ],
    "explanation": "This semantic type detects full web URLs including a required scheme (http, https, or ftp), a domain with a valid alphabetic TLD, and optional port, path, query, and fragment components. It excludes values without a scheme, non-URL URIs (e.g., mailto), bare domains, file paths, and malformed hosts. Use it to validate and classify fields that store complete web addresses for navigation, linking, or resource retrieval.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:28:57.875620"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_MX",
    "description": "A text field containing Mexican state names that follow Spanish linguistic conventions with proper capitalization, spacing, and diacritical marks. The format represents official federal entity designations as used in Mexican government documentation and legal systems.",
    "pluginType": "regex",
    "regexPattern": "\\b(Aguascalientes|Baja California|Baja California Sur|Campeche|Chiapas|Chihuahua|Ciudad de M\u00e9xico|Coahuila|Coahuila de Zaragoza|Colima|Durango|Guanajuato|Guerrero|Hidalgo|Jalisco|Estado de M\u00e9xico|Michoac\u00e1n|Michoac\u00e1n de Ocampo|Morelos|Nayarit|Nuevo Le\u00f3n|Oaxaca|Puebla|Quer\u00e9taro|Quer\u00e9taro de Arteaga|Quintana Roo|San Luis Potos\u00ed|Sinaloa|Sonora|Tabasco|Tamaulipas|Tlaxcala|Veracruz|Veracruz de Ignacio de la Llave|Yucat\u00e1n|Zacatecas)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4140,
    "headerPatterns": [
      {
        "regExp": "(?i).*(mexican|m\u00e9xico|mexico).*state.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Mexican State Name"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*(nombre).*estado.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Nombre de Estado"
        ],
        "negativeExamples": [
          "Estado Civil"
        ]
      },
      {
        "regExp": "(?i).*(mexican|m\u00e9xico|mexico).*state.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Mexican State"
        ],
        "negativeExamples": [
          "Country State"
        ]
      },
      {
        "regExp": "(?i).*(mx|m\u00e9x|mex).*(state|estado).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "MX State"
        ],
        "negativeExamples": [
          "MX Code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "State"
        ]
      }
    ],
    "positiveContentExamples": [
      "Aguascalientes",
      "Baja California Sur",
      "Ciudad de M\u00e9xico",
      "Estado de M\u00e9xico",
      "Nuevo Le\u00f3n",
      "San Luis Potos\u00ed",
      "Quintana Roo",
      "Yucat\u00e1n"
    ],
    "negativeContentExamples": [
      "Ciudad de Mexico",
      "Nuevo Leon",
      "San Luis Potosi",
      "Estado de Mexico",
      "Mexico City",
      "Baja California Sur Norte",
      "Michoacan",
      "CDMX"
    ],
    "positiveHeaderExamples": [
      "Estado",
      "State",
      "Mexican State",
      "Nombre de Estado",
      "MX State",
      "State Name"
    ],
    "negativeHeaderExamples": [
      "State Code",
      "Country",
      "Municipality",
      "Province",
      "Country Code",
      "Estado Civil"
    ],
    "explanation": "This semantic type identifies values that are official names of Mexico\u2019s 32 federal entities, requiring correct Spanish spelling and diacritics. It prefers standardized legal/government usage (including long-form names where applicable) and excludes codes or informal abbreviations. Typical use cases include validating address components, standardizing geographic attributes in datasets, and improving entity resolution for Mexican administrative divisions.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:29:01.775372"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_NUMBER",
    "description": "A text field containing street numbers that typically follow numeric patterns but may include letters or special characters depending on local addressing conventions. The format represents property identifiers as used in postal addressing and navigation systems.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{1,5}([A-Z])?( [A-Z])?( [1-9]/[1-9])?(/[0-9A-Z]{1,4})?(\\s?-\\s?\\d{1,5}([A-Z])?)?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4310,
    "headerPatterns": [
      {
        "regExp": "(?i).*(house|street|door|property).*(number|no\\.?|num).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street Number"
        ],
        "negativeExamples": [
          "Street Name"
        ]
      },
      {
        "regExp": "(?i).*(address|addr).*(number|no\\.?|num).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address Number"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*\\b(house|hse|st|str)\\b.*\\b(no|num)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "HSE No"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*\\b(door|property)\\b.*\\b(no|number)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Door No"
        ],
        "negativeExamples": [
          "Door Type"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Number"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "12",
      "221B",
      "7/2",
      "12 1/2",
      "123-125",
      "450B-2",
      "15 C",
      "100A/3"
    ],
    "negativeContentExamples": [
      "123 Main",
      "A12",
      "PO Box 12",
      "12Apt 3",
      "12-B",
      "B-12",
      "1 2",
      "123.5"
    ],
    "positiveHeaderExamples": [
      "House Number",
      "Street Number",
      "Number",
      "Door No",
      "Property Number",
      "Street No.",
      "Address Number",
      "House No"
    ],
    "negativeHeaderExamples": [
      "Street Name",
      "Address",
      "City",
      "State",
      "Street Type",
      "Road Name",
      "Zip Code",
      "Unit"
    ],
    "explanation": "This semantic type identifies house or building street numbers as used in addresses, typically consisting of 1\u20135 digits, optionally followed by a letter (with or without a space), fractional suffix (e.g., 1/2), a unit suffix via slash (e.g., /3), and/or a hyphenated range (e.g., 12-14). It is useful for parsing, normalizing, and validating address components during data quality and geocoding workflows.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:29:02.357401"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.SUBURB_AU",
    "description": "A text field containing Australian suburb names that follow standard English linguistic conventions with proper capitalization and spacing. The format represents official locality designations as used in Australian postal and administrative documentation systems.",
    "pluginType": "regex",
    "regexPattern": "\\b(St|Saint|[A-Z][a-z]+|[A-Z]'[A-Za-z]+|Mc[A-Z][a-z]+)([- ](St|Saint|North|South|East|West|Upper|Lower|Central|New|Old|Little|Big|Port|Mount|Point|Bay|Beach|Heads|Heights|Hills|Hill|Valley|Vale|Downs|Plains|Waters|River|Ridge|View|Grove|Park|Town|Harbour|Springs|[A-Z][a-z]+|[A-Z]'[A-Za-z]+|Mc[A-Z][a-z]+)){0,4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4210,
    "headerPatterns": [
      {
        "regExp": "(?i).*(australian).*suburb.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Australian Suburb"
        ],
        "negativeExamples": [
          "State"
        ]
      },
      {
        "regExp": "(?i).*suburb.*name.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Suburb Name"
        ],
        "negativeExamples": [
          "Suburb Code"
        ]
      },
      {
        "regExp": "(?i).*suburb.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Suburb"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*locality.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Locality"
        ],
        "negativeExamples": [
          "Postcode"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "City"
        ]
      }
    ],
    "positiveContentExamples": [
      "St Kilda",
      "Port Melbourne",
      "North Sydney",
      "Glen Waverley",
      "Nambucca Heads",
      "Kings Park",
      "O'Connor",
      "McLaren Vale"
    ],
    "negativeContentExamples": [
      "St. Kilda",
      "Port Melbourne VIC",
      "North Sydney 2060",
      "o\u2019connor",
      "Glen  Waverley",
      "Nambucca Heads NSW",
      "Glen Waverley,",
      "St Kilda 3182"
    ],
    "positiveHeaderExamples": [
      "Suburb",
      "Australian Suburb",
      "Suburb Name",
      "AU Suburb",
      "Suburb (AU)",
      "Locality",
      "Town/Suburb",
      "Locality Name"
    ],
    "negativeHeaderExamples": [
      "State",
      "City",
      "Postcode",
      "State Name",
      "City Name",
      "Postal Code",
      "Street Name",
      "Country"
    ],
    "explanation": "This semantic type targets Australian suburb/locality names, focusing on proper capitalization and common tokens found in Australian place names, including support for apostrophes, hyphens, and qualifiers like North, South, Upper, and Mount. It is intended for datasets containing locality fields used in addressing, geocoding, and administrative records.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:29:04.290718"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS4_EN",
    "description": "A text field containing quaternary address components that typically include wing designations, entrance specifications, or specialized facility identifiers. The format accommodates complex addressing needs for large buildings, campuses, or industrial facilities. This focuses on sub-building or facility access details and excludes unit/suite/room or floor identifiers.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b((north|south|east|west)\\s+wing|wing\\s+(north|south|east|west)|wing\\s+[A-Z]{1,2}|entrance\\s+[A-Z0-9-]{1,3}|gate\\s+[A-Z0-9-]{1,3}|loading\\s+dock\\s+[A-Z0-9-]{1,3}|dock\\s+[A-Z0-9-]{1,3}|bay\\s+[A-Z0-9-]{1,3}|sector\\s+[A-Z0-9-]{1,3}|pod\\s+[A-Z0-9-]{1,3}|concourse\\s+[A-Z]{1,2}|terminal\\s+[A-Z0-9]{1,2})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4240,
    "headerPatterns": [
      {
        "regExp": "(?i).*(address[\\s_]*line[\\s_]*4|addr[\\s_]*line[\\s_]*4|address[\\s_]*4|addr4).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Address Line 4"
        ],
        "negativeExamples": [
          "Address Line 1"
        ]
      },
      {
        "regExp": "(?i).*(wing|entrance|gate|loading[\\s_]*dock|sector|bay|pod).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Wing"
        ],
        "negativeExamples": [
          "Suite"
        ]
      },
      {
        "regExp": "(?i).*(addr[\\s_]*4|addr[\\s_]*ln[\\s_]*4|address[\\s_]*ln[\\s_]*4).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Address_4"
        ],
        "negativeExamples": [
          "Street Address"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Address Line 4"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Wing A",
      "East Wing",
      "Wing South",
      "Entrance 3",
      "Gate B2",
      "Loading Dock 4",
      "Bay C",
      "Sector D4"
    ],
    "negativeContentExamples": [
      "Suite 402",
      "Apt 12B",
      "Unit 7A",
      "Floor 3",
      "Room 210",
      "Gatehouse 1",
      "Entrance-3",
      "Dockside 2"
    ],
    "positiveHeaderExamples": [
      "Address Line 4",
      "Wing",
      "Entrance",
      "Gate",
      "Loading Dock",
      "Sector",
      "Bay",
      "Address_4"
    ],
    "negativeHeaderExamples": [
      "Street Address",
      "Suite",
      "ZIP Code",
      "Address Line 1",
      "Apt",
      "Floor",
      "Building",
      "Postal Code"
    ],
    "explanation": "This semantic type targets sub-building access and facility components commonly entered in a fourth address line, such as wings, entrances, gates, docks, bays, and sectors. It helps distinguish fine-grained location details within large sites, campuses, or industrial complexes. It intentionally excludes unit, apartment, suite, room, or floor indicators that typically belong to other address lines.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:29:08.319634"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_UNION_IN",
    "description": "A text field containing Indian state codes that follow the pattern ^[A-Z]{2}$ consisting of exactly two uppercase letters. The format represents official state/union territory abbreviations as used in Indian government documentation and postal addressing systems.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4180,
    "headerPatterns": [
      {
        "regExp": "(?i).*union.*territory.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Union Territory Code"
        ],
        "negativeExamples": [
          "State Name"
        ]
      },
      {
        "regExp": "(?i).*indian.*state.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Indian State Code"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(india|indian).*(state|union.*territory).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Indian State"
        ],
        "negativeExamples": [
          "District"
        ]
      },
      {
        "regExp": "(?i).*(state|union.*territory).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State/UT Code"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Code"
        ],
        "negativeExamples": [
          "State Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "AP",
      "DL",
      "MH",
      "KA",
      "TN",
      "TS",
      "RJ",
      "PB"
    ],
    "negativeContentExamples": [
      "dl",
      "D1",
      "DEL",
      "D-L",
      "D L",
      "MH3",
      "Rj",
      "CH."
    ],
    "positiveHeaderExamples": [
      "State Code",
      "Indian State",
      "Union Territory Code",
      "IN State Code",
      "State/UT Code",
      "Region Code (India)",
      "UT Code",
      "State Abbrev (IN)"
    ],
    "negativeHeaderExamples": [
      "State Name",
      "Country",
      "District",
      "Province Name",
      "Region",
      "Territory Name",
      "State Description"
    ],
    "explanation": "This semantic type detects two-letter uppercase abbreviations representing Indian states or union territories. It is best applied to columns storing standardized state/UT codes used in government forms, registries, and postal addressing. High threshold and header patterns help distinguish these from other short alphabetic tokens.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:29:13.150751"
  },
  {
    "resultType": "generated",
    "semanticType": "TELEPHONE",
    "description": "A text field containing telephone numbers that may follow various formatting patterns depending on regional conventions and may include country codes, area codes, and separators. The format accommodates international and domestic numbering plans with flexible punctuation and spacing.",
    "pluginType": "regex",
    "regexPattern": "\\b(\\+?\\d{1,3}[\\s.\\-])?(\\(?\\d{2,4}\\)?)[\\s.\\-]\\d{3,4}([\\s.\\-]\\d{2,5})+(\\s?(x|ext|ext\\.)\\s?\\d{1,6})?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4320,
    "headerPatterns": [
      {
        "regExp": "(?i).*(phone|telephone).*(number|no).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Phone Number"
        ],
        "negativeExamples": [
          "Email Address"
        ]
      },
      {
        "regExp": "(?i).*(contact|customer|user).*(phone|telephone).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Customer Phone"
        ],
        "negativeExamples": [
          "Fax Number"
        ]
      },
      {
        "regExp": "(?i).*\\b(tel|ph)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Primary Ph No"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*(mobile|cell).*(phone).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Mobile Phone"
        ],
        "negativeExamples": [
          "Zip Code"
        ]
      },
      {
        "regExp": "(?i).*phone.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Telephone"
        ],
        "negativeExamples": [
          "Email Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "+1 212-555-0123",
      "+44 20 7946 0958",
      "(212) 555-0123",
      "212-555-0123",
      "212.555.0123",
      "+49-89-636-48018",
      "1-800-123-4567",
      "+1 650 555 7890 ext 12"
    ],
    "negativeContentExamples": [
      "+1 2125550123",
      "(212)5550123",
      "212-5550123",
      "555-012",
      "+44 2079460958",
      "1 800 CALLNOW",
      "02079460958",
      "+49 89 636 4801 ext"
    ],
    "positiveHeaderExamples": [
      "Phone Number",
      "Telephone",
      "Phone",
      "Contact Phone",
      "Customer Telephone",
      "Primary Phone Number",
      "Mobile Phone",
      "User Ph No"
    ],
    "negativeHeaderExamples": [
      "Email Address",
      "Fax Number",
      "Address",
      "Account Number",
      "Contact Name",
      "Zip Code",
      "Customer ID",
      "Website"
    ],
    "explanation": "Identifies telephone numbers across international and domestic formats that include optional country codes, area codes, separators (space, hyphen, dot), and optional extensions indicated by x, ext, or ext.. The pattern emphasizes realistic phone structures by requiring separators between numeric blocks and supports common variations without being overly permissive.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:29:14.812612"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_PROVINCE_NA",
    "description": "A text field containing North American state/province codes that typically follow patterns of two or three uppercase letters derived from territorial names. The format represents official abbreviations as used across US, Canadian, and Mexican administrative systems.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4160,
    "headerPatterns": [
      {
        "regExp": "(?i).*(state.*province.*code|province.*state.*code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Province Code"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      },
      {
        "regExp": "(?i).*(state|province).*(code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Code"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(state[-_ ]?prov).*(code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "StateProv Code"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      },
      {
        "regExp": "(?i).*(state.*province|province.*state).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State/Province"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "State Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "CA",
      "NY",
      "TX",
      "ON",
      "QC",
      "BC",
      "JAL",
      "BCN"
    ],
    "negativeContentExamples": [
      "ca",
      "Tx",
      "qc",
      "C-A",
      "N.Y.",
      "A",
      "AB1",
      "N L"
    ],
    "positiveHeaderExamples": [
      "State Code",
      "Province Code",
      "State/Province",
      "State Province Code",
      "Province/State Code",
      "StateProv Code",
      "State or Province Code"
    ],
    "negativeHeaderExamples": [
      "State Name",
      "Province Name",
      "Country",
      "Postal Code",
      "County",
      "Region",
      "State ID",
      "Province Abbr"
    ],
    "explanation": "Identifies two- or three-letter uppercase abbreviations used for North American first-level administrative divisions (US states, Canadian provinces/territories, and Mexican states). Useful for normalizing location columns where values are standardized jurisdiction codes rather than full names.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:29:15.187742"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_MARKER_EN",
    "description": "A text field containing English street type designators that follow established patterns for thoroughfare classification in postal addressing. The format includes standard terms and common abbreviations used to identify road types in English-speaking addressing systems.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(st|street|rd|road|ave|avenue|blvd|boulevard|ln|lane|dr|drive|ct|court|pl|place|ter|terrace|pkwy|parkway|hwy|highway|sq|square|cir|circle|loop|way|trl|trail|aly|alley|cres|crescent|mews|walk|close|cl|row)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 4270,
    "headerPatterns": [
      {
        "regExp": "(?i).*street.*(suffix|type|marker).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street Suffix"
        ],
        "negativeExamples": [
          "Street Name"
        ]
      },
      {
        "regExp": "(?i).*(thoroughfare|road|rd|route).*(suffix|type|marker|abbrev).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Thoroughfare Suffix"
        ],
        "negativeExamples": [
          "House Number"
        ]
      },
      {
        "regExp": "(?i).*street.*abbrev.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street Abbreviation"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*(st|rd|ave|blvd|dr|ln).*(type|suffix).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Rd Type"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*suffix.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Suffix"
        ],
        "negativeExamples": [
          "Prefix"
        ]
      }
    ],
    "positiveContentExamples": [
      "St",
      "Street",
      "Ave",
      "Avenue",
      "Rd",
      "Road",
      "Blvd",
      "Boulevard"
    ],
    "negativeContentExamples": [
      "Streetname",
      "Roadway",
      "Aven",
      "Boulvard",
      "LnName",
      "Circl",
      "Drv",
      "Pkway"
    ],
    "positiveHeaderExamples": [
      "Street Type",
      "Street Suffix",
      "Street Marker",
      "Thoroughfare Suffix",
      "Road Type",
      "Street Abbreviation"
    ],
    "negativeHeaderExamples": [
      "Street Name",
      "House Number",
      "Address",
      "Zip Code",
      "City",
      "State",
      "Unit",
      "Apartment"
    ],
    "explanation": "This type detects English street type designators and common abbreviations typically used as street suffixes in postal addresses (e.g., St, Ave, Rd, Blvd). It is useful for normalizing or validating the street-type component of an address after parsing a full address into its constituent parts.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:29:21.002953"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_UNION_NAME_IN",
    "description": "A text field containing Indian state names that follow standard English linguistic conventions with proper capitalization and spacing. The format represents official state designations as used in Indian government documentation and legal systems.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z][a-z]{2,}( (and|of|[A-Z][a-z]{2,})){0,8}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4190,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bindian\\b.*\\bstate\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Indian State"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*\\bunion\\b.*\\bterritor.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Union Territory"
        ],
        "negativeExamples": [
          "Territory Code"
        ]
      },
      {
        "regExp": "(?i).*\\bstate\\b.*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Name"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*\\b(st|ut|prov)\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "UT Name"
        ],
        "negativeExamples": [
          "Province Code"
        ]
      },
      {
        "regExp": "(?i).*\\bname\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Tamil Nadu",
      "Uttar Pradesh",
      "Madhya Pradesh",
      "West Bengal",
      "Jammu and Kashmir",
      "Andaman and Nicobar Islands",
      "Dadra and Nagar Haveli and Daman and Diu",
      "Delhi"
    ],
    "negativeContentExamples": [
      "tamil nadu",
      "Uttar-Pradesh",
      "Jammu & Kashmir",
      "Andaman and Nicobar Islands,",
      "Delhi NCR",
      "UTTAR PRADESH",
      "MadhyaPradesh",
      "Puducherry."
    ],
    "positiveHeaderExamples": [
      "State",
      "Indian State",
      "Union Territory",
      "State Name",
      "IN State",
      "UT Name",
      "Indian State Name"
    ],
    "negativeHeaderExamples": [
      "State Code",
      "Country",
      "District",
      "Territory Code",
      "Province Code",
      "City",
      "State Code Numeric"
    ],
    "explanation": "This semantic type identifies values that are Indian state or union territory names written in English title case, optionally including lowercase connectors such as 'and' or 'of'. It is useful for classifying administrative division fields in Indian datasets where cells contain the full state/UT name rather than a code.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:29:22.832863"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.CANTON_NAME_CH",
    "description": "Full Swiss canton names in their official language, written as properly capitalized words. Names may comprise one or more words and can include hyphens between capitalized tokens (e.g., Basel-Landschaft). The pattern expects only letters (including diacritics), single spaces, or single hyphens between words, and excludes abbreviations, codes, or additional qualifiers.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z\u00c0-\u00d6\u00d8-\u00df][a-z\u00e0-\u00f6\u00f8-\u00ff]+([ -][A-Z\u00c0-\u00d6\u00d8-\u00df][a-z\u00e0-\u00f6\u00f8-\u00ff]+){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 3730,
    "headerPatterns": [
      {
        "regExp": "(?i).*swiss.*canton.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Swiss Canton Name"
        ],
        "negativeExamples": [
          "Canton Code"
        ]
      },
      {
        "regExp": "(?i).*ch.*canton.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CH Canton Name"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(canton|kanton).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Canton Name"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*(canton|kanton).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Kanton"
        ],
        "negativeExamples": [
          "Province"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Z\u00fcrich",
      "Bern",
      "Basel-Stadt",
      "Basel-Landschaft",
      "Appenzell Ausserrhoden",
      "Appenzell Innerrhoden",
      "Sankt Gallen",
      "Neuch\u00e2tel"
    ],
    "negativeContentExamples": [
      "zurich",
      "Z\u00fcrich 1",
      "Basel-landschaft",
      "Appenzell  Innerrhoden",
      "St. Gallen",
      "Canton de Vaud",
      "Neuch\u00e2tel-",
      "Bern/Berne"
    ],
    "positiveHeaderExamples": [
      "Kanton",
      "Canton Name",
      "Canton",
      "Swiss Canton",
      "CH Canton Name",
      "Canton Full Name",
      "Official Canton Name",
      "CantonName"
    ],
    "negativeHeaderExamples": [
      "Canton Code",
      "Country",
      "City",
      "Province",
      "State Code",
      "Canton ID",
      "Canton Abbreviation",
      "Region"
    ],
    "explanation": "This semantic type identifies full Swiss canton names, focusing on properly capitalized tokens possibly separated by single spaces or single hyphens. It is suited for columns containing official canton names rather than abbreviations, codes, or augmented labels, and leverages header context that mentions canton and name to increase precision.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:29:31.267836"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_NAME_BARE_EN",
    "description": "A text field containing English street names without type suffixes that follow standard English naming conventions with proper capitalization. The format excludes common street type designators while maintaining the essential identifying portion of the street name.",
    "pluginType": "regex",
    "regexPattern": "\\b([1-9][0-9]{0,2}(st|nd|rd|th)|(?!(Street|St|Road|Rd|Avenue|Ave|Boulevard|Blvd|Lane|Ln|Drive|Dr|Way|Place|Pl|Court|Ct|Terrace|Ter|Circle|Cir|Highway|Hwy|Parkway|Pkwy|Square|Sq|Trail|Trl|Alley|Aly)\\b)[A-Z][a-z]*(['-][A-Z][a-z]+)*)\\b(\\s+([1-9][0-9]{0,2}(st|nd|rd|th)|(?!(Street|St|Road|Rd|Avenue|Ave|Boulevard|Blvd|Lane|Ln|Drive|Dr|Way|Place|Pl|Court|Ct|Terrace|Ter|Circle|Cir|Highway|Hwy|Parkway|Pkwy|Square|Sq|Trail|Trl|Alley|Aly)\\b)[A-Z][a-z]*(['-][A-Z][a-z]+)*)){0,4}",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4290,
    "headerPatterns": [
      {
        "regExp": "(?i).*(street|road|avenue|boulevard|lane|drive|way|place|court).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street Name"
        ],
        "negativeExamples": [
          "Street Type"
        ]
      },
      {
        "regExp": "(?i).*(streetname|roadname).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "StreetName"
        ],
        "negativeExamples": [
          "House Number"
        ]
      },
      {
        "regExp": "(?i).*road.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Road Name"
        ],
        "negativeExamples": [
          "Road Type"
        ]
      },
      {
        "regExp": "(?i).*(rd|st|ave|blvd|ln|dr).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Rd Name"
        ],
        "negativeExamples": [
          "Rd Type"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street"
        ],
        "negativeExamples": [
          "Full Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "Main",
      "Oak Meadow",
      "O'Connell",
      "Cedar Grove",
      "West End",
      "Kingswood",
      "5th",
      "Old Mill"
    ],
    "negativeContentExamples": [
      "Main Street",
      "Oak Rd",
      "42nd Avenue",
      "elm",
      "12TH",
      "King's Cross",
      "Highway 7",
      "Maple_Lane"
    ],
    "positiveHeaderExamples": [
      "Street Name",
      "Road Name",
      "Street",
      "StreetName",
      "RoadName",
      "Street Name EN",
      "Street Name Text"
    ],
    "negativeHeaderExamples": [
      "Street Type",
      "House Number",
      "Full Address",
      "Road Type",
      "Address Line 1",
      "Street Suffix",
      "Postal Code"
    ],
    "explanation": "Identifies bare English street names that exclude the street type/suffix (e.g., Street, Rd, Ave). It expects title-cased words and allows common constructs like hyphenation and ordinal numbers (e.g., 5th). Useful for datasets where the street type is stored separately or needs to be appended during formatting.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:29:39.215494"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_ES",
    "description": "Spanish province names with proper capitalization: one to five words, each word starting with an uppercase letter (including accented capitals \u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc\u00d1) followed by lowercase letters (including \u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc). Words are separated by single spaces only; no abbreviations, punctuation, digits, or special characters.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc]+( [A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc]+){0,4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 3960,
    "headerPatterns": [
      {
        "regExp": "(?i).*spanish.*provinc.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Spanish Province Name"
        ],
        "negativeExamples": [
          "Province"
        ]
      },
      {
        "regExp": "(?i).*(provincia|province).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Province Name"
        ],
        "negativeExamples": [
          "Country Name"
        ]
      },
      {
        "regExp": "(?i).*(spanish|es).*provinc.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Spanish Province"
        ],
        "negativeExamples": [
          "City Province"
        ]
      },
      {
        "regExp": "(?i).*\\bprov\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "prov"
        ],
        "negativeExamples": [
          "provider"
        ]
      },
      {
        "regExp": "(?i).*(provincia|province).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Provincia"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Madrid",
      "Barcelona",
      "Valencia",
      "M\u00e1laga",
      "C\u00f3rdoba",
      "La Rioja",
      "Las Palmas",
      "Santa Cruz De Tenerife"
    ],
    "negativeContentExamples": [
      "la Rioja",
      "La rioja",
      "las Palmas",
      "Santa Cruz de Tenerife",
      "MALAGA",
      "Soria1",
      "\u00c1vila/Segovia",
      "Lleida-Alt Urgell"
    ],
    "positiveHeaderExamples": [
      "Provincia",
      "Province",
      "Spanish Province",
      "Province Name",
      "Provincia Nombre",
      "Nombre Provincia",
      "Spanish Province Name"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Region",
      "City",
      "State",
      "County",
      "Province Code",
      "Province ID"
    ],
    "explanation": "This semantic type targets properly capitalized Spanish province names expressed as plain text without abbreviations or special characters. It accepts one to five words, each capitalized and composed only of alphabetic characters including Spanish diacritics, separated by single spaces. Use it to validate or classify columns containing province names in Spanish where consistent title casing and clean formatting are expected.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:29:57.368411"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_PE",
    "description": "Properly capitalized Peruvian province names in Spanish, consisting of one to five words where each word starts with an uppercase letter followed by lowercase letters, including support for Spanish diacritics (\u00e1, \u00e9, \u00ed, \u00f3, \u00fa, \u00f1, \u00fc). No abbreviations, digits, punctuation, hyphens, or special formatting characters are allowed; words are separated by single spaces only.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc]+(\\s[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc]+){0,4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4000,
    "headerPatterns": [
      {
        "regExp": "(?i).*(peru|peruvian|pe).*(province|provincia).*(name|nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "peruvian_province_name"
        ],
        "negativeExamples": [
          "province_code_pe"
        ]
      },
      {
        "regExp": "(?i).*(province|provincia).*(name|nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province name"
        ],
        "negativeExamples": [
          "province code"
        ]
      },
      {
        "regExp": "(?i).*(prov|provinc).*(name|nom).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "prov_name"
        ],
        "negativeExamples": [
          "prov_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "title"
        ]
      }
    ],
    "positiveContentExamples": [
      "Lima",
      "Arequipa",
      "S\u00e1nchez Carri\u00f3n",
      "General S\u00e1nchez Cerro",
      "Coronel Portillo",
      "Padre Abad",
      "Mariscal Ram\u00f3n Castilla",
      "Datem Del Mara\u00f1\u00f3n"
    ],
    "negativeContentExamples": [
      "lima",
      "Datem del Mara\u00f1\u00f3n",
      "General S\u00e1nchez-Cerro",
      "Coronel Portillo, Ucayali",
      "Puno 01",
      "San mArt\u00edn",
      "Mariscal  Ram\u00f3n Castilla",
      "Jos\u00e9 L Ortiz"
    ],
    "positiveHeaderExamples": [
      "Provincia",
      "Province",
      "Peruvian Province",
      "Province Name",
      "Provincia Nombre",
      "province_name_pe",
      "prov_name",
      "PROVINCE_NAME_PE"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Region",
      "City",
      "Province Code",
      "State Name",
      "County",
      "province_id",
      "municipality"
    ],
    "explanation": "This semantic type identifies values that look like official Peruvian province names written as Spanish proper nouns with correct capitalization and Spanish diacritics, consisting of 1\u20135 words separated by single spaces. It excludes strings with lowercase connector words (e.g., de/del), abbreviations, punctuation, digits, or extra qualifiers, focusing strictly on the clean, capitalized form of the province name.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:29:59.724731"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.MIDDLE_INITIAL",
    "description": "A text field containing middle initials that follow the pattern ^[A-Za-z]\\.?$ consisting of a single alphabetic character optionally followed by a period. The format represents abbreviated middle names using standard initial formatting conventions with optional punctuation.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z]\\.\\?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3380,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bmiddle[ _-]*initial\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Middle Initial"
        ],
        "negativeExamples": [
          "Middle Name"
        ]
      },
      {
        "regExp": "(?i).*\\bmiddle\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Middle"
        ],
        "negativeExamples": [
          "MiddleName"
        ]
      },
      {
        "regExp": "(?i).*\\binitial\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Initial"
        ],
        "negativeExamples": [
          "Initials"
        ]
      },
      {
        "regExp": "(?i).*\\bmi\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "MI"
        ],
        "negativeExamples": [
          "Midi"
        ]
      },
      {
        "regExp": "(?i).*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "A",
      "B.",
      "c",
      "D.",
      "e.",
      "F",
      "m.",
      "Z"
    ],
    "negativeContentExamples": [
      "AB",
      "A B",
      "A..",
      ".A",
      "A-",
      "A1",
      "\u00c5.",
      "AA."
    ],
    "positiveHeaderExamples": [
      "Middle Initial",
      "Middle",
      "Initial",
      "MI",
      "M Initial",
      "MiddleInitial",
      "Middle-Initial",
      "Person Middle Initial"
    ],
    "negativeHeaderExamples": [
      "First Name",
      "Middle Name",
      "Full Name",
      "Initials",
      "MiddleName",
      "Given Name",
      "Suffix",
      "Last Name"
    ],
    "explanation": "This semantic type targets single-character middle initials with an optional trailing period, suitable for datasets capturing abbreviated middle names. It reduces ambiguity by focusing on one-letter tokens rather than full names and is intended for use alongside first and last name fields.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:30:40.383826"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.REGION_NAME_TZ",
    "description": "A text field containing Tanzanian regional names that follow standard formatting with proper capitalization and spacing. The format represents official territorial designations as used in Tanzanian government documentation and administrative systems.",
    "pluginType": "regex",
    "regexPattern": "\\b(Dar es Salaam|[A-Z][a-z]{3,}( (Unguja|Pemba|Magharibi))?)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4060,
    "headerPatterns": [
      {
        "regExp": "(?i).*(tanzania|tz).*region.*name.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "TZ region name"
        ],
        "negativeExamples": [
          "Tanzania region code"
        ]
      },
      {
        "regExp": "(?i).*(tanzania|tz).*\\bregion\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Tanzanian Region"
        ],
        "negativeExamples": [
          "Region Manager"
        ]
      },
      {
        "regExp": "(?i).*\\bregion\\b.*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Region Name"
        ],
        "negativeExamples": [
          "Region Count"
        ]
      },
      {
        "regExp": "(?i).*\\bmkoa\\b.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Mkoa"
        ],
        "negativeExamples": [
          "Wilaya"
        ]
      },
      {
        "regExp": "(?i).*\\bname\\b.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Dar es Salaam",
      "Dodoma",
      "Mwanza",
      "Arusha",
      "Pwani",
      "Mjini Magharibi",
      "Kaskazini Unguja",
      "Kusini Pemba"
    ],
    "negativeContentExamples": [
      "Dar Es Salaam",
      "dar es salaam",
      "Mwanza Region",
      "Pwani, Tanzania",
      "Kaskazini Pemba Region",
      "Mjini-Magharibi",
      "Lindi City",
      "Kilimanjaro Region"
    ],
    "positiveHeaderExamples": [
      "Region",
      "Tanzanian Region",
      "Mkoa",
      "Region Name",
      "TZ Region",
      "Administrative Region",
      "Region of Tanzania"
    ],
    "negativeHeaderExamples": [
      "Country",
      "District",
      "City",
      "Region Code",
      "Province",
      "State",
      "County"
    ],
    "explanation": "This semantic type targets officially formatted names of regions within Tanzania, covering single-word mainland regions (e.g., Pwani, Mwanza) and specific multi-word Zanzibar regions (e.g., Kaskazini Unguja, Mjini Magharibi) as well as the special case Dar es Salaam. The pattern enforces proper capitalization of region names, allows a specific lowercase connector in Dar es Salaam, and restricts multi-word second terms to Unguja, Pemba, or Magharibi to avoid false positives like \u201cPwani Region.\u201d\nHeader patterns progress from highly specific (Tanzania/TZ region name) to the primitive concept (name), enabling robust identification from column metadata. The confidence threshold and priority reflect a moderately specific type: constrained by name structure and Tanzanian context but still a text-based name rather than a rigid code.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:30:49.463294"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_BR",
    "description": "A text field containing Brazilian state names that follow Portuguese linguistic conventions with proper capitalization, spacing, and diacritical marks. The format represents official territorial designations as used in Brazilian government documentation and legal systems.",
    "pluginType": "regex",
    "regexPattern": "\\b(Acre|Alagoas|Amap\u00e1|Amazonas|Bahia|Cear\u00e1|Esp\u00edrito Santo|Goi\u00e1s|Maranh\u00e3o|Mato Grosso|Mato Grosso do Sul|Minas Gerais|Par\u00e1|Para\u00edba|Paran\u00e1|Pernambuco|Piau\u00ed|Rio de Janeiro|Rio Grande do Norte|Rio Grande do Sul|Rond\u00f4nia|Roraima|Santa Catarina|S\u00e3o Paulo|Sergipe|Tocantins)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4120,
    "headerPatterns": [
      {
        "regExp": "(?i).*(brazil|br).*(state|estado).*(name|nome).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "BR State Name"
        ],
        "negativeExamples": [
          "BR State Code"
        ]
      },
      {
        "regExp": "(?i).*(brazilian|br).*(state|estado).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Brazilian State"
        ],
        "negativeExamples": [
          "Brazilian State Code"
        ]
      },
      {
        "regExp": "(?i).*(state|estado).*(name|nome).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Nome do Estado"
        ],
        "negativeExamples": [
          "State Number"
        ]
      },
      {
        "regExp": "(?i).*(uf).*(name|nome).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "UF Nome"
        ],
        "negativeExamples": [
          "UF C\u00f3digo"
        ]
      },
      {
        "regExp": "(?i).*(state|estado).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Estado"
        ],
        "negativeExamples": [
          "Region"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "S\u00e3o Paulo",
      "Rio de Janeiro",
      "Minas Gerais",
      "Esp\u00edrito Santo",
      "Paran\u00e1",
      "Mato Grosso do Sul",
      "Santa Catarina",
      "Cear\u00e1"
    ],
    "negativeContentExamples": [
      "Sao Paulo",
      "Rio de Janiero",
      "Minas  Gerais",
      "Distrito Federal",
      "Parana",
      "Mato Grosso do sul",
      "Rondonia",
      "Bah\u00eda"
    ],
    "positiveHeaderExamples": [
      "Estado",
      "State",
      "Brazilian State",
      "Nome do Estado",
      "BR State Name",
      "UF Nome",
      "Name"
    ],
    "negativeHeaderExamples": [
      "State Code",
      "Country",
      "Region",
      "Province",
      "State Abbreviation",
      "UF",
      "Country Region"
    ],
    "explanation": "This semantic type identifies full Brazilian state names precisely as written in Portuguese with correct capitalization and diacritics (e.g., S\u00e3o Paulo, Rio Grande do Sul). It is intended for columns storing the official state name text and helps distinguish full names from codes or abbreviations in Brazilian datasets.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:30:56.753401"
  },
  {
    "resultType": "generated",
    "semanticType": "TIMEZONE.IANA",
    "description": "A text field containing IANA timezone identifiers that follow the pattern of continent/location or region/location with underscores replacing spaces. The format represents standardized timezone designations as maintained by the Internet Assigned Numbers Authority for global time coordination.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z]{3,}(/[A-Za-z0-9][A-Za-z0-9_-]{0,62}){1,2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 4330,
    "headerPatterns": [
      {
        "regExp": "(?i).*iana.*time[ _]?zone.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IANA Timezone"
        ],
        "negativeExamples": [
          "Timezone Code"
        ]
      },
      {
        "regExp": "(?i).*time[ _]?zone[ _]?(id|identifier).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Timezone Identifier"
        ],
        "negativeExamples": [
          "Time Zone Offset"
        ]
      },
      {
        "regExp": "(?i).*\\btz\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "TZ"
        ],
        "negativeExamples": [
          "TZN"
        ]
      },
      {
        "regExp": "(?i).*time[ _]?zone.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Time Zone"
        ],
        "negativeExamples": [
          "UTC Offset"
        ]
      }
    ],
    "positiveContentExamples": [
      "America/New_York",
      "Europe/London",
      "Asia/Kolkata",
      "Pacific/Auckland",
      "Africa/Johannesburg",
      "America/Argentina/Buenos_Aires",
      "Australia/Sydney",
      "Etc/UTC"
    ],
    "negativeContentExamples": [
      "New_York",
      "America/",
      "America//New_York",
      "America/New York",
      "UTC",
      "Europe-London",
      "America\\New_York",
      "123/ABC"
    ],
    "positiveHeaderExamples": [
      "Timezone",
      "Time Zone",
      "IANA Timezone",
      "Timezone Identifier",
      "TZ",
      "User Time Zone",
      "Preferred Timezone",
      "IANA TZ"
    ],
    "negativeHeaderExamples": [
      "UTC Offset",
      "Country",
      "City",
      "Time Offset",
      "Postal Code",
      "Language",
      "Region",
      "GMT"
    ],
    "explanation": "This semantic type identifies values that resemble IANA TZ database identifiers in the common Region/Location or Region/Subregion/Location form, using letters, digits, underscores, and hyphens for location tokens. It is suitable for detecting normalized timezone keys used in applications and logs where spaces are replaced by underscores. Typical use cases include parsing configuration columns, user preference fields, and system logs that store IANA timezone IDs.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:31:35.128461"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS_<LANGUAGE>",
    "description": "A text field containing street addresses that follow language-specific formatting patterns and may include special characters, diacritical marks, or alternative numbering systems. The format adapts to local addressing standards and linguistic conventions for the specified language context. Examples vary by language context.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{1,6}[A-Za-z]?([ -][0-9A-Za-z]{1,4})?\\s+[0-9A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff'\u2019\\-.]{2,}\\s+(Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Lane|Ln|Drive|Dr|Court|Ct|Way|Place|Pl|Square|Sq|Terrace|Ter|Trail|Trl|Highway|Hwy|Route|Rte)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4250,
    "headerPatterns": [
      {
        "regExp": "(?i).*street.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street Address"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      },
      {
        "regExp": "(?i).*(billing|shipping|mailing).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Mailing Address"
        ],
        "negativeExamples": [
          "Street"
        ]
      },
      {
        "regExp": "(?i).*(street_addr|addr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street Addr"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*street.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "221B Baker Street",
      "1600 Pennsylvania Ave",
      "10 Downing St",
      "742 Evergreen Terrace",
      "55-09 37th Ave",
      "12 O\u2019Connell Street",
      "500 Winding Road",
      "300 Highland Blvd"
    ],
    "negativeContentExamples": [
      "Main Street",
      "123 Main",
      "PO Box 123",
      "123, Main Street",
      "45 North",
      "678 Ninth Av",
      "12 Place des Vosges",
      "100 Broadway"
    ],
    "positiveHeaderExamples": [
      "Street Address",
      "Address",
      "Street",
      "Mailing Address",
      "Shipping Address",
      "Billing Street Address",
      "Street Addr"
    ],
    "negativeHeaderExamples": [
      "City",
      "Country",
      "ZIP Code",
      "State",
      "Province",
      "Postal Code",
      "Region"
    ],
    "explanation": "This semantic type identifies text values that look like street-level addresses where a primary number precedes the street name and type, accommodating diacritics, hyphens, and common street-type abbreviations. It is intended to be parameterized per language variant and used to detect address fields in datasets for geocoding, validation, or normalization workflows.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:32:52.796058"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_PROVINCE_NAME_NA",
    "description": "A text field containing North American state/province names that follow standard linguistic conventions with proper capitalization and spacing. The format represents official territorial designations as used across US, Canadian, and Mexican government documentation.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z][a-z\\p{Ll}]+([-' ][A-Z][a-z\\p{Ll}]+){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4170,
    "headerPatterns": [
      {
        "regExp": "(?i).*(state|province)[ _/|-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State/Province Name"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*(state[ _/-]*province|province[ _/-]*state).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Province"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(state|province).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State"
        ],
        "negativeExamples": [
          "Province Code"
        ]
      },
      {
        "regExp": "(?i).*(st|prov)[ _/|-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Prov Name"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "California",
      "New York",
      "British Columbia",
      "Qu\u00e9bec",
      "Nuevo Le\u00f3n",
      "Baja California Sur",
      "Prince Edward Island",
      "San Luis Potosi"
    ],
    "negativeContentExamples": [
      "CA",
      "New york",
      "NEW YORK",
      "State of California",
      "Baja california sur",
      "NewYork",
      "Washington D.C.",
      "Nayarit (MX)"
    ],
    "positiveHeaderExamples": [
      "State",
      "Province",
      "State/Province Name",
      "State Name",
      "Province Name",
      "Prov Name",
      "State Province"
    ],
    "negativeHeaderExamples": [
      "State Code",
      "Province Code",
      "Country",
      "Region",
      "Country Name",
      "Postal Code",
      "State Abbreviation",
      "Province Abbreviation"
    ],
    "explanation": "This semantic type identifies full names of states, provinces, and territories within North America as commonly written in datasets, emphasizing proper capitalization, spacing, and optional hyphen or apostrophe separators. It is intended for columns storing the spelled-out jurisdiction names rather than abbreviations or codes, and works in conjunction with header cues to disambiguate from code fields.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:33:08.232935"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_NAME_BARE_<LANGUAGE>",
    "description": "A text field containing bare street names in English that consist of one to four tokens and may include spaces, hyphens, and apostrophes, as well as diacritical marks. The value excludes street type designators such as Street, Road, Ave, Blvd, etc., focusing solely on the name portion.",
    "pluginType": "regex",
    "regexPattern": "(?!.*\\b(Street|St\\.|St\\b|Road|Rd\\.|Rd\\b|Avenue|Ave\\.|Ave\\b|Boulevard|Blvd\\b|Lane|Ln\\b|Drive|Dr\\b|Way|Court|Ct\\b|Place|Pl\\b|Terrace|Ter\\b|Highway|Hwy\\b)\\b)\\b([A-Z][\\p{L}]+([-\u2019' ][A-Z][\\p{L}]+){0,3}|[0-9]{1,3}(st|nd|rd|th)( [-\u2019'][A-Z][\\p{L}]+){0,3})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4280,
    "headerPatterns": [
      {
        "regExp": "(?i).*(street|road).*name.*bare.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Street Name Bare"
        ],
        "negativeExamples": [
          "Street Name"
        ]
      },
      {
        "regExp": "(?i).*bare.*(street|road).*name.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Bare Street Name"
        ],
        "negativeExamples": [
          "Road Name"
        ]
      },
      {
        "regExp": "(?i).*(road|street).*name.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Road Name"
        ],
        "negativeExamples": [
          "Street Number"
        ]
      },
      {
        "regExp": "(?i).*straat.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Straat"
        ],
        "negativeExamples": [
          "Postcode"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "Street Name"
        ],
        "negativeExamples": [
          "City"
        ]
      }
    ],
    "positiveContentExamples": [
      "Baker",
      "King's Cross",
      "Maple Leaf",
      "Old Mill",
      "River Bend",
      "Sunnybrook",
      "42nd",
      "D\u00fan Laoghaire"
    ],
    "negativeContentExamples": [
      "Baker Street",
      "King's Road",
      "Maple Ave.",
      "Old Mill Rd",
      "42nd Street",
      "River Bend Ln",
      "Cedar Point Dr",
      "High St"
    ],
    "positiveHeaderExamples": [
      "Street Name",
      "Straat",
      "Road Name",
      "Bare Street Name",
      "Street Name Bare",
      "StreetName",
      "Straatnaam",
      "RoadName"
    ],
    "negativeHeaderExamples": [
      "Street Number",
      "Postcode",
      "City",
      "Address Line 1",
      "Street Type",
      "Avenue",
      "Latitude",
      "Name ID"
    ],
    "explanation": "This semantic type targets the name portion of a street without any type designators, enabling separation of street labels from their types in address normalization or parsing workflows. It is useful when datasets store the street name independently from the street type (e.g., for standardized addressing, geocoding pipelines, or deduplication). The regex allows common multi-token names with apostrophes, hyphens, numerically ordinal names, and diacritics while explicitly excluding common English street-type words and abbreviations.",
    "description_pattern": "P4",
    "generated_at": "2025-08-10T17:37:39.352144"
  }
]
[
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.ISO-3166-2",
    "description": "Nation Code: two-letter international identifier for countries using the ISO alpha-2 standard (two uppercase letters). Suitable for fields containing standardized country identifiers rather than free-text country names.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4280,
    "headerPatterns": [
      {
        "regExp": "(?i).*iso[-_ ]?3166[-_ ]?1.*alpha[-_ ]?2.*country.*code.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "iso3166_1_alpha2_country_code"
        ],
        "negativeExamples": [
          "iso3166_1_alpha3"
        ]
      },
      {
        "regExp": "(?i).*country.*(iso[-_ ]?2|iso[-_ ]?3166).*code.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "country_iso2_code"
        ],
        "negativeExamples": [
          "country_iso3_code"
        ]
      },
      {
        "regExp": "(?i).*(iso[-_ ]?2|alpha[-_ ]?2|a2).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "alpha2_code"
        ],
        "negativeExamples": [
          "alpha3_code"
        ]
      },
      {
        "regExp": "(?i).*(country|nation).*(alpha[-_ ]?2|two[-_ ]?letter).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nation_two_letter"
        ],
        "negativeExamples": [
          "country_name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "US",
      "GB",
      "FR",
      "DE",
      "CA",
      "JP",
      "CN",
      "BR"
    ],
    "negativeContentExamples": [
      "USA",
      "U.S",
      "us",
      "G-B",
      "FR1",
      "1C",
      "CN-",
      "DE_"
    ],
    "positiveHeaderExamples": [
      "iso3166_1_alpha2",
      "country_iso2",
      "country_code_iso",
      "nation_alpha2_code",
      "iso2_country_code",
      "country_code_2char",
      "country_a2",
      "two_letter_country_code"
    ],
    "negativeHeaderExamples": [
      "state_code",
      "postal_code",
      "language_code",
      "currency_code",
      "iso3166_1_alpha3",
      "country_name",
      "region_code",
      "airport_code"
    ],
    "explanation": "This semantic type identifies two-letter ISO alpha-2 country codes, typically stored as uppercase pairs of letters (e.g., US, FR). It is useful for normalizing and validating country code fields, facilitating joins against reference data, or mapping to regional aggregates. The value pattern is constrained to exactly two uppercase letters bounded by word boundaries to minimize false positives, while header patterns progressively capture specific ISO references down to the primitive concept of a code.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:39:54.872153"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.ISBN",
    "description": "Book ISBN: hyphenated thirteen-digit publication identifier using the 978 or 979 EAN prefix and four hyphens separating five numeric parts. This identifies formatted ISBN-13 strings where the final character is a digit and hyphenation is present.",
    "pluginType": "regex",
    "regexPattern": "\\b(978|979)-\\d{1,5}-\\d{1,7}-\\d{1,6}-\\d\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4070,
    "headerPatterns": [
      {
        "regExp": "(?i).*book.*isbn.*13.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "book_isbn13"
        ],
        "negativeExamples": [
          "book_id"
        ]
      },
      {
        "regExp": "(?i).*publication.*isbn.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "publication_isbn"
        ],
        "negativeExamples": [
          "publication_year"
        ]
      },
      {
        "regExp": "(?i).*(isbn13|isbn_13|isbn-13).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "isbn_13"
        ],
        "negativeExamples": [
          "issn_13"
        ]
      },
      {
        "regExp": "(?i).*isbn.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "isbn"
        ],
        "negativeExamples": [
          "product_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "978-0-306-40615-7",
      "978-1-4028-9462-6",
      "978-0-545-01022-1",
      "978-0-321-14653-0",
      "978-1-56619-909-4",
      "979-10-90636-07-1",
      "979-1-2345-6789-0",
      "978-99921-58-10-7"
    ],
    "negativeContentExamples": [
      "9780306406157",
      "977-1-4028-9462-6",
      "978-0-306-40615-X",
      "979-10-90636-071",
      "978-0-545-01022-",
      "978-0-545 01022-1",
      "978-0-545--01022-1",
      "978-0-545-0102211-1"
    ],
    "positiveHeaderExamples": [
      "book_isbn13",
      "publication_isbn",
      "isbn_13",
      "isbn",
      "isbn_code",
      "book_isbn_code",
      "publication_isbn13"
    ],
    "negativeHeaderExamples": [
      "book_id",
      "issn",
      "upc_code",
      "catalog_number",
      "serial_code",
      "isbn10",
      "product_code"
    ],
    "explanation": "This semantic type detects hyphenated ISBN-13 values, enforcing the 978/979 prefix and five-part hyphenation with digit-only parts and a single-digit check character. Use it to recognize book identifiers formatted as ISBN-13 in textual datasets, especially when hyphenation is present and structure needs validation without computing the checksum.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:39:56.169020"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.ISIN",
    "description": "Security Identifier: twelve-character international instrument code. ISINs consist of a two-letter country prefix, followed by nine alphanumeric characters, and a final numeric check digit computed by the Luhn algorithm.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2}[A-Z0-9]{9}[0-9]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4080,
    "headerPatterns": [
      {
        "regExp": "(?i).*security.*identifier.*isin.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "security_identifier_isin"
        ],
        "negativeExamples": [
          "security_identifier"
        ]
      },
      {
        "regExp": "(?i).*isin.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "isin_code"
        ],
        "negativeExamples": [
          "instrument_code"
        ]
      },
      {
        "regExp": "(?i).*instrument.*isin.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "instrument_isin"
        ],
        "negativeExamples": [
          "instrument_id"
        ]
      },
      {
        "regExp": "(?i).*isin.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "isin"
        ],
        "negativeExamples": [
          "cusip"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "id"
        ]
      }
    ],
    "positiveContentExamples": [
      "US0004026250",
      "GB00B03MLX29",
      "AU0000XVGZA3",
      "DE000BAY0017",
      "FR0000988040",
      "JP3942400007",
      "NL0000009165",
      "CA135087J984"
    ],
    "negativeContentExamples": [
      "us0004026250",
      "US000402625X",
      "U50004026250",
      "US000402625",
      "US00040262500",
      "US00-4026250",
      "US00040262 50",
      "XS12345678_90"
    ],
    "positiveHeaderExamples": [
      "isin",
      "isin_code",
      "security_identifier_isin",
      "instrument_isin",
      "primary_isin",
      "global_isin",
      "issuer_isin",
      "security_isin_code"
    ],
    "negativeHeaderExamples": [
      "security_identifier",
      "instrument_code",
      "cusip",
      "sedol",
      "isin_flag",
      "isin_count",
      "instrument_id",
      "isin_issue_date"
    ],
    "explanation": "This semantic type detects International Securities Identification Numbers (ISINs), which are 12-character codes: a two-letter country code, nine alphanumeric characters, and a final numeric check digit. It is useful for identifying and validating security identifiers in financial datasets where instruments are referenced by their global standard codes.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:39:57.647394"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.UPC",
    "description": "Product Code: twelve-digit North American barcode. Identifies 12-digit UPC-A product identifiers consisting only of digits, typically printed beneath retail barcodes. Includes the check digit position, though validation of the check digit is beyond the regex pattern.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{12}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4110,
    "headerPatterns": [
      {
        "regExp": "(?i).*(product|item).*(upc|barcode).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "product_upc_code"
        ],
        "negativeExamples": [
          "upc"
        ]
      },
      {
        "regExp": "(?i).*upc.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "upc_code"
        ],
        "negativeExamples": [
          "barcode"
        ]
      },
      {
        "regExp": "(?i).*(gtin[-_ ]?12).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gtin12"
        ],
        "negativeExamples": [
          "gtin14"
        ]
      },
      {
        "regExp": "(?i).*upc.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "upc"
        ],
        "negativeExamples": [
          "serial_number"
        ]
      },
      {
        "regExp": "(?i).*barcode.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "item_barcode"
        ],
        "negativeExamples": [
          "id"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "012345678905",
      "036000291452",
      "042100005264",
      "639382000393",
      "725272730706",
      "049000042915",
      "073366118238",
      "681131180000"
    ],
    "negativeContentExamples": [
      "12345678901",
      "1234567890123",
      "12345678901A",
      "A123456789012",
      "12345-678901",
      "12345 678901",
      "0001234567890",
      "1234567890"
    ],
    "positiveHeaderExamples": [
      "product_upc_code",
      "upc_code",
      "upc",
      "gtin12",
      "item_barcode",
      "retail_upc",
      "primary_barcode",
      "upc_number"
    ],
    "negativeHeaderExamples": [
      "ean",
      "isbn",
      "serial_number",
      "lot_number",
      "sku",
      "product_id",
      "tracking_number",
      "imei"
    ],
    "explanation": "This type targets UPC-A values: exactly 12 numeric digits bounded by word boundaries, suitable for retail product identification and barcode fields. Use when the column holds UPC codes without separators or spaces; header cues like upc, gtin12, and barcode increase confidence. Check digit logic is implied by the category but not enforced by the regex.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:07.153888"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.SEDOL",
    "description": "UK Security Code: seven-character London exchange identifier",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9BCDFGHJKLMNPQRSTVWXYZ]{6}[0-9]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4100,
    "headerPatterns": [
      {
        "regExp": "(?i).*sedol.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "instrument_sedol_code"
        ],
        "negativeExamples": [
          "sedol_status"
        ]
      },
      {
        "regExp": "(?i).*london.*exchange.*sedol.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "london_exchange_sedol"
        ],
        "negativeExamples": [
          "london_stock_ticker"
        ]
      },
      {
        "regExp": "(?i).*(uk|london).*security.*(identifier|id|code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "uk_security_identifier"
        ],
        "negativeExamples": [
          "security_identifier"
        ]
      },
      {
        "regExp": "(?i).*sedol.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "sedol"
        ],
        "negativeExamples": [
          "isin"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "security_code"
        ],
        "negativeExamples": [
          "security_id"
        ]
      }
    ],
    "positiveContentExamples": [
      "B0YBKJ7",
      "0263494",
      "Z9T7WQ2",
      "4M7N9P5",
      "H7L3RZ1",
      "K3S8TY0",
      "1B3G5H9",
      "C5R2LQ8"
    ],
    "negativeContentExamples": [
      "B0ABKJ7",
      "b0ybkj7",
      "026349X",
      "H7L3RZ",
      "4M-79P5",
      "1B3G5H9A",
      "QWERTY1",
      "Z9T7WQ22"
    ],
    "positiveHeaderExamples": [
      "sedol_code",
      "uk_security_identifier",
      "london_exchange_sedol",
      "security_id_sedol",
      "sedol",
      "instrument_sedol_code",
      "security_code",
      "uk_security_code"
    ],
    "negativeHeaderExamples": [
      "isin_code",
      "cusip",
      "ric",
      "ticker",
      "isin",
      "upc_code",
      "national_id_code",
      "passport_number"
    ],
    "explanation": "SEDOL is a seven-character UK security identifier used primarily on the London Stock Exchange. It consists of six alphanumeric characters (letters typically exclude vowels) followed by a numeric check digit. This regex enforces the structural shape and allowed character set but does not validate the check digit algorithm; checksum validation can be performed downstream if required.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:07.275516"
  },
  {
    "resultType": "generated",
    "semanticType": "COLOR.TEXT_EN",
    "description": "Color Name: descriptive hue terminology",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b((light|dark|pale|deep|bright|soft|rich|pastel|neon|vivid|dull|warm|cool|medium|off)[ -])?(red|blue|green|yellow|orange|purple|violet|indigo|black|white|gr[ae]y|brown|pink|cyan|magenta|maroon|navy|teal|olive|lime|beige|tan|gold|silver|bronze|lavender|ivory|coral|peach|mint|turquoise|aqua|aquamarine|burgundy|charcoal|mustard|salmon|plum|khaki|cream|crimson|scarlet|fuchsia)([ -](red|blue|green|yellow|orange|purple|violet|indigo|black|white|gr[ae]y|brown|pink|cyan|magenta|maroon|navy|teal|olive|lime|beige|tan|gold|silver|bronze|lavender|ivory|coral|peach|mint|turquoise|aqua|aquamarine|burgundy|charcoal|mustard|salmon|plum|khaki|cream|crimson|scarlet|fuchsia))?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 4140,
    "headerPatterns": [
      {
        "regExp": "(?i).*colo[u]?r[_ ]?(name|text)[_ ]?en.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "color_text_en"
        ],
        "negativeExamples": [
          "color_code"
        ]
      },
      {
        "regExp": "(?i).*colo[u]?r.*(name|text).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "colour name"
        ],
        "negativeExamples": [
          "favorite color"
        ]
      },
      {
        "regExp": "(?i).*(clr|color|colour)[_ ]?(nm|name|txt|text).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "clr_nm"
        ],
        "negativeExamples": [
          "clr_code"
        ]
      },
      {
        "regExp": "(?i).*hue.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "hue name"
        ],
        "negativeExamples": [
          "hue value"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "value"
        ]
      }
    ],
    "positiveContentExamples": [
      "Red",
      "light blue",
      "dark teal",
      "blue-green",
      "pale yellow",
      "bright magenta",
      "charcoal",
      "off white"
    ],
    "negativeContentExamples": [
      "sky blue",
      "bluish",
      "light-blue42",
      "red/blue",
      "midnight blue",
      "#FF0000",
      "rgb(0,128,0)",
      "beige."
    ],
    "positiveHeaderExamples": [
      "color_text_en",
      "colour name",
      "clr_nm",
      "color name en",
      "color text",
      "hue name",
      "paint color name",
      "product color name"
    ],
    "negativeHeaderExamples": [
      "color_code",
      "favorite color",
      "hex color",
      "rgb_value",
      "shade_id",
      "texture",
      "material",
      "paint finish"
    ],
    "explanation": "This semantic type identifies English color names expressed as descriptive hue terms, optionally with a single modifier such as light or dark, and allows simple hyphenated or two-tone combinations (e.g., blue-green). It excludes numeric/hex/RGB specifications, abbreviations, and multi-word poetic names outside the allowed modifier and base color lists.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:08.227739"
  },
  {
    "resultType": "generated",
    "semanticType": "FILENAME_EXT",
    "description": "file_suffix: period-prefixed format indicator. Identifies standalone file extension tokens beginning with a dot and followed by 2\u20138 alphanumeric characters, optionally with one additional dot-delimited segment.",
    "pluginType": "regex",
    "regexPattern": "\\b\\.[A-Za-z0-9]{2,8}(\\.[A-Za-z0-9]{2,8})?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4460,
    "headerPatterns": [
      {
        "regExp": "(?i).*(filename|file).*extension.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "filename_extension"
        ],
        "negativeExamples": [
          "file_name"
        ]
      },
      {
        "regExp": "(?i).*(document|attachment).*ext.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "attachment_ext"
        ],
        "negativeExamples": [
          "external_id"
        ]
      },
      {
        "regExp": "(?i).*file.*suffix.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "file_suffix"
        ],
        "negativeExamples": [
          "filename"
        ]
      },
      {
        "regExp": "(?i).*(format|mime).*extension.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "format_extension"
        ],
        "negativeExamples": [
          "mime_type"
        ]
      },
      {
        "regExp": "(?i).*extension.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "extension"
        ],
        "negativeExamples": [
          "version"
        ]
      }
    ],
    "positiveContentExamples": [
      ".pdf",
      ".docx",
      ".xlsx",
      ".pptx",
      ".jpeg",
      ".png",
      ".tar.gz",
      ".js.map"
    ],
    "negativeContentExamples": [
      "pdf",
      ".c",
      ".tar..gz",
      ".tar.gz.zip",
      "docx.",
      "..",
      ".mp-3",
      ".7"
    ],
    "positiveHeaderExamples": [
      "filename_extension",
      "file_extension",
      "file_ext",
      "document_extension",
      "attachment_ext",
      "format_extension",
      "file_suffix",
      "extension"
    ],
    "negativeHeaderExamples": [
      "external_id",
      "file_name",
      "mime_type",
      "filename",
      "content_type",
      "path_suffix",
      "url_parameter",
      "identifier"
    ],
    "explanation": "This semantic type detects standalone file extensions such as .pdf, .docx, or compound forms like .tar.gz, ensuring a leading dot and tightly bounded alphanumeric segments. It is useful for columns that store just the extension value extracted from filenames or content metadata.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:09.309525"
  },
  {
    "resultType": "generated",
    "semanticType": "AIRLINE.IATA_CODE",
    "description": "Two-letter airline code used to identify an air carrier. Values are exactly two uppercase A\u2013Z letters with no digits, spaces, or punctuation.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4000,
    "headerPatterns": [
      {
        "regExp": "(?i).*airline.*iata.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "airline_iata_code"
        ],
        "negativeExamples": [
          "airport_iata_code"
        ]
      },
      {
        "regExp": "(?i).*carrier.*iata.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "carrier_iata_code"
        ],
        "negativeExamples": [
          "airline_icao_code"
        ]
      },
      {
        "regExp": "(?i).*airline.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "airline_code"
        ],
        "negativeExamples": [
          "airline_name"
        ]
      },
      {
        "regExp": "(?i).*iata.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iata_code"
        ],
        "negativeExamples": [
          "icao_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "AA",
      "DL",
      "BA",
      "QF",
      "LH",
      "AF",
      "UA",
      "WN"
    ],
    "negativeContentExamples": [
      "A1",
      "aa",
      "AAA",
      "QF1",
      "U",
      "UA-",
      "1A",
      "A A"
    ],
    "positiveHeaderExamples": [
      "airline_iata_code",
      "carrier_iata_code",
      "iata_airline_code",
      "air_carrier_iata_code",
      "airline_code",
      "iata_code",
      "carrier_code",
      "airline_2_letter_code"
    ],
    "negativeHeaderExamples": [
      "airport_iata_code",
      "airline_icao_code",
      "carrier_id",
      "airline_name",
      "iata_number",
      "air_carrier_icao",
      "airport_code",
      "code_type"
    ],
    "explanation": "This semantic type identifies two-letter IATA airline codes, constrained to exactly two uppercase letters to avoid matching other identifiers. It is useful for validating and classifying carrier identifiers in flight schedules, booking data, and transportation datasets where airline codes are recorded.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:10.661095"
  },
  {
    "resultType": "generated",
    "semanticType": "CONTINENT.CODE_EN",
    "description": "Regional Code: two-letter continental abbreviation",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AF",
      "EU",
      "AS",
      "NA",
      "SA",
      "OC",
      "AN"
    ],
    "backout": "^[A-Z]{2}$",
    "confidenceThreshold": 98,
    "priority": 4180,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bcontinent\\b.*\\bcode\\b.*\\ben\\b.*",
        "confidence": 99,
        "mandatory": true,
        "positiveExamples": [
          "continent_code_en"
        ],
        "negativeExamples": [
          "continent_code_fr"
        ]
      },
      {
        "regExp": "(?i).*\\bcontinent\\b.*\\bcode\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "continent_code"
        ],
        "negativeExamples": [
          "country_code"
        ]
      },
      {
        "regExp": "(?i).*\\bcontinental\\b.*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "continental_code_en"
        ],
        "negativeExamples": [
          "continent_id"
        ]
      },
      {
        "regExp": "(?i).*\\bcont\\b.*\\bcode\\b.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "cont_code"
        ],
        "negativeExamples": [
          "content_code"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "AF",
      "EU",
      "AS",
      "NA",
      "SA",
      "OC",
      "AN"
    ],
    "negativeContentExamples": [
      "AU",
      "EU1",
      "N A",
      "SAH",
      "AF-",
      "as",
      "NA/EU",
      "ANT"
    ],
    "positiveHeaderExamples": [
      "continent_code_en",
      "continental_code_en",
      "continent code en",
      "continent_code",
      "cont_code",
      "cont_cd",
      "continent code"
    ],
    "negativeHeaderExamples": [
      "continent_code_fr",
      "country_code",
      "content_code",
      "continent_id",
      "code_type",
      "region_code",
      "language_code"
    ],
    "explanation": "This semantic type identifies two-letter English abbreviations for continents. It is a finite, well-defined set suitable for strict validation and normalization in datasets where continent codes are required.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:12.464348"
  },
  {
    "resultType": "generated",
    "semanticType": "AIRPORT_CODE.IATA",
    "description": "Airport ID: three-letter destination code identifying an airport using the IATA standard. Values are exactly three uppercase alphabetic characters and are commonly used for routing, ticketing, and baggage handling.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4020,
    "headerPatterns": [
      {
        "regExp": "(?i).*destination.*airport.*iata.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "destination_airport_iata_code"
        ],
        "negativeExamples": [
          "destination_airport_name"
        ]
      },
      {
        "regExp": "(?i).*(origin|departure|arrival).*airport.*iata.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "origin_airport_iata_code"
        ],
        "negativeExamples": [
          "arrival_gate_code"
        ]
      },
      {
        "regExp": "(?i).*airport.*iata.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "airport_iata_code"
        ],
        "negativeExamples": [
          "airport_icao_code"
        ]
      },
      {
        "regExp": "(?i).*(orig|dest).*iata.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "dest_iata"
        ],
        "negativeExamples": [
          "dest_airport"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "airport_name"
        ]
      }
    ],
    "positiveContentExamples": [
      "LAX",
      "JFK",
      "CDG",
      "HND",
      "SYD",
      "DXB",
      "SFO",
      "ORD"
    ],
    "negativeContentExamples": [
      "LAX1",
      "LA-X",
      "J F K",
      "SFOO",
      "SF",
      "123",
      "laX",
      "L\u00c4X"
    ],
    "positiveHeaderExamples": [
      "destination_airport_iata_code",
      "arrival_iata_code",
      "origin_airport_iata_code",
      "airport_iata",
      "dest_iata",
      "iata",
      "iata_code",
      "airport_code_iata"
    ],
    "negativeHeaderExamples": [
      "airport_name",
      "icao_code",
      "country_code",
      "zip_code",
      "arrival_gate_code",
      "dest_airport",
      "iata_name",
      "flight_number"
    ],
    "explanation": "This semantic type recognizes IATA airport codes, which are three-letter uppercase alphabetic identifiers assigned to airports. It is useful for parsing and validating destination/origin fields, mapping routes, and enriching transportation datasets with airport metadata.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:13.195849"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.CUSIP",
    "description": "Security Code: nine-character alphanumeric identifier for a financial instrument where the ninth character is a numeric check digit.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z0-9]{8}[0-9]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4040,
    "headerPatterns": [
      {
        "regExp": "(?i).*cusip[_ ]?(number|no|id|code).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "cusip_number"
        ],
        "negativeExamples": [
          "cusip_issue"
        ]
      },
      {
        "regExp": "(?i).*(security|instrument).*cusip.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "security_cusip"
        ],
        "negativeExamples": [
          "security_code"
        ]
      },
      {
        "regExp": "(?i).*cusip.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cusip"
        ],
        "negativeExamples": [
          "isin"
        ]
      },
      {
        "regExp": "(?i).*(security|instrument).*\\bid\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "security_id"
        ],
        "negativeExamples": [
          "security identifier"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "38259P508",
      "459200101",
      "17275R102",
      "594918104",
      "037833100",
      "19260Q107",
      "172967424",
      "G1151C101"
    ],
    "negativeContentExamples": [
      "03783310X",
      "03783310",
      "0378331001",
      "0378-33100",
      "0378331 00",
      "ab7833100",
      "G1151C10X",
      "12345678X"
    ],
    "positiveHeaderExamples": [
      "cusip",
      "cusip_number",
      "cusip id",
      "security_cusip",
      "instrument cusip",
      "cusip code",
      "cusip9",
      "issuer cusip"
    ],
    "negativeHeaderExamples": [
      "isin",
      "sedol",
      "security_code",
      "security identifier",
      "ticker",
      "account_code",
      "id",
      "reference_number"
    ],
    "explanation": "CUSIP is a nine-character security identifier with a numeric check digit in the ninth position. The regex enforces exactly eight uppercase alphanumeric characters followed by a single digit to avoid overbroad matches. Header patterns progress from explicit CUSIP labels to broader code-related terms, with the primitive pattern ensuring alignment to 'code' terminology while content validation provides precision.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:15.661166"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.LUHN",
    "description": "Payment Card: digit sequence with validation checksum. Targets primary account numbers (PAN) typically 15, 16, or 19 digits, optionally grouped by spaces or hyphens in common formats (4-4-4-4 or 4-6-5).",
    "pluginType": "regex",
    "regexPattern": "\\b(\\d{16}|\\d{15}|\\d{19}|\\d{4}[ -]\\d{4}[ -]\\d{4}[ -]\\d{4}|\\d{4}[ -]\\d{6}[ -]\\d{5})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4090,
    "headerPatterns": [
      {
        "regExp": "(?i).*(credit|debit|payment).*card.*(number|no|num|pan).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "credit_card_number"
        ],
        "negativeExamples": [
          "cardholder_name"
        ]
      },
      {
        "regExp": "(?i).*primary.*account.*number.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "primary_account_number"
        ],
        "negativeExamples": [
          "account_number"
        ]
      },
      {
        "regExp": "(?i).*(card|cc).*(_)?(number|no|num).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cc_number"
        ],
        "negativeExamples": [
          "card_type"
        ]
      },
      {
        "regExp": "(?i).*(card|acct).*pan.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "card_pan"
        ],
        "negativeExamples": [
          "pantry_code"
        ]
      },
      {
        "regExp": "(?i).*(number|num).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "4111 1111 1111 1111",
      "5555-3412-3456-7890",
      "4532756279624064",
      "378282246310005",
      "3712 345678 90123",
      "6011000990139424099",
      "2223003122003222",
      "4000-0000-0000-0002"
    ],
    "negativeContentExamples": [
      "4111 1111 1111 111",
      "41111111111111",
      "3782 8224631 0005",
      "5555-3412-3456-789O",
      "4111.1111.1111.1111",
      "1234-5678-9012-345-6",
      "550000000000000000",
      "3400 000000 0000"
    ],
    "positiveHeaderExamples": [
      "credit_card_number",
      "card_number",
      "cc_number",
      "primary_account_number",
      "card_pan",
      "payment_card_no",
      "pan",
      "cardnum"
    ],
    "negativeHeaderExamples": [
      "cardholder_name",
      "card_type",
      "account_number",
      "iban",
      "routing_number",
      "transaction_id",
      "authorization_code",
      "security_code"
    ],
    "explanation": "Identifies digit-only payment card primary account numbers (PAN) that are either contiguous (15, 16, or 19 digits) or grouped with spaces/hyphens in standard formats (4-4-4-4 or 4-6-5). Suitable for detecting card numbers for validation, redaction, or compliance workflows where a Luhn checksum is expected.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:17.319025"
  },
  {
    "resultType": "generated",
    "semanticType": "DIRECTION",
    "description": "Compass bearing expressed as primary navigational orientation using cardinal or intercardinal directions (e.g., N, NE, NORTH, SOUTHWEST). Accepts standard abbreviations and full words with optional space or hyphen between components.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(N|NE|E|SE|S|SW|W|NW|NORTH|EAST|SOUTH|WEST|NORTH[- ]EAST|SOUTH[- ]EAST|SOUTH[- ]WEST|NORTH[- ]WEST|NORTHEAST|SOUTHEAST|SOUTHWEST|NORTHWEST)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4410,
    "headerPatterns": [
      {
        "regExp": "(?i).*compass.*bearing.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "compass_bearing"
        ],
        "negativeExamples": [
          "compass_distance"
        ]
      },
      {
        "regExp": "(?i).*(cardinal|intercardinal).*(direction|dir).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cardinal_direction"
        ],
        "negativeExamples": [
          "cardinal_number"
        ]
      },
      {
        "regExp": "(?i).*wind.*direction.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "wind_direction"
        ],
        "negativeExamples": [
          "wind_speed"
        ]
      },
      {
        "regExp": "(?i).*compass.*dir.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "compass_dir"
        ],
        "negativeExamples": [
          "file_dir"
        ]
      },
      {
        "regExp": "(?i).*direction.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "direction"
        ],
        "negativeExamples": [
          "orientation"
        ]
      }
    ],
    "positiveContentExamples": [
      "N",
      "NE",
      "S",
      "NW",
      "NORTH",
      "SOUTHWEST",
      "NORTH-EAST",
      "SOUTH WEST"
    ],
    "negativeContentExamples": [
      "ENE",
      "NNE",
      "WNW",
      "ESE",
      "EASTWARD",
      "NORTHEASTERLY",
      "90\u00b0",
      "N-E"
    ],
    "positiveHeaderExamples": [
      "compass_bearing",
      "cardinal_direction",
      "wind_direction",
      "primary_dir",
      "navigation_direction",
      "compass_dir"
    ],
    "negativeHeaderExamples": [
      "compass_distance",
      "cardinal_number",
      "wind_speed",
      "file_dir",
      "bearing_degrees",
      "orientation"
    ],
    "explanation": "This semantic type identifies textual compass directions representing primary navigational orientation (cardinal and intercardinal), including common abbreviations and full-word forms with optional space or hyphen separators. It is useful for datasets describing bearings or headings in words rather than numeric degrees.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:19.074494"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.LONGITUDE_DMS",
    "description": "Longitude DMS: traditional degree-minute-second coordinates",
    "pluginType": "regex",
    "regexPattern": "\\b(([EW]\\s*(180|1[0-7][0-9]|[1-9]?[0-9])\\s*\u00b0\\s*([0-5]?[0-9])\\s*['\u2019]\\s*([0-5]?[0-9](\\.[0-9]+)?)\\s*[\"\u201d])|((180|1[0-7][0-9]|[1-9]?[0-9])\\s*\u00b0\\s*([0-5]?[0-9])\\s*['\u2019]\\s*([0-5]?[0-9](\\.[0-9]+)?)\\s*[\"\u201d]\\s*[EW]))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4240,
    "headerPatterns": [
      {
        "regExp": "(?i).*(longitude|long|lon|lng)[_\\- ]*dms.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "longitude_dms"
        ],
        "negativeExamples": [
          "longitude_decimal"
        ]
      },
      {
        "regExp": "(?i).*longitude.*(deg|min|sec|dms).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "longitude_deg_min_sec"
        ],
        "negativeExamples": [
          "latitude_deg_min_sec"
        ]
      },
      {
        "regExp": "(?i).*(lon|lng)[_\\- ]*(deg|min|sec|dms).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lng_dms"
        ],
        "negativeExamples": [
          "lat_dms"
        ]
      },
      {
        "regExp": "(?i).*(longitude|lon|lng).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "map_longitude"
        ],
        "negativeExamples": [
          "coordinate_latitude"
        ]
      },
      {
        "regExp": "(?i).*coordinate.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "coordinate"
        ],
        "negativeExamples": [
          "location"
        ]
      }
    ],
    "positiveContentExamples": [
      "73\u00b0 59' 8\" W",
      "0\u00b0 0' 0\" E",
      "123\u00b0 12' 30.5\" E",
      "W 45\u00b0 30' 15\"",
      "179\u00b0 59' 59.9\" W",
      "E 180\u00b0 0' 0\"",
      "10\u00b0 5' 0\" W",
      "100\u00b0 00' 59\" E"
    ],
    "negativeContentExamples": [
      "181\u00b0 0' 0\" E",
      "45\u00b0 60' 0\" W",
      "45\u00b0 59' 60\" E",
      "45\u00b0 30' 15\" N",
      "45\u00b0 30' W",
      "45\u00b0 30' 15\"",
      "45 30' 15\" E",
      "100\u00b0 -5' 20\" W"
    ],
    "positiveHeaderExamples": [
      "longitude_dms",
      "lon_dms",
      "longitude_deg_min_sec",
      "lon_degminsec",
      "lng_dms",
      "map_longitude",
      "geo_longitude_dms",
      "coordinate_longitude_dms"
    ],
    "negativeHeaderExamples": [
      "latitude_dms",
      "longitude_decimal",
      "lat_lon_dms",
      "bearing_dms",
      "coord_dms",
      "latitude",
      "lat_deg_min_sec",
      "east_west"
    ],
    "explanation": "This semantic type detects longitude values expressed in Degrees-Minutes-Seconds notation with an explicit E or W direction, either prefixed or suffixed. It enforces valid ranges for degrees (0\u2013180), minutes (0\u201359), and seconds (0\u201359 with optional decimals), and requires the degree, minute, and second symbols.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:19.455893"
  },
  {
    "resultType": "generated",
    "semanticType": "CITY",
    "description": "Location name for a municipality or city-level settlement, represented as a human-readable name (letters with optional spaces, hyphens, and periods). Intended for values like New York, Los Angeles, or Ho Chi Minh City that denote a municipal area.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Za-z]{2,}\\.|[A-Za-z]{2,}|[A-Za-z]\\.)([-' ]([A-Za-z]{2,}\\.|[A-Za-z]{2,}|[A-Za-z]\\.)){0,4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4120,
    "headerPatterns": [
      {
        "regExp": "(?i).*(shipping|billing|residential|mailing|home|office).*city.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "shipping_city"
        ],
        "negativeExamples": [
          "shipping_state"
        ]
      },
      {
        "regExp": "(?i).*(origin|source|from|pickup).*city.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "origin_city"
        ],
        "negativeExamples": [
          "origin_country"
        ]
      },
      {
        "regExp": "(?i).*(destination|dest|arrival|to|dropoff).*city.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "destination_city"
        ],
        "negativeExamples": [
          "destination_state"
        ]
      },
      {
        "regExp": "(?i).*(address|location|place).*city.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "address_city"
        ],
        "negativeExamples": [
          "address_line2"
        ]
      },
      {
        "regExp": "(?i).*(addr|loc|orig|src|dest).*cty.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "dest_cty"
        ],
        "negativeExamples": [
          "dest_code"
        ]
      },
      {
        "regExp": "(?i).*city.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "city"
        ],
        "negativeExamples": [
          "county"
        ]
      }
    ],
    "positiveContentExamples": [
      "New York",
      "Los Angeles",
      "St. Louis",
      "San Jose",
      "Mexico City",
      "Aix-en-Provence",
      "Ho Chi Minh City",
      "Quebec City"
    ],
    "negativeContentExamples": [
      "New York, NY",
      "Los Angeles 90012",
      "San Jose-95112",
      "Paris-13",
      "Berlin/Germany",
      "Mexico City, DF",
      "St. Louis, MO",
      "Phoenix AZ 85004"
    ],
    "positiveHeaderExamples": [
      "shipping_city",
      "billing_city",
      "origin_city",
      "destination_city",
      "residence_city",
      "customer_city",
      "home_city",
      "city"
    ],
    "negativeHeaderExamples": [
      "shipping_state",
      "origin_country",
      "destination_town",
      "customer_county",
      "city_code",
      "timezone",
      "postal_code",
      "location_name"
    ],
    "explanation": "This semantic type identifies city or municipality names as free-text location values consisting of alphabetic tokens, possibly including spaces, hyphens, or periods (e.g., St. Louis, Aix-en-Provence). It is useful for classifying columns that store the city component of a postal address, trip endpoints, or customer residence locations. The regex is intentionally conservative to avoid numeric codes and compound address strings with punctuation like commas or slashes.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:20.273307"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.NORTHING",
    "description": "Y Coordinate: northward distance measurement",
    "pluginType": "regex",
    "regexPattern": "\\b(northing|y|n)\\s*[:=]?\\s*(\\d{1,3}([ ,]\\d{3})+|\\d{4,8})([.,]\\d{1,3})?\\s*(m|meter|meters)?\\b|\\b(\\d{1,3}([ ,]\\d{3})+|\\d{4,8})([.,]\\d{1,3})?\\s*(m|meter|meters)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4250,
    "headerPatterns": [
      {
        "regExp": "(?i).*y[\\s_-]*coordinate[\\s_-]*(meters|metres|m).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "y_coordinate_meters"
        ],
        "negativeExamples": [
          "x_coordinate_meters"
        ]
      },
      {
        "regExp": "(?i).*(northing)[\\s_-]*(meters|metres|m).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "northing_m"
        ],
        "negativeExamples": [
          "easting_m"
        ]
      },
      {
        "regExp": "(?i).*(y[\\s_-]*northing|northing).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "y northing"
        ],
        "negativeExamples": [
          "x easting"
        ]
      },
      {
        "regExp": "(?i).*(y[\\s_-]*coord|y[\\s_-]*axis|y).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "y_coord"
        ],
        "negativeExamples": [
          "x_axis"
        ]
      },
      {
        "regExp": "(?i).*coordinate.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "coordinate_y"
        ],
        "negativeExamples": [
          "code_value"
        ]
      }
    ],
    "positiveContentExamples": [
      "Y: 4465123",
      "northing 4,465,123",
      "northing: 4465123.5 m",
      "y=7645321",
      "N: 0034567 m",
      "7,654,321 m",
      "8456123 meters"
    ],
    "negativeContentExamples": [
      "easting: 4465123",
      "x=4465123",
      "north 4465123",
      "y: -4465123",
      "44.65123 m",
      "4.465.123 m",
      "4,465,12 m"
    ],
    "positiveHeaderExamples": [
      "y_coordinate_meters",
      "northing",
      "y_coord",
      "y northing",
      "northing_m",
      "y_axis_meters",
      "coordinate_y"
    ],
    "negativeHeaderExamples": [
      "easting",
      "x_coordinate",
      "latitude",
      "longitude",
      "grid_zone",
      "y_value",
      "row_number"
    ],
    "explanation": "Identifies northing values representing the Y-axis distance in projected coordinate systems, typically expressed in meters. The pattern favors labeled values (northing/y) and values with metric units, and supports common thousand separators and limited decimal precision for realistic measurement formats.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:22.685354"
  },
  {
    "resultType": "generated",
    "semanticType": "CONTINENT.TEXT_EN",
    "description": "Continental Region: major landmass designation",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AFRICA",
      "ANTARCTICA",
      "ASIA",
      "EUROPE",
      "NORTH AMERICA",
      "SOUTH AMERICA",
      "OCEANIA",
      "AUSTRALIA"
    ],
    "backout": "^[A-Z]+( [A-Z]+){0,2}$",
    "confidenceThreshold": 98,
    "priority": 4190,
    "headerPatterns": [
      {
        "regExp": "(?i).*continent.*text.*en.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "continent_text_en"
        ],
        "negativeExamples": [
          "continent_code"
        ]
      },
      {
        "regExp": "(?i).*(continent.*name|continent.*label|continent.*text).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "continent_name"
        ],
        "negativeExamples": [
          "country_name"
        ]
      },
      {
        "regExp": "(?i).*(geo|geography).*continent.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "geography_continent"
        ],
        "negativeExamples": [
          "geography_region"
        ]
      },
      {
        "regExp": "(?i).*cont.*name.*",
        "confidence": 91,
        "mandatory": true,
        "positiveExamples": [
          "cont_name"
        ],
        "negativeExamples": [
          "company_name"
        ]
      },
      {
        "regExp": "(?i).*continent.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "continent"
        ],
        "negativeExamples": [
          "region"
        ]
      }
    ],
    "positiveContentExamples": [
      "AFRICA",
      "ANTARCTICA",
      "ASIA",
      "EUROPE",
      "NORTH AMERICA",
      "SOUTH AMERICA",
      "OCEANIA",
      "AUSTRALIA"
    ],
    "negativeContentExamples": [
      "AMERICAS",
      "CENTRAL AMERICA",
      "EUROPEAN",
      "ASIA PACIFIC",
      "MIDDLE EAST",
      "NORTH-AMERICA",
      "SOUTHERN AFRICA",
      "EURASIA"
    ],
    "positiveHeaderExamples": [
      "continent_text_en",
      "continent_name",
      "continent_label",
      "geography_continent",
      "home_continent",
      "billing_continent",
      "cont_name",
      "customer_continent"
    ],
    "negativeHeaderExamples": [
      "continent_code",
      "region",
      "country_name",
      "timezone",
      "state_province",
      "hemisphere",
      "language",
      "area_code"
    ],
    "explanation": "This semantic type identifies continent names written in English text form (e.g., AFRICA, NORTH AMERICA). Use it for fields storing human-readable continent labels rather than codes or numeric identifiers. It is suitable for validation and standardization of continent label columns and for mapping to regional aggregations.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:24.424545"
  },
  {
    "resultType": "generated",
    "semanticType": "DAY.ABBR_<LOCALE>",
    "description": "weekday_short: 3-letter locale-specific day abbreviation for English (Mon\u2013Sun as three-letter forms). Use this for fields storing standardized 3-letter weekday abbreviations.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "MON",
      "TUE",
      "WED",
      "THU",
      "FRI",
      "SAT",
      "SUN"
    ],
    "backout": "^[A-Z]{3}$",
    "confidenceThreshold": 98,
    "priority": 4380,
    "headerPatterns": [
      {
        "regExp": "(?i).*(weekday|wkday)[-_ ]?(abbr|abbrev|short).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "weekday_abbr"
        ],
        "negativeExamples": [
          "billing_week"
        ]
      },
      {
        "regExp": "(?i).*(day[_-]?of[_-]?week).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "day_of_week"
        ],
        "negativeExamples": [
          "work_week"
        ]
      },
      {
        "regExp": "(?i).*(wkday).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "wkday"
        ],
        "negativeExamples": [
          "workday_count"
        ]
      },
      {
        "regExp": "(?i).*(dow).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "dow"
        ],
        "negativeExamples": [
          "week_index"
        ]
      },
      {
        "regExp": "(?i).*day.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "day"
        ],
        "negativeExamples": [
          "date"
        ]
      }
    ],
    "positiveContentExamples": [
      "MON",
      "TUE",
      "WED",
      "THU",
      "FRI",
      "SAT",
      "SUN"
    ],
    "negativeContentExamples": [
      "Mon",
      "MONDAY",
      "MON.",
      "THUR",
      "WEDS",
      "FRI1",
      "SAT-",
      "SUN_"
    ],
    "positiveHeaderExamples": [
      "weekday_abbr",
      "weekday_short",
      "day_of_week",
      "dow",
      "wkday",
      "weekday_abbrev",
      "dow_code"
    ],
    "negativeHeaderExamples": [
      "bill_date",
      "download_count",
      "week_index",
      "calendar_month",
      "shift_name",
      "iso_week",
      "business_hours"
    ],
    "explanation": "This semantic type identifies English three-letter weekday abbreviations. It is useful for normalizing and validating fields that store concise weekday codes, enabling consistent parsing and aggregation by day of week across datasets.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:24.761767"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.TEXT_ES",
    "description": "nombre_pa\u00eds: designaci\u00f3n nacional en idioma espa\u00f1ol",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "ESPA\u00d1A",
      "M\u00c9XICO",
      "ARGENTINA",
      "COLOMBIA",
      "CHILE",
      "PER\u00da",
      "BOLIVIA",
      "PARAGUAY",
      "URUGUAY",
      "VENEZUELA",
      "ECUADOR",
      "GUATEMALA",
      "HONDURAS",
      "EL SALVADOR",
      "NICARAGUA",
      "COSTA RICA",
      "PANAM\u00c1",
      "CUBA",
      "REP\u00daBLICA DOMINICANA",
      "ESTADOS UNIDOS",
      "REINO UNIDO",
      "FRANCIA",
      "ALEMANIA",
      "ITALIA",
      "GUINEA ECUATORIAL"
    ],
    "backout": "^[A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc]+(?:[ -][A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc]+){0,4}$",
    "confidenceThreshold": 98,
    "priority": 4320,
    "headerPatterns": [
      {
        "regExp": "(?i).*(nombre[ _-]?pa[i\u00ed]s|country[ _-]?name)[ _-]?(es|espa[n\u00f1]ol|spanish).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nombre_pais_es"
        ],
        "negativeExamples": [
          "codigo_pais"
        ]
      },
      {
        "regExp": "(?i).*(pa[i\u00ed]s|country)[ _-]?(nombre|name)[ _-]?(es|espa[n\u00f1]ol|spanish).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "country_name_spanish"
        ],
        "negativeExamples": [
          "country_code"
        ]
      },
      {
        "regExp": "(?i).*(nombre|name)[ _-]?(pa[i\u00ed]s|country).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nombre_pais"
        ],
        "negativeExamples": [
          "nombre_estado"
        ]
      },
      {
        "regExp": "(?i).*(ctry|cntry|ctr|pais|pa\u00eds)[ _-]?(nm|nom|nbre|name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ctry_name"
        ],
        "negativeExamples": [
          "region_name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Espa\u00f1a",
      "M\u00e9xico",
      "Argentina",
      "Estados Unidos",
      "Rep\u00fablica Dominicana",
      "Guinea Ecuatorial",
      "Reino Unido",
      "Costa Rica"
    ],
    "negativeContentExamples": [
      "Barcelona",
      "Europeo",
      "Rep\u00fablica",
      "Estados Unido",
      "Dominican Republic",
      "Corea Sur",
      "Costa-Rico",
      "MX"
    ],
    "positiveHeaderExamples": [
      "nombre_pais_es",
      "country_name_es",
      "nombre_pais",
      "pais_nombre",
      "ctry_name",
      "pais",
      "country_name_spanish",
      "nombre_pais_esp"
    ],
    "negativeHeaderExamples": [
      "codigo_pais",
      "country_code",
      "nombre_estado",
      "region",
      "nacionalidad",
      "idioma",
      "pais_id",
      "pais_numero"
    ],
    "explanation": "This semantic type identifies country names expressed in Spanish (texto libre), such as Espa\u00f1a, M\u00e9xico, or Estados Unidos. It is intended for columns that store the textual country name rather than codes or abbreviations. The list provides a representative set of common Spanish country names and the backout regex restricts the general shape to alphabetic words with spaces or hyphens.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:25.149804"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE_PAIR.DECIMAL",
    "description": "GPS Position: comma-separated latitude-longitude pair. Values are decimal degrees with optional leading sign and fractional part, with a comma separator and optional spaces between components.",
    "pluginType": "regex",
    "regexPattern": "\\b[+-]?(90(\\.0+)?|[0-8]?\\d(\\.\\d+)?)\\s*,\\s*[+-]?(180(\\.0+)?|1[0-7]\\d(\\.\\d+)?|[0-9]?\\d(\\.\\d+)?)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4260,
    "headerPatterns": [
      {
        "regExp": "(?i).*(latitude|lat)[ _-]*(longitude|lon).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "latitude_longitude"
        ],
        "negativeExamples": [
          "latitude"
        ]
      },
      {
        "regExp": "(?i).*gps.*(position|coord|coordinates).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gps_position"
        ],
        "negativeExamples": [
          "gps_speed"
        ]
      },
      {
        "regExp": "(?i).*(geo|geographic).*coord.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "geographic_coordinates"
        ],
        "negativeExamples": [
          "geo_code"
        ]
      },
      {
        "regExp": "(?i).*(lat)[ _-]*(long|lng).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lat_lng"
        ],
        "negativeExamples": [
          "lng"
        ]
      },
      {
        "regExp": "(?i).*coord.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "coordinates"
        ],
        "negativeExamples": [
          "location"
        ]
      }
    ],
    "positiveContentExamples": [
      "37.7749, -122.4194",
      "-33.8688, 151.2093",
      "0.0, 0.0",
      "+48.8566, +2.3522",
      "89.9999, -179.9999",
      "-45, 170.5",
      "90, 180",
      "-0.123, 179"
    ],
    "negativeContentExamples": [
      "91.0, -122.0",
      "37.7749 -122.4194",
      "-33.8688; 151.2093",
      "37.7749, -181",
      "100, 50",
      "34.05 N, 118.25 W",
      "85.0, -",
      "-, 120.0"
    ],
    "positiveHeaderExamples": [
      "latitude_longitude",
      "lat_lon",
      "gps_position",
      "geo_coordinates",
      "lat_lng",
      "coordinates",
      "gps_coords",
      "location_coordinates"
    ],
    "negativeHeaderExamples": [
      "latitude",
      "longitude",
      "gps_speed",
      "geo_code",
      "location",
      "postal_code",
      "city",
      "alt"
    ],
    "explanation": "Identifies comma-separated latitude-longitude pairs in decimal degrees. The pattern enforces valid numeric ranges for latitude (-90 to 90) and longitude (-180 to 180), allows optional leading sign and fractional parts, and permits optional spaces around the comma separator. Use this type to detect geospatial point positions represented as decimal degree pairs.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:27.386609"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.ABA",
    "description": "Bank Routing Number: nine-digit institution identifier. This identifies an ABA routing transit number (RTN) formatted as nine contiguous digits with valid Federal Reserve prefix ranges (01\u201312, 21\u201332, 61\u201372, 80). The pattern constrains to 9 digits and valid starting ranges; checksum evaluation is not performed by the regex.",
    "pluginType": "regex",
    "regexPattern": "\\b((0[1-9]|1[0-2]|2[1-9]|3[0-2]|6[1-9]|7[0-2]|80)\\d{7})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4030,
    "headerPatterns": [
      {
        "regExp": "(?i).*aba.*routing.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "aba_routing_number"
        ],
        "negativeExamples": [
          "aba_code"
        ]
      },
      {
        "regExp": "(?i).*routing.*transit.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "routing_transit_number"
        ],
        "negativeExamples": [
          "transit_code"
        ]
      },
      {
        "regExp": "(?i).*bank.*routing.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "bank_routing_number"
        ],
        "negativeExamples": [
          "bank_account_number"
        ]
      },
      {
        "regExp": "(?i).*\\brtn\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "rtn"
        ],
        "negativeExamples": [
          "return_reason"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "021001088",
      "122105278",
      "211370545",
      "321081669",
      "661000124",
      "701000987",
      "801234567",
      "091000019"
    ],
    "negativeContentExamples": [
      "001000015",
      "130000015",
      "331234567",
      "731234567",
      "02100002",
      "0210000219",
      "02-1000021",
      "02100002A"
    ],
    "positiveHeaderExamples": [
      "aba_routing_number",
      "bank_routing_number",
      "routing_transit_number",
      "aba_number",
      "routing_no",
      "wire_routing_number",
      "rtn",
      "number"
    ],
    "negativeHeaderExamples": [
      "account_number",
      "swift_code",
      "iban",
      "transit_code",
      "routing_id",
      "sort_code",
      "return_reason",
      "aba_code"
    ],
    "explanation": "This semantic type targets U.S. ABA routing transit numbers: nine contiguous digits with valid prefix ranges that designate the Federal Reserve routing symbol. Use it to identify and validate the shape of bank routing numbers in payment, ACH, or wire datasets when only format-based verification is available.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:28.052809"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.LONGITUDE_DECIMAL",
    "description": "Geographic Longitude: east-west decimal position in decimal degrees. Accepts optional leading sign and optional fractional part, ranging from -180 to 180 inclusive.",
    "pluginType": "regex",
    "regexPattern": "\\b[+-]?((180(\\.0+)?)|(1[0-7]\\d(\\.\\d+)?)|([0-9]{1,2}(\\.\\d+)?))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 4230,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\blongitude\\b.*\\bdecimal\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "longitude_decimal"
        ],
        "negativeExamples": [
          "latitude_decimal"
        ]
      },
      {
        "regExp": "(?i).*\\bgeo.*\\blongitude\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "geo_longitude"
        ],
        "negativeExamples": [
          "geo_latitude"
        ]
      },
      {
        "regExp": "(?i).*\\blongitude\\b.*\\bdeg\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "longitude_deg"
        ],
        "negativeExamples": [
          "latitude_deg"
        ]
      },
      {
        "regExp": "(?i).*\\blon\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lon"
        ],
        "negativeExamples": [
          "lat"
        ]
      },
      {
        "regExp": "(?i).*\\blng\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lng"
        ],
        "negativeExamples": [
          "lat_dir"
        ]
      },
      {
        "regExp": "(?i).*\\blongitude\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "longitude"
        ],
        "negativeExamples": [
          "latitude"
        ]
      }
    ],
    "positiveContentExamples": [
      "-122.4194",
      "73.9857",
      "+12.5",
      "0",
      "179.9999",
      "180",
      "-0.1278",
      "99.0"
    ],
    "negativeContentExamples": [
      "180.0001",
      "-180.1",
      "-181",
      "200",
      "73.9857 W",
      "E 12.34",
      "12,34",
      "45\u00b012'34\""
    ],
    "positiveHeaderExamples": [
      "longitude_decimal",
      "geo_longitude",
      "longitude_deg",
      "lng",
      "lon",
      "longitude_dd",
      "map_longitude",
      "center_longitude"
    ],
    "negativeHeaderExamples": [
      "latitude",
      "lat",
      "x_coordinate",
      "long_description",
      "geocode_long",
      "east_west",
      "meridian",
      "latitude_decimal"
    ],
    "explanation": "This semantic type identifies decimal degree longitudes, capturing east-west positions on the globe as floating-point numbers between -180 and 180 inclusive. It is useful for validating and profiling geographic coordinates in datasets, especially when paired with a latitude field to form coordinate pairs.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:28.513747"
  },
  {
    "resultType": "generated",
    "semanticType": "FREE_TEXT",
    "description": "Unrestricted narrative or descriptive text intended for human-readable notes, comments, or explanations. Values typically contain multiple words, sentences, and punctuation rather than a fixed code or structured format.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z][A-Za-z\u2019'\u2019-]*\\b(?:[ ]+\\b[A-Za-z0-9][A-Za-z0-9\u2019'\u2019,.\\-()!?:;]*\\b){3,}",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4470,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bfree[_ -]?text\\b.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "free_text"
        ],
        "negativeExamples": [
          "free_shipping"
        ]
      },
      {
        "regExp": "(?i).*\\b(customer|user|case|order|ticket)[_ -]?(notes|comments|description|narrative)\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "customer_notes"
        ],
        "negativeExamples": [
          "customer_id"
        ]
      },
      {
        "regExp": "(?i).*\\b(description|details|remarks|narrative)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "description"
        ],
        "negativeExamples": [
          "summary"
        ]
      },
      {
        "regExp": "(?i).*\\b(notes|comments|message|feedback)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "comments"
        ],
        "negativeExamples": [
          "author"
        ]
      },
      {
        "regExp": "(?i).*\\btext\\b.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "text"
        ],
        "negativeExamples": [
          "context"
        ]
      }
    ],
    "positiveContentExamples": [
      "Please deliver to the back entrance after 5 pm.",
      "Customer reported intermittent connectivity issues throughout the day.",
      "This product exceeds expectations in both build quality and performance.",
      "Notes: rescheduled meeting due to conflicting travel plans.",
      "The applicant provided detailed references and additional documentation.",
      "Directions: take the second left, then continue past the library.",
      "Packaging was damaged on arrival, but the contents remained intact.",
      "Payment will be processed once the invoice discrepancies are resolved."
    ],
    "negativeContentExamples": [
      "Order delayed",
      "Pending review",
      "See attached",
      "Contact support",
      "Shipped on 7/15",
      "john.doe@example.com",
      "ABC-123-XYZ",
      "2024-08-01 10:30"
    ],
    "positiveHeaderExamples": [
      "free_text",
      "free text",
      "notes",
      "comments",
      "description",
      "details",
      "remarks",
      "narrative"
    ],
    "negativeHeaderExamples": [
      "status",
      "code",
      "email",
      "quantity",
      "country",
      "address",
      "subject",
      "title"
    ],
    "explanation": "This semantic type identifies unstructured, multi-word narrative content typically used for comments, notes, or descriptions. The regex requires at least four word-like tokens, favoring human-readable freeform text and reducing false matches with short labels, codes, or structured identifiers. It is intentionally broad but safeguarded with token counts and word boundaries to avoid over-matching structured fields.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:29.747168"
  },
  {
    "resultType": "generated",
    "semanticType": "EPOCH.SECONDS",
    "description": "epoch_seconds: standard Unix timestamp in seconds. Values are numeric strings consisting of 9\u201310 digits representing seconds since 1970-01-01T00:00:00Z.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{9,10}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4440,
    "headerPatterns": [
      {
        "regExp": "(?i).*epoch.*seconds.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "epoch_seconds"
        ],
        "negativeExamples": [
          "epoch_milliseconds"
        ]
      },
      {
        "regExp": "(?i).*unix.*timestamp.*sec.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "unix_timestamp_sec"
        ],
        "negativeExamples": [
          "unix_timestamp_ms"
        ]
      },
      {
        "regExp": "(?i).*timestamp.*seconds.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "timestamp_seconds"
        ],
        "negativeExamples": [
          "timestamp_minutes"
        ]
      },
      {
        "regExp": "(?i).*ts.*sec.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ts_seconds"
        ],
        "negativeExamples": [
          "ts_ms"
        ]
      },
      {
        "regExp": "(?i).*date.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "event_date"
        ],
        "negativeExamples": [
          "event_time"
        ]
      }
    ],
    "positiveContentExamples": [
      "315532800",
      "631152000",
      "915148800",
      "946684800",
      "123456789",
      "1262304000",
      "1609459200",
      "2147483647"
    ],
    "negativeContentExamples": [
      "1609459200000",
      "21474836470",
      "94668480",
      "01609459200",
      "Z1609459200",
      "1609459200Z",
      "T1609459200Z",
      "2021-01-01"
    ],
    "positiveHeaderExamples": [
      "epoch_seconds",
      "unix_timestamp_seconds",
      "ts_seconds",
      "epoch_sec",
      "timestamp_seconds",
      "unix_ts_sec",
      "created_epoch_seconds",
      "record_epoch_sec"
    ],
    "negativeHeaderExamples": [
      "epoch_milliseconds",
      "unix_timestamp_ms",
      "timestamp",
      "event_date",
      "time_seconds",
      "elapsed_seconds",
      "unix_epoch",
      "record_time_ms"
    ],
    "explanation": "This semantic type detects Unix epoch timestamps expressed in whole seconds as 9\u201310 digit numeric strings. It is useful for identifying machine-generated time fields that represent absolute instants without formatting or timezone suffixes.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:30.073119"
  },
  {
    "resultType": "generated",
    "semanticType": "COLOR.TEXT_ES",
    "description": "Nombre de Color: terminolog\u00eda descriptiva de tonos",
    "pluginType": "regex",
    "regexPattern": "\\b(azul|rojo|verde|amarillo|naranja|morado|p\u00farpura|violeta|rosa|rosado|magenta|fucsia|cian|turquesa|marr\u00f3n|marron|caf\u00e9|cafe|beige|negro|blanco|gris|plateado|plata|dorado|oro|\u00e1mbar|ambar|lila|granate|borgo\u00f1a|borgona|ocre|lavanda|salm\u00f3n|salmon|coral)(\\s+(claro|oscuro|pastel|intenso|vivo|medio|marino|oliva|el\u00e9ctrico|electrico|ne\u00f3n|neon|p\u00e1lido|palido|met\u00e1lico|metalico|perla))?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4150,
    "headerPatterns": [
      {
        "regExp": "(?i).*(nombre).*color.*(es|spa|espanol|espa\u00f1ol).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nombre_color_es"
        ],
        "negativeExamples": [
          "color_code"
        ]
      },
      {
        "regExp": "(?i).*(color).*texto.*(es|spa).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "color_texto_es"
        ],
        "negativeExamples": [
          "color_text"
        ]
      },
      {
        "regExp": "(?i).*color.*(nombre|name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "color_nombre"
        ],
        "negativeExamples": [
          "color_rgb"
        ]
      },
      {
        "regExp": "(?i).*(desc|descripcion|descripci\u00f3n).*color.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "descripcion_color"
        ],
        "negativeExamples": [
          "descripcion"
        ]
      },
      {
        "regExp": "(?i).*color.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "color"
        ],
        "negativeExamples": [
          "shade"
        ]
      }
    ],
    "positiveContentExamples": [
      "azul",
      "rojo",
      "verde oliva",
      "azul marino",
      "gris claro",
      "marr\u00f3n oscuro",
      "rosa pastel",
      "dorado"
    ],
    "negativeContentExamples": [
      "blue",
      "roxo",
      "verde-oliva",
      "claro azul",
      "gris claaro",
      "rojo+oscuro",
      "verde oliva claro",
      "#FF5733"
    ],
    "positiveHeaderExamples": [
      "nombre_color_es",
      "color_texto_es",
      "color_nombre",
      "descripcion_color",
      "texto_color",
      "nombre_de_color",
      "etiqueta_color",
      "color_spanish"
    ],
    "negativeHeaderExamples": [
      "hex_code",
      "rgb_value",
      "tono",
      "shade",
      "pigmento",
      "id_tono",
      "fondo",
      "estilo"
    ],
    "explanation": "This semantic type recognizes Spanish color names written as text, optionally followed by a common modifier such as claro, oscuro, marino, u oliva. It targets descriptive tone terminology rather than coded or numeric color representations. Typical use cases include labeling, UI theming fields, catalog descriptions, or dataset columns where colors are expressed in Spanish words.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:30.198972"
  },
  {
    "resultType": "generated",
    "semanticType": "COLOR.HEX",
    "description": "Color Value: hexadecimal RGB representation",
    "pluginType": "regex",
    "regexPattern": "#([0-9A-Fa-f]{6}|[0-9A-Fa-f]{3})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4130,
    "headerPatterns": [
      {
        "regExp": "(?i).*(hexadecimal|hex).*color.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "hex_color_code"
        ],
        "negativeExamples": [
          "color_value"
        ]
      },
      {
        "regExp": "(?i).*(rgb.*hex|hex.*rgb).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "hex_rgb_code"
        ],
        "negativeExamples": [
          "rgb_value"
        ]
      },
      {
        "regExp": "(?i).*color.*hex.*value.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "color_hex_value"
        ],
        "negativeExamples": [
          "color_value"
        ]
      },
      {
        "regExp": "(?i).*(hex.*code|code.*hex).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "css_hex_code"
        ],
        "negativeExamples": [
          "product_code"
        ]
      },
      {
        "regExp": "(?i).*color.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "color"
        ],
        "negativeExamples": [
          "hue"
        ]
      }
    ],
    "positiveContentExamples": [
      "#000000",
      "#FFFFFF",
      "#1a2b3c",
      "#ABC",
      "#0F0",
      "#C0FFEE",
      "#FfA07A",
      "#123456"
    ],
    "negativeContentExamples": [
      "000000",
      "#12345",
      "#1234567",
      "#GGGGGG",
      "##123456",
      "#12",
      "#ABCDEG",
      "#abcdex"
    ],
    "positiveHeaderExamples": [
      "hex_color_code",
      "rgb_hex",
      "color_hex_value",
      "hex_rgb_code",
      "css_hex_color",
      "color_code_hex",
      "hexcolor",
      "color_hex"
    ],
    "negativeHeaderExamples": [
      "rgb_value",
      "hue",
      "tint",
      "palette",
      "hex_timestamp",
      "rgba_code",
      "background",
      "product_code"
    ],
    "explanation": "This semantic type identifies hexadecimal RGB color values commonly used in data sets that store colors, such as UI themes or CSS-like attributes. It recognizes both short (#RGB) and full (#RRGGBB) formats and enforces hexadecimal digits only without alpha components.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:30.466586"
  },
  {
    "resultType": "generated",
    "semanticType": "DAY.DIGITS",
    "description": "Numeric calendar day within a month (1\u201331), with optional leading zero for single-digit days. Intended for standalone day-of-month values, not full dates or day-of-week names.",
    "pluginType": "regex",
    "regexPattern": "\\b(0?[1-9]|[12][0-9]|3[01])\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4390,
    "headerPatterns": [
      {
        "regExp": "(?i).*day[_\\s-]*of[_\\s-]*month.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "day_of_month"
        ],
        "negativeExamples": [
          "calendar_date"
        ]
      },
      {
        "regExp": "(?i).*calendar[_\\s-]*day.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "calendar_day"
        ],
        "negativeExamples": [
          "calendar_date"
        ]
      },
      {
        "regExp": "(?i).*(billing|statement|invoice)[_\\s-]*day.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "billing_day"
        ],
        "negativeExamples": [
          "billing_date"
        ]
      },
      {
        "regExp": "(?i).*(dom|day[_\\s-]*no|day[_\\s-]*num).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "day_no"
        ],
        "negativeExamples": [
          "order_no"
        ]
      },
      {
        "regExp": "(?i).*day.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "day"
        ],
        "negativeExamples": [
          "date"
        ]
      }
    ],
    "positiveContentExamples": [
      "1",
      "2",
      "09",
      "15",
      "23",
      "28",
      "30",
      "31"
    ],
    "negativeContentExamples": [
      "00",
      "0",
      "32",
      "9th",
      "3.0",
      "5a",
      "31st",
      "040"
    ],
    "positiveHeaderExamples": [
      "calendar_day",
      "day_of_month",
      "billing_day",
      "statement_day",
      "invoice_day",
      "day_no",
      "dom"
    ],
    "negativeHeaderExamples": [
      "calendar_date",
      "month",
      "invoice_total",
      "record_id",
      "start_time",
      "week_number",
      "due_date"
    ],
    "explanation": "This semantic type identifies numeric day-of-month values from 1 to 31, allowing an optional leading zero for single-digit days. It is suitable for fields that store only the calendar day component, not full dates or descriptive day names.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:30.938274"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.TEXT_NL",
    "description": "Landnaam in het Nederlands: de volledige, nationale aanduiding van een land zoals geschreven in de Nederlandse taal (bijv. Nederland, Belgi\u00eb, Verenigde Staten). Ondersteunt samengestelde namen, verbindingswoorden (en, van, de, het, der, des) en koppeltekens, inclusief namen met d\u2019/d'.",
    "pluginType": "regex",
    "regexPattern": "\\b\\p{Lu}\\p{Ll}{2,}(-\\p{Lu}\\p{Ll}{2,})*(\\s+(\\p{Lu}\\p{Ll}{2,}|en|van|de|het|der|des|d\u2019\\p{Lu}\\p{Ll}{2,}|d'\\p{Lu}\\p{Ll}{2,})(-\\p{Lu}\\p{Ll}{2,})*){0,6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4330,
    "headerPatterns": [
      {
        "regExp": "(?i).*(landnaam|country.*name).*(nl|nederlands|dutch).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "landnaam_nl"
        ],
        "negativeExamples": [
          "country_code"
        ]
      },
      {
        "regExp": "(?i).*naam.*van.*land.*(nl|nederlands).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "naam_van_land_nederlands"
        ],
        "negativeExamples": [
          "landenlijst"
        ]
      },
      {
        "regExp": "(?i).*(country|land).*(name|naam).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "country_name"
        ],
        "negativeExamples": [
          "address_name"
        ]
      },
      {
        "regExp": "(?i).*(ctry|cntry|lnd).*(nm|name).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "ctry_nm"
        ],
        "negativeExamples": [
          "land_id"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Nederland",
      "Belgi\u00eb",
      "Duitsland",
      "Verenigde Staten",
      "Verenigd Koninkrijk",
      "Zuid-Afrika",
      "C\u00f4te d\u2019Ivoire",
      "Bosni\u00eb en Herzegovina"
    ],
    "negativeContentExamples": [
      "NL",
      "USA",
      "NEDERLAND",
      "Nederland 2",
      "land: Nederland",
      "Cote d Ivoire",
      "V.K.",
      "St. Lucia"
    ],
    "positiveHeaderExamples": [
      "landnaam_nl",
      "land_naam",
      "naam_van_land",
      "country_name_nl",
      "nl_country_name",
      "landnaam_nederlands",
      "dutch_country_name"
    ],
    "negativeHeaderExamples": [
      "country_code",
      "iso_code",
      "nationaliteit",
      "plaatsnaam",
      "stad",
      "staat",
      "region_name"
    ],
    "explanation": "This semantic type identifies Dutch-language country names written out in full words, allowing multi-word names, connecting words (en, van, de, het, der, des), hyphenated parts, and names with d\u2019/d'. It excludes codes, abbreviations, numeric or punctuated variants, and all-uppercase acronyms.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:31.699705"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.EAN13",
    "description": "Product barcode: a thirteen-digit Global Trade Item Number (GTIN-13), commonly known as EAN-13. It consists of 13 numeric digits and may be displayed with optional single spaces or hyphens between digits.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d([- ]?\\d){12}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4050,
    "headerPatterns": [
      {
        "regExp": "(?i).*(ean|gtin)[-_ ]?13.*(code|barcode|number).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ean13_code"
        ],
        "negativeExamples": [
          "upc_code"
        ]
      },
      {
        "regExp": "(?i).*(ean|gtin)[-_ ]?13.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gtin13"
        ],
        "negativeExamples": [
          "isbn13"
        ]
      },
      {
        "regExp": "(?i).*(ean|gtin).*(code|barcode|number).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ean_code"
        ],
        "negativeExamples": [
          "sku_code"
        ]
      },
      {
        "regExp": "(?i).*(product|retail).*(barcode|bar ?code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "product_barcode"
        ],
        "negativeExamples": [
          "order_number"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "number"
        ]
      }
    ],
    "positiveContentExamples": [
      "4006381333931",
      "5901234123457",
      "9780306406157",
      "0123456789012",
      "400-6381333931",
      "4006381 333931",
      "8712345678901",
      "6928804012345"
    ],
    "negativeContentExamples": [
      "400638133393",
      "40063813339310",
      "978030640615X",
      "400--6381333931",
      "400_6381333931",
      "978030640615",
      "97803064061570",
      "400638133393I"
    ],
    "positiveHeaderExamples": [
      "ean13_code",
      "gtin_13",
      "product_barcode",
      "ean_code",
      "gtin13",
      "ean13_number",
      "retail_barcode",
      "gtin_code"
    ],
    "negativeHeaderExamples": [
      "upc_code",
      "isbn13",
      "sku_code",
      "order_number",
      "serial_code",
      "ean8",
      "qr_code",
      "tracking_number"
    ],
    "explanation": "EAN-13 is a 13-digit numeric identifier used for retail product barcodes, often displayed as GTIN-13. The pattern accepts exactly 13 digits with optional single spaces or hyphens between digits to reflect common formatting. This type helps detect product barcode fields; header cues like EAN/GTIN-13 and barcode terms increase confidence while a primitive 'code' pattern provides a fallback.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:32.567282"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.ISO-3166-3",
    "description": "Three-letter country code (international identifier) composed of exactly three uppercase letters A\u2013Z with no digits, spaces, or separators. Intended for standardized country identifiers in datasets and code fields.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4290,
    "headerPatterns": [
      {
        "regExp": "(?i).*iso.*3166.*alpha.*3.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iso_3166_alpha3_code"
        ],
        "negativeExamples": [
          "iso_3166_alpha2_code"
        ]
      },
      {
        "regExp": "(?i).*country.*alpha.*3.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "country_alpha3_code"
        ],
        "negativeExamples": [
          "country_alpha2_code"
        ]
      },
      {
        "regExp": "(?i).*iso.*3.*country.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iso3_country_code"
        ],
        "negativeExamples": [
          "iso2_country_code"
        ]
      },
      {
        "regExp": "(?i).*three.*letter.*country.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "three_letter_country_code"
        ],
        "negativeExamples": [
          "three_letter_currency_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "USA",
      "CAN",
      "MEX",
      "GBR",
      "FRA",
      "DEU",
      "JPN",
      "AUS"
    ],
    "negativeContentExamples": [
      "US",
      "GBRT",
      "gbr",
      "GbR",
      "1SA",
      "G B R",
      "ZAF1",
      "DE-U"
    ],
    "positiveHeaderExamples": [
      "iso_3166_alpha3_code",
      "country_iso3_code",
      "alpha3_country_code",
      "three_letter_country_code",
      "iso3_country_code",
      "country_alpha3_code",
      "country_code3",
      "country_code_3"
    ],
    "negativeHeaderExamples": [
      "country_iso2_code",
      "country_name",
      "currency_code",
      "airport_code",
      "state_code",
      "iso_3166_alpha2",
      "two_letter_country_code",
      "postal_code"
    ],
    "explanation": "This semantic type identifies three-letter international country identifiers commonly used in datasets. Values are exactly three uppercase letters A\u2013Z, with no digits, symbols, or spaces. Use this to classify columns that store standardized three-letter country codes, guided by strong header cues such as ISO, 3166, alpha3, and country code terminology.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:32.807277"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.LATITUDE_DMS",
    "description": "Latitude DMS: traditional degree-minute-second coordinates",
    "pluginType": "regex",
    "regexPattern": "\\b[+\\-]?(([0-8]?[0-9])|90)\\s*[\u00b0\u00ba]\\s*([0-5]?[0-9])\\s*['\u2019]\\s*([0-5]?[0-9](\\.[0-9]+)?)\\s*[\"\u201d]\\s*([NnSs])?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4220,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\blatitude\\b.*\\bdms\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "latitude_dms"
        ],
        "negativeExamples": [
          "longitude_dms"
        ]
      },
      {
        "regExp": "(?i).*\\blatitude\\b.*\\bcoordinate\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "latitude_coordinate"
        ],
        "negativeExamples": [
          "geo_longitude"
        ]
      },
      {
        "regExp": "(?i).*\\blat\\b.*\\bdeg\\b.*\\bmin\\b.*\\bsec\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lat_deg_min_sec"
        ],
        "negativeExamples": [
          "lat_decimal"
        ]
      },
      {
        "regExp": "(?i).*\\bgeo\\b.*\\blat\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "geo_lat"
        ],
        "negativeExamples": [
          "geo_long"
        ]
      },
      {
        "regExp": "(?i).*\\blatitude\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "latitude"
        ],
        "negativeExamples": [
          "longitude"
        ]
      }
    ],
    "positiveContentExamples": [
      "45\u00b0 30' 15\" N",
      "34\u00b020'10\"N",
      "-23\u00b012'00\"",
      "0\u00b0 0' 0\" S",
      "89\u00b0 59' 59.9\" n",
      "+07\u00b003'09\" N",
      "90\u00b0 0' 0\" S",
      "12\u00b0 5' 6.5\" s"
    ],
    "negativeContentExamples": [
      "100\u00b0 10' 10\" N",
      "45\u00b0 60' 00\" N",
      "45\u00b0 59' 60\" N",
      "45\u00b0 30' N",
      "45 30' 15\" N",
      "N 45\u00b0 30' 15\"",
      "23\u00b0 12\" 0' S",
      "45\u00b030'15.5 N"
    ],
    "positiveHeaderExamples": [
      "latitude_dms",
      "lat_deg_min_sec",
      "latitude_coordinate",
      "geo_lat_dms",
      "position_latitude_dms",
      "map_latitude",
      "sensor_latitude_dms",
      "user_latitude"
    ],
    "negativeHeaderExamples": [
      "longitude_dms",
      "lat_decimal",
      "latlon",
      "geo_longitude",
      "latitude_decimal",
      "northing",
      "y_coordinate",
      "geo_long"
    ],
    "explanation": "This semantic type identifies latitude values expressed in Degrees-Minutes-Seconds (DMS) notation. It expects a degree symbol, a minute mark, a second mark (seconds may include decimals), and optionally a leading sign or trailing hemisphere indicator (N/S). The regex enforces valid numeric ranges for latitude degrees (0\u201390) and for minutes/seconds (0\u201359) to reduce false positives. Typical uses include mapping, geocoding, and parsing geographic datasets where latitude is recorded in DMS form.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:36.224523"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.EASTING",
    "description": "X Coordinate: eastward distance measurement",
    "pluginType": "regex",
    "regexPattern": "\\b([eExX]\\s*)?([1-9][0-9]{4,6})(\\.[0-9]+)?\\s*([eE])?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 4200,
    "headerPatterns": [
      {
        "regExp": "(?i).*(utm[_\\s-]?easting|x[_\\s-]?easting|east[_\\s-]?x).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "utm_easting"
        ],
        "negativeExamples": [
          "utm_northing"
        ]
      },
      {
        "regExp": "(?i).*(east(ing)?[_\\s-]?(coord|coordinate)|x[_\\s-]?(coord|coordinate)).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "east_coordinate"
        ],
        "negativeExamples": [
          "north_coordinate"
        ]
      },
      {
        "regExp": "(?i).*(grid|map|proj).*(east|x).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "grid_x"
        ],
        "negativeExamples": [
          "grid_y"
        ]
      },
      {
        "regExp": "(?i).*(easting|east|x).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "easting"
        ],
        "negativeExamples": [
          "longitude"
        ]
      },
      {
        "regExp": "(?i).*coordinate.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "coordinate"
        ],
        "negativeExamples": [
          "address"
        ]
      }
    ],
    "positiveContentExamples": [
      "345678",
      "701234.25",
      "E 456789",
      "x 612345",
      "523456 e",
      "100234.0",
      "X 789012.5",
      "e 234567"
    ],
    "negativeContentExamples": [
      "4567",
      "-345678",
      "034567",
      "12345m",
      "12,345",
      "W 345678",
      "345678N",
      "99999."
    ],
    "positiveHeaderExamples": [
      "easting",
      "utm_easting",
      "east_coordinate",
      "x_coord",
      "grid_x",
      "map_easting",
      "e_x",
      "east_x"
    ],
    "negativeHeaderExamples": [
      "northing",
      "y_coord",
      "longitude",
      "latitude",
      "bearing",
      "index",
      "postal_code",
      "time_zone"
    ],
    "explanation": "Easting represents the X component of a planar or projected coordinate system, measured as distance increasing eastward from a defined origin or central meridian. Typical values are positive numbers with 5\u20137 digits, sometimes accompanied by an X/E indicator or decimal precision. This type helps identify fields containing the eastward axis of a grid coordinate, such as UTM easting or similar projected systems.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:37.161239"
  },
  {
    "resultType": "generated",
    "semanticType": "CREDIT_CARD_TYPE",
    "description": "card_brand: payment network identification. Represents the card payment network or scheme associated with a card, expressed as a standardized brand name (e.g., VISA, MASTERCARD, AMERICAN EXPRESS).",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "VISA",
      "MASTERCARD",
      "AMERICAN EXPRESS",
      "DISCOVER",
      "JCB",
      "DINERS CLUB",
      "UNIONPAY",
      "MAESTRO",
      "MIR",
      "ELO",
      "HIPERCARD",
      "RUPAY",
      "VERVE",
      "INTERAC",
      "TROY",
      "CARTES BANCAIRES",
      "UATP",
      "BANCONTACT",
      "NAPAS",
      "LANKAPAY"
    ],
    "backout": "^[A-Z][A-Z ]{1,19}$",
    "confidenceThreshold": 93,
    "priority": 4340,
    "headerPatterns": [
      {
        "regExp": "(?i).*credit.*card.*brand.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "credit_card_brand"
        ],
        "negativeExamples": [
          "credit_card_number"
        ]
      },
      {
        "regExp": "(?i).*credit.*card.*network.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "credit_card_network"
        ],
        "negativeExamples": [
          "card_network_latency"
        ]
      },
      {
        "regExp": "(?i).*payment.*network.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "payment_network"
        ],
        "negativeExamples": [
          "network_type"
        ]
      },
      {
        "regExp": "(?i).*card.*brand.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "card_brand"
        ],
        "negativeExamples": [
          "card_type"
        ]
      },
      {
        "regExp": "(?i).*cc.*brand.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cc_brand"
        ],
        "negativeExamples": [
          "cc_number"
        ]
      },
      {
        "regExp": "(?i).*brand.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "brand"
        ],
        "negativeExamples": [
          "type"
        ]
      }
    ],
    "positiveContentExamples": [
      "VISA",
      "MASTERCARD",
      "AMERICAN EXPRESS",
      "DISCOVER",
      "JCB",
      "DINERS CLUB",
      "UNIONPAY",
      "CARTES BANCAIRES"
    ],
    "negativeContentExamples": [
      "AMEX",
      "VISA CREDIT",
      "MASTER CARD",
      "UNION PAY",
      "DINERS-CLUB",
      "AMERICANEXPRESS",
      "DISCOVER CARD",
      "J C B"
    ],
    "positiveHeaderExamples": [
      "credit_card_brand",
      "card_brand",
      "cc_brand",
      "payment_network",
      "credit_card_network",
      "card_network",
      "brand"
    ],
    "negativeHeaderExamples": [
      "credit_card_number",
      "cardholder_name",
      "issuing_bank",
      "bank_name",
      "product_category",
      "account_type",
      "transaction_network",
      "network_latency"
    ],
    "explanation": "This semantic type identifies the payment network brand associated with a card (e.g., VISA, MASTERCARD), typically used to categorize transactions, validate routing, or segment portfolios by scheme. Values are drawn from a finite, well-known set of card network brands, making a controlled list appropriate. Header patterns prioritize explicit mentions of credit card brand/network and common abbreviations (cc_brand), falling back to the primitive concept 'brand' when context is minimal.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:37.643693"
  },
  {
    "resultType": "generated",
    "semanticType": "EPOCH.MILLISECONDS",
    "description": "Millisecond-precision Unix timestamp represented as a 13-digit integer counting milliseconds since 1970-01-01T00:00:00Z. Commonly used in logs and event datasets to denote precise time points.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{13}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4430,
    "headerPatterns": [
      {
        "regExp": "(?i).*epoch.*millis.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "event_epoch_millis"
        ],
        "negativeExamples": [
          "event_epoch_seconds"
        ]
      },
      {
        "regExp": "(?i).*epoch.*ms.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "created_at_epoch_ms"
        ],
        "negativeExamples": [
          "created_at_epoch_sec"
        ]
      },
      {
        "regExp": "(?i).*(timestamp|time).*millis.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "log_timestamp_millis"
        ],
        "negativeExamples": [
          "log_timestamp_microseconds"
        ]
      },
      {
        "regExp": "(?i).*(unix|posix).*ms.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "unix_time_ms"
        ],
        "negativeExamples": [
          "unix_time"
        ]
      },
      {
        "regExp": "(?i).*date.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "event_date"
        ],
        "negativeExamples": [
          "event_time"
        ]
      }
    ],
    "positiveContentExamples": [
      "1704067200123",
      "1699999999999",
      "1625097600456",
      "1514764800001",
      "1400000000999",
      "1356998400123",
      "1234567890123",
      "2000000000000"
    ],
    "negativeContentExamples": [
      "1704067200",
      "170406720012",
      "17040672001234",
      "1704067200123.0",
      "-1704067200123",
      "1704067200123Z",
      "1_704_067_200_123"
    ],
    "positiveHeaderExamples": [
      "event_epoch_millis",
      "created_at_epoch_ms",
      "log_timestamp_millis",
      "unix_time_ms",
      "posix_epoch_ms",
      "request_time_millis",
      "epoch_ms",
      "tx_epoch_millis"
    ],
    "negativeHeaderExamples": [
      "event_epoch_seconds",
      "created_at_epoch_sec",
      "log_timestamp_microseconds",
      "unix_time",
      "posix_time_us",
      "time_ns",
      "timestamp_iso8601",
      "event_time"
    ],
    "explanation": "This semantic type identifies millisecond-precision Unix timestamps, typically found in log files, telemetry, and event tracking systems where sub-second resolution is required. It strictly matches 13-digit integers to clearly distinguish milliseconds from seconds (10 digits) and microseconds (16 digits or more).",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:44.709341"
  },
  {
    "resultType": "generated",
    "semanticType": "CRYPTOCURRENCY.TEXT_EN",
    "description": "English display names of blockchain-based digital currency assets (coins or tokens), written as proper names. Examples include single-word assets (e.g., Bitcoin) and multi-word assets that often include crypto-specific terms (e.g., Bitcoin Cash, USD Coin, Wrapped Bitcoin). This type excludes tickers/symbols, wallet addresses, and generic person or company names.",
    "pluginType": "regex",
    "regexPattern": "\\b((Bitcoin|Ethereum|Solana|Cardano|Polkadot|Litecoin|Monero|Dogecoin|Tron|Dash|Ripple|Stellar|Tether)|((Wrapped[ -])?([A-Z][a-z]+|[A-Z]{2,5})([ -]([A-Z][a-z]+|[A-Z]{2,5})){0,3} (Coin|Token|DAO|Cash|Classic|Network|Protocol|Chain|Swap|Finance|Pay|SV|USD|Lumens|Fuel)))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4350,
    "headerPatterns": [
      {
        "regExp": "(?i).*(crypto|cryptocurrency).*(asset|coin|token).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "crypto_asset_name"
        ],
        "negativeExamples": [
          "crypto_asset_symbol"
        ]
      },
      {
        "regExp": "(?i).*(digital).*(currency).*(name).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "digital_currency_name"
        ],
        "negativeExamples": [
          "digital_currency_code"
        ]
      },
      {
        "regExp": "(?i).*(blockchain).*(asset|token).*(name).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "blockchain_asset_name"
        ],
        "negativeExamples": [
          "blockchain_address"
        ]
      },
      {
        "regExp": "(?i).*(cryptocurrency|crypto).*(name).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "cryptocurrency_name"
        ],
        "negativeExamples": [
          "cryptocurrency_code"
        ]
      },
      {
        "regExp": "(?i).*(ccy).*(name).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "ccy_name"
        ],
        "negativeExamples": [
          "ccy_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "number"
        ]
      }
    ],
    "positiveContentExamples": [
      "Bitcoin",
      "Ethereum",
      "Cardano",
      "Litecoin",
      "Dogecoin",
      "Bitcoin Cash",
      "USD Coin",
      "Wrapped Bitcoin"
    ],
    "negativeContentExamples": [
      "bitcoin",
      "BTC",
      "Solana 2.0",
      "Bitcoin-2",
      "Ripple Labs",
      "John Smith",
      "Bitcoin.com",
      "NEO"
    ],
    "positiveHeaderExamples": [
      "crypto_asset_name",
      "cryptocurrency_name",
      "digital_currency_name",
      "blockchain_asset_name",
      "coin_name",
      "token_name",
      "asset_name",
      "name"
    ],
    "negativeHeaderExamples": [
      "crypto_asset_symbol",
      "cryptocurrency_code",
      "digital_currency_id",
      "blockchain_address",
      "token_symbol",
      "coin_ticker",
      "account_name",
      "filename"
    ],
    "explanation": "This semantic type identifies English-language cryptocurrency asset names, such as coins and tokens, formatted as proper names. It is useful for distinguishing human-readable asset names from tickers/symbols, codes, wallet addresses, and other identifiers in financial, exchange, or blockchain datasets.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:50.347067"
  },
  {
    "resultType": "generated",
    "semanticType": "DAY.FULL_<LOCALE>",
    "description": "Full weekday name in English (en), such as Monday through Sunday. Used to identify columns containing the complete day-of-week name rather than abbreviations or numeric representations.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "MONDAY",
      "TUESDAY",
      "WEDNESDAY",
      "THURSDAY",
      "FRIDAY",
      "SATURDAY",
      "SUNDAY"
    ],
    "backout": "^[A-Z]{6,9}$",
    "confidenceThreshold": 96,
    "priority": 4400,
    "headerPatterns": [
      {
        "regExp": "(?i).*full.*weekday.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "full_weekday_name"
        ],
        "negativeExamples": [
          "weekday_name_short"
        ]
      },
      {
        "regExp": "(?i).*full.*day.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "full_day_name"
        ],
        "negativeExamples": [
          "day_name_short"
        ]
      },
      {
        "regExp": "(?i).*day.*of.*week.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "day_of_week"
        ],
        "negativeExamples": [
          "week_of_day"
        ]
      },
      {
        "regExp": "(?i).*weekday.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "weekday"
        ],
        "negativeExamples": [
          "weekend_flag"
        ]
      },
      {
        "regExp": "(?i).*day.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "day"
        ],
        "negativeExamples": [
          "date"
        ]
      }
    ],
    "positiveContentExamples": [
      "Monday",
      "TUESDAY",
      "Wednesday",
      "thursday",
      "FRIDAY",
      "Saturday",
      "SUNDAY",
      "MonDay"
    ],
    "negativeContentExamples": [
      "Mon",
      "Tue",
      "Monday 1",
      "Monday.",
      "Mondays",
      "Mon-day",
      "Munday",
      "Lunes"
    ],
    "positiveHeaderExamples": [
      "full_weekday_name",
      "full_day_name",
      "weekday_full",
      "day_of_week_full",
      "weekday_name",
      "dayname_full",
      "long_weekday_name"
    ],
    "negativeHeaderExamples": [
      "date",
      "week_number",
      "week_index",
      "month_name",
      "holiday",
      "workweek_code",
      "shift_name",
      "iso_week"
    ],
    "explanation": "This semantic type identifies values that are the full English names of the days of the week. It is appropriate for columns storing text like Monday through Sunday, not abbreviations or numeric encodings. The list plugin ensures strict matching to the seven valid names, while the backout pattern provides a constrained fallback shape check.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:50.418355"
  },
  {
    "resultType": "generated",
    "semanticType": "EMAIL",
    "description": "Electronic mail address used to identify a contact endpoint for sending and receiving messages. Matches common email formats with local-part, at-sign, and domain with alphabetic top-level domain.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4420,
    "headerPatterns": [
      {
        "regExp": "(?i).*customer.*email.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_email_address"
        ],
        "negativeExamples": [
          "customer_mailing_address"
        ]
      },
      {
        "regExp": "(?i).*user.*email.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "user_email"
        ],
        "negativeExamples": [
          "username"
        ]
      },
      {
        "regExp": "(?i).*(cust|acct).*email.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cust_email"
        ],
        "negativeExamples": [
          "cust_id"
        ]
      },
      {
        "regExp": "(?i).*(e[_-]?mail).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "work_e-mail"
        ],
        "negativeExamples": [
          "work_mailbox"
        ]
      },
      {
        "regExp": "(?i).*email.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "email"
        ],
        "negativeExamples": [
          "phone"
        ]
      }
    ],
    "positiveContentExamples": [
      "john.doe@example.com",
      "jane+news@sub.example.co.uk",
      "support@my-domain.org",
      "user123@service.io",
      "a_b.test@company.travel",
      "ops.team@data-center.net",
      "first.last@university.edu",
      "no-reply@x.ai"
    ],
    "negativeContentExamples": [
      "userexample.com",
      "user@domain",
      "user@domain.c",
      "@example.com",
      "user@my_domain.com",
      "user@domain.123",
      "info@localhost",
      "user@domain.c0m"
    ],
    "positiveHeaderExamples": [
      "customer_email_address",
      "user_email",
      "contact_email",
      "primary_email",
      "billing_email",
      "account_email",
      "work_e-mail",
      "email"
    ],
    "negativeHeaderExamples": [
      "mailing_address",
      "username",
      "contact_phone",
      "customer_name",
      "primary_phone",
      "account_id",
      "website_url",
      "notification_opt_in"
    ],
    "explanation": "This semantic type identifies email addresses in datasets. The regex targets a local-part comprised of letters, digits, and common symbols, followed by '@', a domain with dots and hyphens, and an alphabetic top-level domain of length two or more. Use for columns containing contact emails; header patterns prioritize specific variants and end with a primitive 'email' matcher. Threshold and priority are tuned for a highly specific format to minimize false positives.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:51.343311"
  },
  {
    "resultType": "generated",
    "semanticType": "CURRENCY.TEXT_EN",
    "description": "English-language currency designation (spelled-out currency names), such as \"US dollar\", \"Euro\", or \"Japanese yen\". Focuses on textual names of monetary units rather than codes or symbols.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b((euro|euros|yen|yuan|rand|ringgit|baht|taka|manat|cedi|naira|real|reais|sol|soles|zloty|zlotych|forint|lei|leu|lev|leva|riel|dong|kip|gourde|quetzal|pula|tala|paanga|kuna|som|dobra|ariary|ouguiya|loti|dalasi|dram|denar|tugrik|lek|pound sterling|pounds sterling)|([A-Za-z][A-Za-z.-]*)(?: [A-Za-z][A-Za-z.-]*)* (dollar|dollars|pound|pounds|yen|yuan|rupee|rupees|riyal|riyals|dirham|dirhams|dinar|dinars|franc|francs|peso|pesos|won|krone|krona|kroner|kronor|lira|lire|rand|rial|ringgit|baht|taka|shekel|shekels|manat|bolivar|bolivares|boliviano|kwacha|kwanzas|kwanza|cedi|naira|real|reais|sol|soles|zloty|zlotych|forint|leu|lei|lev|leva|riel|dong|kip|gourde|quetzal|pula|tala|paanga|kuna|mark|marka|koruna|koruny|som|tugrik|ariary|ouguiya|loti|dalasi|dram|denar))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4360,
    "headerPatterns": [
      {
        "regExp": "(?i).*(currency).*(name|text).*(en|english).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "currency_name_en"
        ],
        "negativeExamples": [
          "currency_code_en"
        ]
      },
      {
        "regExp": "(?i).*(monetary|monetary_unit|money).*(name|text).*(en|english).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "monetary_unit_text_en"
        ],
        "negativeExamples": [
          "monetary_unit_code"
        ]
      },
      {
        "regExp": "(?i).*(currency).*(name|text).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "currency_text"
        ],
        "negativeExamples": [
          "currency_code"
        ]
      },
      {
        "regExp": "(?i).*(curr|ccy).*(name|txt).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "ccy_name"
        ],
        "negativeExamples": [
          "ccy_code"
        ]
      },
      {
        "regExp": "(?i).*(name).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "US dollar",
      "United States dollar",
      "Euro",
      "Japanese yen",
      "British pounds sterling",
      "Canadian dollars",
      "Saudi riyal",
      "Brazilian real"
    ],
    "negativeContentExamples": [
      "USD",
      "US$",
      "100 dollars",
      "eurozone",
      "dollar",
      "pound",
      "United States USD",
      "EUR"
    ],
    "positiveHeaderExamples": [
      "currency_name_en",
      "currency_text_en",
      "monetary_unit_name_en",
      "currency_long_name",
      "ccy_name",
      "currency_name",
      "currency_english_name"
    ],
    "negativeHeaderExamples": [
      "currency_code",
      "iso_currency_code",
      "amount_currency",
      "price_currency",
      "exchange_rate",
      "country_name",
      "currency_symbol",
      "symbol"
    ],
    "explanation": "This semantic type identifies English-language currency names (monetary units) written out in text, including both singular and plural forms and multi-word regional descriptors (e.g., \"Hong Kong dollar\"). It explicitly excludes currency codes (e.g., USD, EUR), symbols (e.g., $, \u20ac), and amounts that include numbers.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:52.854513"
  },
  {
    "resultType": "generated",
    "semanticType": "CURRENCY_CODE.ISO-4217",
    "description": "Three-letter ISO 4217 currency code identifier (e.g., USD, EUR, JPY). Matches uppercase alphabetic codes representing monetary currencies.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4370,
    "headerPatterns": [
      {
        "regExp": "(?i).*currency.*iso.*4217.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "currency_iso_4217_code"
        ],
        "negativeExamples": [
          "currency_code_4217"
        ]
      },
      {
        "regExp": "(?i).*iso.*currency.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iso_currency_code"
        ],
        "negativeExamples": [
          "iso_country_code"
        ]
      },
      {
        "regExp": "(?i).*currency.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "transaction_currency_code"
        ],
        "negativeExamples": [
          "currency_symbol"
        ]
      },
      {
        "regExp": "(?i).*(curr|ccy|fx).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "payment_currency"
        ],
        "negativeExamples": [
          "payment_method"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "USD",
      "EUR",
      "JPY",
      "GBP",
      "AUD",
      "CAD",
      "CHF",
      "CNY"
    ],
    "negativeContentExamples": [
      "US",
      "USDT",
      "usd",
      "EU R",
      "EUR1",
      "J-PY",
      "123",
      "US$"
    ],
    "positiveHeaderExamples": [
      "currency_iso_4217_code",
      "iso_currency_code",
      "transaction_currency_code",
      "payment_currency",
      "ccy_code",
      "fx_currency_code",
      "billing_currency_code",
      "currency"
    ],
    "negativeHeaderExamples": [
      "currency_name",
      "iso_country",
      "exchange_rate",
      "currency_symbol",
      "amount",
      "payment_method",
      "country",
      "locale"
    ],
    "explanation": "Detects three-letter ISO 4217 currency codes commonly used in financial transactions, billing, FX data, and accounting systems. Useful for validating or profiling fields that store standardized monetary identifiers rather than currency names or symbols.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:53.278709"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.SIN_CA",
    "description": "insurance_number: 9-digit Canadian employment and benefits identifier",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{3}[ -]?\\d{3}[ -]?\\d{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4660,
    "headerPatterns": [
      {
        "regExp": "(?i).*canadian.*social.*insurance.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "canadian social insurance number"
        ],
        "negativeExamples": [
          "social insurance number"
        ]
      },
      {
        "regExp": "(?i).*(ca|canada|canadian).*\\bsin\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CA SIN"
        ],
        "negativeExamples": [
          "employee sin"
        ]
      },
      {
        "regExp": "(?i).*(social.*insurance|\\bsin\\b).*(number|no|id).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "sin number"
        ],
        "negativeExamples": [
          "insurance policy number"
        ]
      },
      {
        "regExp": "(?i).*\\bsin\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "government sin"
        ],
        "negativeExamples": [
          "sinus measurement"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "123456789",
      "123 456 789",
      "123-456-789",
      "987654321",
      "741 852 963",
      "602-345-918",
      "905 667 332",
      "410-223-719"
    ],
    "negativeContentExamples": [
      "12345678",
      "1234567890",
      "123 45 6789",
      "123-4567-89",
      "12A 456 789",
      "123.456.789",
      "123/456/789",
      "123_456_789"
    ],
    "positiveHeaderExamples": [
      "canadian social insurance number",
      "CA SIN",
      "social insurance number",
      "sin number",
      "employee sin",
      "benefits sin",
      "canada sin id",
      "government sin"
    ],
    "negativeHeaderExamples": [
      "insurance policy number",
      "national id number",
      "tax identification number",
      "ssn",
      "claim number",
      "employee number",
      "social insurance code",
      "sinus measurement"
    ],
    "explanation": "This semantic type recognizes Canadian Social Insurance Numbers in common formats: 9 contiguous digits, or three groups of three separated by a single space or hyphen. It is intended for datasets containing employment and benefits identifiers specific to Canada. Structural validation is performed via pattern shape only and does not include checksum or issuance rule validation.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:56.194627"
  },
  {
    "resultType": "generated",
    "semanticType": "COLOR.TEXT_NL",
    "description": "Kleurnaam: beschrijvende tintterminologie in het Nederlands. Waarden zijn tekstuele kleur-/tintnamen zoals 'lichtblauw', 'bordeauxrood' of 'kastanjebruin'.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b((licht|donker|fel|pastel|mat|warm|koel|bleek|diep|helder|zacht|intens)[ -]?)?(olijf|zee|hemels|kastanje|nacht|smaragd|saffier|mosterd|salie|koraal|konings|kobalt|steen|leisteen|bordeaux)?[ -]?(rood|groen|blauw|geel|zwart|wit|grijs|paars|oranje|bruin|beige|turquoise|turkoois|cyaan|magenta|violet|indigo|goud|zilver|koper|antraciet|taupe|lila|fuchsia|lavendel|khaki|oker|mint|koraal)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 4160,
    "headerPatterns": [
      {
        "regExp": "(?i).*(\\bkleurnaam\\b|\\bcolor\\b.*\\bname\\b).*\\b(nl|nederlands|dutch)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "kleurnaam_nl"
        ],
        "negativeExamples": [
          "kleurcode_nl"
        ]
      },
      {
        "regExp": "(?i).*(\\bkleur\\b|\\bcolor\\b).*(\\bnaam\\b|\\bname\\b|\\bomschrijving\\b|\\bbeschrijving\\b).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "product_kleur_naam"
        ],
        "negativeExamples": [
          "kleurcode"
        ]
      },
      {
        "regExp": "(?i).*(\\bclr\\b|\\bcol\\b|\\bklr\\b).*(\\bnm\\b|\\bnaam\\b|\\bname\\b).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "clr_name_nl"
        ],
        "negativeExamples": [
          "col_code"
        ]
      },
      {
        "regExp": "(?i).*(\\btint\\b|\\bschakering\\b).*(\\bnaam\\b|\\bomschrijving\\b).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "kleurtint_omschrijving"
        ],
        "negativeExamples": [
          "tintcode"
        ]
      },
      {
        "regExp": "(?i).*\\b(kleur|tint)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "kleur"
        ],
        "negativeExamples": [
          "color_code"
        ]
      }
    ],
    "positiveContentExamples": [
      "rood",
      "lichtblauw",
      "donkergrijs",
      "olijfgroen",
      "bordeauxrood",
      "hemelsblauw",
      "zeegroen",
      "kastanjebruin"
    ],
    "negativeContentExamples": [
      "lichtblauwgrijs",
      "blauwachtig",
      "donkerazuur",
      "kleur onbekend",
      "roodachtig",
      "zeegroene",
      "witachtig",
      "grijz"
    ],
    "positiveHeaderExamples": [
      "kleurnaam",
      "kleurnaam_nl",
      "kleur_omschrijving",
      "product_kleur_naam",
      "beschrijving_kleur",
      "kleurtint_omschrijving",
      "clr_name_nl",
      "color_name_nl"
    ],
    "negativeHeaderExamples": [
      "kleurcode",
      "color_code",
      "hex_kleur",
      "rgb_kleur",
      "pantone_kleur",
      "ral_kleur",
      "kleurnummer",
      "kleur_id"
    ],
    "explanation": "Deze semantische type detecteert Nederlandse kleur-/tintnamen als vrije tekst, inclusief gebruikelijke intensiteitsprefixen (bijv. licht-, donker-, fel-) en beschrijvende samenstellingen (bijv. bordeauxrood, olijfgroen). Het is bedoeld voor kolommen met beschrijvende kleurnamen in natuurlijke taal, niet voor codes of numerieke kleurrepresentaties.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:56.401061"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE_PAIR.DECIMAL_PAREN",
    "description": "Location Coords: parenthesized coordinate pair. Identifies two decimal numbers representing latitude and longitude enclosed in parentheses, separated by a comma, with optional signs and whitespace. Examples include forms like (37.7749, -122.4194) and (+12.5, -45.25).",
    "pluginType": "regex",
    "regexPattern": "\\(\\s*[+-]?\\d{1,2}(\\.\\d+)?\\s*,\\s*[+-]?\\d{1,3}(\\.\\d+)?\\s*\\)",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 4270,
    "headerPatterns": [
      {
        "regExp": "(?i).*location.*coordinates.*parenthesized.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "location_coordinates_parenthesized"
        ],
        "negativeExamples": [
          "location_coordinates"
        ]
      },
      {
        "regExp": "(?i).*(latitude|lat)[ _-]*(longitude|lon)[ _-]*pair.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "latitude_longitude_pair"
        ],
        "negativeExamples": [
          "latitude_value"
        ]
      },
      {
        "regExp": "(?i).*(geo|location)[ _-]*coordinates[ _-]*(pair|tuple).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "geo_coordinates_pair"
        ],
        "negativeExamples": [
          "geo_coordinate"
        ]
      },
      {
        "regExp": "(?i).*coord(pair|tuple).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "coordpair"
        ],
        "negativeExamples": [
          "coordinates_list"
        ]
      },
      {
        "regExp": "(?i).*coordinate.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "coordinate"
        ],
        "negativeExamples": [
          "location"
        ]
      }
    ],
    "positiveContentExamples": [
      "(37.7749, -122.4194)",
      "(-33.8688, 151.2093)",
      "(0.0, 0.0)",
      "(90, -180)",
      "(48.8566, 2.3522)",
      "(+12.5, -45.25)",
      "( 45.0000 , 9.0000 )",
      "(-7.5, 110.75)"
    ],
    "negativeContentExamples": [
      "37.7749, -122.4194",
      "(37.7749 -122.4194)",
      "(37.7749,-122.4194, 10)",
      "(37.7749; -122.4194)",
      "(N37.7749, W122.4194)",
      "37.7749,-122.4194)",
      "(37,7749, -122,4194)",
      "(lat: 37.7749, lon: -122.4194)"
    ],
    "positiveHeaderExamples": [
      "location_coordinates_parenthesized",
      "latitude_longitude_pair",
      "geo_coordinates_pair",
      "coordpair",
      "coordinates_tuple",
      "geo_coordinate_pair",
      "lat_lon_pair",
      "location_coordinates_tuple"
    ],
    "negativeHeaderExamples": [
      "location_coords",
      "latitude_text",
      "longitude_values",
      "geo_point_string",
      "coords_description",
      "latlon_notes",
      "position_code",
      "place_name"
    ],
    "explanation": "This semantic type targets values that look like a latitude/longitude decimal pair inside parentheses, separated by a comma. It allows optional plus/minus signs and whitespace, and supports both integer and fractional components. Typical use cases include geospatial datasets where coordinates are stored as a single field in parenthesized decimal form.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:56.642867"
  },
  {
    "resultType": "generated",
    "semanticType": "HONORIFIC_EN",
    "description": "English honorific or courtesy title used as a name prefix (e.g., Mr, Ms, Dr, Prof), typically appearing before a personal name.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "MR",
      "MR.",
      "MRS",
      "MRS.",
      "MS",
      "MS.",
      "MISS",
      "MX",
      "DR",
      "DR.",
      "PROF",
      "PROF.",
      "SIR",
      "DAME",
      "LADY",
      "LORD",
      "REV",
      "REV.",
      "FR",
      "FR.",
      "HON",
      "HON.",
      "JUDGE",
      "JUSTICE"
    ],
    "backout": "^[A-Z]{2,7}\\.?$",
    "confidenceThreshold": 95,
    "priority": 4550,
    "headerPatterns": [
      {
        "regExp": "(?i).*(honorific|salutation).*(prefix|title).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "honorific_prefix"
        ],
        "negativeExamples": [
          "honorary_prefix"
        ]
      },
      {
        "regExp": "(?i).*(name|person).*title.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "person_title"
        ],
        "negativeExamples": [
          "job_title"
        ]
      },
      {
        "regExp": "(?i).*name.*prefix.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name_prefix"
        ],
        "negativeExamples": [
          "prefix_code"
        ]
      },
      {
        "regExp": "(?i).*(salutation|honorific).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "salutation"
        ],
        "negativeExamples": [
          "titlecase"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "account_id"
        ]
      }
    ],
    "positiveContentExamples": [
      "Mr",
      "Mr.",
      "Ms",
      "Mrs.",
      "Mx",
      "Dr",
      "Dr.",
      "Prof"
    ],
    "negativeContentExamples": [
      "Mister",
      "Doctor",
      "Professeur",
      "Sr.",
      "Capt.",
      "Rev Dr",
      "Mr & Mrs",
      "Honourable"
    ],
    "positiveHeaderExamples": [
      "honorific_prefix",
      "title_prefix",
      "salutation",
      "person_title",
      "name_title",
      "contact_title",
      "name_prefix",
      "courtesy_title"
    ],
    "negativeHeaderExamples": [
      "job_title",
      "username",
      "country_code",
      "prefix_code",
      "prefix_length",
      "subtitle",
      "title_case",
      "honorary_member"
    ],
    "explanation": "This semantic type captures English honorifics used as prefixes to personal names, such as Mr, Ms, Dr, and Prof, including both dotted and non-dotted forms. It is useful for parsing, standardizing, and validating title fields or extracting prefixes from full names in contact lists and CRM datasets.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:57.357218"
  },
  {
    "resultType": "generated",
    "semanticType": "COMPANY_NAME",
    "description": "Business Name: registered corporate entity designation. Identifies organization names that include a formal corporate suffix such as Inc, LLC, Ltd, GmbH, PLC, and similar legal forms.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b[A-Za-z0-9][A-Za-z0-9&'\u2019\\-\\., ]{1,80}\\s*,?\\s*(LLC|L\\.L\\.C\\.|INC|INC\\.|INCORPORATED|LTD|LTD\\.|LIMITED|CO|CO\\.|CORP|CORP\\.|CORPORATION|LLP|PLC|PTY LTD|GMBH|AG|S\\.A\\.|SAS|BV|N\\.V\\.|NV|OY|K\\.K\\.|KK|SARL|S\\.A\\.R\\.L\\.|SRL|S\\.R\\.L\\.|SPA|S\\.P\\.A\\.|SL|AB|OOO|ZAO)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4170,
    "headerPatterns": [
      {
        "regExp": "(?i).*registered.*company.*name.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "registered_company_name"
        ],
        "negativeExamples": [
          "registered_company_id"
        ]
      },
      {
        "regExp": "(?i).*legal.*entity.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "legal_entity_name"
        ],
        "negativeExamples": [
          "legal_entity_id"
        ]
      },
      {
        "regExp": "(?i).*business.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "business_name"
        ],
        "negativeExamples": [
          "business_id"
        ]
      },
      {
        "regExp": "(?i).*(company|corp|co).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "corp_name"
        ],
        "negativeExamples": [
          "company_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "company_code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Acme Inc.",
      "Globex LLC",
      "Initech Incorporated",
      "Wayne Enterprises, Ltd",
      "Stark Industries, Inc",
      "Umbrella Co.",
      "Blue Ocean GmbH",
      "Sunrise Holdings Pty Ltd"
    ],
    "negativeContentExamples": [
      "Wayne Enterprises",
      "Stark Industries",
      "Umbrella Company",
      "Acme L.L.C",
      "Globex Group",
      "Initech Incorp",
      "Blue Ocean GMB",
      "Nordic Systems A.B."
    ],
    "positiveHeaderExamples": [
      "company_name",
      "registered_company_name",
      "legal_entity_name",
      "business_name",
      "corp_name",
      "corporate_name",
      "co_name",
      "entity_name"
    ],
    "negativeHeaderExamples": [
      "company_code",
      "customer_name",
      "registered_company_id",
      "business_id",
      "corporate_status",
      "person_name",
      "account_name",
      "org_code"
    ],
    "explanation": "This semantic type detects organization names that include a formal legal suffix (e.g., LLC, Inc., Ltd, GmbH, PLC). It is useful for identifying registered business entities rather than informal labels or product/brand names. Header patterns are layered from highly specific variants to general 'name' to support varied schema conventions while content rules ensure the presence of a recognized corporate designation.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:57.793124"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.EIN_US",
    "description": "US Employer Identification Number (EIN): a tax_id_number consisting of a 2-digit prefix, a hyphen, and a 7-digit employer code (NN-NNNNNNN). This format strictly requires the hyphen separator and only digits.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{2}-[0-9]{7}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4600,
    "headerPatterns": [
      {
        "regExp": "(?i).*federal.*employer.*identification.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "federal_employer_identification_number"
        ],
        "negativeExamples": [
          "federal_employer_identification_code"
        ]
      },
      {
        "regExp": "(?i).*(fein).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fein_number"
        ],
        "negativeExamples": [
          "ein_code"
        ]
      },
      {
        "regExp": "(?i).*employer.*identification.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "employer_identification_number"
        ],
        "negativeExamples": [
          "employee_identification_number"
        ]
      },
      {
        "regExp": "(?i).*(ein|fein).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ein"
        ],
        "negativeExamples": [
          "tin"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "12-3456789",
      "00-1234567",
      "98-7654321",
      "01-2345678",
      "20-0001234",
      "73-9876543",
      "10-0000000",
      "99-9999999"
    ],
    "negativeContentExamples": [
      "123-45-6789",
      "12 3456789",
      "12-345678",
      "12-34567890",
      "1-23456789",
      "123456789",
      "12-3456A89",
      "12\u20143456789"
    ],
    "positiveHeaderExamples": [
      "federal_employer_identification_number",
      "employer_identification_number",
      "fein_number",
      "ein",
      "company_ein",
      "business_fein",
      "irs_ein",
      "tax_id_number_ein"
    ],
    "negativeHeaderExamples": [
      "social_security_number",
      "tin_number",
      "employer_id",
      "federal_tax_id",
      "vat_number",
      "employee_identification_number",
      "vendor_id_number",
      "registration_number"
    ],
    "explanation": "This semantic type targets US Employer Identification Numbers (EIN) with the exact shape NN-NNNNNNN, requiring a hyphen and digits only. It is suitable for validating and classifying employer tax identifiers in US datasets while avoiding confusion with SSNs, TINs without the hyphen, or other registration numbers.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:40:57.945275"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.BSN_NL",
    "description": "Dutch citizen number (Burgerservicenummer): 9-digit national identification code used in the Netherlands for residents and citizens. Numeric only, typically stored without separators and may include leading zeros.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{9}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4580,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\b(burgerservicenummer|dutch[_ ]citizen[_ ]number|citizen[_ ]service[_ ]number|bsn[_ ]number)\\b.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "citizen_service_number"
        ],
        "negativeExamples": [
          "customer_service_number"
        ]
      },
      {
        "regExp": "(?i).*\\b(national[_ ]id[_ ]nl|dutch[_ ]national[_ ]id|nl[_ ]national[_ ]id)\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "dutch_national_id"
        ],
        "negativeExamples": [
          "national_id"
        ]
      },
      {
        "regExp": "(?i).*\\b(nl[_ ]bsn|bsn[_ ]nl)\\b.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "nl_bsn"
        ],
        "negativeExamples": [
          "bsn_usa"
        ]
      },
      {
        "regExp": "(?i).*\\bbsn\\b.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "bsn"
        ],
        "negativeExamples": [
          "ssn"
        ]
      },
      {
        "regExp": "(?i).*\\bnumber\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "056239874",
      "123456789",
      "310456782",
      "987654321",
      "201734569",
      "740829156",
      "620518734",
      "439812675"
    ],
    "negativeContentExamples": [
      "12345678",
      "1234567890",
      "123 456 789",
      "123-456-789",
      "A23456789",
      "12345678B",
      "00123456",
      "12.3456789"
    ],
    "positiveHeaderExamples": [
      "nl_bsn",
      "bsn_number",
      "dutch_citizen_number",
      "burgerservicenummer",
      "dutch_national_id",
      "national_id_nl",
      "citizen_service_number",
      "bsn"
    ],
    "negativeHeaderExamples": [
      "ssn",
      "passport_number",
      "customer_number",
      "national_id",
      "patient_id",
      "tax_id",
      "vat_number",
      "account_number"
    ],
    "explanation": "Identifies the Dutch Burgerservicenummer (BSN), a 9-digit, numeric-only national identifier commonly found in government, healthcare, and payroll datasets. The regex focuses on a standalone 9-digit token using word boundaries; check rules such as the 11-test are not enforced in the pattern and should be validated downstream if required. Header patterns prioritize Dutch-specific terms and BSN abbreviations, then degrade to generic 'number' to capture minimal schema hints while maintaining a high confidence threshold.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:00.040739"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.SSN_CH",
    "description": "Swiss social security number formatted with the Swiss country numeric prefix and segmented digit groups. Expected structure is the country prefix 756 followed by three groups of digits separated by a dot, space, or hyphen, in the pattern 756 XXXX XXXX XX.",
    "pluginType": "regex",
    "regexPattern": "\\b756[ .-][0-9]{4}[ .-][0-9]{4}[ .-][0-9]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4670,
    "headerPatterns": [
      {
        "regExp": "(?i).*(swiss|ch).*(social.*security|ssn).*(number|code).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "swiss_social_security_number"
        ],
        "negativeExamples": [
          "national_social_security_number"
        ]
      },
      {
        "regExp": "(?i).*(swiss|ch).*(ssn|social.*security).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "ch_ssn"
        ],
        "negativeExamples": [
          "eu_ssn"
        ]
      },
      {
        "regExp": "(?i).*(ssn).*(ch|swiss).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ssn_ch"
        ],
        "negativeExamples": [
          "ssn_us"
        ]
      },
      {
        "regExp": "(?i).*(national).*(ssn|social.*security).*(ch|swiss).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "national_ssn_switzerland"
        ],
        "negativeExamples": [
          "national_ssn_germany"
        ]
      },
      {
        "regExp": "(?i).*social.*security.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "social_security_number"
        ],
        "negativeExamples": [
          "national_id_number"
        ]
      }
    ],
    "positiveContentExamples": [
      "756.1234.5678.90",
      "756 9876 5432 10",
      "756-0001-2345-67",
      "756.1111.2222.33",
      "756 3333 4444 55",
      "756-7777-8888-99",
      "756.2468.1357.24",
      "756 1357 2468 42"
    ],
    "negativeContentExamples": [
      "755.1234.5678.90",
      "756.123.5678.90",
      "756.12345.6789.01",
      "756.1234.567.890",
      "75612345678901",
      "756/1234/5678/90",
      "756.1234.5678.9A",
      "756-1234-5678-901"
    ],
    "positiveHeaderExamples": [
      "swiss_social_security_number",
      "ssn_ch",
      "ch_ssn",
      "social_security_number_ch",
      "swiss_social_security_code",
      "national_ssn_switzerland",
      "person_ssn_ch",
      "swiss_ssn"
    ],
    "negativeHeaderExamples": [
      "ssn",
      "national_id",
      "tax_number_ch",
      "vat_number_ch",
      "ein_ch",
      "bsn_nl",
      "nin_uk",
      "passport_number_ch"
    ],
    "explanation": "IDENTITY.SSN_CH targets Swiss-formatted social security numbers that include the numeric country prefix 756 and three digit groups separated by a dot, space, or hyphen (format: 756 XXXX XXXX XX). It is useful for validating and classifying Swiss social security fields where the presence of the Swiss prefix and segmented grouping is expected, without performing check-digit validation.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:00.392508"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.AADHAAR_IN",
    "description": "Indian Aadhaar number: 12-digit government-issued resident identification number used for residents of India. Values are digits only, typically grouped 4-4-4 with optional single spaces or hyphens, and the first digit is 2\u20139.",
    "pluginType": "regex",
    "regexPattern": "\\b[2-9]\\d{3}[ -]?\\d{4}[ -]?\\d{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4570,
    "headerPatterns": [
      {
        "regExp": "(?i).*aadhaar.*(number|no).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "aadhaar number"
        ],
        "negativeExamples": [
          "aadhaar reference"
        ]
      },
      {
        "regExp": "(?i).*aadhaar.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "aadhaar id"
        ],
        "negativeExamples": [
          "employee id"
        ]
      },
      {
        "regExp": "(?i).*uidai.*aadhaar.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "uidai aadhaar"
        ],
        "negativeExamples": [
          "uid number"
        ]
      },
      {
        "regExp": "(?i).*(uid|uidai).*(number|no).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "uid number"
        ],
        "negativeExamples": [
          "user id"
        ]
      },
      {
        "regExp": "(?i).*(india|indian).*identity.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "indian identity number"
        ],
        "negativeExamples": [
          "national identity number"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "2345 6789 0123",
      "9876 5432 1098",
      "3456-7890-1234",
      "678912345678",
      "2987 6501 2345",
      "4567-1234-8901",
      "7890 4321 5678",
      "345612349876"
    ],
    "negativeContentExamples": [
      "1234 5678 9012",
      "0234 5678 9012",
      "2345 6789 012",
      "2345 67890 1234",
      "2345_6789_0123",
      "2345  6789 0123",
      "AA45 6789 0123",
      "4567/1234/8901"
    ],
    "positiveHeaderExamples": [
      "aadhaar number",
      "aadhaar_no",
      "aadhaar id",
      "uidai aadhaar",
      "uid number",
      "uidai no",
      "indian identity number",
      "aadhaar card number"
    ],
    "negativeHeaderExamples": [
      "national identity number",
      "employee id",
      "passport number india",
      "pan number",
      "taxpayer id india",
      "customer identifier",
      "user id",
      "voter id"
    ],
    "explanation": "This semantic type detects Indian Aadhaar numbers in datasets using a strict 12-digit pattern with optional single space or hyphen separators and a first digit between 2 and 9. The regex uses word boundaries to avoid matching within longer digit strings and avoids anchors to remain FTA-compatible. Header patterns progress from specific Aadhaar terms to general code terminology, ensuring robust identification by column names. This pattern does not perform check-digit validation and focuses on structural recognition.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:03.230499"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.LATITUDE_DECIMAL",
    "description": "Geographic Latitude: north-south decimal position. Represents a latitude in decimal degrees from -90 to 90 inclusive, with optional leading sign and optional fractional part. Values must be numeric only, without degree symbols or cardinal direction letters.",
    "pluginType": "regex",
    "regexPattern": "\\b[+-]?([0-8]?\\d(\\.\\d+)?|90(\\.0+)?)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 4210,
    "headerPatterns": [
      {
        "regExp": "(?i).*(decimal[ _-]*latitude|latitude[ _-]*decimal).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "decimal_latitude"
        ],
        "negativeExamples": [
          "latitude_dms"
        ]
      },
      {
        "regExp": "(?i).*(lat[ _-]*decimal|decimal[ _-]*lat).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lat_decimal"
        ],
        "negativeExamples": [
          "latitude"
        ]
      },
      {
        "regExp": "(?i).*(gps|geo|geographic)[ _-]*latitude.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gps_latitude"
        ],
        "negativeExamples": [
          "gps_longitude"
        ]
      },
      {
        "regExp": "(?i).*(coordinate|coord)[ _-]*latitude.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "coord_latitude"
        ],
        "negativeExamples": [
          "coord_x"
        ]
      },
      {
        "regExp": "(?i).*latitude.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "latitude"
        ],
        "negativeExamples": [
          "longitude"
        ]
      }
    ],
    "positiveContentExamples": [
      "0",
      "45",
      "+45.123456",
      "-12.5",
      "89.9999",
      "-0.0001",
      "90",
      "-90"
    ],
    "negativeContentExamples": [
      "90.0001",
      "-90.01",
      "100",
      "91.2",
      "-91",
      "180",
      "-120.5",
      "95"
    ],
    "positiveHeaderExamples": [
      "decimal_latitude",
      "latitude_decimal",
      "lat_decimal",
      "gps_latitude",
      "geo_latitude",
      "coordinate_latitude",
      "latitude",
      "user_latitude"
    ],
    "negativeHeaderExamples": [
      "longitude",
      "latency",
      "latlon",
      "lat_deg",
      "y_coordinate",
      "gps_longitude",
      "address_longitude",
      "elevation"
    ],
    "explanation": "This semantic type identifies decimal-degree latitude values ranging from -90 to 90 inclusive. It supports optional leading plus or minus signs and an optional fractional part, and rejects values with degree symbols, direction letters, or out-of-range magnitudes. Typical uses include geospatial datasets, GPS readings, and mapping applications where latitude is stored in decimal degrees.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:05.687730"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.IBAN",
    "description": "International Account: standardized cross-border bank identifier",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b([A-Z]{2}\\d{2}[A-Z0-9]{11,30}|[A-Z]{2}\\d{2}( [A-Z0-9]{4}){2,7}( [A-Z0-9]{1,4})?)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4060,
    "headerPatterns": [
      {
        "regExp": "(?i).*(international[\\s_]*bank[\\s_]*account[\\s_]*number).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "international_bank_account_number"
        ],
        "negativeExamples": [
          "bank_account_number"
        ]
      },
      {
        "regExp": "(?i).*iban[\\s_]*(number|code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iban_code"
        ],
        "negativeExamples": [
          "routing_number"
        ]
      },
      {
        "regExp": "(?i).*(bank[\\s_]*iban|account[\\s_]*iban).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "bank_iban"
        ],
        "negativeExamples": [
          "bank_account"
        ]
      },
      {
        "regExp": "(?i).*iban.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iban"
        ],
        "negativeExamples": [
          "swift_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "DE89370400440532013000",
      "GB29 NWBK 6016 1331 9268 19",
      "FR76 3000 6000 0112 3456 7890 189",
      "ES91 2100 0418 4502 0005 1332",
      "IT60 X054 2811 1010 0000 0123 456",
      "NL91 ABNA 0417 1643 00",
      "CH93 0076 2011 6238 5295 7",
      "GR16 0110 1250 0000 0001 2300 695"
    ],
    "negativeContentExamples": [
      "GB2X NWBK 6016 1331 9268 19",
      "DE89-3704-0044-0532-0130-00",
      "89370400440532013000DE",
      "DE89123456789",
      "AA12 34 56 78 90",
      "GB29NWBK6016-1331-9268-19",
      "FR7A30006000011234567890189",
      "CH93_0076_2011_6238_5295_7"
    ],
    "positiveHeaderExamples": [
      "iban",
      "iban_code",
      "bank_iban",
      "customer_iban",
      "international_bank_account_number",
      "payer_iban",
      "iban_number"
    ],
    "negativeHeaderExamples": [
      "swift_code",
      "routing_number",
      "account_number",
      "bic",
      "bank_code",
      "transaction_id",
      "sort_code"
    ],
    "explanation": "This semantic type identifies International Bank Account Numbers (IBAN), including both compact (no spaces) and commonly spaced representations. It enforces two leading letters (country code), two check digits, and the remaining alphanumeric structure typical of IBANs. Use it to validate and classify fields carrying IBANs in payment, banking, and financial datasets.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:06.165203"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTIFIER",
    "description": "record_key: unique alphanumeric code for entity identification",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z0-9]{8,20}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4560,
    "headerPatterns": [
      {
        "regExp": "(?i).*(record[_\\s-]?key|record[_\\s-]?id).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "record_key"
        ],
        "negativeExamples": [
          "record_count"
        ]
      },
      {
        "regExp": "(?i).*(entity|record)[_\\s-]?(identifier|id).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "entity id"
        ],
        "negativeExamples": [
          "entity_type"
        ]
      },
      {
        "regExp": "(?i).*(customer|user|account)[_\\s-]?(id|identifier).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_identifier"
        ],
        "negativeExamples": [
          "customer_name"
        ]
      },
      {
        "regExp": "(?i).*(unique|primary)[_\\s-]?(id|identifier).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "primary_identifier"
        ],
        "negativeExamples": [
          "primary_code"
        ]
      },
      {
        "regExp": "(?i).*identifier.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "identifier"
        ],
        "negativeExamples": [
          "identity"
        ]
      }
    ],
    "positiveContentExamples": [
      "A1B2C3D4",
      "9Z8Y7X6W",
      "ab12CD34",
      "1234ABCD",
      "ZXCVBN12",
      "qwerty09",
      "M3N4P5Q6",
      "kL9mN0pQ"
    ],
    "negativeContentExamples": [
      "A12B-34CD",
      "AB12_CD34",
      "A1B2 3C4D",
      "A1B2C7",
      "ABCDEFGHIJKLMNOPQRSTU1",
      "AB#12CD34",
      ".A1B2C3D4",
      "A1B2/C3D4"
    ],
    "positiveHeaderExamples": [
      "record_key",
      "record id",
      "entity_identifier",
      "entity id",
      "primary_identifier",
      "unique_id",
      "customer_identifier",
      "user_id"
    ],
    "negativeHeaderExamples": [
      "record_date",
      "key_metric",
      "customer_name",
      "entity_type",
      "user_count",
      "primary_code",
      "unique_key_desc",
      "account_number"
    ],
    "explanation": "This semantic type identifies generic entity record identifiers that are purely alphanumeric and between 8 and 20 characters long. It is intended for keys such as record_key, entity id, or customer identifier fields where the header semantics indicate an identifier, and the data values are compact alphanumeric tokens without separators.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:09.466158"
  },
  {
    "resultType": "generated",
    "semanticType": "FULL_ADDRESS_EN",
    "description": "mailing_address: complete postal location with standard formatting",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{1,6}\\s+[A-Za-z0-9.'-]{1,30}(\\s+[A-Za-z0-9.'-]{1,30})*\\s+(Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Lane|Ln|Drive|Dr|Court|Ct|Way|Terrace|Ter|Place|Pl|Parkway|Pkwy)\\b(\\s+(N|S|E|W|NE|NW|SE|SW))?(\\s+(Apt|Apartment|Unit|Suite|Ste)\\s+[A-Za-z0-9-]{1,6})?,\\s+[A-Za-z][A-Za-z.' -]{1,49},\\s+[A-Za-z]{2}\\s+(\\d{5}(-\\d{4})?|[A-Za-z]\\d[A-Za-z]\\s?\\d[A-Za-z]\\d)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4480,
    "headerPatterns": [
      {
        "regExp": "(?i).*(mailing|shipping|billing)[ _-]*(full|complete)[ _-]*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_mailing_full_address"
        ],
        "negativeExamples": [
          "shipping_city"
        ]
      },
      {
        "regExp": "(?i).*(full|complete)[ _-]*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "full_address"
        ],
        "negativeExamples": [
          "full_name"
        ]
      },
      {
        "regExp": "(?i).*(mailing|shipping|billing)[ _-]*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "shipping_address"
        ],
        "negativeExamples": [
          "shipping_postal_code"
        ]
      },
      {
        "regExp": "(?i).*(full[ _-]*addr|addr[ _-]*full).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "full_addr"
        ],
        "negativeExamples": [
          "addr_line1"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "address"
        ],
        "negativeExamples": [
          "location"
        ]
      }
    ],
    "positiveContentExamples": [
      "742 Evergreen Terrace, Springfield, IL 62704",
      "1600 Pennsylvania Ave NW, Washington, DC 20500",
      "350 Fifth Ave, New York, NY 10118",
      "1 Market St, San Francisco, CA 94105",
      "200 University Ave W, Waterloo, ON N2L 3G1",
      "55 King St W, Toronto, ON M5K 1A1",
      "123 Main St Apt 5, Springfield, IL 62704",
      "777 Saint-Laurent Blvd, Montreal, QC H2Y 2Y6"
    ],
    "negativeContentExamples": [
      "742 Evergreen Terrace, Springfield, IL",
      "123 Main St",
      "PO Box 123, Springfield, IL 62704",
      "221B Baker Street, London, NW1 6XE",
      "1600 Pennsylvania Ave, Washington DC 20500",
      "10 Downing St, London, SW1A 2AA",
      "1 Market St, San Francisco CA 94105",
      "5000 Yonge St, North York, Ontario M2N 7E9"
    ],
    "positiveHeaderExamples": [
      "mailing_full_address",
      "customer_shipping_full_address",
      "billing_complete_address",
      "full_address",
      "addr_full",
      "complete_address_en",
      "shipping_address",
      "mailing_address"
    ],
    "negativeHeaderExamples": [
      "mailing_city",
      "shipping_postal_code",
      "recipient_name",
      "geo_location",
      "zip_code",
      "place_name",
      "delivery_instructions",
      "coordinates"
    ],
    "explanation": "This semantic type targets full English-language mailing addresses in a single field, including a street number, street name with type, optional directional or unit, city, state/province code, and postal/ZIP code. The pattern is tuned for common US and Canadian formats to reduce false positives while still allowing typical variations like NW/SE directionals and apartment/suite indicators.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:11.573941"
  },
  {
    "resultType": "generated",
    "semanticType": "AIRLINE.TEXT_EN",
    "description": "Airline Company: full name of commercial carrier",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z][A-Za-z&.'-]+[ ]+){1,5}(Air|Airline|Airlines|Airways|Air Lines|Aviation)([ ]+[A-Z][A-Za-z&.'-]+){0,5}\\b|\\b([A-Z][A-Za-z&.'-]+[ ]+){0,5}(Air|Airline|Airlines|Airways|Air Lines|Aviation)([ ]+[A-Z][A-Za-z&.'-]+){1,5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4010,
    "headerPatterns": [
      {
        "regExp": "(?i).*operat.*airline.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "operating_airline_name"
        ],
        "negativeExamples": [
          "operating_airline_code"
        ]
      },
      {
        "regExp": "(?i).*marketing.*carrier.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "marketing_carrier_name"
        ],
        "negativeExamples": [
          "marketing_carrier_code"
        ]
      },
      {
        "regExp": "(?i).*airline.*company.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "airline_company_name"
        ],
        "negativeExamples": [
          "airline_company_code"
        ]
      },
      {
        "regExp": "(?i).*(airline|carrier).*(full|legal).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "carrier_full_name"
        ],
        "negativeExamples": [
          "airline_short_code"
        ]
      },
      {
        "regExp": "(?i).*(airline|carrier).*(name|nm).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "airline_nm"
        ],
        "negativeExamples": [
          "carrier_id"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Delta Air Lines",
      "Qatar Airways",
      "Emirates Airline",
      "Air India",
      "China Southern Airlines",
      "All Nippon Airways",
      "Ethiopian Airlines",
      "Saint John's Aviation"
    ],
    "negativeContentExamples": [
      "qatar airways",
      "Air filter",
      "Jet Propulsion Laboratory",
      "Air & Sea Logistics",
      "Airfield Services",
      "Airline_Booking_System",
      "Air 123 Logistics",
      "Charter Flight Company"
    ],
    "positiveHeaderExamples": [
      "operating_airline_name",
      "marketing_carrier_name",
      "airline_company_name",
      "carrier_full_name",
      "airline_nm",
      "airline_name",
      "oper_airline_name",
      "carrier_legal_name"
    ],
    "negativeHeaderExamples": [
      "operating_airline_code",
      "airline_iata_code",
      "carrier_id",
      "flight_number",
      "aircraft_type",
      "airport_code",
      "company_code",
      "booking_reference"
    ],
    "explanation": "Identifies full airline company names written in English, typically containing tokens such as Air, Airline, Airlines, Airways, Air Lines, or Aviation and proper capitalization. Useful for distinguishing carrier names in bookings, schedules, ticketing, and operational data. The pattern emphasizes capitalized word tokens and airline-indicative terms to reduce confusion with generic phrases.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:15.175416"
  },
  {
    "resultType": "generated",
    "semanticType": "INDUSTRY_CODE.NAICS",
    "description": "Six-digit North American Industry Classification System (NAICS) business category code. Values are exactly six digits with no separators, spaces, or letters.",
    "pluginType": "regex",
    "regexPattern": "\\b[1-9][0-9]{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4710,
    "headerPatterns": [
      {
        "regExp": "(?i).*naics[_ ]?(code|id|number).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "naics_code"
        ],
        "negativeExamples": [
          "sic_code"
        ]
      },
      {
        "regExp": "(?i).*industry[_ ]?classification[_ ]?(code|id|number).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "industry_classification_code"
        ],
        "negativeExamples": [
          "industry_description"
        ]
      },
      {
        "regExp": "(?i).*(north[_ ]?american|na)[_ ]?industry[_ ]?classification.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "north_american_industry_classification"
        ],
        "negativeExamples": [
          "industry_classification_description"
        ]
      },
      {
        "regExp": "(?i).*(ind|business)[_ ]?(class|sector)[_ ]?(code|id).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ind_class_code"
        ],
        "negativeExamples": [
          "industry_status"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "status"
        ]
      }
    ],
    "positiveContentExamples": [
      "111110",
      "221114",
      "236220",
      "311111",
      "423450",
      "451110",
      "522110",
      "541330"
    ],
    "negativeContentExamples": [
      "054133",
      "54133",
      "5413300",
      "54-1330",
      "541 330",
      "54133A",
      "A41330",
      "54133.0"
    ],
    "positiveHeaderExamples": [
      "naics_code",
      "business_category_naics",
      "north_american_industry_classification",
      "industry_classification_code",
      "naics6",
      "naics_number",
      "industry_class_code"
    ],
    "negativeHeaderExamples": [
      "sic_code",
      "industry_description",
      "business_category_text",
      "hs_code",
      "sector_code",
      "classification_name",
      "code_type"
    ],
    "explanation": "This type identifies six-digit NAICS business category codes used to classify economic activities in North America. It expects exactly six digits with no separators or alphabetic characters. Typical use cases include validating or profiling columns that store NAICS codes and enriching records with standardized industry classifications.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:16.033839"
  },
  {
    "resultType": "generated",
    "semanticType": "GENDER.TEXT_JA",
    "description": "\u6027\u5225_\u65e5\u672c\u8a9e: Japanese language gender identification. Identifies Japanese text values representing gender, including common terms for male, female, unknown, and unspecified states.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "\u7537",
      "\u7537\u6027",
      "\u7537\u5b50",
      "\u5973",
      "\u5973\u6027",
      "\u5973\u5b50",
      "\u6027\u5225\u4e0d\u660e",
      "\u4e0d\u660e",
      "\u4e0d\u8a73",
      "\u672a\u56de\u7b54",
      "\u7121\u56de\u7b54",
      "\u975e\u516c\u958b",
      "\u305d\u306e\u4ed6",
      "\u304a\u3068\u3053",
      "\u304a\u3093\u306a",
      "\u3060\u3093\u305b\u3044",
      "\u3058\u3087\u305b\u3044",
      "\u7537\u5973",
      "\u672a\u9078\u629e",
      "\u9078\u629e\u306a\u3057"
    ],
    "backout": "^[\\p{IsHan}\\p{Hiragana}]{1,4}$",
    "confidenceThreshold": 95,
    "priority": 4500,
    "headerPatterns": [
      {
        "regExp": "(?i).*gender.*(text|label).*(ja|jp|japanese).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gender_text_ja"
        ],
        "negativeExamples": [
          "gender_code"
        ]
      },
      {
        "regExp": "(?i).*\u6027\u5225.*(\u30c6\u30ad\u30b9\u30c8|\u6587\u5b57\u5217|\u30e9\u30d9\u30eb).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u6027\u5225_\u30c6\u30ad\u30b9\u30c8"
        ],
        "negativeExamples": [
          "\u6027\u5225\u30b3\u30fc\u30c9"
        ]
      },
      {
        "regExp": "(?i).*(seibetsu).*(text|label).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "seibetsu_label"
        ],
        "negativeExamples": [
          "seibetsu_cd"
        ]
      },
      {
        "regExp": "(?i).*(gender|sex).*(ja|jp|japanese|seibetsu).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_gender_jp"
        ],
        "negativeExamples": [
          "customer_gender_code"
        ]
      },
      {
        "regExp": "(?i).*gender.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gender"
        ],
        "negativeExamples": [
          "age"
        ]
      }
    ],
    "positiveContentExamples": [
      "\u7537\u6027",
      "\u5973\u6027",
      "\u7537",
      "\u5973",
      "\u304a\u3068\u3053",
      "\u304a\u3093\u306a",
      "\u6027\u5225\u4e0d\u660e",
      "\u305d\u306e\u4ed6"
    ],
    "negativeContentExamples": [
      "\u7537/\u5973",
      "\u6027\u5225: \u7537\u6027",
      "\u5973\u6027?",
      "\u7537\u5973\u6bd4",
      "\u7537\u6027\uff08\u672a\u56de\u7b54\uff09",
      "\u672a\u8a2d\u5b9a",
      "\u30b8\u30a7\u30f3\u30c0\u30fc",
      "\u5973\u6027_"
    ],
    "positiveHeaderExamples": [
      "gender_text_ja",
      "\u6027\u5225_\u30c6\u30ad\u30b9\u30c8",
      "user_gender_jp",
      "customer_seibetsu_label",
      "\u6027\u5225\u30e9\u30d9\u30eb",
      "seibetsu_text",
      "gender_japanese",
      "sex_ja"
    ],
    "negativeHeaderExamples": [
      "postal_code",
      "country",
      "timezone",
      "start_date",
      "customer_name",
      "age",
      "email_address",
      "ip_address"
    ],
    "explanation": "This semantic type recognizes Japanese text values indicating gender, including common forms for male/female and typical labels for unknown or not provided. Use it to classify columns where the content is Japanese text labels rather than codes or abbreviations. Header detection prioritizes fields explicitly marked as Japanese gender text or labels, then falls back to general gender fields.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:16.060171"
  },
  {
    "resultType": "generated",
    "semanticType": "MACADDRESS",
    "description": "Hardware address consisting of 6 pairs of hexadecimal digits identifying a network interface. Common representations use separators as 6 pairs separated by colons or hyphens, or three groups of four hexadecimal digits separated by dots.",
    "pluginType": "regex",
    "regexPattern": "\\b([0-9A-Fa-f]{2}([:-][0-9A-Fa-f]{2}){5}|[0-9A-Fa-f]{4}(\\.[0-9A-Fa-f]{4}){2})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4790,
    "headerPatterns": [
      {
        "regExp": "(?i).*mac[^a-z0-9]?address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mac_address"
        ],
        "negativeExamples": [
          "ip_address"
        ]
      },
      {
        "regExp": "(?i).*(device|adapter|interface)[^a-z0-9]?mac.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "device_mac"
        ],
        "negativeExamples": [
          "device_id"
        ]
      },
      {
        "regExp": "(?i).*(ethernet|wifi|wlan)[^a-z0-9]?mac.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "wifi_mac"
        ],
        "negativeExamples": [
          "wifi_password"
        ]
      },
      {
        "regExp": "(?i).*(hwaddr|lladdr|physaddr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "hwaddr"
        ],
        "negativeExamples": [
          "hostaddr"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "address"
        ],
        "negativeExamples": [
          "hostname"
        ]
      }
    ],
    "positiveContentExamples": [
      "00:1A:2B:3C:4D:5E",
      "00-1a-2b-3c-4d-5e",
      "AA:BB:CC:DD:EE:FF",
      "aa-bb-cc-dd-ee-ff",
      "1C-6F-65-F1-9A-00",
      "1c:6f:65:f1:9a:00",
      "a1b2.c3d4.e5f6",
      "A1B2.C3D4.E5F6"
    ],
    "negativeContentExamples": [
      "00:1A:2B:3C:4D",
      "00:1A:2B:3C:4D:5E:6F",
      "00:1G:2B:3C:4D:5E",
      "0:1A:2B:3C:4D:5E",
      "AABBCCDDEEFF",
      "001A.2B3C.4D5Z",
      "001A.2B3C.4D5E.0000",
      "00-1A-2B-3C-4D-5E-"
    ],
    "positiveHeaderExamples": [
      "mac_address",
      "device_mac",
      "wifi_mac",
      "hardware_address",
      "ethernet_adapter_mac",
      "bluetooth_mac",
      "lladdr",
      "hwaddr"
    ],
    "negativeHeaderExamples": [
      "ip_address",
      "device_id",
      "mac_model",
      "mailing_address",
      "billing_address",
      "sha1_hash",
      "serial_number",
      "hostname"
    ],
    "explanation": "This semantic type detects MAC addresses for network interfaces using common notations: six pairs of hexadecimal digits separated by colons or hyphens, or three groups of four hex digits separated by dots. The value pattern is constrained with word boundaries and explicit token counts to avoid false positives. Header patterns prioritize explicit mentions of 'mac address' and device-related variants, then common abbreviations, and finally the primitive term 'address' to support broad schema variations.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:17.838094"
  },
  {
    "resultType": "generated",
    "semanticType": "IMEI",
    "description": "International Mobile Equipment Identity (IMEI): a device_serial identifier consisting of exactly 15 digits used to uniquely identify mobile equipment. It is often used for device tracking, blacklist checks, and inventory management across telecom systems.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{15}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4700,
    "headerPatterns": [
      {
        "regExp": "(?i).*device.*imei.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "device_imei_number"
        ],
        "negativeExamples": [
          "device_serial_number"
        ]
      },
      {
        "regExp": "(?i).*mobile.*imei.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mobile_imei"
        ],
        "negativeExamples": [
          "mobile_meid"
        ]
      },
      {
        "regExp": "(?i).*handset.*imei.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "handset_imei_id"
        ],
        "negativeExamples": [
          "handset_id"
        ]
      },
      {
        "regExp": "(?i).*equipment.*imei.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "equipment_imei"
        ],
        "negativeExamples": [
          "equipment_id"
        ]
      },
      {
        "regExp": "(?i).*imei.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "imei"
        ],
        "negativeExamples": [
          "serial_number"
        ]
      }
    ],
    "positiveContentExamples": [
      "490154203237518",
      "351756051523999",
      "356938035643809",
      "867698040000001",
      "358240051111110",
      "004401015093732",
      "861234050987654",
      "352099001761481"
    ],
    "negativeContentExamples": [
      "49015420323751",
      "4901542032375187",
      "4901542032375 18",
      "49015420323751A",
      "49-0154203237518",
      "4901542032375",
      "3490154203237518",
      "49015420323751800"
    ],
    "positiveHeaderExamples": [
      "device_imei_number",
      "mobile_imei",
      "handset_imei_id",
      "equipment_imei",
      "imei",
      "device_imei_no",
      "phone_imei",
      "imei_id"
    ],
    "negativeHeaderExamples": [
      "device_serial_number",
      "mobile_meid",
      "handset_id",
      "equipment_id",
      "serial_number",
      "device_iccid",
      "phone_number",
      "imsi"
    ],
    "explanation": "This semantic type targets 15-digit IMEI values as a contiguous numeric token using a strict word-bounded pattern. It is intended for mobile device identification fields and logs where IMEIs appear without separators or labels. The priority and threshold are tuned to reduce conflicts with other numeric identifiers while relying on header context for higher precision.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:18.095352"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.NHS_UK",
    "description": "UK National Health Service patient identifier: a 10-digit numeric NHS number. Commonly formatted as three digits, a separator (space or hyphen), three digits, a separator, and four digits, or as a continuous 10-digit string. Contains only digits, with optional single spaces or hyphens as separators.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{3}\\s\\d{3}\\s\\d{4}\\b|\\b\\d{3}-\\d{3}-\\d{4}\\b|\\b\\d{10}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4620,
    "headerPatterns": [
      {
        "regExp": "(?i).*uk.*nhs.*patient.*number.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "uk_nhs_patient_number"
        ],
        "negativeExamples": [
          "nhs_patient_id"
        ]
      },
      {
        "regExp": "(?i).*nhs.*patient.*id.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "nhs_patient_id"
        ],
        "negativeExamples": [
          "patient_id_number"
        ]
      },
      {
        "regExp": "(?i).*nhs.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nhs_number"
        ],
        "negativeExamples": [
          "national_insurance_number"
        ]
      },
      {
        "regExp": "(?i).*health.*service.*id.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "health_service_id"
        ],
        "negativeExamples": [
          "service_request_id"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "id"
        ]
      }
    ],
    "positiveContentExamples": [
      "943 476 5919",
      "401 023 4440",
      "1234567890",
      "987 654 3210",
      "234-567-8901",
      "555 123 4567",
      "0001234567",
      "321-654-0987"
    ],
    "negativeContentExamples": [
      "943 4765 919",
      "401 02 34440",
      "123456789",
      "12345678901",
      "987 654 - 3210",
      "234_567_8901",
      "555  123  4567",
      "123 456 789A"
    ],
    "positiveHeaderExamples": [
      "nhs_number",
      "patient_nhs_id",
      "uk_nhs_patient_number",
      "gb_nhs_patient_number",
      "nhs_patient_id",
      "health_service_id",
      "patient_id_number",
      "uk_health_service_id"
    ],
    "negativeHeaderExamples": [
      "nhs_trust_code",
      "patient_record_id",
      "national_insurance_number",
      "insurance_policy_number",
      "hospital_unit_code",
      "gp_practice_code",
      "passport_number",
      "patient_reference"
    ],
    "explanation": "This semantic type detects UK NHS patient numbers, which are 10 numeric digits and are often formatted as 3-3-4 with single spaces or hyphens, or as a contiguous 10-digit string. It is intended for patient identifiers associated with the UK National Health Service and avoids matching similar but differently named identifiers such as national insurance or passport numbers.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:18.859598"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.VAT_<COUNTRY>",
    "description": "tax_registration: country-specific business value-added tax identifier for the United Kingdom (GB). Matches 9-digit VAT numbers, optionally with a 3-digit branch suffix, with or without the 'GB' prefix and with common spacing.",
    "pluginType": "regex",
    "regexPattern": "\\b([Gg][Bb])?\\s?((\\d{9})|(\\d{3}\\s\\d{4}\\s\\d{2}))(\\s?\\d{3})?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4690,
    "headerPatterns": [
      {
        "regExp": "(?i).*(gb|uk).*(vat).*(number|no|id|code).*",
        "confidence": 99,
        "mandatory": true,
        "positiveExamples": [
          "gb_vat_number"
        ],
        "negativeExamples": [
          "vat_number"
        ]
      },
      {
        "regExp": "(?i).*(vat).*(registration|reg).*(number|no|id|code).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "uk_vat_reg_no"
        ],
        "negativeExamples": [
          "vat_rate"
        ]
      },
      {
        "regExp": "(?i).*(company|business|org).*(vat).*(id|number|no|code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "company_vat_id"
        ],
        "negativeExamples": [
          "vat_number"
        ]
      },
      {
        "regExp": "(?i).*(tax).*(vat).*(id|number|no|code).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "tax_vat_no"
        ],
        "negativeExamples": [
          "tax_code"
        ]
      },
      {
        "regExp": "(?i).*(vat).*(id|number|no|code).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "vat_code"
        ],
        "negativeExamples": [
          "tax_id"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "GB123456789",
      "GB 123456789",
      "GB123 4567 89",
      "gb123456789",
      "123456789",
      "123456789001",
      "GB123456789001",
      "123 4567 89 001"
    ],
    "negativeContentExamples": [
      "GB12345678",
      "GB1234567890",
      "UK123456789",
      "GB123 456 789",
      "12345678O1",
      "GB123456789 0000",
      "DE123456789",
      "12345678 001"
    ],
    "positiveHeaderExamples": [
      "gb_vat_number",
      "uk_vat_reg_no",
      "vat_registration_id",
      "company_vat_id",
      "vat_code",
      "vat_number",
      "tax_vat_no",
      "gb_vat_code"
    ],
    "negativeHeaderExamples": [
      "sales_tax_number",
      "company_tax_id",
      "vat_rate",
      "invoice_number",
      "country_code",
      "product_code",
      "customer_name",
      "tin_number"
    ],
    "explanation": "This semantic type identifies United Kingdom VAT registration numbers for businesses, including optional 'GB' prefix and optional 3-digit branch suffix. It is intended for classifying columns containing GB VAT identifiers in raw datasets and supports common unspaced and spaced formats.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:19.904233"
  },
  {
    "resultType": "generated",
    "semanticType": "LANGUAGE.TEXT_EN",
    "description": "Full English names of natural human languages (e.g., English, Haitian Creole, Mandarin Chinese). Values are expected to be properly capitalized words, optionally separated by spaces, hyphens, or apostrophes, and may include a brief parenthetical qualifier.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z][a-z]+([ '-][A-Z][a-z]+){0,5}(\\s\\([A-Z][a-z]+([ -][A-Z][a-z]+){0,3}\\))?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4780,
    "headerPatterns": [
      {
        "regExp": "(?i).*spoken.*language.*english.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "spoken_language_english_name"
        ],
        "negativeExamples": [
          "programming_language_name"
        ]
      },
      {
        "regExp": "(?i).*language.*name.*english.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "language_name_en"
        ],
        "negativeExamples": [
          "language_family"
        ]
      },
      {
        "regExp": "(?i).*natural.*language.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "natural_language_name"
        ],
        "negativeExamples": [
          "language_level"
        ]
      },
      {
        "regExp": "(?i).*(lang|lng).*name.*en.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lang_name_en"
        ],
        "negativeExamples": [
          "language_id"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "title"
        ]
      }
    ],
    "positiveContentExamples": [
      "English",
      "French",
      "Mandarin Chinese",
      "American Sign Language",
      "Haitian Creole",
      "Old English",
      "Serbo-Croatian",
      "Quechua"
    ],
    "negativeContentExamples": [
      "ENGLISH",
      "eng",
      "English, UK",
      "French-CA",
      "English/Spanish",
      "Portuguese (BR)",
      "Spanish (Latin AMERICA)",
      "xhosa"
    ],
    "positiveHeaderExamples": [
      "language_name",
      "spoken_language",
      "language_name_en",
      "english_language_name",
      "natural_language_name",
      "lang_name_en",
      "language_full_name",
      "spoken_language_english_name"
    ],
    "negativeHeaderExamples": [
      "language_code",
      "locale",
      "programming_language",
      "country_name",
      "language_family",
      "language_id",
      "name_prefix",
      "timezone_name"
    ],
    "explanation": "This semantic type classifies values that are full English names of natural languages, not codes. It emphasizes proper capitalization and common separators typical of language names and allows limited parenthetical qualifiers. Use it for profile fields, survey responses, or datasets capturing spoken language names. It intentionally excludes ISO codes, locale tags, country/region codes, and programming languages.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:20.908377"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.INDIVIDUAL_NUMBER_JA",
    "description": "A 12-digit Japanese administrative identification number for residents, represented as a contiguous numeric string without separators. Commonly used as a resident identification code in administrative datasets.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{12}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4610,
    "headerPatterns": [
      {
        "regExp": "(?i).*(japan|jp).*(individual|my).*number.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "jp_individual_number"
        ],
        "negativeExamples": [
          "customer_number"
        ]
      },
      {
        "regExp": "(?i).*resident.*id.*code.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "resident_id_code"
        ],
        "negativeExamples": [
          "resident_code"
        ]
      },
      {
        "regExp": "(?i).*(national|personal).*id.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "personal_id_number"
        ],
        "negativeExamples": [
          "national_id"
        ]
      },
      {
        "regExp": "(?i).*(mynum|my_no|jnin|ind_no).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "mynum"
        ],
        "negativeExamples": [
          "myname"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "012345678901",
      "123456789012",
      "987654321098",
      "000123456789",
      "555555555555",
      "709812345678",
      "110203040506",
      "321098765432"
    ],
    "negativeContentExamples": [
      "12345678901",
      "1234567890123",
      "1234-5678-9012",
      "12345678_9012",
      "12345678901A",
      "123456789O12",
      "1234 5678 9012",
      "0012345678901"
    ],
    "positiveHeaderExamples": [
      "jp_individual_number",
      "japan_my_number",
      "resident_id_code",
      "personal_id_number",
      "national_id_number",
      "mynum",
      "jp_resident_id_number",
      "ja_individual_no"
    ],
    "negativeHeaderExamples": [
      "customer_number",
      "resident_code",
      "national_id",
      "passport_number",
      "account_number",
      "employee_id",
      "resident_identifier",
      "code"
    ],
    "explanation": "This semantic type identifies a Japanese resident identification number formatted as exactly 12 consecutive digits, bounded by word boundaries. It is appropriate for datasets storing the identifier as a pure numeric string without separators. Header patterns prioritize Japan-specific and resident-ID terms before falling back to more general identification and numeric terminology. A high confidence threshold and identity-level priority help prevent confusion with generic 12-digit numbers.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:23.187385"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.NI_UK",
    "description": "UK National Insurance identifier in the format of two letters, six digits, and a final letter. Common renderings may include spaces between digit pairs, e.g., AB 12 34 56 C.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z]{2}\\s?\\d{2}\\s?\\d{2}\\s?\\d{2}\\s?[A-Za-z]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4630,
    "headerPatterns": [
      {
        "regExp": "(?i).*national.*insurance.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "national_insurance_number"
        ],
        "negativeExamples": [
          "insurance_policy_number"
        ]
      },
      {
        "regExp": "(?i).*social.*security.*ref.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "social_security_ref"
        ],
        "negativeExamples": [
          "social_security_number"
        ]
      },
      {
        "regExp": "(?i).*national.*insurance.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "uk_national_insurance"
        ],
        "negativeExamples": [
          "insurance_expiry_date"
        ]
      },
      {
        "regExp": "(?i).*(nino|ni[ _]?no).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "employee_nino"
        ],
        "negativeExamples": [
          "ni_rate"
        ]
      },
      {
        "regExp": "(?i).*id.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "person_id"
        ],
        "negativeExamples": [
          "policy_number"
        ]
      }
    ],
    "positiveContentExamples": [
      "AB123456C",
      "CD654321A",
      "QQ112233D",
      "jk987654b",
      "ZX 12 34 56 A",
      "HM 01 23 45 D",
      "GH123456A",
      "RN 99 88 77 C"
    ],
    "negativeContentExamples": [
      "AB123456",
      "ABC123456D",
      "AB12345C",
      "A1 23 45 67 C",
      "AB 12 34 56",
      "AB-12-34-56-C",
      "12AB3456C",
      "AB123456CC"
    ],
    "positiveHeaderExamples": [
      "national_insurance_number",
      "nationalInsuranceNumber",
      "social_security_ref",
      "ni_number",
      "nino",
      "uk_national_insurance",
      "ni_no",
      "employee_nino"
    ],
    "negativeHeaderExamples": [
      "insurance_expiry_date",
      "policy_number",
      "social_security_number",
      "ni_rate",
      "passport_number",
      "vat_number",
      "tax_code",
      "employee_number"
    ],
    "explanation": "This semantic type detects UK National Insurance numbers consisting of two letters, six digits, and a trailing letter, with optional spaces between digit pairs. It is suitable for validating and classifying personal identifiers used in UK payroll, HR, and tax datasets.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:24.221538"
  },
  {
    "resultType": "generated",
    "semanticType": "GENDER.TEXT_<LANGUAGE>",
    "description": "Textual gender values expressed as words in a single target language (e.g., MALE, FEMALE, NON-BINARY, OTHER), intended for fields storing gender as text rather than codes. This type focuses on common, finite vocabulary items and survey-style responses such as UNKNOWN or PREFER NOT TO SAY.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "MALE",
      "FEMALE",
      "MAN",
      "WOMAN",
      "NON-BINARY",
      "NONBINARY",
      "TRANSGENDER",
      "GENDERQUEER",
      "INTERSEX",
      "AGENDER",
      "BIGENDER",
      "GENDERFLUID",
      "TWO-SPIRIT",
      "OTHER",
      "UNKNOWN",
      "UNSPECIFIED",
      "NOT SPECIFIED",
      "NOT DISCLOSED",
      "PREFER NOT TO SAY",
      "DECLINE TO STATE",
      "NONE"
    ],
    "backout": "^([A-Z][A-Z\\- ]{0,29})$",
    "confidenceThreshold": 93,
    "priority": 4490,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bgender[_ ]text\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_gender_text"
        ],
        "negativeExamples": [
          "gender_code"
        ]
      },
      {
        "regExp": "(?i).*customer.*\\bgender\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_gender"
        ],
        "negativeExamples": [
          "customer_id"
        ]
      },
      {
        "regExp": "(?i).*\\bgender[_ ]identity\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gender_identity"
        ],
        "negativeExamples": [
          "identity_document"
        ]
      },
      {
        "regExp": "(?i).*\\bgndr\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "user_gndr"
        ],
        "negativeExamples": [
          "grand_total"
        ]
      },
      {
        "regExp": "(?i).*\\bsex\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "biological_sex"
        ],
        "negativeExamples": [
          "unisex_sku"
        ]
      },
      {
        "regExp": "(?i).*\\bgender\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gender"
        ],
        "negativeExamples": [
          "age"
        ]
      }
    ],
    "positiveContentExamples": [
      "FEMALE",
      "MALE",
      "NON-BINARY",
      "NONBINARY",
      "TRANSGENDER",
      "GENDERQUEER",
      "AGENDER",
      "TWO-SPIRIT"
    ],
    "negativeContentExamples": [
      "F",
      "M",
      "FEM",
      "MASCULINE",
      "FEMALES",
      "NON BINARY",
      "GENDER FLUID",
      "TRANS"
    ],
    "positiveHeaderExamples": [
      "customer_gender_text",
      "patient_gender",
      "gender_identity",
      "biological_sex",
      "user_gndr",
      "gender",
      "employee_gender"
    ],
    "negativeHeaderExamples": [
      "gender_code",
      "customer_id",
      "identity_document",
      "unisex_sku",
      "age",
      "contact_name",
      "pronouns"
    ],
    "explanation": "This semantic type detects textual representations of gender in a specified language, capturing common labels and survey responses (e.g., MALE, FEMALE, NON-BINARY, OTHER, UNKNOWN). It is intended for columns where gender is stored as free-text or normalized text rather than single-letter or numeric codes. The list plugin constrains matches to a finite vocabulary to avoid ambiguity, with a backout shape for graceful fallback. Header patterns progress from specific forms like gender_text to general primitives like gender.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:25.566340"
  },
  {
    "resultType": "generated",
    "semanticType": "MONTH.ABBR_<LOCALE>",
    "description": "Three-letter month abbreviation for a specific locale. Values are exactly three alphabetic characters and represent the 12 months for that locale (e.g., JAN, FEB, MAR).",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "JAN",
      "FEB",
      "MAR",
      "APR",
      "MAY",
      "JUN",
      "JUL",
      "AUG",
      "SEP",
      "OCT",
      "NOV",
      "DEC"
    ],
    "backout": "^[A-Z]{3}$",
    "confidenceThreshold": 98,
    "priority": 4800,
    "headerPatterns": [
      {
        "regExp": "(?i).*month.*(abbr|abbrev|short|3.?char|3.?letter).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "month_abbr"
        ],
        "negativeExamples": [
          "month_name"
        ]
      },
      {
        "regExp": "(?i).*(calendar|fiscal).*month.*(abbr|short).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "calendar_month_short"
        ],
        "negativeExamples": [
          "calendar_month_name"
        ]
      },
      {
        "regExp": "(?i).*(mon|mnth|mo).*(abbr|short).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mon_abbr"
        ],
        "negativeExamples": [
          "mon_number"
        ]
      },
      {
        "regExp": "(?i).*month.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "month"
        ],
        "negativeExamples": [
          "day"
        ]
      }
    ],
    "positiveContentExamples": [
      "JAN",
      "FEB",
      "MAR",
      "APR",
      "MAY",
      "JUN",
      "JUL",
      "AUG"
    ],
    "negativeContentExamples": [
      "JNA",
      "SEPT",
      "JANUARY",
      "DE C",
      "MAR1",
      "OCT-",
      "May",
      "J U N"
    ],
    "positiveHeaderExamples": [
      "month_abbr",
      "month_short",
      "calendar_month_abbr",
      "fiscal_month_short",
      "mon_abbr",
      "mnth_short",
      "month_3char",
      "month_3letter"
    ],
    "negativeHeaderExamples": [
      "weekday_abbr",
      "day_short",
      "year_abbr",
      "quarter_short",
      "fiscal_quarter_abbr",
      "week_abbr",
      "mo_code",
      "mon_index"
    ],
    "explanation": "This semantic type identifies three-letter month abbreviations for a specific locale, drawn from a fixed set of 12 values. It is useful for columns storing compact month labels such as month_abbr or month_short. The backout pattern constrains values to exactly three uppercase letters, while the primary detection relies on the finite list.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:29.408835"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.DUNS",
    "description": "Business identifier: a 9-digit commercial entity tracking code. Accepts either a contiguous 9-digit string or a 2-3-4 digit grouping separated by a single space or hyphen.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{9}\\b|\\b\\d{2}[- ]\\d{3}[- ]\\d{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4590,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bduns[_\\s-]*number\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "duns_number"
        ],
        "negativeExamples": [
          "account_number"
        ]
      },
      {
        "regExp": "(?i).*\\bduns[_\\s-]*(id|no|num|code)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "DUNS No"
        ],
        "negativeExamples": [
          "dns_server"
        ]
      },
      {
        "regExp": "(?i).*\\bd[-_\\s]*u[-_\\s]*n[-_\\s]*s\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "vendor_duns"
        ],
        "negativeExamples": [
          "dns_server"
        ]
      },
      {
        "regExp": "(?i).*\\b(business|company|vendor|supplier)[_\\s-]*(identifier|id|ref)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "company_id"
        ],
        "negativeExamples": [
          "customer_id"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "supplier_duns_code"
        ],
        "negativeExamples": [
          "supplier_duns_no"
        ]
      }
    ],
    "positiveContentExamples": [
      "123456789",
      "001234567",
      "12-345-6789",
      "12 345 6789",
      "10-000-0001",
      "550123789",
      "730610245",
      "00-001-2345"
    ],
    "negativeContentExamples": [
      "12345678",
      "1234567890",
      "123-45-6789",
      "12-34-56789",
      "12-3456-789",
      "12-3456789",
      "12_345_6789",
      "12345 6789"
    ],
    "positiveHeaderExamples": [
      "duns_number",
      "DUNS No",
      "duns id",
      "vendor_duns",
      "supplier_duns_code",
      "company_duns_number",
      "organization_duns_no",
      "business_duns"
    ],
    "negativeHeaderExamples": [
      "ssn",
      "tax_id",
      "dns_server",
      "company_name",
      "account_number",
      "registration_no",
      "invoice_ref",
      "customer_reference"
    ],
    "explanation": "IDENTITY.DUNS identifies 9-digit commercial entity tracking codes used to uniquely reference businesses. It matches either a continuous 9-digit string or a 2-3-4 grouping with single spaces or hyphens. Typical use cases include vendor master data, supplier onboarding, and business verification workflows.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:30.535519"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.PERSONNUMMER_SE",
    "description": "Swedish personal identity number (personnummer): a birth date component followed by a 4-digit individual sequence code. Accepted forms include YYMMDD-XXXX, YYMMDD+XXXX, YYMMDDXXXX, YYYYMMDD-XXXX, YYYYMMDD+XXXX, and YYYYMMDDXXXX, where the separator is either a hyphen or plus, or absent. Months are 01\u201312 and days are 01\u201331; no spaces or other separators are allowed.",
    "pluginType": "regex",
    "regexPattern": "\\b(19\\d{2}|20\\d{2})(0[1-9]|1[0-2])(0[1-9]|[12]\\d|3[01])[-+]?\\d{4}\\b|\\b\\d{2}(0[1-9]|1[0-2])(0[1-9]|[12]\\d|3[01])[-+]?\\d{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4650,
    "headerPatterns": [
      {
        "regExp": "(?i).*(personnummer|se[_ ]?person[_ ]?number|personal[_ ]identity[_ ]number[_ ]se).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "personnummer"
        ],
        "negativeExamples": [
          "personal_identity_number"
        ]
      },
      {
        "regExp": "(?i).*(personal[_ ]identity[_ ]number|national[_ ]id[_ ]se|swedish[_ ]id).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "personal_identity_number"
        ],
        "negativeExamples": [
          "customer_id"
        ]
      },
      {
        "regExp": "(?i).*(person[_ ]?no|person[_ ]?num|persnr|person[_ ]?id).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "person_no"
        ],
        "negativeExamples": [
          "product_number"
        ]
      },
      {
        "regExp": "(?i).*(identity|national[_ ]id|citizen[_ ]id|gov[_ ]id).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "identity"
        ],
        "negativeExamples": [
          "invoice_id"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "19900115-1234",
      "19850730+5678",
      "20011201-0042",
      "850101-2390",
      "7406301234",
      "20191231+0007",
      "19740306-1111",
      "9901011230"
    ],
    "negativeContentExamples": [
      "19901315-1234",
      "20191232-0007",
      "20190015-6789",
      "2019011-1234",
      "20011201_0042",
      "85-0101-2390",
      "990131+12A4",
      "19740306 1111"
    ],
    "positiveHeaderExamples": [
      "personnummer",
      "se_person_number",
      "personal_identity_number_se",
      "swedish_id",
      "national_id_se",
      "person_no",
      "persnr",
      "person_id"
    ],
    "negativeHeaderExamples": [
      "invoice_code",
      "customer_id",
      "passport_id",
      "employee_count",
      "account_ref",
      "tax_code",
      "order_id",
      "iban"
    ],
    "explanation": "This semantic type detects Swedish personal identity numbers (personnummer). It recognizes 10-digit and 12-digit variants with optional century, and an optional single separator of hyphen or plus. The pattern enforces valid month (01\u201312) and day (01\u201331) formats and disallows spaces or non-digit characters in the numeric parts.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:30.960892"
  },
  {
    "resultType": "generated",
    "semanticType": "MONTH.DIGITS",
    "description": "calendar_month: number from 1-12 representing month of year",
    "pluginType": "regex",
    "regexPattern": "\\b(0?[1-9]|1[0-2])\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4810,
    "headerPatterns": [
      {
        "regExp": "(?i).*calendar.*month.*num.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "calendar_month_num"
        ],
        "negativeExamples": [
          "calendar_week_num"
        ]
      },
      {
        "regExp": "(?i).*month[_\\s-]?number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "month_number"
        ],
        "negativeExamples": [
          "month_name"
        ]
      },
      {
        "regExp": "(?i).*month[_\\s-]?(no|num).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "month_no"
        ],
        "negativeExamples": [
          "month_text"
        ]
      },
      {
        "regExp": "(?i).*(mth|mnth|mo)[_\\s-]?(num|no|#).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mth_num"
        ],
        "negativeExamples": [
          "mo_name"
        ]
      },
      {
        "regExp": "(?i).*month.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "month"
        ],
        "negativeExamples": [
          "date"
        ]
      }
    ],
    "positiveContentExamples": [
      "1",
      "2",
      "9",
      "10",
      "12",
      "07",
      "03",
      "11"
    ],
    "negativeContentExamples": [
      "0",
      "13",
      "00",
      "1.0",
      "012",
      "5th",
      "1/12",
      "Jan"
    ],
    "positiveHeaderExamples": [
      "calendar_month_num",
      "month_number",
      "month_no",
      "month_digits",
      "mth_num",
      "mnth_no",
      "month_index",
      "mo_num"
    ],
    "negativeHeaderExamples": [
      "month_name",
      "calendar_week_num",
      "day_number",
      "minute",
      "quarter_number",
      "fiscal_quarter",
      "weekday_number",
      "date"
    ],
    "explanation": "Identifies numeric month values using one or two digits, allowing optional leading zero and restricting the range to 1\u201312. Useful for columns that store the month of year as integers rather than text labels.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:32.104552"
  },
  {
    "resultType": "generated",
    "semanticType": "GENDER.TEXT_ZH",
    "description": "\u6027\u522b_\u4e2d\u6587: Chinese language gender identification",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "\u7537",
      "\u5973",
      "\u7537\u6027",
      "\u5973\u6027",
      "\u7537\u58eb",
      "\u5973\u58eb",
      "\u7537\u751f",
      "\u5973\u751f",
      "\u5176\u4ed6",
      "\u672a\u77e5",
      "\u4fdd\u5bc6",
      "\u672a\u8bf4\u660e",
      "\u672a\u6307\u5b9a",
      "\u4e0d\u900f\u9732"
    ],
    "backout": "^[\\u4e00-\\u9fff]{1,4}$",
    "confidenceThreshold": 93,
    "priority": 4510,
    "headerPatterns": [
      {
        "regExp": "(?i).*(gender|sex).*(text|label).*(zh|cn|\u4e2d\u6587).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "sex_label_cn"
        ],
        "negativeExamples": [
          "gender_code_zh"
        ]
      },
      {
        "regExp": "(?i).*(gender|sex).*(zh|cn|\u4e2d\u6587).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gender_zh"
        ],
        "negativeExamples": [
          "gender_text_en"
        ]
      },
      {
        "regExp": "(?i).*(xingbie|xb|gndr|sx).*(zh|cn|\u4e2d\u6587).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "xb_label_zh"
        ],
        "negativeExamples": [
          "gndr_code"
        ]
      },
      {
        "regExp": "(?i).*(xingbie|xb|gndr|sx).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "user_xingbie"
        ],
        "negativeExamples": [
          "user_gender"
        ]
      },
      {
        "regExp": "(?i).*gender.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gender"
        ],
        "negativeExamples": [
          "sex"
        ]
      }
    ],
    "positiveContentExamples": [
      "\u7537",
      "\u5973",
      "\u7537\u6027",
      "\u5973\u6027",
      "\u7537\u58eb",
      "\u5973\u58eb",
      "\u5176\u4ed6",
      "\u4fdd\u5bc6"
    ],
    "negativeContentExamples": [
      "\u6027\u522b",
      "\u7537/\u5973",
      "\u5973-\u6027",
      "\u7537\u60271",
      "\u5973\u5b9d\u5b9d",
      "\u7537\u5b69",
      "\u5973\u6027(\u5973)",
      "\u5973 \u6027"
    ],
    "positiveHeaderExamples": [
      "gender_text_zh",
      "sex_label_cn",
      "\u6027\u522b_\u4e2d\u6587",
      "customer_gender_zh",
      "user_sex_text_cn",
      "gender_label_\u4e2d\u6587",
      "zh_gender",
      "applicant_xingbie_cn"
    ],
    "negativeHeaderExamples": [
      "gender_code",
      "sex_id",
      "gender_en",
      "\u6027\u522b\u4ee3\u7801",
      "customer_gender_numeric",
      "gender_description",
      "zh_language",
      "user_title_zh"
    ],
    "explanation": "This semantic type identifies Chinese-language gender values commonly found in datasets, including concise forms (\u7537/\u5973) and descriptive forms (\u7537\u6027/\u5973\u6027), as well as typical placeholders like \u5176\u4ed6, \u672a\u77e5, \u4fdd\u5bc6. It is intended for columns where the data values are Chinese text labels denoting gender rather than codes or numeric representations.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:32.559408"
  },
  {
    "resultType": "generated",
    "semanticType": "LANGUAGE.ISO-639-2",
    "description": "language_id: 3-letter extended international language code",
    "pluginType": "regex",
    "regexPattern": "\\b[a-z]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4770,
    "headerPatterns": [
      {
        "regExp": "(?i).*language.*iso[_ -]?639[_ -]?2.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "language_iso639_2_code"
        ],
        "negativeExamples": [
          "iso_639_1_language"
        ]
      },
      {
        "regExp": "(?i).*iso[_ -]?639[_ -]?2.*lang.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iso6392_lang_code"
        ],
        "negativeExamples": [
          "iso6391_lang"
        ]
      },
      {
        "regExp": "(?i).*language.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "language_code"
        ],
        "negativeExamples": [
          "language_name"
        ]
      },
      {
        "regExp": "(?i).*(lang|lng).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lng_code"
        ],
        "negativeExamples": [
          "lang_id"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "eng",
      "spa",
      "fra",
      "deu",
      "zho",
      "jpn",
      "rus",
      "ara"
    ],
    "negativeContentExamples": [
      "en",
      "ENG",
      "eng-US",
      "zho1",
      "rus-",
      "spa_ES",
      "por-PT",
      "fr"
    ],
    "positiveHeaderExamples": [
      "language_iso639_2_code",
      "iso6392_lang_code",
      "language_code",
      "lang_code",
      "iso-639-2_language_code",
      "iso 639 2 code",
      "language three letter code",
      "three_letter_language_code"
    ],
    "negativeHeaderExamples": [
      "iso_639_1_code",
      "language_name",
      "locale",
      "country_code",
      "lang",
      "language_id",
      "iso-code",
      "script_code"
    ],
    "explanation": "This semantic type represents ISO 639-2 three-letter language codes as lowercase alphabetic tokens. It is useful for columns storing standardized language identifiers where values are expected to be exactly three lowercase letters, commonly used in multilingual datasets and metadata fields.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:35.628026"
  },
  {
    "resultType": "generated",
    "semanticType": "HASH.SHA256_HEX",
    "description": "secure_hash: 64-character SHA-256 cryptographic digest represented as a contiguous hexadecimal string (0-9, a-f, A-F), with no prefixes or separators.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9A-Fa-f]{64}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4540,
    "headerPatterns": [
      {
        "regExp": "(?i).*(sha[-_ ]?256).*(hash|digest).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "user_sha256_hash"
        ],
        "negativeExamples": [
          "user_sha1_hash"
        ]
      },
      {
        "regExp": "(?i).*sha[-_ ]?256.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "sha-256"
        ],
        "negativeExamples": [
          "sha1_hash"
        ]
      },
      {
        "regExp": "(?i).*(sha[-_ ]?2|sha2).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "sha2_digest"
        ],
        "negativeExamples": [
          "md5_hash"
        ]
      },
      {
        "regExp": "(?i).*(cryptographic|secure).*hash.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "secure_hash"
        ],
        "negativeExamples": [
          "secure_token"
        ]
      },
      {
        "regExp": "(?i).*hash.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "hash"
        ],
        "negativeExamples": [
          "checksum"
        ]
      }
    ],
    "positiveContentExamples": [
      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08",
      "A1B2C3D4E5F60718A9BACBDCEDFE00112233445566778899AABBCCDDEEFF0011",
      "0f1e2d3c4b5a69788796a5b4c3d2e1f0098a7b6c5d4e3f201122334455667788",
      "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF",
      "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
      "d5579c46dfcc7d0d6b0d23f9c8075fdee741c6aab1a1b92e9b3d6f8401b5f90b",
      "abf7c1e92d3a4c5b6e7f8091a2b3c4d5e6f708192a3b4c5d6e7f8091a2b3c4d5"
    ],
    "negativeContentExamples": [
      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b85",
      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855a",
      "0x9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08",
      "e3b0c442-98fc-1c14-9afb-f4c8996fb92427ae41e4649b934ca495991b7852b855",
      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b85g",
      "47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=",
      "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX",
      "5d41402abc4b2a76b9719d911017c592"
    ],
    "positiveHeaderExamples": [
      "sha256_hash",
      "sha256",
      "sha2_hash",
      "secure_hash",
      "user_sha256_digest",
      "transaction_sha256",
      "file_digest_sha256",
      "event_hash"
    ],
    "negativeHeaderExamples": [
      "md5",
      "sha1",
      "checksum",
      "signature",
      "token",
      "uuid",
      "file_id",
      "transaction_id"
    ],
    "explanation": "This semantic type identifies SHA-256 cryptographic digests encoded as 64 contiguous hexadecimal characters with no prefixes (e.g., 0x) and no separators. It is useful for classifying fields containing secure hashes of content, identifiers, or other data where a strong fixed-length hex digest is expected.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:38.632415"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.FIRST_LAST",
    "description": "Full name consisting of a given (first) name followed by a family (last) name separated by a single space. Each token may include letters with diacritics, internal hyphens, or apostrophes, but no digits or extra words.",
    "pluginType": "regex",
    "regexPattern": "\\b\\p{L}[\\p{L}'\u2019\\-]{1,40} \\p{L}[\\p{L}'\u2019\\-]{1,40}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4840,
    "headerPatterns": [
      {
        "regExp": "(?i).*(first[ _-]?name[ _-]?last[ _-]?name|first[ _-]?last|full[ _-]?name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "first_last_name"
        ],
        "negativeExamples": [
          "first_name"
        ]
      },
      {
        "regExp": "(?i).*(customer|client|employee|user|applicant|person|contact)[ _-]*(full[ _-]?name|name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "employee_full_name"
        ],
        "negativeExamples": [
          "employee_number"
        ]
      },
      {
        "regExp": "(?i).*(cust|emp|usr|app|prsn|cntct)[ _-]*(full[ _-]?nm|name|nm).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cust_nm"
        ],
        "negativeExamples": [
          "emp_no"
        ]
      },
      {
        "regExp": "(?i).*(primary|main)[ _-]*contact[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "primary_contact_name"
        ],
        "negativeExamples": [
          "contact_phone"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "timestamp"
        ]
      }
    ],
    "positiveContentExamples": [
      "John Smith",
      "Mar\u00eda L\u00f3pez",
      "Jean-Luc Picard",
      "O\u2019Connor O\u2019Brien",
      "Mary-Jane Watson",
      "Jo\u00e3o Silva",
      "D'Arcy Wendt",
      "Ren\u00e9e Faure"
    ],
    "negativeContentExamples": [
      "John A. Smith",
      "Smith, John",
      "John  Smith",
      "J Smith",
      "John",
      "Mary Jane Watson",
      "O'Neill",
      "John Doe2"
    ],
    "positiveHeaderExamples": [
      "full_name",
      "first_last_name",
      "customer_name",
      "employee_full_name",
      "contact_name",
      "user_name",
      "person_name",
      "applicant_full_name"
    ],
    "negativeHeaderExamples": [
      "customer_id",
      "email",
      "phone_number",
      "address",
      "birth_date",
      "company",
      "employee_number",
      "user_id"
    ],
    "explanation": "This semantic type targets records where a person's first and last names appear as exactly two tokens separated by a single space. It is intended for human personal names, allowing internal apostrophes and hyphens in each token, and excluding additional middle names/initials, commas, multiple spaces, and any digits. Typical uses include validating or classifying columns labeled as full names in CRMs, HR systems, or sign-up forms.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:38.694270"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.NPI_US",
    "description": "provider_code: 10-digit US healthcare professional identifier. Values are 10 numeric digits with a leading 1 or 2 and no separators or formatting.",
    "pluginType": "regex",
    "regexPattern": "\\b[12][0-9]{9}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4640,
    "headerPatterns": [
      {
        "regExp": "(?i).*(national.*provider.*identifier).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "national_provider_identifier_number"
        ],
        "negativeExamples": [
          "provider_identifier_number"
        ]
      },
      {
        "regExp": "(?i).*(provider|practitioner|physician).*npi.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "provider_npi"
        ],
        "negativeExamples": [
          "provider_id"
        ]
      },
      {
        "regExp": "(?i).*(npi|national.*provider).*identifier.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "npi_identifier"
        ],
        "negativeExamples": [
          "provider_identifier"
        ]
      },
      {
        "regExp": "(?i).*\\bnpi\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "npi"
        ],
        "negativeExamples": [
          "np_id"
        ]
      },
      {
        "regExp": "(?i).*(provider|practitioner|physician).*identifier.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "provider_identifier"
        ],
        "negativeExamples": [
          "provider_city"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "status"
        ]
      }
    ],
    "positiveContentExamples": [
      "1423587689",
      "1540098731",
      "1992038475",
      "2123456789",
      "2239081765",
      "2615048392",
      "2076543219",
      "1789054321"
    ],
    "negativeContentExamples": [
      "3123456789",
      "123456789",
      "21034567890",
      "1 234567890",
      "1-234-567-890",
      "0012345678",
      "2O13456789",
      "2,013,456,789"
    ],
    "positiveHeaderExamples": [
      "npi",
      "npi_number",
      "provider_npi",
      "npi_id",
      "national_provider_identifier",
      "us_npi_code",
      "physician_npi"
    ],
    "negativeHeaderExamples": [
      "provider_id",
      "npi_status",
      "provider_taxonomy_code",
      "national_provider_name",
      "error_code",
      "provider_npi_flag",
      "physician_license_number",
      "tax_id"
    ],
    "explanation": "This semantic type detects US National Provider Identifier (NPI) values, which are 10-digit numeric identifiers assigned to healthcare providers. The pattern enforces a leading 1 or 2 and exactly 10 digits with no separators. It is intended for fields where the data consists solely of the NPI code, supported by strong header signals such as 'npi', 'provider_npi', or 'national_provider_identifier'. Use this type to classify columns containing NPI codes and to distinguish them from other identifiers or general numeric fields.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:39.617051"
  },
  {
    "resultType": "generated",
    "semanticType": "INDUSTRY_EN",
    "description": "business_sector: descriptive name of primary economic activity",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AGRICULTURE, FORESTRY AND FISHING",
      "MINING, QUARRYING AND OIL AND GAS EXTRACTION",
      "UTILITIES",
      "CONSTRUCTION",
      "MANUFACTURING",
      "WHOLESALE TRADE",
      "RETAIL TRADE",
      "TRANSPORTATION AND WAREHOUSING",
      "INFORMATION",
      "FINANCE AND INSURANCE",
      "REAL ESTATE AND RENTAL AND LEASING",
      "PROFESSIONAL, SCIENTIFIC AND TECHNICAL SERVICES",
      "MANAGEMENT OF COMPANIES AND ENTERPRISES",
      "ADMINISTRATIVE AND SUPPORT SERVICES",
      "EDUCATIONAL SERVICES",
      "HEALTH CARE AND SOCIAL ASSISTANCE",
      "ARTS, ENTERTAINMENT AND RECREATION",
      "ACCOMMODATION AND FOOD SERVICES",
      "PUBLIC ADMINISTRATION",
      "OTHER SERVICES (EXCEPT PUBLIC ADMINISTRATION)"
    ],
    "backout": "^[A-Z][A-Z ,&/()\\-]{2,70}$",
    "confidenceThreshold": 98,
    "priority": 4720,
    "headerPatterns": [
      {
        "regExp": "(?i).*primary.*industry.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "primary_industry_name"
        ],
        "negativeExamples": [
          "industry_code"
        ]
      },
      {
        "regExp": "(?i).*business.*sector.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "business_sector_name"
        ],
        "negativeExamples": [
          "business_sector_code"
        ]
      },
      {
        "regExp": "(?i).*(industry|sector).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "sector_name"
        ],
        "negativeExamples": [
          "segment_name"
        ]
      },
      {
        "regExp": "(?i).*(primary|main).*(industry|sector).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "main_industry"
        ],
        "negativeExamples": [
          "product_category"
        ]
      },
      {
        "regExp": "(?i).*(economic|econ).*(sector|activity).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "primary_economic_activity"
        ],
        "negativeExamples": [
          "economic_indicator"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "industry_name"
        ],
        "negativeExamples": [
          "industry_code"
        ]
      }
    ],
    "positiveContentExamples": [
      "MANUFACTURING",
      "FINANCE AND INSURANCE",
      "RETAIL TRADE",
      "AGRICULTURE, FORESTRY AND FISHING",
      "TRANSPORTATION AND WAREHOUSING",
      "HEALTH CARE AND SOCIAL ASSISTANCE",
      "INFORMATION",
      "PUBLIC ADMINISTRATION"
    ],
    "negativeContentExamples": [
      "MANUFACTURING SECTOR",
      "BANKING",
      "RETAIL",
      "GOVERNMENT",
      "HEALTHCARE",
      "OIL AND GAS",
      "PROFESSIONAL SERVICES",
      "REAL ESTATE"
    ],
    "positiveHeaderExamples": [
      "primary_industry_name",
      "business_sector_name",
      "industry_en",
      "primary_economic_activity",
      "sector_name",
      "main_industry",
      "industry_name",
      "industry_sector_name"
    ],
    "negativeHeaderExamples": [
      "industry_code",
      "naics_code",
      "business_sector_code",
      "company_name",
      "customer_segment",
      "product_category",
      "department_name",
      "segment_name"
    ],
    "explanation": "This semantic type captures the English descriptive name of an organization's primary industry or business sector (e.g., Manufacturing, Finance and Insurance). It is intended for datasets that store standardized, top-level sector names rather than coded classifications. The list enumerates common high-level sectors; the backout pattern provides a safety net for validation of the general shape.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:45.456676"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.FIRST",
    "description": "given_name: primary personal identifier assigned at birth",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z][A-Za-z]+([ '-][A-Za-z][A-Za-z]+){0,2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4830,
    "headerPatterns": [
      {
        "regExp": "(?i).*((first|given)[ _-]*name|name[ _-]*(first|given)).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "first_name"
        ],
        "negativeExamples": [
          "full_name"
        ]
      },
      {
        "regExp": "(?i).*(person|user|customer|contact)[ _-]*(first|given)[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "person_first_name"
        ],
        "negativeExamples": [
          "customer_last_name"
        ]
      },
      {
        "regExp": "(?i).*(fname|gname|first[ _-]*nm|given[ _-]*nm).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fname"
        ],
        "negativeExamples": [
          "lname"
        ]
      },
      {
        "regExp": "(?i).*((primary|preferred)[ _-]*(first|given)[ _-]*name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "primary_given_name"
        ],
        "negativeExamples": [
          "preferred_full_name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "title"
        ]
      }
    ],
    "positiveContentExamples": [
      "Maria",
      "Jean-Luc",
      "De'Andre",
      "Ana Maria",
      "Mary Jane",
      "Li",
      "Paolo",
      "Siu Ming"
    ],
    "negativeContentExamples": [
      "J",
      "A.B.",
      "J-M",
      "Mc'D",
      "Anne_Marie",
      "Maria!",
      "Mary-J",
      "2Pac"
    ],
    "positiveHeaderExamples": [
      "first_name",
      "given_name",
      "fname",
      "person_first_name",
      "customer_givenname",
      "name_first",
      "user_fname",
      "primary_given_name"
    ],
    "negativeHeaderExamples": [
      "last_name",
      "surname",
      "middle_name",
      "full_name",
      "company_name",
      "username",
      "maiden_name",
      "contact_name"
    ],
    "explanation": "This semantic type identifies personal given names (first names), allowing alphabetic tokens with optional hyphens or apostrophes and up to three tokens to support common multi-part given names. It excludes initials-only values, numeric or symbol-heavy strings, and underscores, aiming to capture realistic first-name data used for person identification.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:46.385017"
  },
  {
    "resultType": "generated",
    "semanticType": "MONTH.FULL_<LOCALE>",
    "description": "Full month name in English (e.g., January, February). Represents the complete month designation in the specified language (here: English, locale EN).",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "JANUARY",
      "FEBRUARY",
      "MARCH",
      "APRIL",
      "MAY",
      "JUNE",
      "JULY",
      "AUGUST",
      "SEPTEMBER",
      "OCTOBER",
      "NOVEMBER",
      "DECEMBER"
    ],
    "backout": "^[A-Z]{3,9}$",
    "confidenceThreshold": 98,
    "priority": 4820,
    "headerPatterns": [
      {
        "regExp": "(?i).*full.*month.*name.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "full_month_name"
        ],
        "negativeExamples": [
          "month_name"
        ]
      },
      {
        "regExp": "(?i).*month.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "calendar_month_name"
        ],
        "negativeExamples": [
          "month_number"
        ]
      },
      {
        "regExp": "(?i).*mnth.*name.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "mnth_name"
        ],
        "negativeExamples": [
          "mnth_code"
        ]
      },
      {
        "regExp": "(?i).*mo.*name.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "mo_name"
        ],
        "negativeExamples": [
          "mo_code"
        ]
      },
      {
        "regExp": "(?i).*month.*",
        "confidence": 91,
        "mandatory": true,
        "positiveExamples": [
          "month"
        ],
        "negativeExamples": [
          "weekday"
        ]
      }
    ],
    "positiveContentExamples": [
      "January",
      "FEBRUARY",
      "March",
      "April",
      "MAY",
      "June",
      "July",
      "AUGUST"
    ],
    "negativeContentExamples": [
      "Jan",
      "Sept",
      "January 2024",
      "Oct.",
      "Febrary",
      "January-",
      "Jan uary",
      "Septembre"
    ],
    "positiveHeaderExamples": [
      "full_month_name",
      "month_full_name",
      "calendar_month_name",
      "fullmonthname",
      "monthname_full",
      "complete_month_name",
      "calendar_full_month_name",
      "month_name"
    ],
    "negativeHeaderExamples": [
      "mnth_abbr",
      "mo_abbr",
      "weekday_name",
      "calendar_quarter",
      "season_name",
      "mth_name",
      "mon_name",
      "year_name"
    ],
    "explanation": "This semantic type identifies full English month names. It is suitable for columns storing month labels as complete words rather than abbreviations or numeric codes, such as report labels, calendar dimensions, and time-series metadata.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:48.861770"
  },
  {
    "resultType": "generated",
    "semanticType": "LANGUAGE.ISO-639-1",
    "description": "lang_code: 2-letter international language identifier",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4760,
    "headerPatterns": [
      {
        "regExp": "(?i).*iso.*639.*1.*language.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "ISO 639-1 Language Code"
        ],
        "negativeExamples": [
          "Language code"
        ]
      },
      {
        "regExp": "(?i).*language.*iso.*639.*1.*code.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Language ISO 639-1 Code"
        ],
        "negativeExamples": [
          "ISO 639-2 Language Code"
        ]
      },
      {
        "regExp": "(?i).*language.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Language Code"
        ],
        "negativeExamples": [
          "Language Name"
        ]
      },
      {
        "regExp": "(?i).*lang.*code.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "lang_code"
        ],
        "negativeExamples": [
          "lang_name"
        ]
      },
      {
        "regExp": "(?i).*default.*language.*code.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Default Language Code"
        ],
        "negativeExamples": [
          "Default Locale"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "en",
      "EN",
      "fr",
      "ES",
      "de",
      "zh",
      "ar",
      "ja"
    ],
    "negativeContentExamples": [
      "en-US",
      "eng",
      "e",
      "EN1",
      "e1",
      "pt_BR",
      "zh-Hans",
      "fr-CA"
    ],
    "positiveHeaderExamples": [
      "ISO 639-1 Language Code",
      "Language ISO 639-1 Code",
      "Language Code",
      "lang_code",
      "Language (ISO 639-1)",
      "UI Language Code",
      "Default Language Code"
    ],
    "negativeHeaderExamples": [
      "Country Code",
      "ISO 639-2 Language Code",
      "Language Name",
      "Locale",
      "Region Code",
      "Dialect Code",
      "Timezone"
    ],
    "explanation": "This semantic type identifies 2-letter ISO 639-1 language codes as standalone tokens in data fields. It is useful for classifying language identifiers in datasets, configuration values, and user preferences where standardized two-letter language codes are stored.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:50.636780"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.AGE",
    "description": "years_old: numerical age in completed years since birth. Values are whole numbers representing full years only.",
    "pluginType": "regex",
    "regexPattern": "\\b(0|[1-9][0-9]|1[01][0-9]|120)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 4950,
    "headerPatterns": [
      {
        "regExp": "(?i).*(years[ _]?old|age[ _]?in[ _]?years|age[ _]?years|age[ _]?yrs).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "age_in_years"
        ],
        "negativeExamples": [
          "age_months"
        ]
      },
      {
        "regExp": "(?i).*(person|patient|customer|user|member)[ _]?age.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "person_age"
        ],
        "negativeExamples": [
          "customer_birth_year"
        ]
      },
      {
        "regExp": "(?i).*age[ _]?(yrs|yr).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "age_yrs"
        ],
        "negativeExamples": [
          "age_years"
        ]
      },
      {
        "regExp": "(?i).*\\bage\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "age"
        ],
        "negativeExamples": [
          "age_group"
        ]
      }
    ],
    "positiveContentExamples": [
      "0",
      "4",
      "16",
      "21",
      "45",
      "67",
      "100",
      "120"
    ],
    "negativeContentExamples": [
      "121",
      "-1",
      "34.5",
      "09",
      "100 years",
      "65y",
      "1 2",
      "000"
    ],
    "positiveHeaderExamples": [
      "age_years",
      "person_age",
      "years_old",
      "age_yrs",
      "patient_age",
      "age_in_years",
      "user_age"
    ],
    "negativeHeaderExamples": [
      "date_of_birth",
      "tenure_years",
      "service_years",
      "age_months",
      "age_group",
      "birth_year",
      "experience_years"
    ],
    "explanation": "This semantic type identifies a person's age expressed as an integer number of completed years, typically ranging from 0 to 120. It is intended for datasets where the age value is stored as a whole number without units or fractional components.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:51.117360"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.RACE_ABBR_EN",
    "description": "ethnicity_code: abbreviated racial or ethnic category identifier. Uppercase English abbreviations representing race or ethnicity, typically 2\u20135 letters (e.g., WHT, BLK, ASN).",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "WHT",
      "BLK",
      "ASN",
      "HISP",
      "LAT",
      "AIAN",
      "NHPI",
      "MIX",
      "MLT",
      "OTH",
      "UNK",
      "REF",
      "NDS",
      "TWO",
      "MENA"
    ],
    "backout": "^[A-Z]{2,5}$",
    "confidenceThreshold": 97,
    "priority": 4990,
    "headerPatterns": [
      {
        "regExp": "(?i).*race.*ethnicity.*code.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "race_ethnicity_code"
        ],
        "negativeExamples": [
          "ethnicity_race"
        ]
      },
      {
        "regExp": "(?i).*(ethnicity|race).*(abbr|abbrev|abbreviation|cd).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "ethnicity_abbr"
        ],
        "negativeExamples": [
          "race_group"
        ]
      },
      {
        "regExp": "(?i).*(race|ethnicity).*code.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "race_code"
        ],
        "negativeExamples": [
          "ethnicity_name"
        ]
      },
      {
        "regExp": "(?i).*(eth|ethn|race).*cd.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "eth_cd"
        ],
        "negativeExamples": [
          "eth_label"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "WHT",
      "BLK",
      "ASN",
      "HISP",
      "AIAN",
      "NHPI",
      "OTH",
      "UNK"
    ],
    "negativeContentExamples": [
      "WHITE",
      "BLACK",
      "ASIAN",
      "LATIN",
      "AIA",
      "NHP",
      "OTHER",
      "UNKN"
    ],
    "positiveHeaderExamples": [
      "ethnicity_code",
      "race_code",
      "race_ethnicity_code",
      "ethnicity_abbr",
      "race_abbreviation",
      "eth_cd",
      "race_eth_cd",
      "ethnicity_cd"
    ],
    "negativeHeaderExamples": [
      "ethnicity_name",
      "race_category",
      "demographic_group",
      "race_desc",
      "ethn_label",
      "race_type",
      "group_name",
      "age_group"
    ],
    "explanation": "This semantic type identifies English-language abbreviated race/ethnicity codes stored as short uppercase tokens. Use when columns contain standardized abbreviations rather than full descriptive labels. The list-based approach ensures precise matching to known abbreviations, with a backout pattern for shape-based fallback in uncertain contexts.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:53.214079"
  },
  {
    "resultType": "generated",
    "semanticType": "PERIOD.YEAR_RANGE",
    "description": "A pair of four-digit years indicating the start and end of a time span (e.g., 1999-2003, 2010 to 2012). Accepts common separators such as hyphen, en/em dash, slash, or the words 'to'/'through' with optional surrounding spaces. Intended for fields capturing durations expressed strictly as two years.",
    "pluginType": "regex",
    "regexPattern": "\\b(1[6-9][0-9]{2}|20[0-9]{2}|21[0-9]{2})\\b\\s*(\\-|\u2013|\u2014|/|\\s+to\\s+|\\s+through\\s+)\\s*\\b(1[6-9][0-9]{2}|20[0-9]{2}|21[0-9]{2})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 4940,
    "headerPatterns": [
      {
        "regExp": "(?i).*(fiscal|coverage|contract|service|employment).*year.*(range|span|period).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "fiscal_year_range"
        ],
        "negativeExamples": [
          "fiscal_year_code"
        ]
      },
      {
        "regExp": "(?i).*(start|begin).*year.*(end|finish).*year.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "start_year_end_year"
        ],
        "negativeExamples": [
          "start_month_end_month"
        ]
      },
      {
        "regExp": "(?i).*(period|duration|time[_ ]?span).*(year|years).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "duration_years"
        ],
        "negativeExamples": [
          "billing_period_days"
        ]
      },
      {
        "regExp": "(?i).*y(rs?|ear[s]?).*(range|rng|span|period).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "yrs_range"
        ],
        "negativeExamples": [
          "yr_count"
        ]
      },
      {
        "regExp": "(?i).*year.*range.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "year_range"
        ],
        "negativeExamples": [
          "date_range"
        ]
      }
    ],
    "positiveContentExamples": [
      "1999-2003",
      "2001 \u2013 2004",
      "2010 to 2012",
      "1987/1990",
      "2020 \u2014 2021",
      "1600-1699",
      "2099\u20132101",
      "1890 through 1895"
    ],
    "negativeContentExamples": [
      "1999-03",
      "99-2003",
      "2010 to 10",
      "201A\u2013201B",
      "FY2018-2019",
      "300-400",
      "2010-",
      "2099 until 2101"
    ],
    "positiveHeaderExamples": [
      "year_range",
      "fiscal_year_range",
      "employment_years_range",
      "contract_period_years",
      "duration_years",
      "start_year_end_year",
      "coverage_year_span",
      "service_year_period"
    ],
    "negativeHeaderExamples": [
      "year",
      "years",
      "date_range",
      "age_range",
      "fiscal_year",
      "period",
      "coverage_range",
      "start_year"
    ],
    "explanation": "This semantic type captures two four-digit years representing a duration, allowing separators such as hyphen, en/em dash, slash, or the words 'to'/'through'. It is useful for coverage periods, contract durations, and fiscal year spans where only start and end years are present. The pattern is constrained to recognizable year ranges to avoid confusion with general ranges or single-year fields.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:55.081705"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.LAST",
    "description": "family_name: inherited surname identifying family lineage",
    "pluginType": "regex",
    "regexPattern": "\\b[\\p{L}]+(['-][\\p{L}]+)*( [\\p{L}]+(['-][\\p{L}]+)*){0,2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4850,
    "headerPatterns": [
      {
        "regExp": "(?i).*(customer|employee|user|applicant|patient)[_ -]?last[_ -]?name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_last_name"
        ],
        "negativeExamples": [
          "customer_first_name"
        ]
      },
      {
        "regExp": "(?i).*(customer|employee|user|applicant|patient).*(surname|family[_ -]?name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "employee_surname"
        ],
        "negativeExamples": [
          "employee_id"
        ]
      },
      {
        "regExp": "(?i).*(surname|family[_ -]?name|last[_ -]?name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "family_name"
        ],
        "negativeExamples": [
          "last_login"
        ]
      },
      {
        "regExp": "(?i).*(last[_ -]?nm|lastnm|ln)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ln"
        ],
        "negativeExamples": [
          "login"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "email"
        ]
      }
    ],
    "positiveContentExamples": [
      "Smith",
      "O'Connor",
      "Garc\u00eda",
      "Nguyen",
      "van der Meer",
      "de la Cruz",
      "Smith-Jones",
      "Li"
    ],
    "negativeContentExamples": [
      "Smith, John",
      "J. Smith",
      "O''Connor",
      "van  der Meer",
      "O\u2019Connor",
      "D\u2019Amico",
      "L\u00f3pez.",
      "van der Meer IV"
    ],
    "positiveHeaderExamples": [
      "last_name",
      "surname",
      "family_name",
      "customer_last_name",
      "employee_surname",
      "applicant_family_name",
      "ln"
    ],
    "negativeHeaderExamples": [
      "first_name",
      "given_name",
      "full_name",
      "middle_name",
      "username",
      "last_login",
      "family_id"
    ],
    "explanation": "Represents a person's last name (surname), typically inherited and used to identify family lineage. Supports common constructions such as hyphenated names and internal apostrophes, and multi-token surnames with up to three words (e.g., 'de la Cruz', 'van der Meer'). Best used for columns explicitly storing only the family/surname portion of a person's name.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:55.398146"
  },
  {
    "resultType": "generated",
    "semanticType": "HASH.SHA1_HEX",
    "description": "hash_digest: 40-character SHA-1 cryptographic fingerprint represented as contiguous hexadecimal characters (0-9, a-f) in any case. No separators, prefixes, or whitespace are allowed; exactly 40 hex characters.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9A-Fa-f]{40}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4530,
    "headerPatterns": [
      {
        "regExp": "(?i).*(sha[\\s_-]?1).*(digest|hash|fingerprint|sum).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "sha1_digest"
        ],
        "negativeExamples": [
          "sha256_digest"
        ]
      },
      {
        "regExp": "(?i).*(sha[\\s_-]?1).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "file_sha1"
        ],
        "negativeExamples": [
          "file_sha256"
        ]
      },
      {
        "regExp": "(?i).*(sha1sum|shasum).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "sha1sum"
        ],
        "negativeExamples": [
          "md5sum"
        ]
      },
      {
        "regExp": "(?i).*(checksum|fingerprint|digest).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "file_fingerprint"
        ],
        "negativeExamples": [
          "signature"
        ]
      },
      {
        "regExp": "(?i).*hash.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "hash"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "da39a3ee5e6b4b0d3255bfef95601890afd80709",
      "2fd4e1c67a2d28fced849ee1bb76e7391b93eb12",
      "0beec7b5ea3f0fdbc95d0dd47f3c5bc275da8a33",
      "A9993E364706816ABA3E25717850C26C9CD0D89D",
      "8F14E45FCEEA167A5A36DEB2CFBEBF7E4254D7F0",
      "1f3870be274f6c49b3e31a0c6728957f5d7fe5bb",
      "9c1185a5c5e9fc54612808977ee8f548b2258d31",
      "3F786850E387550FDAB836ED7E6DC881DE23001B"
    ],
    "negativeContentExamples": [
      "da39a3ee5e6b4b0d3255bfef95601890afd8070",
      "da39a3ee5e6b4b0d3255bfef95601890afd80709a",
      "da39a3ee5e6b4b0d3255bfef95601890afd8-0709",
      "G9993E364706816ABA3E25717850C26C9CD0D89D",
      "da39a3ee5e6b4b0d3255bfef95601890afd8 0709",
      "9e107d9d372bb6826bd81d3542a419d6",
      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "3q2+7w==3q2+7w==3q2+7w==3q2+7w=="
    ],
    "positiveHeaderExamples": [
      "sha1_hash",
      "sha1_digest",
      "sha1sum",
      "file_sha1",
      "content_fingerprint",
      "artifact_hash",
      "checksum_sha1",
      "sha-1"
    ],
    "negativeHeaderExamples": [
      "sha256_hash",
      "md5sum",
      "uuid",
      "etag",
      "signature",
      "encryption_key",
      "token",
      "guid"
    ],
    "explanation": "Identifies SHA-1 digests encoded as exactly 40 hexadecimal characters with no separators or whitespace. Useful for classifying columns storing content-addressed identifiers, file fingerprints, or commit-like hashes where SHA-1 is used. The detection uses a strict word-bounded regex to avoid partial or over-broad matches, and header patterns prioritize explicit SHA-1 terminology before broader hash-related terms.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:55.458335"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_ES",
    "description": "Spanish postal code: exactly five consecutive digits with no separators. Intended for Spain-only postal codes; typically the first two digits correspond to province identifiers.",
    "pluginType": "regex",
    "regexPattern": "\\b(0[1-9]|[1-4][0-9]|5[0-2])[0-9]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5070,
    "headerPatterns": [
      {
        "regExp": "(?i).*(spain|es).*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "es_postal_code"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      },
      {
        "regExp": "(?i).*codigo.*postal.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "codigo_postal"
        ],
        "negativeExamples": [
          "codigo_provincia"
        ]
      },
      {
        "regExp": "(?i).*(zip).*es.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "zip_es"
        ],
        "negativeExamples": [
          "zip_us"
        ]
      },
      {
        "regExp": "(?i).*(postal|zip).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_postal_code"
        ],
        "negativeExamples": [
          "area_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "number"
        ]
      }
    ],
    "positiveContentExamples": [
      "01004",
      "08015",
      "28013",
      "46001",
      "07012",
      "35010",
      "52006",
      "51001"
    ],
    "negativeContentExamples": [
      "00000",
      "99013",
      "53001",
      "2801",
      "280130",
      "28-013",
      "28O13",
      "5100A"
    ],
    "positiveHeaderExamples": [
      "es_postal_code",
      "codigo_postal",
      "zip_es",
      "shipping_postal_code",
      "billing_postal_code",
      "customer_postal_code",
      "cp_es",
      "postal_code_spain"
    ],
    "negativeHeaderExamples": [
      "area_code",
      "country_code",
      "zip_us",
      "province_code",
      "city_name",
      "address_line1",
      "cpus",
      "postal_zone"
    ],
    "explanation": "Detects Spanish postal codes in datasets where values are five digits with province-based leading digits. Useful for validating, profiling, or standardizing address data specific to Spain and differentiating it from other countries' postal code formats.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:41:56.126997"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.MIDDLE_INITIAL",
    "description": "Single-letter abbreviation of a person's middle name; accepts an optional trailing period. Intended for tokens like \"A\" or \"A.\" only.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z]\\.??\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4880,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bmiddle[_ ]name[_ ]initial\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "middle name initial"
        ],
        "negativeExamples": [
          "middle name"
        ]
      },
      {
        "regExp": "(?i).*\\bmiddle[_ ]initial\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "middle_initial"
        ],
        "negativeExamples": [
          "first_initial"
        ]
      },
      {
        "regExp": "(?i).*\\bmiddle[_ ]initial[_ ]letter\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "middle initial letter"
        ],
        "negativeExamples": [
          "initial letter"
        ]
      },
      {
        "regExp": "(?i).*\\bm[_ ]?i\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "m_i"
        ],
        "negativeExamples": [
          "min"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "A",
      "B.",
      "c",
      "D.",
      "e",
      "F.",
      "y",
      "Z."
    ],
    "negativeContentExamples": [
      "AB",
      "A B",
      "A.B",
      "Jr",
      "3",
      "A..",
      "a1",
      "A-"
    ],
    "positiveHeaderExamples": [
      "middle_initial",
      "middle initial",
      "middle name initial",
      "mi",
      "m_i",
      "m initial",
      "middle initial letter",
      "middle name init"
    ],
    "negativeHeaderExamples": [
      "middle name",
      "first initial",
      "last_initial",
      "name",
      "initials",
      "min",
      "middle",
      "code"
    ],
    "explanation": "This semantic type identifies a single-character middle-name initial with an optional trailing period, commonly used in personal names (e.g., \"J\" or \"J.\"). It is useful for datasets that store middle initials separately from first and last names.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:00.115350"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.SUFFIX",
    "description": "Post-nominal or generational suffix appended to a person's surname, such as lineage markers (e.g., Jr., Sr., II, III, IV) or credential/honorific abbreviations (e.g., PhD, MD, Esq., CPA). This captures concise designations that follow a surname to indicate generation, qualification, or status.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(JR\\.?|SR\\.?|II|III|IV|V|VI|VII|VIII|IX|X|P\\.?H\\.?D\\.?|M\\.?D\\.?|D\\.?D\\.?S\\.?|D\\.?V\\.?M\\.?|R\\.?N\\.?|M\\.?B\\.?A\\.?|C\\.?P\\.?A\\.?|E\\.?S\\.?Q\\.?)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4890,
    "headerPatterns": [
      {
        "regExp": "(?i).*(last|sur|family).*name.*suffix.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "last_name_suffix"
        ],
        "negativeExamples": [
          "last_name_prefix"
        ]
      },
      {
        "regExp": "(?i).*name.*suffix.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name_suffix"
        ],
        "negativeExamples": [
          "name_code"
        ]
      },
      {
        "regExp": "(?i).*post[\\s_-]*nominal.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postnominal"
        ],
        "negativeExamples": [
          "pre_nominal"
        ]
      },
      {
        "regExp": "(?i).*(generation|generational).*suffix.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "generation_suffix"
        ],
        "negativeExamples": [
          "generation"
        ]
      },
      {
        "regExp": "(?i).*((name).*(sfx|gen)|(sfx|gen).*(name)).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name_gen"
        ],
        "negativeExamples": [
          "name_group"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Jr.",
      "Sr",
      "II",
      "III",
      "IV",
      "Ph.D.",
      "MD",
      "Esq."
    ],
    "negativeContentExamples": [
      "I",
      "IV.",
      "JR1",
      "Senior",
      "P H D",
      "M D",
      "Esquire",
      "IIII"
    ],
    "positiveHeaderExamples": [
      "last_name_suffix",
      "surname_suffix",
      "name_suffix",
      "postnominal",
      "generation_suffix",
      "name_gen",
      "sfx_name",
      "family_name_suffix"
    ],
    "negativeHeaderExamples": [
      "suffix",
      "generation",
      "post_prefix",
      "prefix",
      "degree",
      "honorific",
      "credential",
      "code_suffix"
    ],
    "explanation": "This semantic type detects concise post-surname suffixes that denote lineage (e.g., II, III, Jr, Sr) or credentials/honorifics (e.g., PhD, MD, Esq, CPA). It is useful when parsing or validating person name fields, particularly when suffixes are stored separately or need to be extracted from full names.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:01.560715"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.AGE_RANGE",
    "description": "age_bracket: span of years for demographic categorization",
    "pluginType": "regex",
    "regexPattern": "\\b(\\d{1,3}\\s*[-\u2013]\\s*\\d{1,3}|\\d{1,3}\\s*to\\s*\\d{1,3}|\\d{1,3}\\s*\\+|([Uu]nder|[Bb]elow)\\s*\\d{1,3}|\\d{1,3}\\s*(and\\s*over|and\\s*older|or\\s*older|plus))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4960,
    "headerPatterns": [
      {
        "regExp": "(?i).*(customer|user|member|patient|person|participant)[_\\s-]*age[_\\s-]*(range|bracket|band|bucket|group|segment).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_age_range"
        ],
        "negativeExamples": [
          "customer_age"
        ]
      },
      {
        "regExp": "(?i).*(age[_\\s-]*(range|bracket|band|bucket|group|segment)).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "age_bracket"
        ],
        "negativeExamples": [
          "age_estimate"
        ]
      },
      {
        "regExp": "(?i).*(demographic|demo)[_\\s-]*(age|ages)[_\\s-]*(range|group|band|bucket|bracket|segment).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "demographic_age_group"
        ],
        "negativeExamples": [
          "demographic_gender"
        ]
      },
      {
        "regExp": "(?i).*(age[_\\s-]*(rng|grp|band)).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "participant_age_rng"
        ],
        "negativeExamples": [
          "rng_value"
        ]
      },
      {
        "regExp": "(?i).*age.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "age"
        ],
        "negativeExamples": [
          "birthdate"
        ]
      }
    ],
    "positiveContentExamples": [
      "0-17",
      "18-24",
      "25\u201334",
      "35 to 44",
      "45 - 54",
      "55+",
      "65 and over",
      "Under 18"
    ],
    "negativeContentExamples": [
      "30",
      "18/24",
      "Under-18",
      "over 65",
      "65 or more",
      "Below eighteen",
      "18 to twenty four",
      "-24"
    ],
    "positiveHeaderExamples": [
      "customer_age_range",
      "age_bracket",
      "age_band",
      "age_group",
      "demographic_age_bucket",
      "user_age_segment",
      "participant_age_rng",
      "age"
    ],
    "negativeHeaderExamples": [
      "customer_birth_year",
      "birthdate",
      "date_of_birth",
      "gender",
      "customer_segment",
      "postal_code",
      "household_size",
      "risk_band"
    ],
    "explanation": "Represents an age bracket expressed as a numeric span or open-ended threshold, commonly used for demographic grouping (e.g., 18-24, 65+, Under 18, 65 and over). This type recognizes ranges with hyphens or the word 'to', plus-style thresholds, and common under/over phrases. Typical use cases include segmentation for analytics, reporting, and cohort analysis.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:02.075638"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_IN",
    "description": "India PIN: six digit postal identifier. Six-digit numeric code used for Indian postal addresses; first digit is non-zero, with an optional single space between the third and fourth digits.",
    "pluginType": "regex",
    "regexPattern": "\\b[1-9]\\d{2}\\s?\\d{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 5090,
    "headerPatterns": [
      {
        "regExp": "(?i).*(india|indian).*(pin|postal).*(code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "indian_postal_code"
        ],
        "negativeExamples": [
          "postal_code_uk"
        ]
      },
      {
        "regExp": "(?i).*pin.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "billing_pin_code"
        ],
        "negativeExamples": [
          "area_code"
        ]
      },
      {
        "regExp": "(?i).*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postal_code_india"
        ],
        "negativeExamples": [
          "zip_code"
        ]
      },
      {
        "regExp": "(?i).*pin.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "recipient_pin"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "110001",
      "560001",
      "400001",
      "700001",
      "600001",
      "380001",
      "411001",
      "560 001"
    ],
    "negativeContentExamples": [
      "060001",
      "56001",
      "5600001",
      "560-001",
      "560  001",
      "560001A",
      "A60001",
      "56 0001"
    ],
    "positiveHeaderExamples": [
      "indian_postal_code",
      "india_pin_code",
      "pincode",
      "pin_code",
      "postal_code_india",
      "recipient_pin",
      "postcode_in",
      "billing_pin"
    ],
    "negativeHeaderExamples": [
      "zip_code",
      "area_code",
      "country_code",
      "state_code",
      "ifsc_code",
      "gstin",
      "postal_code_uk",
      "phone_number"
    ],
    "explanation": "Detects Indian Postal Index Numbers (PIN), which are six-digit numeric postal codes used across India. Useful for validating and extracting postal codes from address fields, shipping records, and customer profiles, including variants that include a single space separator after the third digit.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:07.745132"
  },
  {
    "resultType": "generated",
    "semanticType": "IPADDRESS.IPV6",
    "description": "IPv6 address: colon-separated hexadecimal groups representing 128-bit network addresses, supporting compressed forms with double colons and variable group counts. This type targets textual representations of IPv6 without zone identifiers or embedded IPv4 segments.",
    "pluginType": "regex",
    "regexPattern": "\\b((([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){1,7}:)|(:((:[0-9A-Fa-f]{1,4}){1,7}|:))|(([0-9A-Fa-f]{1,4}:){1,6}:[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){1,5}(:[0-9A-Fa-f]{1,4}){1,2})|(([0-9A-Fa-f]{1,4}:){1,4}(:[0-9A-Fa-f]{1,4}){1,3})|(([0-9A-Fa-f]{1,4}:){1,3}(:[0-9A-Fa-f]{1,4}){1,4})|(([0-9A-Fa-f]{1,4}:){1,2}(:[0-9A-Fa-f]{1,4}){1,5})|([0-9A-Fa-f]{1,4}:((:[0-9A-Fa-f]{1,4}){1,6})))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4740,
    "headerPatterns": [
      {
        "regExp": "(?i).*(ipv6|ip6)[ _-]*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_ipv6_address"
        ],
        "negativeExamples": [
          "ipv4_address"
        ]
      },
      {
        "regExp": "(?i).*(client|server|host|device)[ _-]*(ipv6|ip6).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "client_ipv6"
        ],
        "negativeExamples": [
          "client_ip"
        ]
      },
      {
        "regExp": "(?i).*(src|source|dst|dest|destination)[ _-]*(ipv6|ip6).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "src_ipv6"
        ],
        "negativeExamples": [
          "src_ip"
        ]
      },
      {
        "regExp": "(?i).*ip[ _-]*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "device_ip_address"
        ],
        "negativeExamples": [
          "email_address"
        ]
      },
      {
        "regExp": "(?i).*ip.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ip"
        ],
        "negativeExamples": [
          "url"
        ]
      }
    ],
    "positiveContentExamples": [
      "2001:0db8:85a3:0000:0000:8a2e:0370:7334",
      "2001:db8:85a3:0:0:8a2e:370:7334",
      "fe80::1",
      "::1",
      "2001:db8::8a2e:370:7334",
      "2001:0db8:0000:0000:0000:0000:1428:57ab",
      "2001:db8:0:1:1:1:1:1",
      "fd12:3456:789a:1::1234"
    ],
    "negativeContentExamples": [
      "2001:db8:85a3:0:0:8a2e:370:7334:",
      "2001:db8:85a3:0:0:8a2e:370:7334:9",
      "2001-db8-85a3-0000-0000-8a2e-0370-7334",
      "12345::1",
      "fe80:::1",
      "::ffff:192.168.0.1",
      "g001:db8::1",
      "2001:db8:85a3::8a2e::7334"
    ],
    "positiveHeaderExamples": [
      "customer_ipv6_address",
      "client_ipv6",
      "device_ip6_address",
      "src_ipv6",
      "dst_ipv6",
      "server_ipv6",
      "ip_v6",
      "node_ipv6_addr"
    ],
    "negativeHeaderExamples": [
      "ipv4_address",
      "mac_address",
      "email",
      "url",
      "hostname",
      "subnet_mask",
      "ip_version",
      "gateway"
    ],
    "explanation": "This semantic type identifies IPv6 addresses in textual data, focusing on colon-separated hexadecimal groups and supporting compressed forms like ::1 and 2001:db8::1. It is useful for parsing logs, network telemetry, audit trails, and configuration exports where IPv6 addresses appear in various formats without zone identifiers or embedded IPv4 segments.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:08.913421"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.MIDDLE",
    "description": "middle_given_name: secondary name between first and family names",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z]\\.?)(\\s+[A-Z]\\.?)?\\b|\\b[A-Z][a-z]{2,}([-'][A-Z][a-z]{2,})?\\b|\\b[A-Z][a-z]{2,}\\s+[A-Z][a-z]{2,}\\b|\\b[A-Z]{3,15}([-'][A-Z]{3,15})?\\b|\\b[A-Z]{3,15}\\s+[A-Z]{3,15}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4870,
    "headerPatterns": [
      {
        "regExp": "(?i).*(middle[_\\s-]*given[_\\s-]*name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "middle_given_name"
        ],
        "negativeExamples": [
          "given_name"
        ]
      },
      {
        "regExp": "(?i).*(customer|employee|applicant|person)[_\\s-]*middle[_\\s-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "employee_middle_name"
        ],
        "negativeExamples": [
          "employee_last_name"
        ]
      },
      {
        "regExp": "(?i).*(middle[_\\s-]*initial|\\b(mname|mi)\\b).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "middle_initial"
        ],
        "negativeExamples": [
          "middle_manager"
        ]
      },
      {
        "regExp": "(?i).*(middle|mid)[_\\s-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mid_name"
        ],
        "negativeExamples": [
          "maiden_name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "date"
        ]
      }
    ],
    "positiveContentExamples": [
      "J.",
      "M",
      "Ann",
      "Marie-Claire",
      "Jean Paul",
      "O'Neal",
      "L. M.",
      "ANNE"
    ],
    "negativeContentExamples": [
      "j",
      "jo",
      "A.C.",
      "A B C",
      "Ann Marie Claire",
      "Jo3",
      "AN",
      "O''Neal"
    ],
    "positiveHeaderExamples": [
      "middle_given_name",
      "middle_name",
      "customer_middle_name",
      "employee_mid_name",
      "mname",
      "mi",
      "middle_initial"
    ],
    "negativeHeaderExamples": [
      "first",
      "last",
      "surname",
      "initials",
      "email",
      "address",
      "city"
    ],
    "explanation": "Identifies a person's middle given name or initials, appearing between the first and family names. Supports single-letter initials with or without periods, single names with standard casing, hyphenated or apostrophe-compound names, and two-token middle names. Useful for parsing and normalizing person records where the middle given component is stored separately.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:10.133842"
  },
  {
    "resultType": "generated",
    "semanticType": "PERIOD.QUARTER",
    "description": "Business quarter: a three-month period within a fiscal or calendar year, expressed with tokens like Q1\u2013Q4, often paired with a year (YYYY or YY), FY designator, or the word 'Quarter'.",
    "pluginType": "regex",
    "regexPattern": "\\b(Q[1-4][\\s\\-\\/](20\\d{2})|(20\\d{2})[\\s\\-\\/]Q[1-4]|Q[1-4][\\s\\-\\/]\\d{2}|\\d{2}[\\s\\-\\/]Q[1-4]|Quarter[\\s\\-]?[1-4]|[1-4]Q(20\\d{2}|\\d{2})|FY[\\s\\-]?(20\\d{2}|\\d{2})[\\s\\-]?Q[1-4]|Q[1-4][\\s\\-]?FY[\\s\\-]?(20\\d{2}|\\d{2}))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4930,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\b(fiscal|reporting|calendar)\\b.*\\bquarter\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "reporting_quarter"
        ],
        "negativeExamples": [
          "fiscal_year"
        ]
      },
      {
        "regExp": "(?i).*\\bfy\\b.*\\bquarter\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fy_quarter"
        ],
        "negativeExamples": [
          "calendar_quarter"
        ]
      },
      {
        "regExp": "(?i).*\\bqtr\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fiscal_qtr"
        ],
        "negativeExamples": [
          "qty"
        ]
      },
      {
        "regExp": "(?i).*\\bq[1-4]\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "q1"
        ],
        "negativeExamples": [
          "q5"
        ]
      },
      {
        "regExp": "(?i).*\\bquarter\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "quarter"
        ],
        "negativeExamples": [
          "month"
        ]
      }
    ],
    "positiveContentExamples": [
      "Q4 2023",
      "2022-Q2",
      "Q3 FY2021",
      "Quarter 2",
      "1Q23",
      "FY24 Q1",
      "2020 Q4",
      "Q2-21"
    ],
    "negativeContentExamples": [
      "Q5",
      "Quarter 0",
      "2023 Q0",
      "H1 2023",
      "Q3M2",
      "Q12",
      "FQ3",
      "Q-1"
    ],
    "positiveHeaderExamples": [
      "fiscal_quarter",
      "calendar_quarter",
      "reporting_quarter",
      "quarter",
      "fy_quarter",
      "fiscal_qtr",
      "quarter_label",
      "qtr"
    ],
    "negativeHeaderExamples": [
      "quarterly_revenue",
      "fiscal_year",
      "month",
      "qtrly",
      "period",
      "semester",
      "qty",
      "week"
    ],
    "explanation": "Identifies values representing a business quarter within a fiscal or calendar year, including formats such as 'Q3 FY2021', '2022-Q2', '1Q23', 'FY24 Q1', and 'Quarter 2'. The pattern emphasizes explicit quarter tokens (Q1\u2013Q4) paired with recognized context like years (YYYY or YY), FY designators, or the literal 'Quarter'. This type is useful for grouping time-based metrics and aligning records into standard three-month periods for financial and operational reporting.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:11.010171"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_BG",
    "description": "Bulgarian postal code: a 4-digit numeric regional mail sorting identifier used in Bulgaria. The value consists solely of four decimal digits with no letters or separators.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5030,
    "headerPatterns": [
      {
        "regExp": "(?i).*(bulgarian|bg).*(postal|post).*(code|postcode).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "bulgarian_postal_code"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      },
      {
        "regExp": "(?i).*(bg|bulgaria).*(postcode|post_code|post code).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "bg_postcode"
        ],
        "negativeExamples": [
          "recipient_postcode"
        ]
      },
      {
        "regExp": "(?i).*(bulgarian|bg).*(zip|postal).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "bg_zip_code"
        ],
        "negativeExamples": [
          "bg_phone_code"
        ]
      },
      {
        "regExp": "(?i).*(post_code|post code|postcode|postal).*",
        "confidence": 91,
        "mandatory": true,
        "positiveExamples": [
          "recipient_postcode"
        ],
        "negativeExamples": [
          "postal_address"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "id"
        ]
      }
    ],
    "positiveContentExamples": [
      "1000",
      "1527",
      "2306",
      "4000",
      "5002",
      "6008",
      "7608",
      "9000"
    ],
    "negativeContentExamples": [
      "12345",
      "999",
      "12 34",
      "12-34",
      "A234",
      "1O34",
      "\u0660\u0661\u0662\u0663",
      "\uff11\uff12\uff13\uff14"
    ],
    "positiveHeaderExamples": [
      "bulgarian_postal_code",
      "bg_postcode",
      "bulgaria_post_code",
      "recipient_bg_postcode",
      "postcode_bg",
      "delivery_bulgarian_postal_code",
      "bg_zip_code"
    ],
    "negativeHeaderExamples": [
      "postal_code",
      "recipient_postcode",
      "country_code_bg",
      "bulgarian_address",
      "bg_phone_code",
      "zip_code",
      "postcode_hint",
      "shipping_code"
    ],
    "explanation": "This semantic type identifies Bulgarian postal codes that are exactly four digits long, ensuring they are isolated tokens using word boundaries. It is useful for classifying address-related fields specific to Bulgaria where the data consists solely of 4-digit numeric codes, without letters or separators. High threshold and low priority are set to avoid conflicts with other generic 4-digit numeric fields.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:11.560188"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_JA",
    "description": "Japan postal code consisting of exactly three digits, a hyphen, and four digits (e.g., 123-4567). Only ASCII digits 0-9 are allowed and no spaces or extra characters are permitted.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{3}-[0-9]{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5100,
    "headerPatterns": [
      {
        "regExp": "(?i).*(jp|japan).*(postal|post|zip).*(code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "jp_postal_code"
        ],
        "negativeExamples": [
          "japan_postal_address"
        ]
      },
      {
        "regExp": "(?i).*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postal_code"
        ],
        "negativeExamples": [
          "postal_index"
        ]
      },
      {
        "regExp": "(?i).*zip.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "zip_code_jp"
        ],
        "negativeExamples": [
          "zip_extension"
        ]
      },
      {
        "regExp": "(?i).*postcode.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "japan_postcode"
        ],
        "negativeExamples": [
          "postal_code_japan"
        ]
      },
      {
        "regExp": "(?i).*(pcode|pc).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "jp_pcode"
        ],
        "negativeExamples": [
          "product_category"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "postal"
        ]
      }
    ],
    "positiveContentExamples": [
      "100-0001",
      "060-0042",
      "530-0001",
      "150-0002",
      "810-0004",
      "901-0155",
      "980-0014",
      "003-0801"
    ],
    "negativeContentExamples": [
      "1000001",
      "10-00001",
      "100-000",
      "100-00012",
      "100 -0001",
      "A00-0001",
      "100-00A1",
      "100-0001-2"
    ],
    "positiveHeaderExamples": [
      "jp_postal_code",
      "japan_postal_code",
      "postal_code_jp",
      "postcode_japan",
      "zip_code_jp",
      "jp_zip_code",
      "japan_postcode",
      "jp_postcode"
    ],
    "negativeHeaderExamples": [
      "postal_address",
      "zip_extension",
      "country_code",
      "area_code_jp",
      "address_postal",
      "zip_length",
      "product_code",
      "customer_postal"
    ],
    "explanation": "This type recognizes Japan postal codes with the strict NNN-NNNN structure. It is useful for validating and classifying columns that store Japanese postal codes formatted with a single hyphen and seven total digits.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:13.435208"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_FR",
    "description": "French mail code: five digit sequence",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 5080,
    "headerPatterns": [
      {
        "regExp": "(?i).*(fr|france)[ _-]*(postal|zip)[ _-]*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fr_postal_code"
        ],
        "negativeExamples": [
          "us_postal_code"
        ]
      },
      {
        "regExp": "(?i).*postal[ _-]*code[ _-]*(fr|france).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postal_code_fr"
        ],
        "negativeExamples": [
          "postal_code_state"
        ]
      },
      {
        "regExp": "(?i).*(code[ _-]*postal).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code_postal"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      },
      {
        "regExp": "(?i).*(fr|french)[ _-]*(postcode|zipcode|zip|postal).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "french_postcode"
        ],
        "negativeExamples": [
          "shipping_postal"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "number"
        ]
      }
    ],
    "positiveContentExamples": [
      "01000",
      "13008",
      "20167",
      "29200",
      "33000",
      "69007",
      "75001",
      "97400"
    ],
    "negativeContentExamples": [
      "7500",
      "750001",
      "75 001",
      "F-75001",
      "75001-1234",
      "FR75001",
      "75001A",
      "75-001"
    ],
    "positiveHeaderExamples": [
      "fr_postal_code",
      "postal_code_fr",
      "code_postal",
      "french_postcode",
      "fr_zip_code",
      "france_postal_code",
      "postcode_fr",
      "cp_fr"
    ],
    "negativeHeaderExamples": [
      "us_postal_code",
      "postal_code_state",
      "postal_zone",
      "postal_address",
      "zip_extension",
      "country_code",
      "insee_code",
      "department_code"
    ],
    "explanation": "Identifies French postal codes as standalone five-digit numeric strings, such as 75001 or 13008. Suitable for classifying address fields or validating French mailing data. The pattern is intentionally strict to digits-only and leverages header cues with French-specific tokens to reduce collisions with other 5-digit numeric identifiers.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:14.771902"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.RACE_EN",
    "description": "racial_category: full descriptive ethnic or racial group designation",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(american indian and alaska native|american indian or alaska native|american indian|alaska native|native american|native hawaiian and other pacific islander|native hawaiian or other pacific islander|native hawaiian|other pacific islander|pacific islander|black or african american|black/african american|african american|black|white|caucasian|asian|middle eastern or north african|middle eastern|north african|mena|hispanic or latino|hispanic/latino|hispanic|latino|latina|latinx|two or more races|two or more race|multiracial|mixed race|some other race|other race)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5000,
    "headerPatterns": [
      {
        "regExp": "(?i).*(racial.*category|race.*category|race_category).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "racial_category"
        ],
        "negativeExamples": [
          "race_type"
        ]
      },
      {
        "regExp": "(?i).*(race.*ethnic|ethnic.*race|race_ethnicity).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "race_ethnicity"
        ],
        "negativeExamples": [
          "ethnicity"
        ]
      },
      {
        "regExp": "(?i).*(demographic.*race|participant.*race|person.*race).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "demographic_race"
        ],
        "negativeExamples": [
          "demographics"
        ]
      },
      {
        "regExp": "(?i).*(ethnicity_and_race|ethnicity.*and.*race).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ethnicity_and_race"
        ],
        "negativeExamples": [
          "ethnic_group"
        ]
      },
      {
        "regExp": "(?i).*race.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "race"
        ],
        "negativeExamples": [
          "ethnicity"
        ]
      }
    ],
    "positiveContentExamples": [
      "Asian",
      "Black or African American",
      "White",
      "Hispanic or Latino",
      "American Indian or Alaska Native",
      "Native Hawaiian or Other Pacific Islander",
      "Middle Eastern or North African",
      "Two or more races"
    ],
    "negativeContentExamples": [
      "African",
      "Pacific",
      "Middle-East",
      "North Africa",
      "Hispanic Latino",
      "Two races",
      "Mixed",
      "Other"
    ],
    "positiveHeaderExamples": [
      "racial_category",
      "race_ethnicity",
      "participant_race",
      "demographic_race",
      "person_race_en",
      "ethnicity_and_race",
      "race_category"
    ],
    "negativeHeaderExamples": [
      "ethnicity",
      "country_of_origin",
      "nationality",
      "language",
      "gender",
      "age_group",
      "region"
    ],
    "explanation": "This semantic type identifies English-language race or ethnicity category labels commonly used in demographic data. It targets standardized phrases and their common variants while avoiding overly broad or unrelated demographic attributes.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:16.784156"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.MARITAL_STATUS_EN",
    "description": "English-language legal marriage and partnership designation values used to indicate a person's marital or registered partnership status. Values are finite and represent legally recognized states such as single, married, divorced, widowed, separated, civil/registered partnerships, and related lawful categories.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "SINGLE",
      "MARRIED",
      "SEPARATED",
      "DIVORCED",
      "WIDOWED",
      "ANNULLED",
      "CIVIL UNION",
      "CIVIL PARTNERSHIP",
      "DOMESTIC PARTNERSHIP",
      "REGISTERED PARTNERSHIP",
      "COMMON-LAW MARRIAGE",
      "LEGALLY SEPARATED",
      "JUDICIALLY SEPARATED",
      "POLYGAMOUS MARRIAGE"
    ],
    "backout": "^[A-Z][A-Z -]{2,49}$",
    "confidenceThreshold": 95,
    "priority": 4980,
    "headerPatterns": [
      {
        "regExp": "(?i).*marital[_ ]status.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "marital_status"
        ],
        "negativeExamples": [
          "marital_age"
        ]
      },
      {
        "regExp": "(?i).*relationship[_ ]status.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "relationship status"
        ],
        "negativeExamples": [
          "relationship score"
        ]
      },
      {
        "regExp": "(?i).*(marital|relationship).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "marital"
        ],
        "negativeExamples": [
          "status_code"
        ]
      },
      {
        "regExp": "(?i).*(mrtl|mstat|rel[_ ]?stat(us)?).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "mstat"
        ],
        "negativeExamples": [
          "rel_type"
        ]
      },
      {
        "regExp": "(?i).*status.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "status"
        ],
        "negativeExamples": [
          "state"
        ]
      }
    ],
    "positiveContentExamples": [
      "SINGLE",
      "MARRIED",
      "DIVORCED",
      "WIDOWED",
      "SEPARATED",
      "CIVIL UNION",
      "DOMESTIC PARTNERSHIP",
      "REGISTERED PARTNERSHIP"
    ],
    "negativeContentExamples": [
      "ENGAGED",
      "IN A RELATIONSHIP",
      "MARRIED 2019",
      "DIVORCED/SEPARATED",
      "WIDOW",
      "SINGLE?",
      "CIVIL-UNION",
      "DOMESTIC PARTNER"
    ],
    "positiveHeaderExamples": [
      "marital_status",
      "Marital Status",
      "relationship_status",
      "Relationship Status",
      "legal_marital_status",
      "Legal Relationship Status",
      "mstat",
      "rel_status"
    ],
    "negativeHeaderExamples": [
      "relationship_score",
      "marital_age",
      "status_description",
      "partner_name",
      "household_status",
      "employment_status",
      "relationship_type",
      "status_code"
    ],
    "explanation": "This semantic type captures standardized, legally recognized marital and registered partnership statuses in English. It is designed for columns storing a person's legal relationship designation, using a finite list of values suitable for validation and normalization.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:17.229687"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_DE",
    "description": "German PLZ: five-digit regional mail sorting code used to route mail within Germany. Values are exactly five numeric digits and may include leading zeros.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5060,
    "headerPatterns": [
      {
        "regExp": "(?i).*(de|german).*(postal|post|zip).*(code|plz).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "german_postal_code"
        ],
        "negativeExamples": [
          "german_city_code"
        ]
      },
      {
        "regExp": "(?i).*\\bplz\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "plz"
        ],
        "negativeExamples": [
          "zip"
        ]
      },
      {
        "regExp": "(?i).*(postal[_ ]?code|post[_ ]?code|postcode|zip[_ ]?code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postal_code_de"
        ],
        "negativeExamples": [
          "region_code_de"
        ]
      },
      {
        "regExp": "(?i).*(postal|postcode|zip).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "shipping_postcode_de"
        ],
        "negativeExamples": [
          "area_de"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "number"
        ]
      }
    ],
    "positiveContentExamples": [
      "01067",
      "10115",
      "20095",
      "50667",
      "80331",
      "28195",
      "60549",
      "89073"
    ],
    "negativeContentExamples": [
      "1011",
      "101150",
      "12 345",
      "D12345",
      "123-45",
      "12.345",
      "1234A",
      "1O115"
    ],
    "positiveHeaderExamples": [
      "german_postal_code",
      "de_postal_code",
      "postal_code_de",
      "plz",
      "plz_de",
      "shipping_postcode_de",
      "customer_plz",
      "billing_plz"
    ],
    "negativeHeaderExamples": [
      "german_city",
      "de_region",
      "address_line1",
      "phone_number_de",
      "de_state",
      "region_de",
      "municipality",
      "country"
    ],
    "explanation": "This semantic type identifies German postal codes (PLZ), which are exactly five numeric digits and may include leading zeros. It is suitable for columns containing German mailing codes in address datasets or logistics systems, and relies on both content shape and common header terms (including PLZ) for accurate detection.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:19.577220"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_CO",
    "description": "Colombian 6-digit postal code used for departmental and municipal mail delivery. Values are exactly six digits without separators.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 5050,
    "headerPatterns": [
      {
        "regExp": "(?i).*colombia.*postal.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "colombia_postal_code"
        ],
        "negativeExamples": [
          "country_postal_code"
        ]
      },
      {
        "regExp": "(?i).*postal.*code.*co.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "postal_code_co"
        ],
        "negativeExamples": [
          "postal_code_us"
        ]
      },
      {
        "regExp": "(?i).*post.?code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postcode"
        ],
        "negativeExamples": [
          "zip_code"
        ]
      },
      {
        "regExp": "(?i).*codigo.*postal.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "codigo_postal"
        ],
        "negativeExamples": [
          "codigo_area"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "050001",
      "050010",
      "080001",
      "110111",
      "110221",
      "130001",
      "760034",
      "730006"
    ],
    "negativeContentExamples": [
      "12345",
      "1234567",
      "123-456",
      "123 456",
      "A123456",
      "12345B",
      "12_3456",
      "0000000"
    ],
    "positiveHeaderExamples": [
      "colombia_postal_code",
      "postal_code_co",
      "codigo_postal",
      "postcode",
      "zip_code_co",
      "co_postal_code",
      "codigo_postal_colombia",
      "postalcode_co"
    ],
    "negativeHeaderExamples": [
      "country_code",
      "area_code",
      "state_code",
      "zip4",
      "postal_box",
      "address_code",
      "co_country_code",
      "company_code"
    ],
    "explanation": "This semantic type detects Colombian postal codes, represented as exactly six digits with no separators or letters. It is useful for validating and standardizing address datasets that include Colombian mail delivery identifiers and for distinguishing Colombian ZIP/postal fields from other country-specific formats.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:19.838865"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_SE",
    "description": "Sweden postcode: three digits, space, two digits. Matches Swedish 5-digit numeric postcodes formatted as three digits, space, two digits (e.g., \"123 45\").",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{3} \\d{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5140,
    "headerPatterns": [
      {
        "regExp": "(?i).*(sweden|swedish|se).*postal.*code.*",
        "confidence": 99,
        "mandatory": true,
        "positiveExamples": [
          "se_postal_code"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      },
      {
        "regExp": "(?i).*(sweden|swedish|se).*(postcode|post.*code|zip.*code).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "sweden_postcode"
        ],
        "negativeExamples": [
          "post_code_uk"
        ]
      },
      {
        "regExp": "(?i).*(se|sweden|swedish).*(post|postal|postcode).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "se_postcode"
        ],
        "negativeExamples": [
          "zip_code_us"
        ]
      },
      {
        "regExp": "(?i).*(postal|post|zip).*code.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "delivery_postal_code_se"
        ],
        "negativeExamples": [
          "error_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "111 22",
      "123 45",
      "405 30",
      "752 36",
      "984 99",
      "211 20",
      "412 63",
      "169 79"
    ],
    "negativeContentExamples": [
      "11122",
      "11 222",
      "111-22",
      "111 2",
      "111 222",
      "A11 22",
      "111 2A",
      "12 345"
    ],
    "positiveHeaderExamples": [
      "se_postal_code",
      "sweden_postcode",
      "postal_code_sweden",
      "se_postcode",
      "zip_code_sweden",
      "delivery_postal_code_se",
      "se_zip_code",
      "swedish_postal_code"
    ],
    "negativeHeaderExamples": [
      "postal_code",
      "zip_code_us",
      "country_code_se",
      "post_code_uk",
      "area_code",
      "error_code",
      "billing_code",
      "province_code"
    ],
    "explanation": "Detects Swedish postal codes formatted as three digits, space, two digits (NNN NN). Useful for validating and classifying address datasets specific to Sweden, enforcing the required space separator and numeric-only content.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:19.887383"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_UY",
    "description": "Uruguay postal code: exactly five consecutive digits forming a standalone token.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5160,
    "headerPatterns": [
      {
        "regExp": "(?i).*uruguay.*postal.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "uruguay_postal_code"
        ],
        "negativeExamples": [
          "uruguay_country_code"
        ]
      },
      {
        "regExp": "(?i).*(uy|ury).*postal.*code.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "uy_postal_code"
        ],
        "negativeExamples": [
          "uy_area_code"
        ]
      },
      {
        "regExp": "(?i).*postal.*code.*uy.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "postal_code_uy"
        ],
        "negativeExamples": [
          "postal_code_us"
        ]
      },
      {
        "regExp": "(?i).*(zip|zipcode).*uy.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "zipcode_uy"
        ],
        "negativeExamples": [
          "zip_code_us"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "11000",
      "11500",
      "12005",
      "13010",
      "20000",
      "20345",
      "45012",
      "91234"
    ],
    "negativeContentExamples": [
      "1100",
      "110000",
      "11 000",
      "11-000",
      "1100A",
      "A11000",
      "12.345",
      "1234B"
    ],
    "positiveHeaderExamples": [
      "uruguay_postal_code",
      "uy_postal_code",
      "postal_code_uy",
      "zipcode_uy",
      "ury_postal_code",
      "postalcode_uruguay",
      "delivery_postal_code_uy",
      "mail_postal_code_uy"
    ],
    "negativeHeaderExamples": [
      "uruguay_country_code",
      "area_code",
      "zip_code_us",
      "state_code",
      "postal_area",
      "street_name",
      "phone_number",
      "country"
    ],
    "explanation": "This semantic type identifies Uruguay postal codes represented as a standalone sequence of exactly five digits. It is intended for fields where the data consists solely of a five-digit postal code token, commonly found in address datasets for Uruguay.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:21.121703"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_CA",
    "description": "Canadian postal code in the format A1A 1A1: letter\u2013digit\u2013letter, space, digit\u2013letter\u2013digit. Letters are restricted to ABCEGHJKLMNPRSTVXY and a single space is mandatory between the third and fourth characters. Useful for validating and classifying Canadian address postal code fields.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b[ABCEGHJKLMNPRSTVXY]\\d[ABCEGHJKLMNPRSTVXY] \\d[ABCEGHJKLMNPRSTVXY]\\d\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5040,
    "headerPatterns": [
      {
        "regExp": "(?i).*(canadian|canada).*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "canadian_postal_code"
        ],
        "negativeExamples": [
          "us_postal_code"
        ]
      },
      {
        "regExp": "(?i).*canada.*post.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "canada_postcode"
        ],
        "negativeExamples": [
          "canada_post_office"
        ]
      },
      {
        "regExp": "(?i).*\\bca\\b.*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ca_postal_code"
        ],
        "negativeExamples": [
          "campus_postal_code"
        ]
      },
      {
        "regExp": "(?i).*\\bca\\b.*zip.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ca_zip_code"
        ],
        "negativeExamples": [
          "cat_zipper_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "postal"
        ]
      }
    ],
    "positiveContentExamples": [
      "K1A 0B1",
      "M5V 2T6",
      "H2Z 1A7",
      "V6B 3H7",
      "T2P 1J9",
      "R3C 4X7",
      "X0A 1H0",
      "Y1A 1A1"
    ],
    "negativeContentExamples": [
      "M5V2T6",
      "K1A-0B1",
      "D1A 0B1",
      "K1A 0B",
      "K1A 0B11",
      "K1A 00B",
      "W1A 0B1",
      "K1A 0I1"
    ],
    "positiveHeaderExamples": [
      "canadian_postal_code",
      "postal_code_ca",
      "ca_postal_code",
      "canada_postcode",
      "canada_zip_code",
      "mailing_postal_code_canada",
      "recipient_postal_code_ca"
    ],
    "negativeHeaderExamples": [
      "us_postal_code",
      "postal_code_uk",
      "zip_code",
      "country_code",
      "ca_province_code",
      "canadian_area_code",
      "canada_post_date"
    ],
    "explanation": "This semantic type targets Canadian postal codes with the exact A1A 1A1 structure: letter\u2013digit\u2013letter, a single space, then digit\u2013letter\u2013digit. The allowed letters are constrained to ABCEGHJKLMNPRSTVXY and digits are 0\u20139, ensuring high precision in identifying valid Canadian postal codes in address fields.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:21.431961"
  },
  {
    "resultType": "generated",
    "semanticType": "IPADDRESS.IPV4",
    "description": "network_address: four dot-separated numbers for device identification",
    "pluginType": "regex",
    "regexPattern": "\\b(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4730,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bipv4\\b.*\\baddress\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ipv4_address"
        ],
        "negativeExamples": [
          "ip_address"
        ]
      },
      {
        "regExp": "(?i).*\\b(device|host|client|server)\\b.*\\bipv4\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "device_ipv4"
        ],
        "negativeExamples": [
          "device_id"
        ]
      },
      {
        "regExp": "(?i).*\\b(src|source|dst|dest|destination)\\b.*\\bipv4\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "src_ipv4"
        ],
        "negativeExamples": [
          "src_port"
        ]
      },
      {
        "regExp": "(?i).*\\bip\\b.*\\baddress\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ip_address"
        ],
        "negativeExamples": [
          "street_address"
        ]
      },
      {
        "regExp": "(?i).*\\bipv4\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ipv4"
        ],
        "negativeExamples": [
          "ipv6"
        ]
      },
      {
        "regExp": "(?i).*\\bip\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ip"
        ],
        "negativeExamples": [
          "mac"
        ]
      }
    ],
    "positiveContentExamples": [
      "0.0.0.0",
      "127.0.0.1",
      "192.168.1.1",
      "10.0.0.255",
      "172.16.254.1",
      "8.8.8.8",
      "255.255.255.255",
      "100.64.0.10"
    ],
    "negativeContentExamples": [
      "256.0.0.1",
      "192.168.1",
      "192.168.1.999",
      "1234.1.1.1",
      "192.168..1",
      "abc.def.gha.bcd",
      "01-02-03-04",
      "192.168.1,1"
    ],
    "positiveHeaderExamples": [
      "ipv4_address",
      "device_ipv4",
      "src_ipv4",
      "dst_ipv4",
      "public_ipv4",
      "ip_address",
      "server_ip_address",
      "ipv4"
    ],
    "negativeHeaderExamples": [
      "ipv6_address",
      "mac_address",
      "hostname",
      "server_name",
      "device_id",
      "email_address",
      "street_address",
      "network_mask"
    ],
    "explanation": "Detects IPv4 addresses formatted as four decimal octets separated by dots, where each octet is in the range 0\u2013255. Useful for identifying network-related fields such as client IPs, server IPs, or source/destination IPv4 addresses in logs and datasets.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:22.147441"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_MX",
    "description": "Mexico ZIP: five numeric digits",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{5}\\b(?![-0-9])",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5110,
    "headerPatterns": [
      {
        "regExp": "(?i).*(codigo[_\\s\\-]?postal|postal[_\\s\\-]?code|zip[_\\s\\-]?code)[_\\s\\-]?(mx|mexico).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "codigo_postal_mx"
        ],
        "negativeExamples": [
          "postal_code_uk"
        ]
      },
      {
        "regExp": "(?i).*(mx|mexico).*(postal|codigo).*(code|codigo).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mx_postal_code"
        ],
        "negativeExamples": [
          "mx_state_code"
        ]
      },
      {
        "regExp": "(?i).*(cp|zip)[_\\s\\-]?(mx|mexico).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "zip_mx"
        ],
        "negativeExamples": [
          "zip_plus4"
        ]
      },
      {
        "regExp": "(?i).*(codigo[_\\s\\-]?postal|postal[_\\s\\-]?code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "codigo_postal"
        ],
        "negativeExamples": [
          "area_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "01000",
      "06000",
      "44100",
      "52927",
      "64000",
      "83304",
      "97219",
      "20010"
    ],
    "negativeContentExamples": [
      "1234",
      "123456",
      "12 345",
      "1234A",
      "A1234",
      "123-45",
      "12345-6789",
      "ABCDE"
    ],
    "positiveHeaderExamples": [
      "codigo_postal_mx",
      "postal_code_mx",
      "mx_postal_code",
      "codigo_postal",
      "zip_mx",
      "cp",
      "customer_postal_code",
      "billing_zip_code"
    ],
    "negativeHeaderExamples": [
      "postal_code_uk",
      "zip_plus4",
      "country_code",
      "area_code",
      "mx_state_code",
      "shipping_address",
      "city",
      "timezone"
    ],
    "explanation": "This semantic type identifies Mexican postal codes (C\u00f3digos Postales), which are exactly five digits with no embedded letters or separators. It is useful for validating, extracting, and standardizing Mexico-specific postal code fields in customer, address, shipping, and billing datasets.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:22.645808"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.CANTON_CH",
    "description": "Two-letter uppercase abbreviations for the 26 Swiss cantons. Values are exactly two uppercase Latin letters from the official canton codes and should appear as standalone tokens in text.",
    "pluginType": "regex",
    "regexPattern": "\\b(AG|AI|AR|BE|BL|BS|FR|GE|GL|GR|JU|LU|NE|NW|OW|SG|SH|SO|SZ|TG|TI|UR|VD|VS|ZG|ZH)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5220,
    "headerPatterns": [
      {
        "regExp": "(?i).*(swiss|ch).*(canton|kanton).*(code|abbr|abbrev|short).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "swiss canton code"
        ],
        "negativeExamples": [
          "canton abbr"
        ]
      },
      {
        "regExp": "(?i).*(canton|kanton).*(code|abbr|abbrev|short).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "canton code"
        ],
        "negativeExamples": [
          "province code"
        ]
      },
      {
        "regExp": "(?i).*\\bkt\\b.*(code|abbr|abbrev|short).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "kt code"
        ],
        "negativeExamples": [
          "ticket_code"
        ]
      },
      {
        "regExp": "(?i).*(canton|kanton).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "canton"
        ],
        "negativeExamples": [
          "country"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "ZH",
      "BE",
      "VD",
      "TI",
      "GE",
      "VS",
      "AG",
      "GR"
    ],
    "negativeContentExamples": [
      "zh",
      "CH",
      "ZRH",
      "ZH-",
      "Z_H",
      "ZH1",
      "ZU",
      "AGG"
    ],
    "positiveHeaderExamples": [
      "CH canton code",
      "Swiss canton abbr",
      "canton code",
      "Kanton abbr",
      "kt code",
      "ch_canton_code",
      "CANTON"
    ],
    "negativeHeaderExamples": [
      "canton name",
      "province code",
      "ticket_code",
      "country",
      "country code",
      "postal code",
      "state abbreviation",
      "region"
    ],
    "explanation": "This semantic type recognizes Swiss canton abbreviations as two-letter uppercase codes, ensuring matches occur on token boundaries to reduce false positives. It is useful for validating region fields in Swiss datasets, mapping to administrative divisions, and normalizing region codes during data integration.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:24.039085"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_AU",
    "description": "Australian postcode: 4-digit mail delivery area identifier used in Australia.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 5020,
    "headerPatterns": [
      {
        "regExp": "(?i).*au.*postal.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "au_postal_code"
        ],
        "negativeExamples": [
          "postal_code_us"
        ]
      },
      {
        "regExp": "(?i).*australi.*post.?code.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "australian_postcode"
        ],
        "negativeExamples": [
          "australia_post_date"
        ]
      },
      {
        "regExp": "(?i).*postal.*code.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "customer_postal_code"
        ],
        "negativeExamples": [
          "shipping_zip"
        ]
      },
      {
        "regExp": "(?i).*post.?code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postcode"
        ],
        "negativeExamples": [
          "post_date"
        ]
      },
      {
        "regExp": "(?i).*pcode.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "au_pcode"
        ],
        "negativeExamples": [
          "promo_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "2000",
      "3000",
      "4000",
      "0800",
      "2601",
      "0872",
      "6000",
      "7010"
    ],
    "negativeContentExamples": [
      "200",
      "20000",
      "2O00",
      "2000-",
      "AU-2000",
      "2000A",
      "02 00",
      "12 34"
    ],
    "positiveHeaderExamples": [
      "au_postal_code",
      "australian_postcode",
      "postal_code_au",
      "postcode_au",
      "au_pcode",
      "destination_postcode_au",
      "ship_to_postcode_au",
      "bill_to_au_postcode"
    ],
    "negativeHeaderExamples": [
      "shipping_zip",
      "postal_zone",
      "post_area",
      "zip",
      "city_post",
      "region",
      "state",
      "suburb"
    ],
    "explanation": "Identifies Australian postcodes as standalone four-digit tokens. Suitable for columns containing delivery area identifiers used by Australia Post. The regex uses word boundaries to avoid matching longer numeric strings while remaining flexible for tokenized values.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:24.705914"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.SSN_FR",
    "description": "INSEE/NIR: 15-digit French social security number with embedded demographics (sex, year, month, department, commune, birth order) followed by a 2-digit key. Accepts digits with optional spaces or hyphens between canonical groups; no checksum validation is performed by this pattern.",
    "pluginType": "regex",
    "regexPattern": "\\b[12]\\d{2}[ -]?\\d{2}[ -]?\\d{2}[ -]?\\d{3}[ -]?\\d{3}[ -]?\\d{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4680,
    "headerPatterns": [
      {
        "regExp": "(?i).*insee.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "insee_code"
        ],
        "negativeExamples": [
          "employee_code"
        ]
      },
      {
        "regExp": "(?i).*numero.*securite.*sociale.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "numero_securite_sociale"
        ],
        "negativeExamples": [
          "national_insurance_number_uk"
        ]
      },
      {
        "regExp": "(?i).*nir.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nir"
        ],
        "negativeExamples": [
          "siren"
        ]
      },
      {
        "regExp": "(?i).*(social.*security|securite.*sociale).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fr_social_security_number"
        ],
        "negativeExamples": [
          "employee_security_training"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "1 84 12 75 451 089 46",
      "2 03 01 33 123 045 67",
      "1-99-11-13-250-001-12",
      "2 72 07 59 999 321 08",
      "1 90 10 06 015 200 34",
      "2-85-02-69-300-120-55",
      "1 67 12 92 040 050 09",
      "2 01 05 44 500 777 20"
    ],
    "negativeContentExamples": [
      "1 84 12 75 451 089 4",
      "1 84 12 75 451 089 462",
      "1 84 12 75 451 08A 46",
      "1_84_12_75_451_089_46",
      "1841275451089467",
      "28403761234567",
      "1/84/12/75/451/089/46",
      "1-84-1275-451-089-46"
    ],
    "positiveHeaderExamples": [
      "insee_code",
      "numero_securite_sociale",
      "nir",
      "nss",
      "fr_social_security_number",
      "social_security_code_fr",
      "nir_code",
      "french_ssn"
    ],
    "negativeHeaderExamples": [
      "employee_code",
      "tax_identification_number",
      "siret",
      "siren",
      "iban",
      "passport_number",
      "national_insurance_number_uk",
      "healthcare_beneficiary_id"
    ],
    "explanation": "This semantic type detects the French INSEE/NIR social security number format: a 15-digit identifier beginning with sex (1 or 2), followed by year, month, department, commune, birth order, and a 2-digit key. It permits optional spaces or hyphens between canonical groups and enforces overall structure without performing check-digit or domain validations. Typical use cases include identifying and validating French SSNs in mixed datasets while avoiding false positives from general numeric identifiers.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:24.706256"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.DATE_OF_BIRTH",
    "description": "Complete calendar date of a person's birth expressed as day, month, and year. Accepts common full-date formats such as YYYY-MM-DD, MM/DD/YYYY, DD/MM/YYYY, \"DD Mon YYYY\", and \"Month DD, YYYY\".",
    "pluginType": "regex",
    "regexPattern": "\\b((19[0-9]{2}|20[0-9]{2})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])|(0?[1-9]|1[0-2])/(0?[1-9]|[12][0-9]|3[01])/(19[0-9]{2}|20[0-9]{2})|(0?[1-9]|[12][0-9]|3[01])\\s+(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\\s+(19[0-9]{2}|20[0-9]{2})|(January|February|March|April|May|June|July|August|September|October|November|December)\\s+(0?[1-9]|[12][0-9]|3[01]),\\s+(19[0-9]{2}|20[0-9]{2}))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 4970,
    "headerPatterns": [
      {
        "regExp": "(?i).*date[_ ]of[_ ]birth.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "date_of_birth"
        ],
        "negativeExamples": [
          "birth_date"
        ]
      },
      {
        "regExp": "(?i).*birth[_ -]?date.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "birth-date"
        ],
        "negativeExamples": [
          "birth_year"
        ]
      },
      {
        "regExp": "(?i).*person.*birth.*date.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "person_birth_date"
        ],
        "negativeExamples": [
          "person_birthplace"
        ]
      },
      {
        "regExp": "(?i).*\\bdob\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "dob"
        ],
        "negativeExamples": [
          "doc"
        ]
      },
      {
        "regExp": "(?i).*date.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "date"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "1985-07-23",
      "07/23/1985",
      "23/07/1985",
      "23 Jul 1985",
      "July 23, 1985",
      "2001-01-01",
      "9/5/1999",
      "31 Dec 1970"
    ],
    "negativeContentExamples": [
      "1985/07",
      "07-23-85",
      "23/13/1985",
      "32/01/1985",
      "July 23 1985",
      "1985-7-23",
      "1985.07.23",
      "19850723"
    ],
    "positiveHeaderExamples": [
      "date_of_birth",
      "birth_date",
      "dob",
      "person_birth_date",
      "user_birth_date",
      "birthdate",
      "customer_dob",
      "date of birth"
    ],
    "negativeHeaderExamples": [
      "birth_year",
      "age",
      "date_of_death",
      "registration_date",
      "expected_birth_date",
      "place_of_birth",
      "birthday",
      "event_date"
    ],
    "explanation": "This type identifies fields containing a full date of birth and is intended for PII detection and normalization of birth dates across common date formats. The pattern emphasizes complete dates and avoids partial dates such as month/year or year-only values to reduce ambiguity.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:26.036806"
  },
  {
    "resultType": "generated",
    "semanticType": "SSN",
    "description": "Social Security Number formatted as three digits, hyphen, two digits, hyphen, four digits (###-##-####). Intended for datasets containing US Social Security Numbers where hyphens are present and fixed group lengths are enforced.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{3}-\\d{2}-\\d{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5210,
    "headerPatterns": [
      {
        "regExp": "(?i).*social.*security.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "social_security_number"
        ],
        "negativeExamples": [
          "security_number"
        ]
      },
      {
        "regExp": "(?i).*social.*security.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "social security id"
        ],
        "negativeExamples": [
          "employee_id"
        ]
      },
      {
        "regExp": "(?i).*(ssn|socsec).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ssn"
        ],
        "negativeExamples": [
          "session_id"
        ]
      },
      {
        "regExp": "(?i).*(national.*id|gov.*id).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "national_id"
        ],
        "negativeExamples": [
          "national_code"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "123-45-6789",
      "987-65-4321",
      "001-01-0001",
      "219-84-2045",
      "555-12-3456",
      "320-99-1088",
      "746-20-6001",
      "860-74-0930"
    ],
    "negativeContentExamples": [
      "123456789",
      "12-345-6789",
      "123-4-6789",
      "123-45-678",
      "123-45-67890",
      "123 45 6789",
      "123\u201345\u20136789",
      "12A-45-6789"
    ],
    "positiveHeaderExamples": [
      "ssn",
      "social_security_number",
      "social security id",
      "employee_ssn",
      "applicant_social_security_number",
      "us_ssn",
      "primary_ssn",
      "national_id"
    ],
    "negativeHeaderExamples": [
      "security_id",
      "session_id",
      "passport_id",
      "student_id",
      "employee_id",
      "tax_id",
      "national_code",
      "identity"
    ],
    "explanation": "This semantic type detects US Social Security Numbers using a strict pattern of three digits, a hyphen, two digits, a hyphen, and four digits. It is useful for validating and classifying columns that store SSNs in hyphenated form and for differentiating them from other identifiers with different formats.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:30.115967"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_IE",
    "description": "Irish region: traditional county name",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(ANTRIM|ARMAGH|CARLOW|CAVAN|CLARE|CORK|DERRY|LONDONDERRY|DONEGAL|DUBLIN|DOWN|FERMANAGH|GALWAY|KERRY|KILDARE|KILKENNY|LAOIS|LEITRIM|LIMERICK|LONGFORD|LOUTH|MAYO|MEATH|MONAGHAN|OFFALY|ROSCOMMON|SLIGO|TIPPERARY|TYRONE|WATERFORD|WESTMEATH|WEXFORD|WICKLOW)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 5270,
    "headerPatterns": [
      {
        "regExp": "(?i).*(irish|ireland|ie).*(county).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "county_name_ie"
        ],
        "negativeExamples": [
          "county_code_ie"
        ]
      },
      {
        "regExp": "(?i).*county.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "county_name"
        ],
        "negativeExamples": [
          "country_name"
        ]
      },
      {
        "regExp": "(?i).*(traditional|historic).*county.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "traditional_county"
        ],
        "negativeExamples": [
          "county_population"
        ]
      },
      {
        "regExp": "(?i).*(co|county)[ _-]*(ie|irl|eire).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "co_ie"
        ],
        "negativeExamples": [
          "co_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Dublin",
      "Cork",
      "Galway",
      "Kerry",
      "Kilkenny",
      "Wexford",
      "Antrim",
      "Londonderry"
    ],
    "negativeContentExamples": [
      "County Dublin",
      "Dublin City",
      "Galways",
      "Tipperary North",
      "Derry/Londonderry",
      "Munster",
      "Newry",
      "Mayo County"
    ],
    "positiveHeaderExamples": [
      "irish_county_name",
      "county_name_ie",
      "county_ie",
      "traditional_county",
      "ireland_county",
      "county_name",
      "county"
    ],
    "negativeHeaderExamples": [
      "province",
      "state",
      "region_code",
      "city",
      "country_name",
      "postcode",
      "county_code"
    ],
    "explanation": "This semantic type identifies traditional Irish county names, covering the 32 historical counties across the island of Ireland. It matches the county name alone (e.g., Dublin, Cork, Antrim) and excludes prefixed or suffixed forms such as 'County Dublin' or 'Mayo County'. It is useful for classifying geographic fields that list county names without codes or qualifiers.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:31.003186"
  },
  {
    "resultType": "generated",
    "semanticType": "NATIONALITY_EN",
    "description": "English demonym or adjectival term indicating a person's legal citizenship/national affiliation (e.g., American, Brazilian, Chinese). Represents the nationality expressed in English rather than codes or country names.",
    "pluginType": "regex",
    "regexPattern": "\\b(([A-Z][a-z]+[ -]){0,2})([A-Z][a-z]+)(ian|ean|an|ese|i|ish|er|ic|ch)\\b|\\b(Czech|Greek|Swiss|Thai|Lao|Dutch)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 4900,
    "headerPatterns": [
      {
        "regExp": "(?i).*(customer|applicant|passenger|employee|student).*(nationality|citizenship).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_nationality"
        ],
        "negativeExamples": [
          "customer_country"
        ]
      },
      {
        "regExp": "(?i).*(primary|legal|current).*(nationality|citizenship).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "legal_nationality"
        ],
        "negativeExamples": [
          "legal_name"
        ]
      },
      {
        "regExp": "(?i).*(country[_ ]of[_ ]citizenship|country[_ ]of[_ ]nationality).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "country_of_citizenship"
        ],
        "negativeExamples": [
          "country_of_residence"
        ]
      },
      {
        "regExp": "(?i).*(citizenship[_ ]status|nationality[_ ]status).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "employee_citizenship_status"
        ],
        "negativeExamples": [
          "employee_status"
        ]
      },
      {
        "regExp": "(?i).*citizenship.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "applicant citizenship"
        ],
        "negativeExamples": [
          "citizenship_document_number"
        ]
      },
      {
        "regExp": "(?i).*nationality.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nationality"
        ],
        "negativeExamples": [
          "national"
        ]
      }
    ],
    "positiveContentExamples": [
      "American",
      "French",
      "Brazilian",
      "Chinese",
      "Saudi",
      "New Zealander",
      "Bissau-Guinean",
      "Czech"
    ],
    "negativeContentExamples": [
      "United States",
      "America",
      "Saudi Arabia",
      "New Zealand",
      "American citizen",
      "French nationality",
      "U.S. national",
      "Portuguese (Brazil)"
    ],
    "positiveHeaderExamples": [
      "customer_nationality",
      "applicant citizenship",
      "country_of_citizenship",
      "legal_nationality",
      "passengerNationality",
      "employee_citizenship_status",
      "primary_nationality",
      "student_nationality"
    ],
    "negativeHeaderExamples": [
      "country",
      "language",
      "residence_country",
      "place_of_birth",
      "continent",
      "citizenship_document_number",
      "nationality_code",
      "ethnic_group"
    ],
    "explanation": "This semantic type targets English demonyms that denote a person's legal nationality (citizenship), such as American, Brazilian, or New Zealander. It is intended for columns capturing the nationality string in English rather than country names or codes. The pattern emphasizes common demonym suffixes and selected exceptions, allows up to three capitalized tokens with spaces or hyphens, and avoids broad wildcards to reduce false positives.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:31.037035"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_PT",
    "description": "Portuguese postal code in the format NNNN-NNN: exactly four digits, a hyphen, and three digits. Used to identify postal codes in Portugal.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{4}-[0-9]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5130,
    "headerPatterns": [
      {
        "regExp": "(?i).*(portugal|pt).*(postal|post).*code.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "portugal_postal_code"
        ],
        "negativeExamples": [
          "postal_code_uk"
        ]
      },
      {
        "regExp": "(?i).*(postal|post).*code.*(portugal|pt).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postal_code_pt"
        ],
        "negativeExamples": [
          "country_code_pt"
        ]
      },
      {
        "regExp": "(?i).*(postal|post).*code.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "postal_code"
        ],
        "negativeExamples": [
          "country_identifier"
        ]
      },
      {
        "regExp": "(?i).*(pcode|postcode|zip).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "postcode"
        ],
        "negativeExamples": [
          "post_office"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "1000-001",
      "1990-099",
      "4000-123",
      "8005-245",
      "2900-001",
      "1200-478",
      "9500-321"
    ],
    "negativeContentExamples": [
      "1000 001",
      "100-0001",
      "1000001",
      "1000-1A3",
      "PT-1000-001",
      "1000\u2013001",
      "01000-001",
      "1000-0012"
    ],
    "positiveHeaderExamples": [
      "portugal_postal_code",
      "postal_code_pt",
      "pt_postal_code",
      "post_code_portugal",
      "postcode_pt",
      "delivery_portugal_postal_code",
      "customer_postal_code_pt",
      "ship_to_postal_code_pt"
    ],
    "negativeHeaderExamples": [
      "postal_address",
      "post_office",
      "city_name",
      "region",
      "country",
      "pt_region",
      "address_line",
      "delivery_zone"
    ],
    "explanation": "This semantic type identifies Portuguese postal codes strictly matching the NNNN-NNN structure, ensuring accurate recognition of Portugal-specific postal data. It is suitable for validation, parsing, and schema inference where PT postal codes appear in datasets.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:31.346916"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.LAST_FIRST",
    "description": "Formal personal name in the format: family/surname first, followed by a comma and a space, then given name(s) and optional middle initials (e.g., \"Smith, John\", \"O'Neill, Sean P.\"). Supports hyphens, apostrophes, and multi-token surnames or given names separated by spaces.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z][A-Za-z]{1,40}([ '\\-][A-Z][A-Za-z]{1,40}){0,2},\\s+[A-Z][A-Za-z]{1,40}([ '\\-][A-Z][A-Za-z]{1,40}){0,2}( [A-Z]\\.){0,2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4860,
    "headerPatterns": [
      {
        "regExp": "(?i).*(last[_ ]*first[_ ]*name|name[_ ]*last[_ ]*first).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "last_first_name"
        ],
        "negativeExamples": [
          "first_last_name"
        ]
      },
      {
        "regExp": "(?i).*(surname[_ ]*first|family[_ ]*name[_ ]*first).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "surname_first"
        ],
        "negativeExamples": [
          "first_surname"
        ]
      },
      {
        "regExp": "(?i).*last.*name.*first.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "last_name_first"
        ],
        "negativeExamples": [
          "first_name_last"
        ]
      },
      {
        "regExp": "(?i).*(lname.*fname|ln.*fn).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lname_fname"
        ],
        "negativeExamples": [
          "fname_lname"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "email"
        ]
      }
    ],
    "positiveContentExamples": [
      "Smith, John",
      "O'Connor, Liam",
      "Johnson, Emily Rose",
      "De Marco, Luca",
      "Smith-Jones, Peter Alan",
      "O'Neill, Sean P.",
      "Chen, Wei",
      "McDonald, Andrew J."
    ],
    "negativeContentExamples": [
      "John Smith",
      "Smith,John",
      "S, John",
      "Smith , John",
      "O'Neill, S.",
      "Smith, J",
      "DeMarco John",
      "Smith, John Q"
    ],
    "positiveHeaderExamples": [
      "last_first_name",
      "surname_first",
      "family_name_first",
      "last_name_first",
      "name_last_first",
      "lname_fname",
      "last_comma_first"
    ],
    "negativeHeaderExamples": [
      "first_last",
      "given_first",
      "surname_only",
      "first",
      "last",
      "initials",
      "contact"
    ],
    "explanation": "This semantic type identifies personal names where the surname appears first, followed by a comma and given name(s). It is useful for parsing formal rosters, bibliographic citations, and directories that store names in 'Last, First' order.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:31.947734"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_NL",
    "description": "Netherlands postcode: four digits, space, two letters.",
    "pluginType": "regex",
    "regexPattern": "\\b[1-9][0-9]{3} [A-Z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5120,
    "headerPatterns": [
      {
        "regExp": "(?i).*(netherlands|nl).*(postal|post).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nl_postal_code"
        ],
        "negativeExamples": [
          "postal_code_us"
        ]
      },
      {
        "regExp": "(?i).*(postal|post).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "shipping_postal_code"
        ],
        "negativeExamples": [
          "zip_code"
        ]
      },
      {
        "regExp": "(?i).*(zip|zipcode|zip_code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "zip_code"
        ],
        "negativeExamples": [
          "postcode"
        ]
      },
      {
        "regExp": "(?i).*\\bpc\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "pc"
        ],
        "negativeExamples": [
          "product_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postal_code"
        ],
        "negativeExamples": [
          "address"
        ]
      }
    ],
    "positiveContentExamples": [
      "1011 AB",
      "2511 BV",
      "3512 JE",
      "5611 EM",
      "9712 CP",
      "8011 ZZ",
      "2628 CD",
      "1102 CV"
    ],
    "negativeContentExamples": [
      "1011AB",
      "1011 ab",
      "0101 AB",
      "101 AB",
      "10110 AB",
      "1011 ABC",
      "1011-AB",
      "1011  AB"
    ],
    "positiveHeaderExamples": [
      "nl_postal_code",
      "postcode_nl",
      "netherlands_postcode",
      "shipping_postal_code",
      "zip_code",
      "address_zip_code",
      "pc",
      "postal_code"
    ],
    "negativeHeaderExamples": [
      "postal_code_us",
      "airport_code",
      "invoice_number",
      "country_code",
      "product_code",
      "address_line1",
      "state_province",
      "city_name"
    ],
    "explanation": "This semantic type identifies Netherlands postal codes, formatted as exactly four digits followed by a space and two uppercase letters (e.g., 1011 AB). It is useful for validating and standardizing Dutch address datasets and for extracting or verifying NL-specific postal code fields.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:32.507732"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.YEAR_OF_BIRTH",
    "description": "birth_year: four-digit calendar year of person's birth",
    "pluginType": "regex",
    "regexPattern": "\\b(1[0-9]{3}|20[0-9]{2})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5010,
    "headerPatterns": [
      {
        "regExp": "(?i).*person.*birth.*year.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "person_birth_year"
        ],
        "negativeExamples": [
          "person_birthdate"
        ]
      },
      {
        "regExp": "(?i).*person.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "person"
        ],
        "negativeExamples": [
          "customer"
        ]
      },
      {
        "regExp": "(?i).*year.*of.*birth.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "year_of_birth"
        ],
        "negativeExamples": [
          "year_of_issue"
        ]
      },
      {
        "regExp": "(?i).*birth.*year.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "birth_year"
        ],
        "negativeExamples": [
          "birthdate"
        ]
      },
      {
        "regExp": "(?i).*yob.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "yob"
        ],
        "negativeExamples": [
          "dob"
        ]
      },
      {
        "regExp": "(?i).*date.*",
        "confidence": 85,
        "mandatory": true,
        "positiveExamples": [
          "date"
        ],
        "negativeExamples": [
          "time"
        ]
      }
    ],
    "positiveContentExamples": [
      "1923",
      "1939",
      "1977",
      "1985",
      "1990",
      "2001",
      "2007",
      "2016"
    ],
    "negativeContentExamples": [
      "85",
      "198",
      "19850",
      "2101",
      "0999",
      "201A",
      "0000",
      "3020"
    ],
    "positiveHeaderExamples": [
      "birth_year",
      "year_of_birth",
      "yob",
      "person_birth_year",
      "employee_birth_year",
      "customer_yob",
      "birthyear",
      "birth_year_yyyy"
    ],
    "negativeHeaderExamples": [
      "dob",
      "birthdate",
      "date_of_birth",
      "hiring_year",
      "fiscal_year",
      "graduation_year",
      "issue_year",
      "year_joined"
    ],
    "explanation": "Identifies a four-digit calendar year representing a person's year of birth, typically appearing as an isolated 4-digit token within the range 1000\u20132099. Useful for demographic analyses, age calculation, and cohort segmentation where only the birth year (not full date) is provided.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:36.037759"
  },
  {
    "resultType": "generated",
    "semanticType": "PERIOD.HALF",
    "description": "Six-month period designation within an annual cycle, identifying the first or second half of a given year. Accepts concise tokens such as H1/H2, 1H/2H, HY1/HY2 and their combinations with an optional year before or after (e.g., 2023 H1, H2-2024), as well as textual forms like First Half or 2nd half.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b((19[0-9]{2}|20[0-9]{2})[ /-])?(H[ ]?Y[ ]?1|H[ ]?Y[ ]?2|H[ ]?1|H[ ]?2|1[ ]?H|2[ ]?H|1(st)?[ ]?half|2(nd)?[ ]?half|first[ ]?half|second[ ]?half|half[ ]?1|half[ ]?2)([ /-](19[0-9]{2}|20[0-9]{2}))?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4920,
    "headerPatterns": [
      {
        "regExp": "(?i).*(fiscal[_ -]?year[_ -]?half|fy[_ -]?half).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "fy_half"
        ],
        "negativeExamples": [
          "fy_quarter"
        ]
      },
      {
        "regExp": "(?i).*(calendar[_ -]?year[_ -]?half|cy[_ -]?half).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "calendar_year_half"
        ],
        "negativeExamples": [
          "calendar_quarter"
        ]
      },
      {
        "regExp": "(?i).*(year[_ -]?half|half[_ -]?year).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "year_half"
        ],
        "negativeExamples": [
          "year_quarter"
        ]
      },
      {
        "regExp": "(?i).*(\\bhy\\b|halfyear|semi[_ -]?annual).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "hy"
        ],
        "negativeExamples": [
          "hr"
        ]
      },
      {
        "regExp": "(?i).*\\bhalf\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "half"
        ],
        "negativeExamples": [
          "quarter"
        ]
      }
    ],
    "positiveContentExamples": [
      "H1",
      "H2",
      "1H",
      "2H",
      "HY1",
      "2023 H1",
      "H2-2024",
      "First Half"
    ],
    "negativeContentExamples": [
      "Q1",
      "2023Q2",
      "H3",
      "3H",
      "H1.2023",
      "2023H1",
      "firsthalf",
      "HY0"
    ],
    "positiveHeaderExamples": [
      "year_half",
      "fy_half",
      "calendar_year_half",
      "hy",
      "half",
      "semi_annual_period",
      "half_year",
      "reporting_half"
    ],
    "negativeHeaderExamples": [
      "year_quarter",
      "fy_quarter",
      "calendar_year_quarter",
      "quarter",
      "month",
      "weekly_period",
      "reporting_period",
      "year"
    ],
    "explanation": "This semantic type targets half-year period identifiers, capturing both token forms (H1/H2, 1H/2H, HY1/HY2) and readable phrases (First Half, 2nd half), with optional four-digit years on either side separated by a space, hyphen, or slash. It is useful for classifying reporting periods, fiscal or calendar half-year fields, and time-based aggregations where data is tracked at six-month granularity.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:39.930087"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_HU",
    "description": "Hungarian region: county administrative name. Recognizes the official names of Hungary's counties, including correct diacritics and hyphenation.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "B\u00c1CS-KISKUN",
      "BARANYA",
      "B\u00c9K\u00c9S",
      "BORSOD-ABA\u00daJ-ZEMPL\u00c9N",
      "CSONGR\u00c1D-CSAN\u00c1D",
      "FEJ\u00c9R",
      "GY\u0150R-MOSON-SOPRON",
      "HAJD\u00da-BIHAR",
      "HEVES",
      "J\u00c1SZ-NAGYKUN-SZOLNOK",
      "KOM\u00c1ROM-ESZTERGOM",
      "N\u00d3GR\u00c1D",
      "PEST",
      "SOMOGY",
      "SZABOLCS-SZATM\u00c1R-BEREG",
      "TOLNA",
      "VAS",
      "VESZPR\u00c9M",
      "ZALA"
    ],
    "backout": "^[A-Z\u00c1\u00c9\u00cd\u00d3\u00d6\u0150\u00da\u00dc\u0170][A-Z\u00c1\u00c9\u00cd\u00d3\u00d6\u0150\u00da\u00dc\u0170 -]{1,40}$",
    "confidenceThreshold": 98,
    "priority": 5260,
    "headerPatterns": [
      {
        "regExp": "(?i).*hungarian.*county.*name.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "hungarian_county_name"
        ],
        "negativeExamples": [
          "county_name_de"
        ]
      },
      {
        "regExp": "(?i).*megye.*name.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "megye_name"
        ],
        "negativeExamples": [
          "megye_code"
        ]
      },
      {
        "regExp": "(?i).*(hungarian|hu).*(county|megye).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "hu_county"
        ],
        "negativeExamples": [
          "county_list"
        ]
      },
      {
        "regExp": "(?i).*(cnty|cty).*name.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "cnty_name"
        ],
        "negativeExamples": [
          "cty_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "B\u00c1CS-KISKUN",
      "BARANYA",
      "B\u00c9K\u00c9S",
      "BORSOD-ABA\u00daJ-ZEMPL\u00c9N",
      "CSONGR\u00c1D-CSAN\u00c1D",
      "FEJ\u00c9R",
      "GY\u0150R-MOSON-SOPRON",
      "J\u00c1SZ-NAGYKUN-SZOLNOK"
    ],
    "negativeContentExamples": [
      "BUDAPEST",
      "BORSOD ABA\u00daJ ZEMPL\u00c9N",
      "FEJER",
      "PEST COUNTY",
      "HAJDU-BIHAR",
      "CSONGR\u00c1D",
      "GYOR-MOSON-SOPRON",
      "SZABOLCS SZATM\u00c1R BEREG"
    ],
    "positiveHeaderExamples": [
      "hungarian_county_name",
      "county_hu_name",
      "megye_name",
      "county_name_hu",
      "hu_megye_name",
      "cnty_name",
      "county_name",
      "countyname_hungarian"
    ],
    "negativeHeaderExamples": [
      "county_code",
      "megye_id",
      "region_name",
      "province_name",
      "country_name",
      "city_name",
      "county_population",
      "county_fips_code"
    ],
    "explanation": "This semantic type identifies the official names of Hungary's counties (megy\u00e9k). It is intended for columns storing county name labels, supporting correct diacritics and hyphenation found in Hungarian toponyms.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:41.399083"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_FIPS_US",
    "description": "US county code: five digit FIPS identifier. The first two digits represent the state FIPS code (01\u201356), followed by a three-digit county code within that state. Values are strictly five numeric digits and are commonly used for geographic joins and normalization across datasets.",
    "pluginType": "regex",
    "regexPattern": "\\b(0[1-9]|[1-4][0-9]|5[0-6])[0-9]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 5250,
    "headerPatterns": [
      {
        "regExp": "(?i).*county[ _-]*fips[ _-]*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "county_fips_code"
        ],
        "negativeExamples": [
          "state_fips_code"
        ]
      },
      {
        "regExp": "(?i).*county[ _-]*fips.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "county_fips"
        ],
        "negativeExamples": [
          "state_fips"
        ]
      },
      {
        "regExp": "(?i).*fips[ _-]*county.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fips_county"
        ],
        "negativeExamples": [
          "fips_state"
        ]
      },
      {
        "regExp": "(?i).*(county|cnty)[ _-]*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "county_code"
        ],
        "negativeExamples": [
          "area_code"
        ]
      },
      {
        "regExp": "(?i).*fips.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fips"
        ],
        "negativeExamples": [
          "zip"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "id"
        ]
      }
    ],
    "positiveContentExamples": [
      "01001",
      "02013",
      "04013",
      "06037",
      "12086",
      "17031",
      "36061",
      "48201"
    ],
    "negativeContentExamples": [
      "00000",
      "57001",
      "0603",
      "060370",
      "06-037",
      "FIPS06037",
      "06 037",
      "06_037"
    ],
    "positiveHeaderExamples": [
      "county_fips_code",
      "county_fips",
      "fips_county",
      "fips_county_code",
      "cnty_fips",
      "county_code",
      "fips",
      "county_fipsid"
    ],
    "negativeHeaderExamples": [
      "zip_code",
      "state_fips_code",
      "fips_state",
      "area_code",
      "county_name",
      "county_id",
      "postal_code",
      "province_code"
    ],
    "explanation": "This semantic type identifies five-digit U.S. county FIPS codes, where the first two digits encode the state (01\u201356) and the last three digits encode the county within that state. It is intended for geographic normalization, joins, and validation when columns explicitly reference FIPS-based county identifiers. The content regex enforces a five-digit token with valid state ranges, while header patterns prioritize fields explicitly labeled with county and FIPS terminology to reduce ambiguity with other five-digit numeric identifiers such as postal ZIP codes.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:42.330732"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.ZIP5_US",
    "description": "US ZIP: five digit postal code. Exactly five digits with no separators or suffixes.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 5180,
    "headerPatterns": [
      {
        "regExp": "(?i).*us.*zip.*5.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "us_zip5"
        ],
        "negativeExamples": [
          "zip5_code"
        ]
      },
      {
        "regExp": "(?i).*zip.*code.*5.*digit.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "zip_code_5_digit"
        ],
        "negativeExamples": [
          "zip_code_9_digit"
        ]
      },
      {
        "regExp": "(?i).*postal.*code.*us.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "postal_code_us"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      },
      {
        "regExp": "(?i).*zip.*5.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "zip_5"
        ],
        "negativeExamples": [
          "zip_9"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "00501",
      "02108",
      "10001",
      "30301",
      "60601",
      "85001",
      "98101",
      "99950"
    ],
    "negativeContentExamples": [
      "1234",
      "123456",
      "12345-6789",
      "12345 6789",
      "12 345",
      "1234A",
      "ZIP 12345",
      "123_45"
    ],
    "positiveHeaderExamples": [
      "us_zip5",
      "zip5_code",
      "zip_code_5_digit",
      "postal_code_us",
      "us_postal_code",
      "zip_5",
      "usa_zip",
      "zipcode_5"
    ],
    "negativeHeaderExamples": [
      "zip9_code",
      "postal_code",
      "canada_postal_code",
      "zip_plus4",
      "zipcode_uk",
      "postal_code_intl",
      "local_postcode",
      "area_code"
    ],
    "explanation": "Identifies standalone U.S. ZIP codes consisting of exactly five digits, with no spaces, hyphens, or suffixes. Useful for validating and standardizing basic U.S. postal codes where only the five-digit form is expected.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:43.253640"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_CODE_BR",
    "description": "Brazilian municipal code: seven digit IBGE identifier. Numeric only, exactly 7 digits without separators or formatting.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{7}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5370,
    "headerPatterns": [
      {
        "regExp": "(?i).*ibge.*municipality.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ibge_municipality_code"
        ],
        "negativeExamples": [
          "ibge_state_code"
        ]
      },
      {
        "regExp": "(?i).*codigo.*ibge.*municip.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "codigo_ibge_municipio"
        ],
        "negativeExamples": [
          "codigo_ibge_uf"
        ]
      },
      {
        "regExp": "(?i).*municipality.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality_code"
        ],
        "negativeExamples": [
          "municipality_name"
        ]
      },
      {
        "regExp": "(?i).*(municipio|municipality).*ibge.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality_ibge_code"
        ],
        "negativeExamples": [
          "ibge_code"
        ]
      },
      {
        "regExp": "(?i).*(munic|muni|mun).*(code|cod).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mun_code"
        ],
        "negativeExamples": [
          "mun_id"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "3550308",
      "3304557",
      "5300108",
      "1100015",
      "2927408",
      "4106902",
      "1501402",
      "2605459"
    ],
    "negativeContentExamples": [
      "355030",
      "35503080",
      "3550A08",
      "35503-08",
      "3550 308",
      "3.550.308",
      "355_0308",
      "35503O8"
    ],
    "positiveHeaderExamples": [
      "ibge_municipality_code",
      "codigo_ibge_municipio",
      "municipality_code",
      "mun_code",
      "municipality_ibge_code",
      "codigo_municipio",
      "municipio_cod_ibge"
    ],
    "negativeHeaderExamples": [
      "ibge_state_code",
      "municipality_name",
      "municipal_id",
      "city_code",
      "municipio_nome",
      "codigo_ibge_uf",
      "postal_code"
    ],
    "explanation": "This semantic type identifies Brazilian IBGE municipality codes, which are seven-digit numeric identifiers used for municipalities. Values must be exactly 7 digits with no separators or formatting. It is useful for validating and linking Brazilian municipal data across datasets and systems.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:44.365848"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.ZIP5_PLUS4_US",
    "description": "US extended ZIP: five digits, hyphen, four digits.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{5}-\\d{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5170,
    "headerPatterns": [
      {
        "regExp": "(?i).*((zip[-_ ]?code|zipcode)).*plus[-_ ]?4.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "zipcode_plus4"
        ],
        "negativeExamples": [
          "zipcode"
        ]
      },
      {
        "regExp": "(?i).*(zip[-_+ ]?4).*code.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "zip4_code"
        ],
        "negativeExamples": [
          "zip_code4_missing_plus"
        ]
      },
      {
        "regExp": "(?i).*(zip).*plus.*4.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "us_zip_plus_4"
        ],
        "negativeExamples": [
          "zip_extension"
        ]
      },
      {
        "regExp": "(?i).*(zip[-_+ ]?4).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "zip+4"
        ],
        "negativeExamples": [
          "zip5"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "02115-1234",
      "10001-0001",
      "30309-4521",
      "60614-7890",
      "94105-4321",
      "85001-2345",
      "73301-1200",
      "99501-9999"
    ],
    "negativeContentExamples": [
      "02115-123",
      "2115-1234",
      "021151234",
      "02115 1234",
      "02115_1234",
      "02115\u20131234",
      "02115-12345",
      "ABCDE-1234"
    ],
    "positiveHeaderExamples": [
      "zipcode_plus4",
      "zip_code_plus_4",
      "zip_plus_4",
      "zip4_code",
      "us_zip_plus_4",
      "postal_zip_plus_4",
      "zip4",
      "zip+4"
    ],
    "negativeHeaderExamples": [
      "zipcode",
      "zip_code",
      "zip5",
      "postal_code",
      "area_code",
      "country_code",
      "zip_prefix",
      "address_line2"
    ],
    "explanation": "This semantic type identifies US ZIP+4 postal codes that consist of exactly five digits, a hyphen, and exactly four digits (e.g., 12345-6789). It is useful for validating and profiling datasets that store the extended US postal code format.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:44.941142"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_US",
    "description": "US subdivision: local county jurisdiction",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b((city and county of )?[A-Z][A-Za-z.']+([- ][A-Za-z.']+)* (County|Parish|Borough|Census Area))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 5290,
    "headerPatterns": [
      {
        "regExp": "(?i).*(us|usa|united.*states).*(county|parish|borough|census.*area).*(name|title).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "us_county_name"
        ],
        "negativeExamples": [
          "us_state_name"
        ]
      },
      {
        "regExp": "(?i).*(city.*and.*county|county|parish|borough|census.*area).*(name|title).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "county_title"
        ],
        "negativeExamples": [
          "municipality_name"
        ]
      },
      {
        "regExp": "(?i).*(\\bcnty\\b|\\bco\\b|\\bboro\\b|\\bpar\\b).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cnty_name"
        ],
        "negativeExamples": [
          "company_name"
        ]
      },
      {
        "regExp": "(?i).*(city.*and.*county|county|parish|borough|census.*area).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "parish"
        ],
        "negativeExamples": [
          "region"
        ]
      },
      {
        "regExp": "(?i).*county.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "county"
        ],
        "negativeExamples": [
          "country"
        ]
      }
    ],
    "positiveContentExamples": [
      "Los Angeles County",
      "Cook County",
      "Orange County",
      "St. Louis County",
      "Queen Anne's County",
      "Plaquemines Parish",
      "Anchorage Borough",
      "Yukon-Koyukuk Census Area"
    ],
    "negativeContentExamples": [
      "County of Los Angeles",
      "Orange County CA",
      "Orange County, CA",
      "St. Louis Co.",
      "Orleans Parish LA",
      "City and County of San Francisco, CA",
      "New York City",
      "Anchorage Municipality"
    ],
    "positiveHeaderExamples": [
      "county",
      "county_name",
      "us_county",
      "county_title",
      "parish_name",
      "borough",
      "census_area",
      "city_and_county"
    ],
    "negativeHeaderExamples": [
      "country",
      "state",
      "state_code",
      "city_name",
      "municipality",
      "zipcode",
      "region_name",
      "company"
    ],
    "explanation": "This semantic type identifies US local county-level jurisdictions, including those labeled as County, Parish (Louisiana), Borough (Alaska), and Census Area (Alaska). It is suitable for classifying data columns that contain county-equivalent names across the United States.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:45.084279"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.DISTRICT_NAME_PT",
    "description": "Portuguese territory: district administrative unit. Represents the official names of the 18 mainland Portuguese districts in Portuguese, using uppercase forms including diacritics and spaces where applicable.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "LISBOA",
      "PORTO",
      "AVEIRO",
      "SET\u00daBAL",
      "COIMBRA",
      "BRAGA",
      "VISEU",
      "SANTAR\u00c9M",
      "PORTALEGRE",
      "LEIRIA",
      "\u00c9VORA",
      "BEJA",
      "FARO",
      "CASTELO BRANCO",
      "GUARDA",
      "VILA REAL",
      "VIANA DO CASTELO",
      "BRAGAN\u00c7A"
    ],
    "backout": "^[A-Z\u00c1\u00c2\u00c3\u00c0\u00c9\u00ca\u00cd\u00d3\u00d4\u00d5\u00da\u00c7 ]{3,25}$",
    "confidenceThreshold": 98,
    "priority": 5330,
    "headerPatterns": [
      {
        "regExp": "(?i).*(portugal|pt).*(district|distrito).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "pt_district_name"
        ],
        "negativeExamples": [
          "province_name"
        ]
      },
      {
        "regExp": "(?i).*(portugal|pt).*(district|distrito).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "portugal_distrito"
        ],
        "negativeExamples": [
          "district_code"
        ]
      },
      {
        "regExp": "(?i).*(distrito).*nome.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nome_distrito"
        ],
        "negativeExamples": [
          "nome_municipio"
        ]
      },
      {
        "regExp": "(?i).*(district|distrito).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "district_name"
        ],
        "negativeExamples": [
          "region_name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "LISBOA",
      "PORTO",
      "SET\u00daBAL",
      "BRAGA",
      "COIMBRA",
      "FARO",
      "VIANA DO CASTELO",
      "CASTELO BRANCO"
    ],
    "negativeContentExamples": [
      "LISBON",
      "PORTO DISTRICT",
      "MADEIRA",
      "A\u00c7ORES",
      "SETUBAL",
      "CASTELOBRANCO",
      "SINES",
      "BRAGA (PT)"
    ],
    "positiveHeaderExamples": [
      "pt_district_name",
      "district_pt",
      "portugal_distrito_nome",
      "district_name_pt",
      "nome_distrito",
      "portugal_district",
      "distrito_portugal",
      "distrito_nome_pt"
    ],
    "negativeHeaderExamples": [
      "municipality_name",
      "region_name",
      "province_code",
      "postal_code",
      "country",
      "city_name",
      "county_name",
      "subdistrict_name"
    ],
    "explanation": "This semantic type captures the official Portuguese district names for mainland Portugal as a finite, authoritative set. It is intended for validating or classifying columns containing district names (e.g., LISBOA, PORTO, SET\u00daBAL), supporting strict list-based matching with a conservative backout pattern to prevent overreach. Typical use cases include geospatial normalization, address dimension modeling, and jurisdictional aggregation in Portuguese datasets.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:48.146092"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_CA",
    "description": "Two-letter uppercase abbreviations for Canadian provinces and territories. Values are limited to the official two-character region codes such as AB, ON, QC.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AB",
      "BC",
      "MB",
      "NB",
      "NL",
      "NS",
      "NT",
      "NU",
      "ON",
      "PE",
      "QC",
      "SK",
      "YT"
    ],
    "backout": "^[A-Z]{2}$",
    "confidenceThreshold": 98,
    "priority": 5420,
    "headerPatterns": [
      {
        "regExp": "(?i).*canad.*province.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "canadian_province_code"
        ],
        "negativeExamples": [
          "canadian_postal_code"
        ]
      },
      {
        "regExp": "(?i).*ca.*province.*code.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "ca_province_code"
        ],
        "negativeExamples": [
          "ca_postal_code"
        ]
      },
      {
        "regExp": "(?i).*province.*abbrev.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "province_abbrev"
        ],
        "negativeExamples": [
          "province_name"
        ]
      },
      {
        "regExp": "(?i).*province.*code.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "province_code"
        ],
        "negativeExamples": [
          "country_code"
        ]
      },
      {
        "regExp": "(?i).*prov.*code.*",
        "confidence": 91,
        "mandatory": true,
        "positiveExamples": [
          "prov_code"
        ],
        "negativeExamples": [
          "prov_name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "AB",
      "BC",
      "MB",
      "NB",
      "NL",
      "NS",
      "ON",
      "QC"
    ],
    "negativeContentExamples": [
      "ca",
      "Qc",
      "QUE",
      "ON-",
      "AB1",
      "XK",
      "YK",
      "NF"
    ],
    "positiveHeaderExamples": [
      "canadian_province_code",
      "ca_province_code",
      "province_code",
      "province_abbrev",
      "prov_code",
      "province_code_ca",
      "province_abbrev_ca",
      "canada_province_code"
    ],
    "negativeHeaderExamples": [
      "province_name",
      "state_code",
      "postal_code",
      "country_code",
      "region_code",
      "ca_province",
      "prov_name",
      "province_id"
    ],
    "explanation": "This semantic type identifies two-letter uppercase abbreviations for Canadian provinces and territories. It is intended for fields storing region codes used in Canadian addresses or regional classifications. Using a finite list ensures precise recognition while the backout guards shape conformity.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:52.870655"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.INSEE_CODE_FR",
    "description": "French municipality code: five digit INSEE identifier. Numeric, fixed length of five digits used to uniquely identify communes in France.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5340,
    "headerPatterns": [
      {
        "regExp": "(?i).*(insee).*(commune|municipality).*(code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "insee_commune_code"
        ],
        "negativeExamples": [
          "insee_department_code"
        ]
      },
      {
        "regExp": "(?i).*(commune|municipality).*(code).*(insee).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality_insee_code"
        ],
        "negativeExamples": [
          "municipality_name"
        ]
      },
      {
        "regExp": "(?i).*(cog).*(commune|municipality).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cog_commune"
        ],
        "negativeExamples": [
          "cog_department"
        ]
      },
      {
        "regExp": "(?i).*insee.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "insee_code"
        ],
        "negativeExamples": [
          "iso_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "id"
        ]
      }
    ],
    "positiveContentExamples": [
      "01001",
      "06088",
      "13055",
      "33063",
      "44109",
      "59350",
      "75056",
      "97105"
    ],
    "negativeContentExamples": [
      "7505",
      "075056",
      "75-056",
      "750 56",
      "2A004",
      "97105A",
      "00000",
      "1234"
    ],
    "positiveHeaderExamples": [
      "insee_commune_code",
      "code_insee_commune",
      "municipality_insee_code",
      "commune_code_insee",
      "insee_code_commune",
      "cog_commune_code",
      "code_insee",
      "insee5_code"
    ],
    "negativeHeaderExamples": [
      "postal_code",
      "zip_code",
      "department_insee_code",
      "commune_name",
      "arrondissement_code",
      "iso_code",
      "siren",
      "town_id"
    ],
    "explanation": "This semantic type recognizes five-digit INSEE commune identifiers used in France. Values are strictly numeric and exactly five digits long. Use when column headers indicate INSEE-related commune/municipality codes; this helps distinguish these identifiers from other five-digit numeric fields such as postal codes.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:54.396858"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_UK",
    "description": "UK postcode consisting of an outward code (area and district) followed by a space and an inward code (sector and unit). The outward code is one or two letters followed by one digit and an optional final letter; the inward code is one digit followed by two letters. The legacy special case GIR 0AA is also supported.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(GIR\\s0AA|[A-Z]{1,2}[0-9][A-Z0-9]?\\s[0-9][A-Z]{2})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5150,
    "headerPatterns": [
      {
        "regExp": "(?i).*(uk|gb).*(post.?code|postcode).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "uk_postcode"
        ],
        "negativeExamples": [
          "billing_postcode"
        ]
      },
      {
        "regExp": "(?i).*(post.?code|postcode).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "shipping_post_code"
        ],
        "negativeExamples": [
          "shipping_country"
        ]
      },
      {
        "regExp": "(?i).*(address|addr).*(post.?code|postcode).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "address_postcode"
        ],
        "negativeExamples": [
          "address_line2"
        ]
      },
      {
        "regExp": "(?i).*(pcode|postcd).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "pcode_uk"
        ],
        "negativeExamples": [
          "product_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "postcode"
        ],
        "negativeExamples": [
          "country_name"
        ]
      }
    ],
    "positiveContentExamples": [
      "EC1A 1BB",
      "W1A 0AX",
      "M1 1AE",
      "B33 8TH",
      "CR2 6XH",
      "DN55 1PT",
      "SW1A 2AA",
      "GIR 0AA"
    ],
    "negativeContentExamples": [
      "EC1A1BB",
      "W1A-0AX",
      "M1 1A",
      "B33 8T",
      "CR2 6XHH",
      "DN55-1PT",
      "GIR0AA",
      "SW1A2AA"
    ],
    "positiveHeaderExamples": [
      "uk_postcode",
      "gb_post_code",
      "recipient_postcode",
      "billing_post_code",
      "shipping_postcode",
      "postal_code_uk",
      "address_post_code",
      "pcode_uk"
    ],
    "negativeHeaderExamples": [
      "country_code",
      "zip_code",
      "postal_city",
      "address_line1",
      "region_code",
      "postage_cost",
      "tracking_number",
      "uk_phone_code"
    ],
    "explanation": "Detects UK postcodes where the outward code (1\u20132 letters + 1 digit + optional letter) is followed by a space and the inward code (1 digit + 2 letters). The pattern is case-insensitive, enforces the required space, and includes the special case GIR 0AA. Use this type to validate or profile columns that specifically store UK postal codes, distinct from other national postal code formats.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:55.549205"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_CODE_NL",
    "description": "Netherlands municipal code: four digit CBS identifier. Accepts exactly four digits, including leading zeros, representing the CBS-assigned municipality identifier. Values must be standalone 4-digit numeric tokens with no separators or letters.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 5380,
    "headerPatterns": [
      {
        "regExp": "(?i).*(cbs).*(gemeente|municipality).*(code).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "cbs_municipality_code"
        ],
        "negativeExamples": [
          "cbs_municipality_name"
        ]
      },
      {
        "regExp": "(?i).*(netherlands|nld|nl).*(gemeente|municipality).*(code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nl_municipality_code"
        ],
        "negativeExamples": [
          "municipality_code"
        ]
      },
      {
        "regExp": "(?i).*(gemeente[ _]?code|gm[ _]?code).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "gm_code"
        ],
        "negativeExamples": [
          "gm_name"
        ]
      },
      {
        "regExp": "(?i).*(cbs).*(code).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "cbs_code"
        ],
        "negativeExamples": [
          "cbs_id"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "0001",
      "0034",
      "0192",
      "0363",
      "0518",
      "0855",
      "1680",
      "1963"
    ],
    "negativeContentExamples": [
      "363",
      "03631",
      "03 63",
      "A363",
      "0363A",
      "3,631",
      "12-34",
      "036_3"
    ],
    "positiveHeaderExamples": [
      "cbs_municipality_code",
      "cbs_gemeente_code",
      "nl_municipality_code",
      "nld_gemeente_code",
      "gm_code",
      "gemeente_code",
      "cbs_code",
      "municipality_code"
    ],
    "negativeHeaderExamples": [
      "cbs_municipality_name",
      "municipality_id",
      "province_code",
      "postal_code",
      "country_code",
      "gm_name",
      "cbs_region_code",
      "city_code"
    ],
    "explanation": "This semantic type detects Netherlands CBS municipality identifiers that are exactly four digits, including leading zeros. It is intended for datasets where each value is a standalone 4-digit municipal code used in administrative, demographic, or geospatial aggregation for NL municipalities. Values containing letters, separators, or not exactly four digits are excluded. Header patterns emphasize CBS/NL context and municipality terminology to reduce ambiguity with other 4-digit numeric fields.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:56.434248"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.TEXT_EN",
    "description": "Nation Name: English country designation",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z][a-z]+( (and|of|the)|[- ][A-Z][a-z]+| [a-z]+'[A-Z][a-z]+){0,5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 4310,
    "headerPatterns": [
      {
        "regExp": "(?i).*(country(_)?name(_)?en|country(_)?text(_)?en|nation(_)?name(_)?en).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "country_name_en"
        ],
        "negativeExamples": [
          "country_code_en"
        ]
      },
      {
        "regExp": "(?i).*(english(_)?country(_)?name|country(_)?name(_)?english|country(_)?english).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "english_country_name"
        ],
        "negativeExamples": [
          "english_country_code"
        ]
      },
      {
        "regExp": "(?i).*(country|nation).*(name|text).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "country_name"
        ],
        "negativeExamples": [
          "country_code"
        ]
      },
      {
        "regExp": "(?i).*(ctry|cntry|geo).*(name|txt).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ctry_name"
        ],
        "negativeExamples": [
          "ctry_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "United States",
      "United Kingdom",
      "Cote d'Ivoire",
      "Bosnia and Herzegovina",
      "Saint Kitts and Nevis",
      "Timor-Leste",
      "Trinidad and Tobago",
      "Papua New Guinea"
    ],
    "negativeContentExamples": [
      "U.S.A.",
      "UK",
      "United  Kingdom",
      "United Kingdom.",
      "Cote d Ivoire",
      "Sao Tome & Principe",
      "Saint Kitts & Nevis",
      "UnitedKingdom"
    ],
    "positiveHeaderExamples": [
      "country_name_en",
      "english_country_name",
      "country_english",
      "nation_name_en",
      "country_text_en",
      "country_full_name",
      "english_country",
      "country_name_english"
    ],
    "negativeHeaderExamples": [
      "country_code_en",
      "country_alpha2",
      "country",
      "nation_id",
      "country_iso_code",
      "country_numeric",
      "country_abbrev",
      "nationality"
    ],
    "explanation": "Identifies English country names written as one to several words with capitalized tokens, allowing spaces or hyphens between words, common lowercase connectors (and, of, the), and tokens like d'Ivoire. It excludes abbreviations, codes, punctuation-heavy forms, and values containing digits. This type is useful for columns storing human-readable country names rather than codes or abbreviations.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:56.580335"
  },
  {
    "resultType": "generated",
    "semanticType": "SPATIAL.GEOJSON",
    "description": "JSON-formatted spatial geometry objects following the GeoJSON structure. Detects geometry objects and feature containers that include the appropriate type token and an accompanying geometry/coordinate container.",
    "pluginType": "regex",
    "regexPattern": "(?i)(\\b\"type\"\\s*:\\s*\"(Point|MultiPoint|LineString|MultiLineString|Polygon|MultiPolygon)\"\\b[\\s\\S]*\\b\"coordinates\"\\s*:\\s*\\[|\\b\"type\"\\s*:\\s*\"Feature\"\\b[\\s\\S]*\\b\"geometry\"\\s*:\\s*\\{|\\b\"type\"\\s*:\\s*\"FeatureCollection\"\\b[\\s\\S]*\\b\"features\"\\s*:\\s*\\[|\\b\"type\"\\s*:\\s*\"GeometryCollection\"\\b[\\s\\S]*\\b\"geometries\"\\s*:\\s*\\[)",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5190,
    "headerPatterns": [
      {
        "regExp": "(?i).*geojson.*geometry.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "geojson_geometry"
        ],
        "negativeExamples": [
          "geometry_geojson"
        ]
      },
      {
        "regExp": "(?i).*(feature|features).*geojson.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "feature_geojson"
        ],
        "negativeExamples": [
          "feature_json"
        ]
      },
      {
        "regExp": "(?i).*(geom|geometry).*(json).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "geom_json"
        ],
        "negativeExamples": [
          "geometry_wkt"
        ]
      },
      {
        "regExp": "(?i).*(spatial|location).*(geojson).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "spatial_geojson"
        ],
        "negativeExamples": [
          "spatial_wkb"
        ]
      },
      {
        "regExp": "(?i).*geojson.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "geojson"
        ],
        "negativeExamples": [
          "json"
        ]
      }
    ],
    "positiveContentExamples": [
      "{\"type\":\"Point\",\"coordinates\":[-73.9857,40.7484]}",
      "{\"type\":\"LineString\",\"coordinates\":[[30.5,50.5],[30.51,50.51]]}",
      "{\"type\":\"Polygon\",\"coordinates\":[[[30,10],[40,40],[20,40],[10,20],[30,10]]]}",
      "{\"type\":\"MultiPolygon\",\"coordinates\":[[[[102.0,2.0],[103.0,2.0],[103.0,3.0],[102.0,3.0],[102.0,2.0]]]]}",
      "{\"type\":\"MultiPoint\",\"coordinates\":[[10,40],[40,30],[20,20],[30,10]]}",
      "{\"type\":\"Feature\",\"geometry\":{\"type\":\"Point\",\"coordinates\":[102.0,0.5]},\"properties\":{\"name\":\"X\"}}",
      "{\"type\":\"FeatureCollection\",\"features\":[{\"type\":\"Feature\",\"geometry\":{\"type\":\"Point\",\"coordinates\":[102.0,0.5]},\"properties\":{}}]}",
      "{\"type\":\"GeometryCollection\",\"geometries\":[{\"type\":\"Point\",\"coordinates\":[100.0,0.0]}]}"
    ],
    "negativeContentExamples": [
      "POINT (30 10)",
      "{\"type\":\"Point\",\"value\":[1,2]}",
      "{\"type\":\"Feature\",\"properties\":{\"name\":\"A\"}}",
      "{\"type\":\"GeometryCollection\",\"items\":[{\"type\":\"Point\",\"coordinates\":[0,0]}]}",
      "{\"type\":\"Location\",\"coordinates\":[30,10]}",
      "{\"geometry\":{\"type\":\"Point\",\"coordinates\":[1,2]}}",
      "{\"type\":\"FeatureCollection\",\"elements\":[]}",
      "{\"type\":\"point\",\"coord\":[1,2]}"
    ],
    "positiveHeaderExamples": [
      "geojson_geometry",
      "feature_geojson",
      "spatial_geojson",
      "geom_json",
      "location_geojson",
      "boundary_geojson",
      "parcel_geojson",
      "geometry_geojson"
    ],
    "negativeHeaderExamples": [
      "wkt_geometry",
      "lat_lon",
      "coordinates",
      "geometry_wkb",
      "topojson",
      "json_blob",
      "shape",
      "feature_json"
    ],
    "explanation": "This semantic type identifies cell values that contain GeoJSON structures for spatial data, including geometry objects (Point, LineString, Polygon and their multi-variants) and containers such as Feature, FeatureCollection, and GeometryCollection. It is useful for detecting spatial fields stored as JSON so that downstream geospatial processing can parse them correctly.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:59.502622"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_BR",
    "description": "Brazilian locality: municipal administrative unit. Detects names of municipalities (cities/localities) in Brazil, allowing accents, spaces, hyphens, and apostrophes common in Portuguese place names.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff']{2,}([- ][A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff']{2,}){0,6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 5350,
    "headerPatterns": [
      {
        "regExp": "(?i).*(municipality|municipio|munic\u001dipio).*(br|brazil|brasil).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality_br"
        ],
        "negativeExamples": [
          "municipality_id"
        ]
      },
      {
        "regExp": "(?i).*(br|brazil|brasil).*(city|cidade).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "brazil_city"
        ],
        "negativeExamples": [
          "city_name"
        ]
      },
      {
        "regExp": "(?i).*(municipality|municipio|munic\u001dipio).*(name|nome).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality_name"
        ],
        "negativeExamples": [
          "state_name"
        ]
      },
      {
        "regExp": "(?i).*(muni|munic).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "muni"
        ],
        "negativeExamples": [
          "unit"
        ]
      },
      {
        "regExp": "(?i).*municipality.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality"
        ],
        "negativeExamples": [
          "state"
        ]
      }
    ],
    "positiveContentExamples": [
      "S\u00e3o Paulo",
      "Rio de Janeiro",
      "Belo Horizonte",
      "Porto Alegre",
      "Foz do Igua\u00e7u",
      "Sant'Ana do Livramento",
      "Olho-d'\u00c1gua",
      "S\u00e3o Jos\u00e9 dos Campos"
    ],
    "negativeContentExamples": [
      "S\u00e3o Paulo - SP",
      "Rio de Janeiro, BR",
      "Curitiba-PR",
      "Guarulhos/SP",
      "S\u00e3o_Paulo",
      "Porto Alegre 1",
      "Recife- PE",
      "Niter\u00f3i RJ"
    ],
    "positiveHeaderExamples": [
      "municipality_br",
      "brazilian_municipality",
      "nome_municipio_brasil",
      "city_br",
      "municipality_name",
      "municipio",
      "municipio_nome",
      "cidade"
    ],
    "negativeHeaderExamples": [
      "state",
      "uf",
      "province",
      "country",
      "bairro",
      "cep",
      "county",
      "district"
    ],
    "explanation": "This semantic type identifies Brazilian municipalities (city/locality names) and accepts alphabetic characters with diacritics, spaces, hyphens, and apostrophes commonly found in Portuguese to cover cases like \"Sant'Ana\" or \"Olho-d'\u00c1gua\". It excludes digits, codes, and appended region markers such as state abbreviations (e.g., \"- SP\", \"/RJ\"). Use this to classify columns containing the name of a municipality/locality in Brazil rather than state codes, postal codes, or broader regions.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:42:59.859266"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_CO",
    "description": "Colombian locality: municipal administrative division. Identifies the textual name of a municipality in Colombia (including multi-word names with Spanish diacritics), without appended department names, codes, or extra qualifiers.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1][A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1'\u2019.\\-]{1,})([ \\-]([A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1][A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1'\u2019.\\-]{1,})){0,4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 5360,
    "headerPatterns": [
      {
        "regExp": "(?i).*(municipality|municipio).*(colombia|col|_co).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality_co"
        ],
        "negativeExamples": [
          "municipality_name"
        ]
      },
      {
        "regExp": "(?i).*(colombia|col|_co).*(municipality|municipio).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "col_municipio"
        ],
        "negativeExamples": [
          "country_municipality"
        ]
      },
      {
        "regExp": "(?i).*(location|locality|localidad).*(municipality|municipio).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "locality_municipality"
        ],
        "negativeExamples": [
          "locality_code"
        ]
      },
      {
        "regExp": "(?i).*(muni|mpio).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mpio_co"
        ],
        "negativeExamples": [
          "mpi0"
        ]
      },
      {
        "regExp": "(?i).*municipality.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality"
        ],
        "negativeExamples": [
          "city"
        ]
      }
    ],
    "positiveContentExamples": [
      "Medell\u00edn",
      "Santiago de Cali",
      "Cartagena de Indias",
      "Santa Marta",
      "San Jos\u00e9 del Guaviare",
      "San Vicente del Cagu\u00e1n",
      "El Carmen de Viboral",
      "Bucaramanga"
    ],
    "negativeContentExamples": [
      "Medell\u00edn, Antioquia",
      "Cali 01",
      "Manizales (Caldas)",
      "Bucaramanga-68001",
      "Cartagena de Indias, Bol\u00edvar",
      "C\u00facuta/Colombia",
      "Municipality: Pereira",
      "Pereira, CO"
    ],
    "positiveHeaderExamples": [
      "municipality",
      "municipality_co",
      "colombia_municipality",
      "municipio",
      "municipio_co",
      "city_co",
      "locality_municipality",
      "town_colombia"
    ],
    "negativeHeaderExamples": [
      "department",
      "province",
      "state_co",
      "municipality_code",
      "postal_code",
      "city_name",
      "country",
      "address_city"
    ],
    "explanation": "This semantic type targets Colombian municipality names as plain text values comprised of alphabetic tokens with optional Spanish diacritics, spaces, or hyphens, and without numeric codes, commas, slashes, or parenthetical qualifiers. It is useful for classifying locality fields in Colombian datasets where the municipality is stored as a name rather than a code. Header patterns emphasize columns explicitly labeled as Colombian municipalities, with fallbacks to common abbreviations and the primitive term.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:04.335137"
  },
  {
    "resultType": "generated",
    "semanticType": "SPATIAL.WKT",
    "description": "Text-based coordinate format for spatial geometry expressed in Well-Known Text (WKT), including POINT, LINESTRING, POLYGON, MULTI*, and GEOMETRYCOLLECTION variants. Recognizes geometry keywords followed by parentheses containing numeric coordinates.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(POINT|LINESTRING|POLYGON|MULTIPOINT|MULTILINESTRING|MULTIPOLYGON|GEOMETRYCOLLECTION)\\b\\s*(Z|M|ZM)?\\s*\\(\\s*[-+0-9.,\\s\\(\\)]*\\d[-+0-9.,\\s\\(\\)]*\\)\\s*",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 5200,
    "headerPatterns": [
      {
        "regExp": "(?i).*(geometry|geom).*(wkt).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "geometry_wkt"
        ],
        "negativeExamples": [
          "geometry_json"
        ]
      },
      {
        "regExp": "(?i).*(spatial).*(geometry).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "spatial_geometry"
        ],
        "negativeExamples": [
          "spatial_index"
        ]
      },
      {
        "regExp": "(?i).*geom.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "geom"
        ],
        "negativeExamples": [
          "geodesic_length"
        ]
      },
      {
        "regExp": "(?i).*wkt.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "wkt"
        ],
        "negativeExamples": [
          "wkid"
        ]
      },
      {
        "regExp": "(?i).*geometry.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "geometry"
        ],
        "negativeExamples": [
          "geography"
        ]
      }
    ],
    "positiveContentExamples": [
      "POINT (30 10)",
      "LINESTRING (30 10, 10 30, 40 40)",
      "POLYGON ((30 10, 40 40, 20 40, 10 20, 30 10))",
      "MULTIPOINT ((10 40), (40 30), (20 20), (30 10))",
      "MULTILINESTRING ((10 10, 20 20), (15 15, 30 15))",
      "MULTIPOLYGON (((40 40, 20 45, 45 30, 40 40)), ((20 35, 10 30, 10 10, 30 5, 45 20, 20 35)))",
      "GEOMETRYCOLLECTION (POINT (40 10), LINESTRING (10 10, 20 20, 10 40))",
      "POINT Z (30 10 5)"
    ],
    "negativeContentExamples": [
      "POINT 30 10",
      "POINT()",
      "TRIANGLE (10 10, 20 20)",
      "MULTILINESTRING ((10 10, 20 20), (15 15, 30 15)",
      "GEOMETRYCOLLECTION POINT (10 10)",
      "POINT (A B)",
      "LINESTRING 30 10, 40 40",
      "MULTIPOINT (10 40; 40 30)"
    ],
    "positiveHeaderExamples": [
      "geometry_wkt",
      "wkt_geometry",
      "geom_wkt",
      "spatial_geometry_text",
      "geom",
      "wkt",
      "geometry"
    ],
    "negativeHeaderExamples": [
      "geometry_json",
      "centroid_wkb",
      "geography",
      "wkid",
      "spatial_index",
      "geomtype",
      "geom_length"
    ],
    "explanation": "This semantic type identifies Well-Known Text (WKT) geometry strings such as POINT, LINESTRING, POLYGON, MULTI* variants, and GEOMETRYCOLLECTION with numeric coordinate content. It is useful for detecting columns storing text representations of spatial geometries for GIS and mapping workflows.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:05.033070"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_AU",
    "description": "Australian state/territory designation using standard two- or three-letter codes (NSW, VIC, QLD, SA, WA, TAS, NT, ACT). Intended for datasets storing abbreviated Australian state or territory codes rather than full names.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "NSW",
      "VIC",
      "QLD",
      "SA",
      "WA",
      "TAS",
      "NT",
      "ACT"
    ],
    "backout": "^[A-Z]{2,3}$",
    "confidenceThreshold": 98,
    "priority": 5570,
    "headerPatterns": [
      {
        "regExp": "(?i).*au.*state.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "au_state_code"
        ],
        "negativeExamples": [
          "state_code"
        ]
      },
      {
        "regExp": "(?i).*australia.*state.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "australia_state_code"
        ],
        "negativeExamples": [
          "australian_state_name"
        ]
      },
      {
        "regExp": "(?i).*state.*territory.*code.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "state_territory_code"
        ],
        "negativeExamples": [
          "territory_code"
        ]
      },
      {
        "regExp": "(?i).*state.*code.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "state_code"
        ],
        "negativeExamples": [
          "state_name"
        ]
      },
      {
        "regExp": "(?i).*st.*cd.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "st_cd"
        ],
        "negativeExamples": [
          "std_dev"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "NSW",
      "VIC",
      "QLD",
      "SA",
      "WA",
      "TAS",
      "NT",
      "ACT"
    ],
    "negativeContentExamples": [
      "NWS",
      "NS-W",
      "QLLD",
      "vic",
      "WA ",
      " ACT",
      "ACT1",
      "N.T"
    ],
    "positiveHeaderExamples": [
      "au_state_code",
      "australia_state_code",
      "state_code",
      "state_territory_code",
      "st_cd",
      "au_territory_code",
      "au_state_abbr",
      "aus_state_code"
    ],
    "negativeHeaderExamples": [
      "state_name",
      "territory",
      "postcode",
      "country_code",
      "region",
      "province_code",
      "time_zone",
      "airport_code"
    ],
    "explanation": "This semantic type identifies abbreviated Australian state and territory codes in datasets. It is a finite, well-defined set of uppercase two- or three-letter codes used in addresses, demographics, and regional reporting. The list-based approach ensures precise matching to the official codes, with a backout shape of 2\u20133 uppercase letters for safe fallback.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:05.359151"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.TEXT_DE",
    "description": "L\u00e4ndername: deutsche Nationalbezeichnung",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z\u00c4\u00d6\u00dc][a-z\u00e0-\u00ff\u00df\u00e4\u00f6\u00fc]{2,})([- ][A-Za-z\u00c0-\u00ff\u00df\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc]{2,}){0,6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4300,
    "headerPatterns": [
      {
        "regExp": "(?i).*(country|land).*(name|bezeichnung).*(de|deu|deutsch).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_country_name_de"
        ],
        "negativeExamples": [
          "customer_country_name_en"
        ]
      },
      {
        "regExp": "(?i).*(land|country).*(bezeichnung|name).*_de.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "land_bezeichnung_de"
        ],
        "negativeExamples": [
          "land_bezeichnung_en"
        ]
      },
      {
        "regExp": "(?i).*(country|land).*(de|deu|deutsch).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "preferred_country_de"
        ],
        "negativeExamples": [
          "preferred_country_en"
        ]
      },
      {
        "regExp": "(?i).*(ctry|land).*(name|bez).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "ctry_name_de"
        ],
        "negativeExamples": [
          "ctry_code_de"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Deutschland",
      "\u00d6sterreich",
      "Schweiz",
      "Vereinigte Staaten von Amerika",
      "Vereinigtes K\u00f6nigreich",
      "Demokratische Republik Kongo",
      "Elfenbeink\u00fcste",
      "Vereinigte Arabische Emirate"
    ],
    "negativeContentExamples": [
      "deutschland",
      "\u00f6sterreich",
      "schweiz",
      "vereinigte staaten von amerika",
      "vereinigtes k\u00f6nigreich",
      "demokratische republik kongo",
      "elfenbeink\u00fcste",
      "uae"
    ],
    "positiveHeaderExamples": [
      "country_name_de",
      "customer_country_name_de",
      "land_bezeichnung_de",
      "ctry_name_de",
      "de_country_name",
      "laendername_de",
      "shipping_country_name_de",
      "billing_land_bezeichnung_de"
    ],
    "negativeHeaderExamples": [
      "country_code_de",
      "country_name_en",
      "land_name",
      "billing_country",
      "nation_name_fr",
      "country_de_code",
      "ctry_iso3",
      "staat_name_local"
    ],
    "explanation": "Identifies German-language country names (exonyms) such as Deutschland, Vereinigtes K\u00f6nigreich, or Vereinigte Arabische Emirate. Useful for datasets storing localized country names in German for addresses, profiles, shipping/billing, or internationalization. The pattern accepts 1\u20137 tokens with letters (including German diacritics) separated by spaces or hyphens, favoring proper capitalization, and relies on header cues to distinguish from other name-like fields.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:07.945512"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_EC",
    "description": "Ecuadorian region: provincial administrative division",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AZUAY",
      "BOLIVAR",
      "CANAR",
      "CARCHI",
      "CHIMBORAZO",
      "COTOPAXI",
      "EL ORO",
      "ESMERALDAS",
      "GALAPAGOS",
      "GUAYAS",
      "IMBABURA",
      "LOJA",
      "LOS RIOS",
      "MANABI",
      "MORONA SANTIAGO",
      "NAPO",
      "ORELLANA",
      "PASTAZA",
      "PICHINCHA",
      "SANTA ELENA",
      "SANTO DOMINGO DE LOS TSACHILAS",
      "SUCUMBIOS",
      "TUNGURAHUA",
      "ZAMORA CHINCHIPE"
    ],
    "backout": "^[A-Z][A-Z ]{2,40}$",
    "confidenceThreshold": 98,
    "priority": 5450,
    "headerPatterns": [
      {
        "regExp": "(?i).*ecuador.*province.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ecuador_province_name"
        ],
        "negativeExamples": [
          "province_name"
        ]
      },
      {
        "regExp": "(?i).*(ec|ecuador).*province.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ec_province"
        ],
        "negativeExamples": [
          "province_code"
        ]
      },
      {
        "regExp": "(?i).*province.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province_name"
        ],
        "negativeExamples": [
          "province_code"
        ]
      },
      {
        "regExp": "(?i).*(prov|provincia).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "prov_name"
        ],
        "negativeExamples": [
          "prov_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "PICHINCHA",
      "GUAYAS",
      "AZUAY",
      "EL ORO",
      "LOS RIOS",
      "MANABI",
      "ESMERALDAS",
      "TUNGURAHUA"
    ],
    "negativeContentExamples": [
      "PICHINCHA PROVINCE",
      "GUAYAS-",
      "EL-ORO",
      "LOS RIOS ECUADOR",
      "SANTO DOMINGO",
      "BOLIVAR(EC)",
      "ZAMORA-CHINCHIPE",
      "ORELLANA, EC"
    ],
    "positiveHeaderExamples": [
      "ecuador_province_name",
      "province_name_ec",
      "ec_province",
      "prov_name",
      "provincia_name",
      "province",
      "province_of_ecuador",
      "province_ec"
    ],
    "negativeHeaderExamples": [
      "province_code",
      "state_name",
      "region_name",
      "country_province_code",
      "city_name",
      "county",
      "departamento",
      "postal_code"
    ],
    "explanation": "Identifies the names of Ecuador's first-level administrative divisions (provinces). This is a finite, country-specific list suitable for validating and standardizing province fields in Ecuador-focused datasets.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:08.000028"
  },
  {
    "resultType": "generated",
    "semanticType": "FILENAME",
    "description": "file_identifier: name with extension for file system reference. Identifies a standalone filename (basename plus extension), excluding directory paths or URIs, e.g., report.pdf or backup_01.tar.gz.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Za-z0-9][A-Za-z0-9 _\\-\\.\\(\\)]{0,100})\\.([A-Za-z0-9]{2,6})(\\.([A-Za-z0-9]{2,6}))?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4450,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\b(source|original|uploaded|export|report|document)[_ ]?file[_ ]?name\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "source_file_name"
        ],
        "negativeExamples": [
          "file_path"
        ]
      },
      {
        "regExp": "(?i).*\\b(file|document)[_ ]?(name|filename)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "document_file_name"
        ],
        "negativeExamples": [
          "document_id"
        ]
      },
      {
        "regExp": "(?i).*\\b(file[_ ]?nm|filenm|fname|filenm|fn)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "file_nm"
        ],
        "negativeExamples": [
          "file_no"
        ]
      },
      {
        "regExp": "(?i).*\\bfilename\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "filename"
        ],
        "negativeExamples": [
          "filetype"
        ]
      },
      {
        "regExp": "(?i).*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "report.pdf",
      "IMG_2023-07-19.jpg",
      "backup_01.tar.gz",
      "notes (final).txt",
      "invoice-2024_05.csv",
      "my-script.sh",
      "data_01.tsv",
      "project.plan.v2.docx"
    ],
    "negativeContentExamples": [
      "config",
      ".env",
      "imagejpg",
      "report.p",
      "file name",
      "resume.\ud83d\udcbc",
      "readme.",
      "\u62a5\u544a.pdf"
    ],
    "positiveHeaderExamples": [
      "file_name",
      "filename",
      "source_file_name",
      "uploaded_filename",
      "document_file_name",
      "export_file_nm",
      "fname",
      "report_filename"
    ],
    "negativeHeaderExamples": [
      "file_path",
      "file_url",
      "file_location",
      "directory_name",
      "mime_type",
      "document_id",
      "file_size",
      "file_created_date"
    ],
    "explanation": "This semantic type identifies standalone filenames that include a basename and at least one extension segment, optionally supporting multi-part extensions (e.g., .tar.gz). It rejects directory paths, URLs, and strings lacking a proper extension or basename, and avoids matching values with disallowed characters or malformed extension segments.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:11.707274"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.REGION_NAME_FR",
    "description": "region_francaise: French territorial administrative designation. Represents the official names of France's first-level administrative regions (metropolitan and overseas), expressed in French with appropriate accents and punctuation.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AUVERGNE-RH\u00d4NE-ALPES",
      "BOURGOGNE-FRANCHE-COMT\u00c9",
      "BRETAGNE",
      "CENTRE-VAL DE LOIRE",
      "CORSE",
      "GRAND EST",
      "HAUTS-DE-FRANCE",
      "\u00ceLE-DE-FRANCE",
      "NORMANDIE",
      "NOUVELLE-AQUITAINE",
      "OCCITANIE",
      "PAYS DE LA LOIRE",
      "PROVENCE-ALPES-C\u00d4TE D'AZUR",
      "GUADELOUPE",
      "GUYANE",
      "MARTINIQUE",
      "MAYOTTE",
      "LA R\u00c9UNION"
    ],
    "backout": "^[A-Z\u00c0\u00c2\u00c4\u00c7\u00c8\u00c9\u00ca\u00cb\u00ce\u00cf\u00d4\u00d6\u00d9\u00db\u00dc\u0178\u00c6\u0152' \\-]{3,40}$",
    "confidenceThreshold": 93,
    "priority": 5530,
    "headerPatterns": [
      {
        "regExp": "(?i).*region.*name.*fr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "region_name_fr"
        ],
        "negativeExamples": [
          "region_code_fr"
        ]
      },
      {
        "regExp": "(?i).*nom.*region.*fr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nom_region_fr"
        ],
        "negativeExamples": [
          "nom_departement_fr"
        ]
      },
      {
        "regExp": "(?i).*french.*region.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "french_region_name"
        ],
        "negativeExamples": [
          "french_region_code"
        ]
      },
      {
        "regExp": "(?i).*region.*francaise.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "region_francaise"
        ],
        "negativeExamples": [
          "region_franchise"
        ]
      },
      {
        "regExp": "(?i).*reg.*fr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "reg_fr"
        ],
        "negativeExamples": [
          "reg_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "title"
        ]
      }
    ],
    "positiveContentExamples": [
      "\u00ceLE-DE-FRANCE",
      "HAUTS-DE-FRANCE",
      "PROVENCE-ALPES-C\u00d4TE D'AZUR",
      "AUVERGNE-RH\u00d4NE-ALPES",
      "NOUVELLE-AQUITAINE",
      "PAYS DE LA LOIRE",
      "GRAND EST",
      "LA R\u00c9UNION"
    ],
    "negativeContentExamples": [
      "ILE-DE-FRANCE",
      "PROVENCE-ALPES-COTE D'AZUR",
      "PAYS-DE-LA-LOIRE",
      "HAUT-DE-FRANCE",
      "NORD-PAS-DE-CALAIS",
      "BASSE-NORMANDIE",
      "LA REUNION",
      "IDF"
    ],
    "positiveHeaderExamples": [
      "region_name_fr",
      "french_region_name",
      "nom_region_fr",
      "region_fr",
      "reg_fr",
      "region_francaise",
      "nom_region_france"
    ],
    "negativeHeaderExamples": [
      "region_code_fr",
      "department_name_fr",
      "province_name",
      "region",
      "region_code",
      "reg_code",
      "country_region_name",
      "state_name"
    ],
    "explanation": "This semantic type captures the official French names of France's first-level administrative regions, including metropolitan and overseas regions, with support for accents, spaces, hyphens, and apostrophes. It uses a finite, authoritative list to ensure high precision in classification; a conservative backout pattern is provided to guide broader validation when needed.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:11.761888"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_IE",
    "description": "Irish territory: traditional historic province. Recognizes the four historic provinces of Ireland in English, including the common alternative spelling for Connacht.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "LEINSTER",
      "MUNSTER",
      "CONNACHT",
      "CONNAUGHT",
      "ULSTER"
    ],
    "backout": "^[A-Z]{6,9}$",
    "confidenceThreshold": 98,
    "priority": 5470,
    "headerPatterns": [
      {
        "regExp": "(?i).*(ie|irish|ireland).*(historic|traditional).*(province).*(name).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "ie_historic_province_name"
        ],
        "negativeExamples": [
          "ie_historic_province_code"
        ]
      },
      {
        "regExp": "(?i).*(province).*(name).*(ie|ireland).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "province_name_ie"
        ],
        "negativeExamples": [
          "province_code_ie"
        ]
      },
      {
        "regExp": "(?i).*(state[_ ]?province).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_province_name"
        ],
        "negativeExamples": [
          "state_province_code"
        ]
      },
      {
        "regExp": "(?i).*(province).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "province"
        ],
        "negativeExamples": [
          "province_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Leinster",
      "Munster",
      "Connacht",
      "Connaught",
      "Ulster",
      "LEINSTER",
      "MUNSTER"
    ],
    "negativeContentExamples": [
      "Leister",
      "Ulester",
      "Monster",
      "Connacht Province",
      "Munsterland",
      "Dublin",
      "Northern Ireland",
      "Connaughts"
    ],
    "positiveHeaderExamples": [
      "ie_historic_province_name",
      "province_name_ie",
      "historic_province",
      "state_province_name",
      "prov_name",
      "irish_province_name",
      "province"
    ],
    "negativeHeaderExamples": [
      "county_name_ie",
      "province_code_ie",
      "state_name",
      "province_id",
      "country_name",
      "timezone_name",
      "city_province"
    ],
    "explanation": "This semantic type identifies values that are the traditional historic provinces of Ireland, suitable for fields storing province names rather than codes. It is best used where the dataset enumerates Leinster, Munster, Connacht/Connaught, or Ulster as distinct region names. The list-based approach ensures high precision, while the backout pattern provides a controlled fallback for similarly shaped strings.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:13.755560"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.REGION_NAME_IT",
    "description": "regione_italiana: Italian constitutional regional designation",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "ABRUZZO",
      "BASILICATA",
      "CALABRIA",
      "CAMPANIA",
      "EMILIA-ROMAGNA",
      "FRIULI-VENEZIA GIULIA",
      "LAZIO",
      "LIGURIA",
      "LOMBARDIA",
      "MARCHE",
      "MOLISE",
      "PIEMONTE",
      "PUGLIA",
      "SARDEGNA",
      "SICILIA",
      "TOSCANA",
      "TRENTINO-ALTO ADIGE",
      "UMBRIA",
      "VALLE D'AOSTA",
      "VENETO"
    ],
    "backout": "^[A-Z][A-Z ' -]{2,29}$",
    "confidenceThreshold": 97,
    "priority": 5540,
    "headerPatterns": [
      {
        "regExp": "(?i).*(italian|italy|ital|it).*region.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "italian_region_name"
        ],
        "negativeExamples": [
          "region_code"
        ]
      },
      {
        "regExp": "(?i).*(region|state|province).*name.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "region_name"
        ],
        "negativeExamples": [
          "region_abbrev"
        ]
      },
      {
        "regExp": "(?i).*(it|ita).*reg.*name.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "it_reg_name"
        ],
        "negativeExamples": [
          "it_reg_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "VALLE D'AOSTA",
      "FRIULI-VENEZIA GIULIA",
      "TRENTINO-ALTO ADIGE",
      "EMILIA-ROMAGNA",
      "LOMBARDIA",
      "SICILIA",
      "TOSCANA",
      "PIEMONTE"
    ],
    "negativeContentExamples": [
      "EMILIA ROMAGNA",
      "FRIULI VENEZIA GIULIA",
      "TRENTINO ALTO ADIGE",
      "VALLE D AOSTA",
      "LOMBARDY",
      "SUDTIROL",
      "REGIONE LOMBARDIA",
      "VENETO REGION"
    ],
    "positiveHeaderExamples": [
      "italian_region_name",
      "region_name_it",
      "nome_regione",
      "regione_italiana",
      "it_reg_name",
      "state_province_name_it",
      "region_name",
      "region_full_name"
    ],
    "negativeHeaderExamples": [
      "region_code",
      "province_name",
      "country_name",
      "state_code",
      "it_region_code",
      "city_name",
      "continent",
      "zipcode"
    ],
    "explanation": "This semantic type identifies the official names of Italy's first-level administrative regions. It is best used to normalize and validate fields that specifically contain the Italian region name rather than codes or other location types.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:17.081588"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_ZA",
    "description": "South African territory: provincial administrative division. This type captures the official names of the nine provinces of South Africa.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "EASTERN CAPE",
      "FREE STATE",
      "GAUTENG",
      "KWAZULU-NATAL",
      "LIMPOPO",
      "MPUMALANGA",
      "NORTH WEST",
      "NORTHERN CAPE",
      "WESTERN CAPE"
    ],
    "backout": "^[A-Z]+([ -][A-Z]+)*$",
    "confidenceThreshold": 97,
    "priority": 5510,
    "headerPatterns": [
      {
        "regExp": "(?i).*south[ _-]?africa.*province.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "south_africa_province_name"
        ],
        "negativeExamples": [
          "south_africa_province_code"
        ]
      },
      {
        "regExp": "(?i).*(za|rsa).*province.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "za_province_name"
        ],
        "negativeExamples": [
          "za_province_code"
        ]
      },
      {
        "regExp": "(?i).*state.*province.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_province_name_za"
        ],
        "negativeExamples": [
          "state_province_code"
        ]
      },
      {
        "regExp": "(?i).*(prov|prv).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "prov_name_za"
        ],
        "negativeExamples": [
          "prov_code_za"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "KWAZULU-NATAL",
      "EASTERN CAPE",
      "WESTERN CAPE",
      "NORTHERN CAPE",
      "FREE STATE",
      "GAUTENG",
      "LIMPOPO",
      "MPUMALANGA"
    ],
    "negativeContentExamples": [
      "CAPE TOWN",
      "EASTERN-CAPE",
      "NORTH-WEST",
      "GAUTENG PROVINCE",
      "WESTERN CAPES",
      "KZN",
      "FREE-STATE",
      "KWAZULU NATAL"
    ],
    "positiveHeaderExamples": [
      "province_name_za",
      "za_province",
      "south_africa_province_name",
      "province_name_south_africa",
      "rsa_province_name",
      "prov_name_za",
      "za_province_name",
      "state_province_name_za"
    ],
    "negativeHeaderExamples": [
      "province_code_za",
      "za_province_code",
      "country_province_name",
      "state_name_us",
      "city_name_za",
      "region_name",
      "state_code",
      "place_name"
    ],
    "explanation": "This semantic type recognizes the official province names of South Africa. Use it to classify columns containing South African provincial administrative names for geographic normalization, validation, and analytics. The list-based approach ensures precise matching to the nine recognized provinces, while the backout pattern provides a controlled fallback shape for related uppercase, space- or hyphen-separated names.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:18.773254"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.DISTRICT_NAME_IN",
    "description": "Indian territory: district administrative division. Identifies the names of administrative districts within India, typically expressed as one to five tokens composed of letters, optional initials, connectors like and/& and occasional numerals (e.g., North 24 Parganas).",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z][A-Za-z0-9'-]+([- ][A-Za-z0-9&.-]+){0,4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5320,
    "headerPatterns": [
      {
        "regExp": "(?i).*(india|in).*district.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "in_district_name"
        ],
        "negativeExamples": [
          "district_name_us"
        ]
      },
      {
        "regExp": "(?i).*district.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "district_name"
        ],
        "negativeExamples": [
          "district_code"
        ]
      },
      {
        "regExp": "(?i).*district.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "district"
        ],
        "negativeExamples": [
          "province"
        ]
      },
      {
        "regExp": "(?i).*\\bdist\\b.*(name|nm).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "dist_nm"
        ],
        "negativeExamples": [
          "distance_nm"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Bengaluru Urban",
      "North 24 Parganas",
      "South Andaman",
      "Prayagraj",
      "Kancheepuram",
      "New Delhi",
      "Dadra and Nagar Haveli",
      "K. V. Ranga Reddy"
    ],
    "negativeContentExamples": [
      "Bengaluru Urban, KA",
      "North-24-Parganas 700001",
      "District: Prayagraj",
      "Kancheepuram (TN)",
      "New Delhi/NDMC",
      "Dadra & Nagar Haveli and Daman & Diu",
      "24 Parganas North",
      "East-Champaran-01"
    ],
    "positiveHeaderExamples": [
      "in_district_name",
      "district_name",
      "indian_district_name",
      "dist_nm",
      "district",
      "district_full_name",
      "districtname",
      "name"
    ],
    "negativeHeaderExamples": [
      "district_code",
      "province_name",
      "city_name",
      "state_province",
      "subdistrict_name",
      "distance_nm",
      "postcode",
      "code"
    ],
    "explanation": "This semantic type targets strings representing Indian district names. The value pattern expects one to five tokens separated by spaces or hyphens, starting with a letter and allowing letters, digits (for cases like 24), connectors such as and/& and punctuation used in initials (periods and apostrophes). It excludes values with appended state codes, slashes, commas, or trailing identifiers that indicate broader territories or extra codes. Typical use cases include classifying columns listing district-level administrative units within India for geospatial enrichment, data validation, or normalization.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:19.365945"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_FIPS_US",
    "description": "us_fips_state: two-digit federal state identification code",
    "pluginType": "regex",
    "regexPattern": "\\b(0[1-9]|[1-4][0-9]|5[0-6])\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5590,
    "headerPatterns": [
      {
        "regExp": "(?i).*us.*fips.*state.*code.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "us_fips_state_code"
        ],
        "negativeExamples": [
          "state_fips_code"
        ]
      },
      {
        "regExp": "(?i).*state.*fips.*code.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "state_fips_code"
        ],
        "negativeExamples": [
          "state_fips"
        ]
      },
      {
        "regExp": "(?i).*fips.*state.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fips_state"
        ],
        "negativeExamples": [
          "county_fips"
        ]
      },
      {
        "regExp": "(?i).*(st|state).*fips.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "st_fips"
        ],
        "negativeExamples": [
          "st_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "01",
      "02",
      "06",
      "09",
      "12",
      "36",
      "48",
      "56"
    ],
    "negativeContentExamples": [
      "00",
      "57",
      "60",
      "5",
      "056",
      "A1",
      "12A",
      "13-"
    ],
    "positiveHeaderExamples": [
      "us_fips_state_code",
      "state_fips_code",
      "fips_state",
      "state_fips",
      "us_state_fips_code",
      "state_fips_id",
      "fips_st_code",
      "fips_state_cd"
    ],
    "negativeHeaderExamples": [
      "state_code",
      "state_name",
      "county_fips_code",
      "country_code",
      "postal_code",
      "province_code",
      "timezone",
      "month"
    ],
    "explanation": "This semantic type identifies U.S. FIPS state codes represented as exactly two digits, covering the range 01 through 56. It is useful for normalizing and validating fields that encode states using the federal two-digit FIPS standard. The regex enforces two-digit numeric values within the valid state range while using word boundaries to avoid partial matches in longer strings. Typical use cases include mapping state identifiers across datasets, joining with reference tables, and validating ingestion of state-coded attributes.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:20.057194"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_DE",
    "description": "Complete German federal state (Bundesland) name in German. Matches the full official names of the 16 Bundesl\u00e4nder, using German spelling with correct hyphenation and diacritics.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "BADEN-W\u00dcRTTEMBERG",
      "BAYERN",
      "BERLIN",
      "BRANDENBURG",
      "BREMEN",
      "HAMBURG",
      "HESSEN",
      "MECKLENBURG-VORPOMMERN",
      "NIEDERSACHSEN",
      "NORDRHEIN-WESTFALEN",
      "RHEINLAND-PFALZ",
      "SAARLAND",
      "SACHSEN",
      "SACHSEN-ANHALT",
      "SCHLESWIG-HOLSTEIN",
      "TH\u00dcRINGEN"
    ],
    "backout": "^[A-Z\u00c4\u00d6\u00dc\u1e9e][A-Z\u00c4\u00d6\u00dc\u1e9e \\-]{2,35}$",
    "confidenceThreshold": 98,
    "priority": 5630,
    "headerPatterns": [
      {
        "regExp": "(?i).*(de|german).*(bundesland|federal[ _-]?state).*(name).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "de_bundesland_name"
        ],
        "negativeExamples": [
          "federal_state_code"
        ]
      },
      {
        "regExp": "(?i).*(de|german).*(bundesland|federal[ _-]?state).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "german_federal_state"
        ],
        "negativeExamples": [
          "state_province"
        ]
      },
      {
        "regExp": "(?i).*(bundesland)[ _-]?name.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "bundesland_name"
        ],
        "negativeExamples": [
          "bundesland_code"
        ]
      },
      {
        "regExp": "(?i).*(de|ger)[ _-]?(state|land)[ _-]?name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "de_state_name"
        ],
        "negativeExamples": [
          "country_name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "BADEN-W\u00dcRTTEMBERG",
      "BAYERN",
      "BERLIN",
      "NORDRHEIN-WESTFALEN",
      "RHEINLAND-PFALZ",
      "SCHLESWIG-HOLSTEIN",
      "MECKLENBURG-VORPOMMERN",
      "SACHSEN-ANHALT"
    ],
    "negativeContentExamples": [
      "NORDRHEIN WESTFALEN",
      "RHEINLAND PFALZ",
      "SCHLESWIG HOLSTEIN",
      "MECKLENBURG VORPOMMERN",
      "BAVARIA",
      "LOWER SAXONY",
      "HAMBURG DE",
      "BERLIN-STADT"
    ],
    "positiveHeaderExamples": [
      "de_bundesland_name",
      "german_federal_state_name",
      "bundesland_name",
      "de_state_name",
      "german_federal_state",
      "bundesland",
      "federal_state_de",
      "land_name"
    ],
    "negativeHeaderExamples": [
      "federal_state_code",
      "country_name",
      "province_name",
      "state_code_de",
      "region_name",
      "iso_3166_2_de",
      "city_name",
      "nl_province_name"
    ],
    "explanation": "This semantic type identifies the complete German names of the 16 federal states (Bundesl\u00e4nder). It uses a finite, curated list to ensure exact matches, enforcing proper German spelling and hyphenation. The backout pattern provides a safe fallback shape for uppercase German letter sequences with spaces and hyphens. Header patterns progress from German-specific field names referencing Bundesl\u00e4nder to the primitive 'name' term.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:20.735594"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_IT",
    "description": "Two-letter uppercase Italian province abbreviation (sigla), such as RM, MI, TO, NA. Intended for datasets where values are the official two-character codes for Italian provinces.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5430,
    "headerPatterns": [
      {
        "regExp": "(?i).*(italy|italian).*(provincia|province|prov).*(code|abbr|sigla).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "italy_province_code"
        ],
        "negativeExamples": [
          "italy_province_name"
        ]
      },
      {
        "regExp": "(?i).*(provincia|province|prov).*(code|abbr|sigla).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "province_code"
        ],
        "negativeExamples": [
          "province_name"
        ]
      },
      {
        "regExp": "(?i).*(it|ita|italy|italian).*(prov|province).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "it_province"
        ],
        "negativeExamples": [
          "country_province"
        ]
      },
      {
        "regExp": "(?i).*(code|abbr|sigla).*(provincia|province|prov).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code_prov"
        ],
        "negativeExamples": [
          "province_name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "RM",
      "MI",
      "TO",
      "NA",
      "FI",
      "GE",
      "BZ",
      "BA"
    ],
    "negativeContentExamples": [
      "R-M",
      "RMN",
      "R",
      "Roma",
      "12",
      "MI-",
      "M1",
      "rm"
    ],
    "positiveHeaderExamples": [
      "italy_province_code",
      "italian_prov_abbr",
      "provincia_sigla",
      "province_code",
      "prov_code",
      "it_province_code",
      "prov_abbr",
      "province_sigla"
    ],
    "negativeHeaderExamples": [
      "province_name",
      "state_code",
      "region_code",
      "country_province",
      "city_code",
      "postal_code",
      "province_id",
      "admin_region"
    ],
    "explanation": "Identifies two-letter uppercase Italian province abbreviations (sigle) commonly used in addresses and administrative datasets. Matching relies on a strict two-letter uppercase token and header cues that reference province codes or abbreviations. Use when columns contain Italian province codes rather than names or other regional identifiers.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:25.421398"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.REGION_NAME_TZ",
    "description": "mkoa_tanzania: Tanzanian administrative regional designation",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(ARUSHA|DAR ES SALAAM|DODOMA|GEITA|IRINGA|KAGERA|KATAVI|KIGOMA|KILIMANJARO|LINDI|MANYARA|MARA|MBEYA|MOROGORO|MTWARA|MWANZA|NJOMBE|PWANI|RUKWA|RUVUMA|SHINYANGA|SIMIYU|SINGIDA|SONGWE|TABORA|TANGA|KASKAZINI PEMBA|KUSINI PEMBA|KASKAZINI UNGUJA|KUSINI UNGUJA|MJINI MAGHARIBI)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5560,
    "headerPatterns": [
      {
        "regExp": "(?i).*(mkoa|region).*(tanzania|tz).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "tanzania_region_name"
        ],
        "negativeExamples": [
          "tanzania_region_code"
        ]
      },
      {
        "regExp": "(?i).*(tanzania|tz).*(region|mkoa).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "tz_region"
        ],
        "negativeExamples": [
          "region_code"
        ]
      },
      {
        "regExp": "(?i).*(region|mkoa).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "region_name"
        ],
        "negativeExamples": [
          "region_code"
        ]
      },
      {
        "regExp": "(?i).*tanzanian.*region.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "tanzanian_region"
        ],
        "negativeExamples": [
          "tanzanian_district"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Arusha",
      "Dar es Salaam",
      "Dodoma",
      "Kilimanjaro",
      "Morogoro",
      "Njombe",
      "Kaskazini Pemba",
      "Mjini Magharibi"
    ],
    "negativeContentExamples": [
      "Dar-es-Salaam",
      "Dodomaa",
      "Kilimanjaroo",
      "Moro goro",
      "Njome",
      "KaskaziniPemba",
      "Mjini-Magharibi",
      "Pwanii"
    ],
    "positiveHeaderExamples": [
      "mkoa_tanzania",
      "tz_region",
      "tanzania_region_name",
      "region_name_tz",
      "mkoa_name",
      "tanzanian_region",
      "tz_mkoa",
      "region_tz"
    ],
    "negativeHeaderExamples": [
      "tz_region_code",
      "tanzania_district_name",
      "province_name",
      "country_region",
      "tz_state",
      "region_number",
      "area_name",
      "location_code"
    ],
    "explanation": "This semantic type detects Tanzanian administrative region names (mikoa), including both Mainland and Zanzibar regions, using a case-insensitive pattern that matches the canonical set of region names. It is suited for columns containing region names and related metadata fields where the cell value is the region name string.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:25.704673"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_BR",
    "description": "br_estado_code: Brazilian state/federal district designation. Two-letter uppercase abbreviations for Brazil's 26 states and the Federal District (e.g., RJ, SP, DF). Only the official two-letter codes are valid; full state names or other subdivisions are excluded.",
    "pluginType": "regex",
    "regexPattern": "\\b(AC|AL|AP|AM|BA|CE|DF|ES|GO|MA|MT|MS|MG|PA|PB|PR|PE|PI|RJ|RN|RS|RO|RR|SC|SP|SE|TO)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5580,
    "headerPatterns": [
      {
        "regExp": "(?i).*(br|brazil).*(state|estado|uf).*(code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "br_state_code"
        ],
        "negativeExamples": [
          "state_code"
        ]
      },
      {
        "regExp": "(?i).*(estado|uf).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "estado_code"
        ],
        "negativeExamples": [
          "estado_nome"
        ]
      },
      {
        "regExp": "(?i).*(br|brazil).*(estado|uf).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "br_uf"
        ],
        "negativeExamples": [
          "us_state"
        ]
      },
      {
        "regExp": "(?i).*(state|estado).*(sigla|abbr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_abbr"
        ],
        "negativeExamples": [
          "state_name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "RJ",
      "SP",
      "MG",
      "RS",
      "DF",
      "BA",
      "SC",
      "AM"
    ],
    "negativeContentExamples": [
      "BR",
      "RJ-SP",
      "rj",
      "RJ1",
      "R J",
      "R_J",
      "SR",
      "PAO"
    ],
    "positiveHeaderExamples": [
      "br_state_code",
      "brazil_state_code",
      "uf_code",
      "estado_sigla",
      "br_uf",
      "brazilian_state_code",
      "estado_code"
    ],
    "negativeHeaderExamples": [
      "country_code",
      "postal_code",
      "state_name",
      "province",
      "region_code",
      "municipality_code",
      "ibge_code",
      "state_abbrev"
    ],
    "explanation": "This semantic type identifies Brazilian state abbreviations (including the Federal District) using the official two-letter codes, suitable for datasets with concise state designations. It is optimized for uppercase A\u2013Z codes and helps disambiguate state codes from other geographic or administrative identifiers.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:26.125662"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_ES",
    "description": "Spanish region: provincial administrative division",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00fc\u00f1]*( ((de|del|la|las|el|y|i) )?[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00fc\u00f1]*){0,4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 5460,
    "headerPatterns": [
      {
        "regExp": "(?i).*province[_ ]name[_ ]es.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province_name_es"
        ],
        "negativeExamples": [
          "province_code"
        ]
      },
      {
        "regExp": "(?i).*nombre[_ ]provincia[_ ]es.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nombre_provincia_es"
        ],
        "negativeExamples": [
          "nombre_provincia_codigo"
        ]
      },
      {
        "regExp": "(?i).*(spanish|espa[\u00f1n]ol|espa[\u00f1n]a).*(province|provincia).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "spanish_province"
        ],
        "negativeExamples": [
          "spanish_postal_code"
        ]
      },
      {
        "regExp": "(?i).*(provincia[_ ]nombre|nombre[_ ]provincia).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "provincia_nombre"
        ],
        "negativeExamples": [
          "provincia_codigo"
        ]
      },
      {
        "regExp": "(?i).*prov[_ ]name[_ ]es.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "prov_name_es"
        ],
        "negativeExamples": [
          "prov_code"
        ]
      },
      {
        "regExp": "(?i).*(provincia|province).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "provincia"
        ],
        "negativeExamples": [
          "ciudad"
        ]
      }
    ],
    "positiveContentExamples": [
      "Madrid",
      "Barcelona",
      "Valencia",
      "Sevilla",
      "Zaragoza",
      "M\u00e1laga",
      "A Coru\u00f1a",
      "Santa Cruz de Tenerife"
    ],
    "negativeContentExamples": [
      "madrid",
      "Barcelona 1",
      "Las-Palmas",
      "Santa Cruz de tenerife",
      "A  Coru\u00f1a",
      "C\u00f3rdoba.",
      "\u00c1lava/",
      "Santa Cruz d Tenerife"
    ],
    "positiveHeaderExamples": [
      "province_name_es",
      "nombre_provincia_es",
      "spanish_province",
      "provincia_nombre",
      "prov_name_es",
      "provincia",
      "provincia_es",
      "provincia_nombre_es"
    ],
    "negativeHeaderExamples": [
      "province_code",
      "state_name_es",
      "country_name_es",
      "region",
      "city_name",
      "county",
      "postal_code",
      "timezone"
    ],
    "explanation": "This type identifies Spanish province names written in Spanish, accounting for accented characters and common connecting words like 'de', 'del', 'la', 'las', 'el', 'y', and 'i'. It is suitable for columns containing values such as 'Madrid', 'A Coru\u00f1a', or 'Santa Cruz de Tenerife' and aims to capture 1\u20135 token province names with proper capitalization.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:26.403851"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_ZA",
    "description": "Two-letter South African provincial designation (sa_province_code). Values are limited to the standard set of province abbreviations.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "EC",
      "FS",
      "GP",
      "LP",
      "MP",
      "NC",
      "NW",
      "WC",
      "ZN"
    ],
    "backout": "^[A-Z]{2}$",
    "confidenceThreshold": 96,
    "priority": 5520,
    "headerPatterns": [
      {
        "regExp": "(?i).*sa.*province.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "sa_province_code"
        ],
        "negativeExamples": [
          "sa_province_name"
        ]
      },
      {
        "regExp": "(?i).*za.*province.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "za_province_code"
        ],
        "negativeExamples": [
          "za_province_name"
        ]
      },
      {
        "regExp": "(?i).*south.*africa.*province.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "south_africa_province_code"
        ],
        "negativeExamples": [
          "province_name_south_africa"
        ]
      },
      {
        "regExp": "(?i).*prov.*code.*za.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "prov_code_za"
        ],
        "negativeExamples": [
          "prov_code_us"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "EC",
      "FS",
      "GP",
      "LP",
      "MP",
      "NC",
      "NW",
      "ZN"
    ],
    "negativeContentExamples": [
      "KZ",
      "KZN",
      "EC1",
      "G P",
      "WC-",
      "ZA",
      "GP.",
      "Mp"
    ],
    "positiveHeaderExamples": [
      "sa_province_code",
      "za_province_code",
      "province_code_za",
      "south_africa_province_code",
      "prov_code_za",
      "za_prov_cd",
      "province_cd_za",
      "sa_prov_code"
    ],
    "negativeHeaderExamples": [
      "country_code",
      "province_name",
      "postal_code_za",
      "state_code",
      "sa_region_code",
      "province_id",
      "za_province",
      "subdivision_code"
    ],
    "explanation": "Identifies two-letter South African province codes in data fields and headers. Use this when a column stores standardized provincial abbreviations (e.g., EC, GP, WC) rather than full province names. The finite list ensures high precision while the backout pattern guards against near-miss two-letter values.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:26.895743"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_MX",
    "description": "mx_estado_name: complete Mexican state/federal entity name. Includes the official Spanish names of Mexico's federal entities using full forms and diacritics. Intended for full names only, not abbreviations or codes.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AGUASCALIENTES",
      "BAJA CALIFORNIA",
      "BAJA CALIFORNIA SUR",
      "CAMPECHE",
      "CHIAPAS",
      "CHIHUAHUA",
      "CIUDAD DE M\u00c9XICO",
      "COAHUILA DE ZARAGOZA",
      "COLIMA",
      "DURANGO",
      "GUANAJUATO",
      "GUERRERO",
      "HIDALGO",
      "JALISCO",
      "M\u00c9XICO",
      "MICHOAC\u00c1N DE OCAMPO",
      "MORELOS",
      "NAYARIT",
      "NUEVO LE\u00d3N",
      "OAXACA",
      "PUEBLA",
      "QUER\u00c9TARO",
      "QUINTANA ROO",
      "SAN LUIS POTOS\u00cd",
      "VERACRUZ DE IGNACIO DE LA LLAVE"
    ],
    "backout": "^[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1 ]{4,40}$",
    "confidenceThreshold": 98,
    "priority": 5640,
    "headerPatterns": [
      {
        "regExp": "(?i).*(mx|mexico).*(state|estado).*(name|nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mexico_state_name"
        ],
        "negativeExamples": [
          "estado_nombre"
        ]
      },
      {
        "regExp": "(?i).*entidad.*federativ.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "entidad_federativa"
        ],
        "negativeExamples": [
          "entidad_id"
        ]
      },
      {
        "regExp": "(?i).*(state|estado).*full.*(name|nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mx_state_full_name"
        ],
        "negativeExamples": [
          "state_abbr_mx"
        ]
      },
      {
        "regExp": "(?i).*(estado|state).*(name|nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "estado_nombre"
        ],
        "negativeExamples": [
          "estado_codigo"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "CIUDAD DE M\u00c9XICO",
      "MICHOAC\u00c1N DE OCAMPO",
      "VERACRUZ DE IGNACIO DE LA LLAVE",
      "NUEVO LE\u00d3N",
      "SAN LUIS POTOS\u00cd",
      "BAJA CALIFORNIA SUR",
      "COAHUILA DE ZARAGOZA",
      "QUER\u00c9TARO"
    ],
    "negativeContentExamples": [
      "MEXICO CITY",
      "ESTADO DE MEXICO",
      "BAJA CALIFORNIA NORTE",
      "VERACRUZ",
      "QUERETARO",
      "SAN LUIS POTOSI",
      "MICHOACAN DE OCAMPO",
      "NUEVO LEON"
    ],
    "positiveHeaderExamples": [
      "mx_estado_name",
      "estado_nombre",
      "entidad_federativa",
      "state_name_mx",
      "nombre_estado_mx",
      "mexico_state_name",
      "entidad_federativa_nombre",
      "mx_state_full_name"
    ],
    "negativeHeaderExamples": [
      "estado_codigo",
      "state_abbr_mx",
      "country_name",
      "municipio_nombre",
      "province_code",
      "zipcode_mx",
      "region_name",
      "entidad_id"
    ],
    "explanation": "This semantic type recognizes full official names of Mexico\u2019s federal entities (states and Mexico City) in Spanish, including diacritics, using a finite list for high precision. It is suitable for columns that store complete state names rather than abbreviations or codes, supporting standardized geographic normalization and validation.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:29.354250"
  },
  {
    "resultType": "generated",
    "semanticType": "GUID",
    "description": "Universally unique identifier in canonical hyphenated form: 8-4-4-4-12 hexadecimal digits separated by hyphens. Accepts uppercase or lowercase A-F and digits 0-9; braces or other delimiters are not included.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9A-Fa-f]{8}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{4}-[0-9A-Fa-f]{12}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 4520,
    "headerPatterns": [
      {
        "regExp": "(?i).*customer[ _-]*(guid|uuid).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_guid"
        ],
        "negativeExamples": [
          "customer_id"
        ]
      },
      {
        "regExp": "(?i).*(order|transaction|session|user|device|account|record)[ _-]*(guid|uuid).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "order_uuid"
        ],
        "negativeExamples": [
          "order_id"
        ]
      },
      {
        "regExp": "(?i).*\\buuid\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "uuid"
        ],
        "negativeExamples": [
          "uuid_version"
        ]
      },
      {
        "regExp": "(?i).*\\bguid\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "guid"
        ],
        "negativeExamples": [
          "guidance"
        ]
      }
    ],
    "positiveContentExamples": [
      "6f9619ff-8b86-d011-b42d-00cf4fc964ff",
      "550e8400-e29b-41d4-a716-446655440000",
      "a0c12f3a-1b2c-4d5e-8f9a-b1c2d3e4f5a6",
      "F47AC10B-58CC-4372-A567-0E02B2C3D479",
      "123e4567-e89b-12d3-a456-426614174000",
      "9b2d9c4a-3f5b-4a2e-9c5d-0b1a2c3d4e5f",
      "0f8fad5b-d9cb-469f-a165-70867728950e",
      "c56a4180-65aa-42ec-a945-5fd21dec0538"
    ],
    "negativeContentExamples": [
      "6f9619ff8b86d011b42d00cf4fc964ff",
      "550e8400-e29b-41d4-a716-44665544",
      "g23e4567-e89b-12d3-a456-426614174000",
      "123e4567-e89b-12d3-a456-4266141740000",
      "123e4567e89b-12d3-a456-426614174000",
      "{550e8400-e29b-41d4-a716-446655440000}",
      "550e8400-e29b-41d4-a716-44665544000z",
      "550e8400-e29b-41d4-a716-4466-55440000"
    ],
    "positiveHeaderExamples": [
      "customer_guid",
      "order_uuid",
      "session_guid",
      "user_uuid",
      "transaction_guid",
      "device_guid",
      "record_uuid",
      "account_guid"
    ],
    "negativeHeaderExamples": [
      "customer_id",
      "unique_id",
      "global_identifier",
      "uid",
      "guidelines",
      "guide",
      "user_key",
      "token_hash"
    ],
    "explanation": "This semantic type detects canonical hyphenated GUID/UUID values using a strict hexadecimal group structure with word boundaries to avoid partial matches. Typical use cases include keys for records, sessions, devices, or transactions where the column explicitly stores a GUID/UUID string.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:31.172858"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COMMUNE_IT",
    "description": "Italian municipality (comune) name: the official toponym of an Italian local administrative entity. Values are typically 1\u20134 tokens using letters (including accents), spaces, hyphens, and internal apostrophes, and may include common Italian particles (e.g., di, del, della, d').",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z\u00c0-\u00d6\u00d8-\u00de][a-z\u00e0-\u00f6\u00f8-\u00ff]*('[A-Z\u00c0-\u00d6\u00d8-\u00de]?[a-z\u00e0-\u00f6\u00f8-\u00ff]+)*)((([ -](di|del|della|dei|degli|da|dal|de|d|sul|sulla|sui|su|alla|alle|al|ai|a|nel|nella|nei|nelle))?[ -]([A-Z\u00c0-\u00d6\u00d8-\u00de][a-z\u00e0-\u00f6\u00f8-\u00ff]*('[A-Z\u00c0-\u00d6\u00d8-\u00de]?[a-z\u00e0-\u00f6\u00f8-\u00ff]+)*))){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5240,
    "headerPatterns": [
      {
        "regExp": "(?i).*(italian|italia|it).*(comune|municipality).*(name|nome).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "italian_municipality_name"
        ],
        "negativeExamples": [
          "municipality_code"
        ]
      },
      {
        "regExp": "(?i).*(comune|municipality).*(residenza|residence|domicilio).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "comune_residenza"
        ],
        "negativeExamples": [
          "residence_city"
        ]
      },
      {
        "regExp": "(?i).*(nome|name).*(comune|municipality).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nome_comune"
        ],
        "negativeExamples": [
          "name_province"
        ]
      },
      {
        "regExp": "(?i).*(comune|municipality).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "comune"
        ],
        "negativeExamples": [
          "province"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "address"
        ]
      }
    ],
    "positiveContentExamples": [
      "Milano",
      "Roma",
      "Napoli",
      "L'Aquila",
      "San Giorgio del Sannio",
      "Castel San Pietro Terme",
      "Castiglione d'Adda",
      "Monte Sant'Angelo"
    ],
    "negativeContentExamples": [
      "Milano (MI)",
      "Roma, IT",
      "Napoli-NA",
      "S. Giorgio",
      "City of Rome",
      "Bologna/BO",
      "20100 Milano",
      "Torino - Italy"
    ],
    "positiveHeaderExamples": [
      "comune",
      "comune_residenza",
      "italian_municipality",
      "municipality_name_it",
      "nome_comune",
      "resident_comune",
      "comune_nascita"
    ],
    "negativeHeaderExamples": [
      "province",
      "region",
      "postal_code",
      "country",
      "address_city",
      "city_code",
      "istat_code"
    ],
    "explanation": "This semantic type identifies the official name of an Italian municipality (comune). It focuses on toponyms composed of 1\u20134 tokens, allowing Italian accents, internal apostrophes (e.g., L'Aquila, Sant'Angelo), hyphens, and common connecting particles such as di, del, della, d', da, and similar. Use this type to classify columns containing Italian commune names, particularly when paired with headers indicating 'comune' or 'municipality'. The regex is intentionally constrained to reduce false positives by disallowing punctuation such as commas, parentheses, slashes, and trailing province abbreviations.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:33.076940"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_MX",
    "description": "Mexican locality: municipal administrative division",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1\u00e1\u00e9\u00ed\u00f3\u00fa\u00fc\u00f1]{1,}(\\.)?(?:[ '\\-][A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1\u00e1\u00e9\u00ed\u00f3\u00fa\u00fc\u00f1]{1,}(\\.)?){0,6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 5390,
    "headerPatterns": [
      {
        "regExp": "(?i).*(municipality|municipio).*(mx|mexico|mexican).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mx_municipality"
        ],
        "negativeExamples": [
          "municipality_name"
        ]
      },
      {
        "regExp": "(?i).*(municipality|municipio).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality_name"
        ],
        "negativeExamples": [
          "municipality_code"
        ]
      },
      {
        "regExp": "(?i).*(municipio|municipality|alcaldia).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "municipio"
        ],
        "negativeExamples": [
          "parish"
        ]
      },
      {
        "regExp": "(?i).*(mpio|muni|mun|munc).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "muni_name"
        ],
        "negativeExamples": [
          "unit_name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Benito Ju\u00e1rez",
      "Oth\u00f3n P. Blanco",
      "San Pedro Garza Garc\u00eda",
      "Gral. Zaragoza",
      "L\u00e1zaro C\u00e1rdenas",
      "Solidaridad",
      "Jos\u00e9 Mar\u00eda Morelos",
      "Villa de \u00c1lvarez"
    ],
    "negativeContentExamples": [
      "Oth\u00f3n P. Blanco, Quintana Roo",
      "San Pedro (Garza Garc\u00eda)",
      "Benito Ju\u00e1rez/QR",
      "General Zaragoza #12",
      "Tl\u00e1huac (Municipio)",
      "San Andr\u00e9s Cholula, Pue.",
      "Ciudad de M\u00e9xico (CDMX)",
      "Villa de \u00c1lvarez, Col."
    ],
    "positiveHeaderExamples": [
      "municipio_mx",
      "mx_municipality",
      "municipality_name",
      "municipio_nombre",
      "alcaldia",
      "muni_name",
      "municipio",
      "municipality"
    ],
    "negativeHeaderExamples": [
      "city_name",
      "state_province",
      "parish",
      "district_name",
      "country",
      "postal_code",
      "locality_code",
      "borough_id"
    ],
    "explanation": "Represents the official name of a Mexican municipality (municipio or alcald\u00eda), allowing common Spanish orthography, abbreviations with trailing periods (e.g., Dr., Gral., single-letter initials like P.), and multi-token names with spaces, hyphens, and apostrophes. Use for columns containing municipality names without state names or additional qualifiers.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:33.632069"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_CA",
    "description": "Full official names of Canadian provinces and territories (e.g., Alberta, Newfoundland and Labrador, Yukon). This type matches the complete province or territory name only, not abbreviations or augmented variants.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "ALBERTA",
      "BRITISH COLUMBIA",
      "MANITOBA",
      "NEW BRUNSWICK",
      "NEWFOUNDLAND AND LABRADOR",
      "NOVA SCOTIA",
      "ONTARIO",
      "PRINCE EDWARD ISLAND",
      "QUEBEC",
      "SASKATCHEWAN",
      "NORTHWEST TERRITORIES",
      "NUNAVUT",
      "YUKON"
    ],
    "backout": "^[A-Za-z][A-Za-z -]{2,30}$",
    "confidenceThreshold": 98,
    "priority": 5440,
    "headerPatterns": [
      {
        "regExp": "(?i).*(canada|ca).*(province|territor).*(name).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "canada province name"
        ],
        "negativeExamples": [
          "canada province code"
        ]
      },
      {
        "regExp": "(?i).*(province|territor).*name.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "province name"
        ],
        "negativeExamples": [
          "territory code"
        ]
      },
      {
        "regExp": "(?i).*prov.*(name|nm).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "prov nm"
        ],
        "negativeExamples": [
          "prov code"
        ]
      },
      {
        "regExp": "(?i).*(canada|ca).*(prov|territ).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "ca prov"
        ],
        "negativeExamples": [
          "ca code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "number"
        ]
      }
    ],
    "positiveContentExamples": [
      "Alberta",
      "British Columbia",
      "Manitoba",
      "New Brunswick",
      "Newfoundland and Labrador",
      "Nova Scotia",
      "Ontario",
      "Prince Edward Island"
    ],
    "negativeContentExamples": [
      "Quebec City",
      "Ontario CA",
      "BC",
      "Alberta Province",
      "Newfoundland & Labrador",
      "Northwest Territory",
      "Yukon Territory",
      "Prince Edward Isle"
    ],
    "positiveHeaderExamples": [
      "canada province name",
      "ca province name",
      "province name",
      "territory name",
      "prov name",
      "prov nm",
      "province_full_name",
      "ca_prov_name"
    ],
    "negativeHeaderExamples": [
      "province code",
      "state name",
      "country name",
      "region name",
      "city name",
      "state_province",
      "territory code",
      "ca_province_code"
    ],
    "explanation": "This semantic type identifies columns that contain the full names of Canadian provinces and territories. It is implemented as a closed list of the 13 official names, ensuring high precision for content matching. Use this type when you need to standardize or validate Canadian province/territory names in datasets where full names (not abbreviations or appended qualifiers) are expected.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:35.403817"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.CANTON_NAME_CH",
    "description": "Full name of a Swiss canton, represented as the spelled-out canton name (e.g., Zurich, Bern, Vaud). Intended to recognize the proper, human-readable canton name rather than abbreviations or codes.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(Zurich|Bern|Lucerne|Uri|Schwyz|Obwalden|Nidwalden|Glarus|Zug|Fribourg|Solothurn|Basel-Stadt|Basel-Landschaft|Schaffhausen|Appenzell Ausserrhoden|Appenzell Innerrhoden|St\\. Gallen|Grisons|Aargau|Thurgau|Ticino|Vaud|Valais|Neuchatel|Geneva|Jura)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5230,
    "headerPatterns": [
      {
        "regExp": "(?i).*canton.*name.*(switzerland|ch).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "canton_name_ch"
        ],
        "negativeExamples": [
          "canton_code_ch"
        ]
      },
      {
        "regExp": "(?i).*(swiss|switzerland|ch).*canton.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "swiss_canton_name"
        ],
        "negativeExamples": [
          "swiss_canton_code"
        ]
      },
      {
        "regExp": "(?i).*canton.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "canton_name"
        ],
        "negativeExamples": [
          "canton_code"
        ]
      },
      {
        "regExp": "(?i).*(cantonal|kanton|kt).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cantonal_name"
        ],
        "negativeExamples": [
          "central"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Zurich",
      "Bern",
      "Lucerne",
      "Basel-Stadt",
      "Basel-Landschaft",
      "St. Gallen",
      "Appenzell Ausserrhoden",
      "Vaud"
    ],
    "negativeContentExamples": [
      "Z\u00fcrich",
      "Basel Stadt",
      "St Gallen",
      "Neuch\u00e2tel",
      "Wallis",
      "Tessin",
      "Zuerich",
      "Appenzell Ausser Rhoden"
    ],
    "positiveHeaderExamples": [
      "canton_name_ch",
      "swiss_canton_name",
      "ch_canton",
      "canton_name",
      "cantonal_name",
      "kanton",
      "canton"
    ],
    "negativeHeaderExamples": [
      "canton_code",
      "province_code_ch",
      "country_name",
      "state_abbrev",
      "region_name",
      "city",
      "canton_id"
    ],
    "explanation": "This semantic type identifies full spelled-out names of Swiss cantons, enabling consistent classification of the state/province field for Switzerland. It is tailored to the canonical English forms and enforces exact name tokens, including necessary spaces, hyphens, and punctuation (e.g., St. Gallen). It intentionally excludes abbreviations, codes, and alternative-language variants not listed (e.g., Z\u00fcrich, Tessin, Wallis) to reduce ambiguity and false positives.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:36.010188"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.REGION_NAME_PE",
    "description": "region_peruana: Peruvian administrative territorial division. Names of Peru's first-level regions (departamentos/regiones) written as plain text.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AMAZONAS",
      "\u00c1NCASH",
      "APUR\u00cdMAC",
      "AREQUIPA",
      "AYACUCHO",
      "CAJAMARCA",
      "CALLAO",
      "CUSCO",
      "HUANCAVELICA",
      "HU\u00c1NUCO",
      "ICA",
      "JUN\u00cdN",
      "LA LIBERTAD",
      "LAMBAYEQUE",
      "LIMA",
      "LORETO",
      "MADRE DE DIOS",
      "MOQUEGUA",
      "PASCO",
      "PIURA",
      "PUNO",
      "SAN MART\u00cdN",
      "TACNA",
      "TUMBES",
      "UCAYALI"
    ],
    "backout": "^[A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1 ]{3,20}$",
    "confidenceThreshold": 97,
    "priority": 5550,
    "headerPatterns": [
      {
        "regExp": "(?i).*(peru|pe).*(region|departamento).*(nombre|name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "peru_region_name"
        ],
        "negativeExamples": [
          "region_code_pe"
        ]
      },
      {
        "regExp": "(?i).*(region_name|nombre_region).*(pe).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "region_name_pe"
        ],
        "negativeExamples": [
          "region_name_mx"
        ]
      },
      {
        "regExp": "(?i).*(region|departamento).*(peru|pe).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "departamento_peru"
        ],
        "negativeExamples": [
          "departamento_bolivia"
        ]
      },
      {
        "regExp": "(?i).*(reg|dpto|dept).*(pe).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "dpto_pe_name"
        ],
        "negativeExamples": [
          "dept_us_name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "\u00c1NCASH",
      "SAN MART\u00cdN",
      "MADRE DE DIOS",
      "LA LIBERTAD",
      "HU\u00c1NUCO",
      "APUR\u00cdMAC",
      "MOQUEGUA",
      "CUSCO"
    ],
    "negativeContentExamples": [
      "LIMA METROPOLITANA",
      "CALLAO PROVINCIA",
      "SAN MARTIN",
      "ANCASH",
      "LA LIBERDAD",
      "MADRE DIOS",
      "CUSCO, PE",
      "AREQUIPA-"
    ],
    "positiveHeaderExamples": [
      "peru_region_name",
      "region_peruana",
      "departamento_peru",
      "reg_pe_name",
      "nombre_region_pe",
      "region_name_pe",
      "dpto_peru_nombre"
    ],
    "negativeHeaderExamples": [
      "ubigeo_code",
      "country_region_name",
      "state_name",
      "city_name",
      "peru_region_code",
      "region",
      "dept_code_pe"
    ],
    "explanation": "This semantic type identifies text values that are the official names of Peru's first-level administrative regions (departamentos/regiones). It is intended for columns storing the region name of Peruvian addresses or geographic attributes. The list is finite and enumerates all recognized regions; a backout pattern allows cautious fallback on alphabetic names with spaces while avoiding over-broad matches. Use when you need to validate or standardize Peruvian region names rather than codes.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:36.152267"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_UNION_IN",
    "description": "Indian state/union territory designation represented as a compact code (typically two uppercase letters). Intended for identifying Indian States and Union Territories in code form, suitable for lookup, grouping, and geospatial joins.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AP",
      "AR",
      "AS",
      "BR",
      "CG",
      "DL",
      "GA",
      "GJ",
      "HR",
      "HP",
      "JH",
      "JK",
      "KA",
      "KL",
      "MP",
      "MH",
      "MN",
      "ML",
      "MZ",
      "NL",
      "OD",
      "PB",
      "RJ",
      "TN",
      "UP"
    ],
    "backout": "^[A-Z]{2}$",
    "confidenceThreshold": 95,
    "priority": 5680,
    "headerPatterns": [
      {
        "regExp": "(?i).*(in|india|indian)[_\\s-]*state[_\\s-]*(code|cd).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "in_state_code"
        ],
        "negativeExamples": [
          "state_code_us"
        ]
      },
      {
        "regExp": "(?i).*(in|india|indian)[_\\s-]*(state|ut|union[_\\s-]*territory)[_\\s-]*(code|cd).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "indian_union_territory_code"
        ],
        "negativeExamples": [
          "union_territory_name"
        ]
      },
      {
        "regExp": "(?i).*(state|ut)[_\\s-]*(code|cd).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_cd"
        ],
        "negativeExamples": [
          "state_name"
        ]
      },
      {
        "regExp": "(?i).*st[_\\s-]*cd.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "st_cd"
        ],
        "negativeExamples": [
          "st_name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "MH",
      "DL",
      "KA",
      "TN",
      "GJ",
      "RJ",
      "UP",
      "OD"
    ],
    "negativeContentExamples": [
      "IN-MH",
      "mh",
      "M H",
      "MH1",
      "OD.",
      "TN-",
      "LAK",
      "G U"
    ],
    "positiveHeaderExamples": [
      "in_state_code",
      "indian_state_code",
      "india_state_cd",
      "indian_union_territory_code",
      "state_ut_code",
      "state_cd",
      "st_cd",
      "state_code_in"
    ],
    "negativeHeaderExamples": [
      "state_name",
      "province_code",
      "country_code",
      "postal_code",
      "state_number",
      "timezone",
      "region_code",
      "in_state_name"
    ],
    "explanation": "This semantic type identifies Indian State/Union Territory codes used in datasets where a compact code is preferred over full names. It is useful for standardizing location attributes, joining reference data, and performing geographic aggregations.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:38.324063"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PREFECTURE_NAME_JA",
    "description": "Japanese prefectural administrative division names written in Japanese (Kanji), including the required suffixes: \u90fd, \u9053, \u5e9c, or \u770c. Matches the official full names of Japan's 47 prefectures such as \u6771\u4eac\u90fd, \u5317\u6d77\u9053, \u4eac\u90fd\u5e9c, \u5927\u962a\u5e9c, and the remaining 43 ending with \u770c.",
    "pluginType": "regex",
    "regexPattern": "(\u6771\u4eac\u90fd|\u5317\u6d77\u9053|\u4eac\u90fd\u5e9c|\u5927\u962a\u5e9c|\u9752\u68ee\u770c|\u5ca9\u624b\u770c|\u5bae\u57ce\u770c|\u79cb\u7530\u770c|\u5c71\u5f62\u770c|\u798f\u5cf6\u770c|\u8328\u57ce\u770c|\u6803\u6728\u770c|\u7fa4\u99ac\u770c|\u57fc\u7389\u770c|\u5343\u8449\u770c|\u795e\u5948\u5ddd\u770c|\u65b0\u6f5f\u770c|\u5bcc\u5c71\u770c|\u77f3\u5ddd\u770c|\u798f\u4e95\u770c|\u5c71\u68a8\u770c|\u9577\u91ce\u770c|\u5c90\u961c\u770c|\u9759\u5ca1\u770c|\u611b\u77e5\u770c|\u4e09\u91cd\u770c|\u6ecb\u8cc0\u770c|\u5175\u5eab\u770c|\u5948\u826f\u770c|\u548c\u6b4c\u5c71\u770c|\u9ce5\u53d6\u770c|\u5cf6\u6839\u770c|\u5ca1\u5c71\u770c|\u5e83\u5cf6\u770c|\u5c71\u53e3\u770c|\u5fb3\u5cf6\u770c|\u9999\u5ddd\u770c|\u611b\u5a9b\u770c|\u9ad8\u77e5\u770c|\u798f\u5ca1\u770c|\u4f50\u8cc0\u770c|\u9577\u5d0e\u770c|\u718a\u672c\u770c|\u5927\u5206\u770c|\u5bae\u5d0e\u770c|\u9e7f\u5150\u5cf6\u770c|\u6c96\u7e04\u770c)",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5410,
    "headerPatterns": [
      {
        "regExp": "(?i).*(prefecture|todofuken).*name.*(ja|jpn|jp).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "prefecture_name_ja"
        ],
        "negativeExamples": [
          "prefecture_code_ja"
        ]
      },
      {
        "regExp": "(?i).*(jp|jpn|ja).*(prefecture|todofuken).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "jp_prefecture_name"
        ],
        "negativeExamples": [
          "jp_prefecture_code"
        ]
      },
      {
        "regExp": "(?i).*(pref|prf).*name.*(ja|jp).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "jpn_pref_name"
        ],
        "negativeExamples": [
          "jpn_pref_code"
        ]
      },
      {
        "regExp": "(?i).*(todofuken|prefecture).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "todofuken_name"
        ],
        "negativeExamples": [
          "todofuken_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "title"
        ]
      }
    ],
    "positiveContentExamples": [
      "\u6771\u4eac\u90fd",
      "\u5317\u6d77\u9053",
      "\u5927\u962a\u5e9c",
      "\u4eac\u90fd\u5e9c",
      "\u795e\u5948\u5ddd\u770c",
      "\u6c96\u7e04\u770c",
      "\u798f\u5ca1\u770c",
      "\u65b0\u6f5f\u770c"
    ],
    "negativeContentExamples": [
      "\u6771\u4eac",
      "\u5317\u6d77\u9053\u5e81",
      "\u795e\u5948\u5ddd\u770c\u6a2a\u6d5c\u5e02",
      "\u5927\u962a",
      "\u4eac\u90fd\u5e02",
      "\u5175\u5eab\u770c\u795e\u6238\u5e02",
      "\u6c96\u7e04\u770c\u90a3\u8987\u5e02",
      "\u6771\u4eac\u90fd\u533a"
    ],
    "positiveHeaderExamples": [
      "prefecture_name_ja",
      "jp_prefecture_name",
      "jpn_pref_name",
      "todofuken_name",
      "prefecture_full_name_jp",
      "prefecture_name_japanese",
      "jp_pref_nm",
      "prefecture_name"
    ],
    "negativeHeaderExamples": [
      "prefecture_code",
      "province_name",
      "state_name",
      "city_name_ja",
      "country_name",
      "region_name_jp",
      "prefecture_id",
      "jp_prefecture_code"
    ],
    "explanation": "This semantic type identifies Japanese prefecture names written in Japanese, ensuring the presence of the correct administrative suffixes \u90fd, \u9053, \u5e9c, or \u770c. It is suited for columns that store the official full prefecture names rather than codes or translations.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:42.280011"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_MX",
    "description": "mx_estado_code: Mexican state/federal entity designation. Identifies three-letter uppercase abbreviations commonly used for Mexico\u2019s states and federal entities.",
    "pluginType": "regex",
    "regexPattern": "\\b(AGU|BCN|BCS|CAM|CHP|CHH|CMX|COA|COL|DUR|GUA|GRO|HID|JAL|MEX|MIC|MOR|NAY|NLE|OAX|PUE|QUE|ROO|SLP|SIN|SON|TAB|TAM|TLA|VER|YUC|ZAC)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 5600,
    "headerPatterns": [
      {
        "regExp": "(?i).*mx[_ ]?estado[_ ]?code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mx_estado_code"
        ],
        "negativeExamples": [
          "mx_estado_nombre"
        ]
      },
      {
        "regExp": "(?i).*mexico.*state.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mexico state code"
        ],
        "negativeExamples": [
          "mexico state name"
        ]
      },
      {
        "regExp": "(?i).*entidad.*federativa.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "entidad_federativa_code"
        ],
        "negativeExamples": [
          "entidad_federativa_nombre"
        ]
      },
      {
        "regExp": "(?i).*(estado|state).*(abbr|abbrev).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_abbr"
        ],
        "negativeExamples": [
          "state_name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "identifier"
        ]
      }
    ],
    "positiveContentExamples": [
      "AGU",
      "BCN",
      "BCS",
      "CMX",
      "JAL",
      "NLE",
      "OAX",
      "VER"
    ],
    "negativeContentExamples": [
      "DF",
      "CDMX",
      "AGUA",
      "B.C.S.",
      "jal",
      "MEX1",
      "SPL",
      "R00"
    ],
    "positiveHeaderExamples": [
      "mx_estado_code",
      "mex_state_code",
      "estado_abbr",
      "mexico state code",
      "mx state abbr",
      "entidad_federativa_code",
      "state_code_mx",
      "mx entidad code"
    ],
    "negativeHeaderExamples": [
      "state_name",
      "province_code",
      "country_code",
      "postal_code_mx",
      "mx_estado_nombre",
      "mex_state_id",
      "airport_code_mx",
      "timezone_code"
    ],
    "explanation": "This semantic type targets columns storing three-letter uppercase codes for Mexican states and the federal entity. It is useful for validating and standardizing datasets that use concise state designations rather than full state names.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:42.435709"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.DEPARTMENT_CO",
    "description": "Colombian region: departmental administrative unit. Identifies the official first-level administrative divisions of Colombia (departamentos) and the Capital District when written as a department-equivalent.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(AMAZONAS|ANTIOQUIA|ARAUCA|ATLANTICO|ATL\u00c1NTICO|BOLIVAR|BOL\u00cdVAR|BOYACA|BOYAC\u00c1|CALDAS|CAQUETA|CAQUET\u00c1|CASANARE|CAUCA|CESAR|CHOCO|CHOC\u00d3|CORDOBA|C\u00d3RDOBA|CUNDINAMARCA|GUAINIA|GUAIN\u00cdA|GUAVIARE|HUILA|LA GUAJIRA|GUAJIRA|MAGDALENA|META|NARINO|NARI\u00d1O|NORTE DE SANTANDER|PUTUMAYO|QUINDIO|QUIND\u00cdO|RISARALDA|SAN ANDRES Y PROVIDENCIA|SAN ANDR\u00c9S Y PROVIDENCIA|ARCHIPIELAGO DE SAN ANDRES, PROVIDENCIA Y SANTA CATALINA|ARCHIPI\u00c9LAGO DE SAN ANDR\u00c9S, PROVIDENCIA Y SANTA CATALINA|SANTANDER|SUCRE|TOLIMA|VALLE DEL CAUCA|VAUPES|VAUP\u00c9S|VICHADA|BOGOTA D\\.C\\.|BOGOT\u00c1 D\\.C\\.|BOGOTA, D\\.C\\.|BOGOT\u00c1, D\\.C\\.|BOGOTA DC|BOGOT\u00c1 DC|DISTRITO CAPITAL)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5300,
    "headerPatterns": [
      {
        "regExp": "(?i).*(colombia|colombian|co).*(departamento|department).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "colombia_department"
        ],
        "negativeExamples": [
          "department_list"
        ]
      },
      {
        "regExp": "(?i).*(co|colombia).*(dpto|dept).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "co_dpto"
        ],
        "negativeExamples": [
          "region_colombia"
        ]
      },
      {
        "regExp": "(?i).*(state|province).*(colombia|co).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_colombia"
        ],
        "negativeExamples": [
          "state_code"
        ]
      },
      {
        "regExp": "(?i).*(region).*(colombia|co).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "region_co"
        ],
        "negativeExamples": [
          "region_eu"
        ]
      },
      {
        "regExp": "(?i).*department.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "department"
        ],
        "negativeExamples": [
          "province"
        ]
      }
    ],
    "positiveContentExamples": [
      "Antioquia",
      "Atl\u00e1ntico",
      "Boyac\u00e1",
      "Choc\u00f3",
      "C\u00f3rdoba",
      "Nari\u00f1o",
      "Valle del Cauca",
      "Norte de Santander"
    ],
    "negativeContentExamples": [
      "Norte Santander",
      "San Andr\u00e9s Providencia",
      "LaGuajira",
      "Cauca Valley",
      "Amazon",
      "Cordova",
      "Quindioo",
      "Bogota Capital District"
    ],
    "positiveHeaderExamples": [
      "colombia_department",
      "department_co",
      "co_dpto",
      "departamento",
      "state_colombia",
      "region_colombia",
      "dept_co",
      "nombre_departamento"
    ],
    "negativeHeaderExamples": [
      "department_budget",
      "customer_department",
      "department_id",
      "province_code",
      "state",
      "country",
      "city",
      "postal_code"
    ],
    "explanation": "This semantic type recognizes the names of Colombia's first-level administrative divisions (departamentos) and the Capital District when expressed in department form (e.g., Bogot\u00e1 D.C., Distrito Capital). It is useful for geospatial normalization, regional aggregations, and validating location fields specifically scoped to Colombia's departmental units.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:44.995881"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_BR",
    "description": "Complete Brazilian state or federal district name (in Portuguese), allowing common presence or absence of diacritics in the value (e.g., S\u00e3o Paulo or Sao Paulo). Values are full names such as \"Rio Grande do Sul\", not abbreviations or codes.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(ACRE|ALAGOAS|AMAPA|AMAP\u00c1|AMAZONAS|BAHIA|CEARA|CEAR\u00c1|DISTRITO FEDERAL|ESPIRITO SANTO|ESP\u00cdRITO SANTO|GOIAS|GOI\u00c1S|MARANHAO|MARANH\u00c3O|MATO GROSSO DO SUL|MATO GROSSO|MINAS GERAIS|PARA|PAR\u00c1|PARAIBA|PARA\u00cdBA|PARANA|PARAN\u00c1|PERNAMBUCO|PIAUI|PIAU\u00cd|RIO DE JANEIRO|RIO GRANDE DO NORTE|RIO GRANDE DO SUL|RONDONIA|ROND\u00d4NIA|RORAIMA|SANTA CATARINA|SAO PAULO|S\u00c3O PAULO|SERGIPE|TOCANTINS)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5620,
    "headerPatterns": [
      {
        "regExp": "(?i).*(br|brazil).*(estado|state).*(nome|name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "br_estado_nome"
        ],
        "negativeExamples": [
          "state_name"
        ]
      },
      {
        "regExp": "(?i).*(br|brazil).*(estado|state).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "brazil_state"
        ],
        "negativeExamples": [
          "country_state"
        ]
      },
      {
        "regExp": "(?i).*(estado|state).*(nome|name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "estado_nome"
        ],
        "negativeExamples": [
          "country_name"
        ]
      },
      {
        "regExp": "(?i).*(nome do estado|state name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nome do estado"
        ],
        "negativeExamples": [
          "nome do pais"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "S\u00e3o Paulo",
      "Rio de Janeiro",
      "Minas Gerais",
      "Bahia",
      "Paran\u00e1",
      "Cear\u00e1",
      "Distrito Federal",
      "Esp\u00edrito Santo"
    ],
    "negativeContentExamples": [
      "Sao-Paulo",
      "Rio Grande",
      "Espirito-Santo",
      "Rondon\u00eda",
      "Rio de Janiero",
      "Distrito-Federal",
      "MinasGerais",
      "Bah\u00eda"
    ],
    "positiveHeaderExamples": [
      "br_estado_nome",
      "estado_nome",
      "nome_estado",
      "brazil_state_name",
      "state_name_br",
      "nome do estado",
      "full_state_name_br",
      "estado"
    ],
    "negativeHeaderExamples": [
      "uf",
      "state_code_br",
      "country_name",
      "municipio",
      "cidade",
      "region_name",
      "state_abbr",
      "postal_code"
    ],
    "explanation": "This semantic type recognizes the complete names of Brazilian states and the federal district. It uses a controlled alternation of known valid state names, including both accented and unaccented variants, bounded by word boundaries to minimize false positives. Typical use cases include normalizing location columns where full state names are stored, validating inputs, and mapping to codes (UF) in ETL pipelines.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:47.469563"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_US",
    "description": "Full U.S. state names written as complete words (e.g., California, New York, North Dakota), covering the 50 states only. Excludes abbreviations, postal codes, territories, and District of Columbia; intended for datasets storing full state names rather than codes.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(Alabama|Alaska|Arizona|Arkansas|California|Colorado|Connecticut|Delaware|Florida|Georgia|Hawaii|Idaho|Illinois|Indiana|Iowa|Kansas|Kentucky|Louisiana|Maine|Maryland|Massachusetts|Michigan|Minnesota|Mississippi|Missouri|Montana|Nebraska|Nevada|New Hampshire|New Jersey|New Mexico|New York|North Carolina|North Dakota|Ohio|Oklahoma|Oregon|Pennsylvania|Rhode Island|South Carolina|South Dakota|Tennessee|Texas|Utah|Vermont|Virginia|Washington|West Virginia|Wisconsin|Wyoming)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5650,
    "headerPatterns": [
      {
        "regExp": "(?i).*(us|usa|united[ _-]?states|american).*(state).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "us_state_name"
        ],
        "negativeExamples": [
          "us_state_code"
        ]
      },
      {
        "regExp": "(?i).*(state).*(full|long).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_full_name"
        ],
        "negativeExamples": [
          "state_full_code"
        ]
      },
      {
        "regExp": "(?i).*(state[_ -]?name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_state_name"
        ],
        "negativeExamples": [
          "customer_state_code"
        ]
      },
      {
        "regExp": "(?i).*(state[_ -]?province).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_province_name"
        ],
        "negativeExamples": [
          "province_name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "California",
      "New York",
      "North Dakota",
      "Rhode Island",
      "Hawaii",
      "Washington",
      "Massachusetts",
      "New Mexico"
    ],
    "negativeContentExamples": [
      "NewYork",
      "Rhode-Island",
      "N Dakota",
      "United States",
      "Puerto Rico",
      "Washingt0n",
      "New Yorks",
      "CA"
    ],
    "positiveHeaderExamples": [
      "us_state_name",
      "state_full_name",
      "customer_state_name",
      "shipping_state_name",
      "american_state_name",
      "united_states_state_name",
      "state_long_name",
      "billing_state_name"
    ],
    "negativeHeaderExamples": [
      "state_code",
      "us_state_code",
      "state_abbreviation",
      "province_name",
      "country_name",
      "state",
      "region_name",
      "state_numeric_code"
    ],
    "explanation": "This semantic type identifies full U.S. state names using an explicit, case-insensitive enumeration of the 50 states. It is intended for columns that store the complete state designation, not abbreviations or codes, and excludes territories and the District of Columbia.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:48.198473"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS4_EN",
    "description": "Address line 4 focused on specialized facility/location designations within a site or building (e.g., Building, Unit, Suite, Floor, Room, Dock, Bay). Intended to capture intra-site delivery or routing details that refine a street address.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(building|bldg|unit|suite|ste|floor|fl|apt|room|rm|dept|department|wing|tower|block|bay|dock|hangar|warehouse|whse|lab|laboratory|campus|plant|shop|office|reception|mail stop|mailstop|receiving|shipping|data center|server room|loading dock|lot|section|sec)\\b([ -]?[A-Z0-9]{1,4}){0,2}([ -]?(N|S|E|W|NE|NW|SE|SW|NORTH|SOUTH|EAST|WEST))?",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5740,
    "headerPatterns": [
      {
        "regExp": "(?i).*street.*address.*4.*en.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "street_address4_en"
        ],
        "negativeExamples": [
          "street_address4"
        ]
      },
      {
        "regExp": "(?i).*address.*line.*4.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "address_line4"
        ],
        "negativeExamples": [
          "address_line3"
        ]
      },
      {
        "regExp": "(?i).*addr.*ln.*4.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "addr_ln4"
        ],
        "negativeExamples": [
          "addr_ln"
        ]
      },
      {
        "regExp": "(?i).*address.*4.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "address4"
        ],
        "negativeExamples": [
          "address3"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "address"
        ],
        "negativeExamples": [
          "city"
        ]
      }
    ],
    "positiveContentExamples": [
      "Building A",
      "Bldg 7",
      "Suite 305",
      "Unit 5A",
      "Room 204B",
      "Wing East",
      "Dock 3",
      "Data Center North"
    ],
    "negativeContentExamples": [
      "123 Main St",
      "PO Box 456",
      "Apartment 3B",
      "Flr 2",
      "Suit 305",
      "BuildingA",
      "Towering West",
      "Depart 12"
    ],
    "positiveHeaderExamples": [
      "address_line4",
      "addr_line4",
      "street_address4_en",
      "address4",
      "addr_ln4",
      "facility_location",
      "building_unit",
      "location_designation"
    ],
    "negativeHeaderExamples": [
      "address_line1",
      "street_address",
      "address3",
      "address_details",
      "delivery_instructions",
      "po_box",
      "attention",
      "city"
    ],
    "explanation": "This semantic type targets the fourth address line often used to specify intra-site facility details such as buildings, floors, rooms, docks, bays, or specialized campus areas. It helps distinguish precise delivery or routing locations within a larger site or building, complementing street address lines and city/postal fields.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:48.912934"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_NL",
    "description": "Netherlands territory: provincial administrative division. Recognizes official province names of the Netherlands (12 provinces), using Dutch naming conventions including hyphenated forms for Noord-/Zuid- variants.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "DRENTHE",
      "FLEVOLAND",
      "FRIESLAND",
      "GELDERLAND",
      "GRONINGEN",
      "LIMBURG",
      "NOORD-BRABANT",
      "NOORD-HOLLAND",
      "OVERIJSSEL",
      "UTRECHT",
      "ZEELAND",
      "ZUID-HOLLAND"
    ],
    "backout": "^[A-Z][A-Z-]+( [A-Z][A-Z-]+)*$",
    "confidenceThreshold": 98,
    "priority": 5490,
    "headerPatterns": [
      {
        "regExp": "(?i).*(netherlands|nl).*province.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "netherlands_province_name"
        ],
        "negativeExamples": [
          "province_name"
        ]
      },
      {
        "regExp": "(?i).*provincie.*naam.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "provincie_naam"
        ],
        "negativeExamples": [
          "provincie_code"
        ]
      },
      {
        "regExp": "(?i).*(netherlands|nl).*(province|provincie).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "netherlands_province"
        ],
        "negativeExamples": [
          "province_code_nl"
        ]
      },
      {
        "regExp": "(?i).*\\bprov\\b.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "prov_name_nl"
        ],
        "negativeExamples": [
          "provider_name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Noord-Holland",
      "Zuid-Holland",
      "Noord-Brabant",
      "Gelderland",
      "Overijssel",
      "Flevoland",
      "Friesland",
      "Utrecht"
    ],
    "negativeContentExamples": [
      "Holland",
      "Zuid Holland",
      "Noord Brabant",
      "South Holland",
      "Overijsel",
      "Brabant",
      "Utrecht Province",
      "Randstad"
    ],
    "positiveHeaderExamples": [
      "nl_province_name",
      "netherlands_province_name",
      "province_name_nl",
      "nl_provincie_naam",
      "provincial_name_netherlands",
      "prov_name_nl",
      "provincie_naam",
      "netherlands_province"
    ],
    "negativeHeaderExamples": [
      "province_code_nl",
      "state_name",
      "city_name_nl",
      "country",
      "county_name",
      "region_name",
      "province",
      "province_id"
    ],
    "explanation": "This semantic type identifies Dutch province names within the Netherlands. It is a finite, well-defined set of 12 official names and is best recognized via a controlled list, with a conservative backout shape for uppercase words and hyphenated tokens. Typical use cases include normalizing administrative geography fields, validating province columns in NL datasets, and preventing confusion with codes or non-Dutch regional terms.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:54.021707"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.DEPARTMENT_NAME_FR",
    "description": "Names of French departments (administrative divisions) written in French, allowing spaces, hyphens, and apostrophes with French diacritics. Typical examples include single-word and multi-word department names such as Ain, C\u00f4tes-d'Armor, or Territoire de Belfort.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b([a-z\u00e0\u00e2\u00e4\u00e6\u00e7\u00e9\u00e8\u00ea\u00eb\u00ee\u00ef\u00f4\u00f6\u00f9\u00fb\u00fc\u00ff\u0153]+(['\u2019][a-z\u00e0\u00e2\u00e4\u00e6\u00e7\u00e9\u00e8\u00ea\u00eb\u00ee\u00ef\u00f4\u00f6\u00f9\u00fb\u00fc\u00ff\u0153]+)?)([ -]([a-z\u00e0\u00e2\u00e4\u00e6\u00e7\u00e9\u00e8\u00ea\u00eb\u00ee\u00ef\u00f4\u00f6\u00f9\u00fb\u00fc\u00ff\u0153]+(['\u2019][a-z\u00e0\u00e2\u00e4\u00e6\u00e7\u00e9\u00e8\u00ea\u00eb\u00ee\u00ef\u00f4\u00f6\u00f9\u00fb\u00fc\u00ff\u0153]+)?)){0,4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5310,
    "headerPatterns": [
      {
        "regExp": "(?i).*(department[_ -]*name[_ -]*fr|departement[_ -]*nom[_ -]*fr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "department_name_fr"
        ],
        "negativeExamples": [
          "department_code_fr"
        ]
      },
      {
        "regExp": "(?i).*french[_ -]*(department|departement)[_ -]*(name|nom).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "french_department_name"
        ],
        "negativeExamples": [
          "french_department_code"
        ]
      },
      {
        "regExp": "(?i).*(departement[_ -]*nom|department[_ -]*name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "departement_nom"
        ],
        "negativeExamples": [
          "departement_code"
        ]
      },
      {
        "regExp": "(?i).*(department|departement).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "departement"
        ],
        "negativeExamples": [
          "department_code"
        ]
      },
      {
        "regExp": "(?i).*(dept|dep)[_ -]*(name|nom).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "dept_name_fr"
        ],
        "negativeExamples": [
          "dep_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Ain",
      "Aisne",
      "Allier",
      "C\u00f4tes-d'Armor",
      "Loire-Atlantique",
      "Hauts-de-Seine",
      "Territoire de Belfort",
      "Val-d'Oise"
    ],
    "negativeContentExamples": [
      "Ain (01)",
      "Seine-Saint-Denis 93",
      "Val-d'Oise-",
      "Loir_et_Cher",
      "Nord\u2013Pas-de-Calais",
      "Haute-Corse.",
      "Alpes--Maritimes",
      "Territoire de Belfort, 90"
    ],
    "positiveHeaderExamples": [
      "department_name_fr",
      "nom_departement",
      "departement_nom_fr",
      "french_department_name",
      "dept_name_fr",
      "nom_dep_fr",
      "departement_nom",
      "fr_department_name"
    ],
    "negativeHeaderExamples": [
      "department_code",
      "dept_number",
      "region_name_fr",
      "nom_commune",
      "country_name_fr",
      "dep_code",
      "department_id",
      "name_en"
    ],
    "explanation": "This semantic type identifies the official names of French departments written in French. Values consist of one to five word tokens using letters (including French diacritics), optional internal apostrophes, and separators limited to single spaces or hyphens. It is useful for normalizing and classifying administrative division names at the department level across metropolitan and overseas French territories.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:43:54.174585"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_US",
    "description": "US state code: two-letter postal abbreviation for U.S. states (e.g., CA, NY). Values are uppercase A\u2013Z and limited to the 50 states.",
    "pluginType": "regex",
    "regexPattern": "\\b(AL|AK|AZ|AR|CA|CO|CT|DE|FL|GA|HI|ID|IL|IN|IA|KS|KY|LA|ME|MD|MA|MI|MN|MS|MO|MT|NE|NV|NH|NJ|NM|NY|NC|ND|OH|OK|OR|PA|RI|SC|SD|TN|TX|UT|VT|VA|WA|WV|WI|WY)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5700,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\b(us|usa|united[ _-]?states)\\b.*\\b(state|st)\\b.*\\b(code|cd|abbr|abbrev)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "us_state_code"
        ],
        "negativeExamples": [
          "country_code"
        ]
      },
      {
        "regExp": "(?i).*\\b(state|st)\\b.*\\b(postal|two[ _-]?letter)\\b.*\\b(code|cd|abbr|abbrev)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_postal_code"
        ],
        "negativeExamples": [
          "province_code"
        ]
      },
      {
        "regExp": "(?i).*\\b(state|st)[ _-]?(code|cd|abbr|abbrev)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "st_cd"
        ],
        "negativeExamples": [
          "status_code"
        ]
      },
      {
        "regExp": "(?i).*\\b(us|usa|united[ _-]?states)\\b.*\\b(state|st)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "us_state"
        ],
        "negativeExamples": [
          "state_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "CA",
      "NY",
      "TX",
      "FL",
      "WA",
      "IL",
      "GA",
      "MA"
    ],
    "negativeContentExamples": [
      "PR",
      "DC",
      "NYC",
      "C A",
      "C-A",
      "ca",
      "AK1",
      "AA"
    ],
    "positiveHeaderExamples": [
      "us_state_code",
      "state_postal_code",
      "st_cd",
      "state_abbr",
      "usa_state_abbrev",
      "united_states_state_cd",
      "us_st_code",
      "state_two_letter_code"
    ],
    "negativeHeaderExamples": [
      "country_code",
      "province_code",
      "status_code",
      "state_name",
      "postal_code",
      "region_code",
      "us_state_name",
      "zip_code"
    ],
    "explanation": "This semantic type identifies two-letter U.S. state postal abbreviations for the 50 states. It is useful for validating state fields, normalizing addresses, and distinguishing state code columns from similar geographic identifiers.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:44:01.900048"
  },
  {
    "resultType": "generated",
    "semanticType": "TIMEZONE.IANA",
    "description": "IANA timezone: standardized global time zone identifier from the IANA TZ database, typically in the form Area/Location or Area/Subarea/Location, and includes canonical singletons like UTC.",
    "pluginType": "regex",
    "regexPattern": "\\b(UTC|GMT|UT|[A-Za-z]{2,}(/[A-Za-z0-9._+-]{2,}){1,3})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 5830,
    "headerPatterns": [
      {
        "regExp": "(?i).*(iana.*time.?zone|time.?zone.*iana|iana.*tz|tz.*iana).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "iana_timezone"
        ],
        "negativeExamples": [
          "timezone_format"
        ]
      },
      {
        "regExp": "(?i).*(time.?zone.*id|time.?zone.*identifier|\\btzid\\b).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "timezone_id"
        ],
        "negativeExamples": [
          "user_id"
        ]
      },
      {
        "regExp": "(?i).*(\\btzid\\b|\\btzdb\\b|\\btz\\b).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "tzid"
        ],
        "negativeExamples": [
          "utc_offset"
        ]
      },
      {
        "regExp": "(?i).*time.?zone.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "timezone"
        ],
        "negativeExamples": [
          "time_offset"
        ]
      }
    ],
    "positiveContentExamples": [
      "America/New_York",
      "Europe/Berlin",
      "Asia/Kolkata",
      "Pacific/Port_Moresby",
      "Etc/UTC",
      "America/Argentina/Buenos_Aires",
      "America/North_Dakota/New_Salem",
      "UTC"
    ],
    "negativeContentExamples": [
      "America New_York",
      "Europe-berlin",
      "America\\New_York",
      "America//New_York",
      "UTC+01",
      "GMT+0",
      "Pacific/ Pago_Pago",
      "America/Argentina//Buenos_Aires"
    ],
    "positiveHeaderExamples": [
      "iana_timezone",
      "timezone",
      "timezone_id",
      "tzid",
      "tz_database",
      "user_timezone",
      "preferred_tz",
      "time_zone_identifier"
    ],
    "negativeHeaderExamples": [
      "utc_offset",
      "time_offset",
      "country",
      "locale",
      "datetime",
      "gmt_offset",
      "region",
      "city"
    ],
    "explanation": "Identifies IANA time zone identifiers such as Area/Location or Area/Subarea/Location (e.g., America/New_York, America/North_Dakota/New_Salem) and includes canonical singletons like UTC. Useful for standardizing and validating timezone fields in datasets for scheduling, localization, and temporal analysis.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:44:01.908808"
  },
  {
    "resultType": "generated",
    "semanticType": "VIN",
    "description": "vehicle_id: 17-character automotive identification code composed of uppercase letters (excluding I, O, Q) and digits, with no spaces or separators. Pattern matches a contiguous 17-character token suitable for standard VIN formats.",
    "pluginType": "regex",
    "regexPattern": "\\b[ABCDEFGHJKLMNPRSTUVWXYZ0-9]{17}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5850,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bvehicle\\b.*\\bidentification\\b.*\\bnumber\\b.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "vehicle_identification_number"
        ],
        "negativeExamples": [
          "vehicle_registration_number"
        ]
      },
      {
        "regExp": "(?i).*\\bvin\\b.*\\bnumber\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "vin_number"
        ],
        "negativeExamples": [
          "vin_decoder"
        ]
      },
      {
        "regExp": "(?i).*\\bvehicle\\b.*\\bid\\b.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "vehicle_id"
        ],
        "negativeExamples": [
          "customer_id"
        ]
      },
      {
        "regExp": "(?i).*\\bvin\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "vin"
        ],
        "negativeExamples": [
          "vehicle_code"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "identification_code"
        ],
        "negativeExamples": [
          "id"
        ]
      }
    ],
    "positiveContentExamples": [
      "1HGCM82633A004352",
      "WBA3A5C53FF607890",
      "JHMFA36207S012345",
      "5YJ3E1EA7HF000337",
      "2GCEK19T1Y1234567",
      "SALWR2VF4FA123456",
      "3N1AB7AP7FY256789",
      "VF3CCBHZ6HS123456"
    ],
    "negativeContentExamples": [
      "1HGCM82633A00435",
      "1HGCM82633A0043521",
      "1HGIM82633A004352",
      "1HGCM82633O004352",
      "1HGCM82633Q004352",
      "1hgcm82633a004352",
      "1HGCM82633A00-352",
      "1HGCM82633A00 352"
    ],
    "positiveHeaderExamples": [
      "vehicle_identification_number",
      "vin",
      "vin_number",
      "vehicle_id",
      "vehicle_identification_code",
      "chassis_vin",
      "vehicle_vin",
      "identification_code"
    ],
    "negativeHeaderExamples": [
      "vehicle_registration_number",
      "engine_number",
      "customer_id",
      "order_code",
      "product_code",
      "license_plate",
      "plate_number",
      "driver_id"
    ],
    "explanation": "This semantic type identifies Vehicle Identification Numbers (VINs), which are 17-character alphanumeric identifiers used to uniquely identify motor vehicles. The regex enforces uppercase letters excluding I, O, and Q, and requires a contiguous 17-character token with no separators. Header patterns progress from explicit VIN terminology to general identification code terms to aid discovery when headers vary.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:44:04.853804"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_NUMBER",
    "description": "Numeric house or property number used in street addressing. Accepts plain integers from 1 to 6 digits without prefixes, suffixes, letters, or ranges.",
    "pluginType": "regex",
    "regexPattern": "\\b[1-9][0-9]{0,5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 5810,
    "headerPatterns": [
      {
        "regExp": "(?i).*street[ _-]*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "street_number"
        ],
        "negativeExamples": [
          "street_name"
        ]
      },
      {
        "regExp": "(?i).*house[ _-]*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "house number"
        ],
        "negativeExamples": [
          "house_name"
        ]
      },
      {
        "regExp": "(?i).*(address|addr)[ _-]*(number|no)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "addr_no"
        ],
        "negativeExamples": [
          "address_line1"
        ]
      },
      {
        "regExp": "(?i).*(st[ _-]*no|str[ _-]*no|hnr)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "st_no"
        ],
        "negativeExamples": [
          "st_name"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "unit_no"
        ]
      }
    ],
    "positiveContentExamples": [
      "1",
      "9",
      "27",
      "105",
      "742",
      "3601",
      "45000",
      "120005"
    ],
    "negativeContentExamples": [
      "0",
      "0012",
      "12A",
      "A12",
      "12-14",
      "12 1/2",
      "1234567",
      "B-12"
    ],
    "positiveHeaderExamples": [
      "street_number",
      "house_number",
      "address_number",
      "addr_no",
      "street no",
      "st_no",
      "hnr"
    ],
    "negativeHeaderExamples": [
      "street_name",
      "house_name",
      "address_line1",
      "unit_no",
      "apartment_no",
      "suite_no",
      "parcel_id",
      "street_code"
    ],
    "explanation": "This semantic type targets the numeric portion of a street address, typically the house or property number. It matches standalone integers between 1 and 6 digits and intentionally excludes ranges, letter suffixes, fractional values, and alphanumeric formats to reduce ambiguity.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:44:07.499419"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_NL",
    "description": "Netherlands locality: municipal administrative unit. Matches official Dutch municipality names, including typical diacritics, hyphens, apostrophes, and occasional parenthetical qualifiers.\nThis type focuses on Dutch municipalities (gemeenten) and is not intended for provinces, neighborhoods, or postal localities.",
    "pluginType": "regex",
    "regexPattern": "\\b(('s|\u2019s)-[A-Z][A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]+|[A-Z][A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]+)(?:[- ][A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff()'.]{2,24}){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5400,
    "headerPatterns": [
      {
        "regExp": "(?i).*(nl|nld|netherlands).*(municipality|gemeente).*(name|naam).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nl_municipality_name"
        ],
        "negativeExamples": [
          "municipality_name_fr"
        ]
      },
      {
        "regExp": "(?i).*(nl|nld|netherlands).*(municipality|gemeente).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "netherlands_gemeente"
        ],
        "negativeExamples": [
          "province_nl"
        ]
      },
      {
        "regExp": "(?i).*(municipality|gemeente).*(name|naam).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality_name"
        ],
        "negativeExamples": [
          "municipal_code"
        ]
      },
      {
        "regExp": "(?i).*(muni|gem)\\b.*(name|naam).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "gem_naam"
        ],
        "negativeExamples": [
          "gem_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Amsterdam",
      "Rotterdam",
      "\u2019s-Hertogenbosch",
      "'s-Gravenhage",
      "S\u00fadwest-Frysl\u00e2n",
      "Eijsden-Margraten",
      "Bergen (NH)",
      "Stichtse Vecht"
    ],
    "negativeContentExamples": [
      "amsterdam",
      "'s-gravenhage",
      "den haag",
      "nijmegen",
      "amsterdam 1012",
      "den  haag",
      "utrecht/provincie",
      "bergen(nh)"
    ],
    "positiveHeaderExamples": [
      "nl_municipality_name",
      "netherlands_gemeente",
      "municipality_name",
      "gemeente_naam",
      "muni_name_nl",
      "gem_naam",
      "netherlands_municipality_name",
      "nl_gemeente_naam"
    ],
    "negativeHeaderExamples": [
      "province",
      "city",
      "postal_code",
      "country",
      "state_province",
      "municipality_code",
      "neighborhood",
      "place_code"
    ],
    "explanation": "This semantic type identifies names of municipalities (gemeenten) within the Netherlands. It accepts common linguistic forms used in Dutch municipality names, including diacritics, hyphenated names, leading \u2019s-/\u2019s- forms, and occasional parenthetical qualifiers used for disambiguation. Typical use cases include categorizing administrative localities for address normalization, demographic reporting, and geospatial aggregation at the municipality level.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:44:10.246598"
  },
  {
    "resultType": "generated",
    "semanticType": "NATIONALITY_NL",
    "description": "Dutch-language nationality (nationaliteit): values expressing a person's legal nation-state relationship written in Dutch, typically as adjectival demonyms (e.g., Nederlandse, Belgische) and similar forms. This type focuses on common Dutch adjectival endings such as -se, -ische, -aanse, -ense, -ese, and -i\u00ebrse.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Za-z\u00c0-\u00ff]{3,}([ -][A-Za-z\u00c0-\u00ff]{2,}){0,2})(se|sche|ische|aanse|ense|ese|i\u00ebrse)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 4910,
    "headerPatterns": [
      {
        "regExp": "(?i).*(nl|nederlands).*nationaliteit.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "nl_nationaliteit"
        ],
        "negativeExamples": [
          "nederlandse_taal"
        ]
      },
      {
        "regExp": "(?i).*nationaliteit.*(nl|nederlands).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nationaliteit_nl"
        ],
        "negativeExamples": [
          "nationaliteit_datum"
        ]
      },
      {
        "regExp": "(?i).*(nationaliteit|nationality).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "nationality_nl"
        ],
        "negativeExamples": [
          "nationalisatie_datum"
        ]
      },
      {
        "regExp": "(?i).*(natl|nat|nation).*",
        "confidence": 90,
        "mandatory": false,
        "positiveExamples": [
          "natl"
        ],
        "negativeExamples": [
          "natuurlijk_persoon"
        ]
      },
      {
        "regExp": "(?i).*nationaliteit.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nationaliteit"
        ],
        "negativeExamples": [
          "geboorteland"
        ]
      }
    ],
    "positiveContentExamples": [
      "Nederlandse",
      "Belgische",
      "Duitse",
      "Franse",
      "Spaanse",
      "Italiaanse",
      "Zweedse",
      "Marokkaanse"
    ],
    "negativeContentExamples": [
      "Nederlander",
      "Belg",
      "Duitser",
      "Fransman",
      "Spanjaard",
      "Italiaan",
      "Zweed",
      "Marokkaan"
    ],
    "positiveHeaderExamples": [
      "nationaliteit",
      "nederlandse nationaliteit",
      "nationaliteit_nl",
      "nl_nationaliteit",
      "klant_nationaliteit",
      "burger nationaliteit",
      "nationality_nl",
      "persoon nationaliteit"
    ],
    "negativeHeaderExamples": [
      "geboorteland",
      "land van herkomst",
      "taal",
      "nationalisatie_datum",
      "staatsburgerschap_datum",
      "woonland",
      "country",
      "identiteit"
    ],
    "explanation": "This semantic type identifies Dutch-language nationality values, focusing on adjectival demonyms common in Dutch (e.g., Nederlandse, Belgische, Franse). The value pattern emphasizes typical Dutch suffixes such as -se, -ische, -aanse, -ense, -ese, and -i\u00ebrse to reduce ambiguity. It is most accurate when paired with headers containing nationaliteit or nationality, optionally with nl/nederlands qualifiers.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:44:16.785544"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_PE",
    "description": "Peruvian region: provincial administrative division",
    "pluginType": "regex",
    "regexPattern": "\\b(Provincia|Prov\\.) (de )?[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1][A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\\-']+( ((de|del|la|las|los|y) )?[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1][A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\\-']+){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 5500,
    "headerPatterns": [
      {
        "regExp": "(?i).*(province_name_pe|provincia_nombre_pe|peru_province_name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province_name_pe"
        ],
        "negativeExamples": [
          "region_name_pe"
        ]
      },
      {
        "regExp": "(?i).*(provincia|province).*(peru|pe).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "peru_province"
        ],
        "negativeExamples": [
          "province_code"
        ]
      },
      {
        "regExp": "(?i).*(province|provincia).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province_name"
        ],
        "negativeExamples": [
          "province_code"
        ]
      },
      {
        "regExp": "(?i).*(prov|prov_name|provincia_nom).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "prov_name"
        ],
        "negativeExamples": [
          "region"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Provincia de Huaral",
      "Provincia de Huarmey",
      "Provincia de Paita",
      "Provincia de San Rom\u00e1n",
      "Prov. de Jorge Basadre",
      "Provincia de Mariscal Nieto",
      "Prov. Leoncio Prado",
      "Provincia de Santiago de Chuco"
    ],
    "negativeContentExamples": [
      "Departamento de Lima",
      "Regi\u00f3n Cusco",
      "Provincia: Huaral",
      "Prov Huaral",
      "Province of Lima",
      "Provincia de lima",
      "Provincia de San  Rom\u00e1n",
      "Provincia de 123"
    ],
    "positiveHeaderExamples": [
      "provincia_nombre_pe",
      "peru_province_name",
      "province_name_pe",
      "pe_provincia",
      "provincia",
      "prov_name",
      "peru_provincia",
      "province"
    ],
    "negativeHeaderExamples": [
      "departamento",
      "region_name",
      "country",
      "state_code",
      "city_name",
      "postal_code",
      "timezone",
      "county"
    ],
    "explanation": "Identifies Peruvian provincial administrative division names as data values formatted with the explicit province indicator (Provincia or the abbreviation Prov.) followed by the official name, accommodating common Spanish connectors such as de, del, la, las, los, and y. This is useful for normalizing and validating columns that store province labels in Peruvian datasets, especially when combined with informative headers indicating province context.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:44:17.072173"
  },
  {
    "resultType": "generated",
    "semanticType": "JOB_TITLE_EN",
    "description": "English-language position title: professional role or occupation designation for an individual (e.g., Senior Software Engineer, Director of Sales, CFO). Intended for free-text job/role titles rather than codes or department names.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b((Senior|Junior|Sr\\.|Jr\\.|Lead|Principal|Assistant|Associate|Deputy|Chief|Head|Vice)\\s+)?([A-Z][a-z]+|[A-Z]{2,5})([ /&-]([A-Z][a-z]+|[A-Z]{2,5})){0,3}[ ,/-]+(Administrator|Analyst|Architect|Assistant|Associate|Attorney|Auditor|Chef|Clerk|Consultant|Coordinator|Designer|Developer|Director|Driver|Engineer|Executive|Instructor|Lawyer|Librarian|Manager|Nurse|Officer|Operator|Pharmacist|Planner|Practitioner|President|Professor|Programmer|Recruiter|Representative|Researcher|Scientist|Specialist|Strategist|Supervisor|Teacher|Technician|Therapist|Trainer)\\b|\\b(Director|Manager|Head|Chief|Officer|President|Dean|Chair|Supervisor|Coordinator|Lead)\\b(,|[ ]+of)(([ /&-]([A-Z][a-z]+|[A-Z]{2,5})){1,4})\\b|\\b(CFO|CEO|CTO|COO|CIO|CMO|VP|SVP|EVP)\\b(([ ,/-]([A-Z][a-z]+|[A-Z]{2,5})){0,3})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4750,
    "headerPatterns": [
      {
        "regExp": "(?i).*employee.*job.*title.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "employee_job_title"
        ],
        "negativeExamples": [
          "employee_job_code"
        ]
      },
      {
        "regExp": "(?i).*job.*title.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "job_title"
        ],
        "negativeExamples": [
          "job_code"
        ]
      },
      {
        "regExp": "(?i).*position.*title.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "position_title"
        ],
        "negativeExamples": [
          "position_id"
        ]
      },
      {
        "regExp": "(?i).*(role|occupation).*title.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "occupation_title"
        ],
        "negativeExamples": [
          "role_id"
        ]
      },
      {
        "regExp": "(?i).*title.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "title"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "Senior Software Engineer",
      "Chief Financial Officer",
      "VP, Operations",
      "Director of Sales",
      "Nurse Practitioner",
      "Data Scientist",
      "Warehouse Supervisor",
      "Junior Accountant"
    ],
    "negativeContentExamples": [
      "Sales Department",
      "Engineering Team",
      "John Doe",
      "2023 Manager",
      "Manager Level 2",
      "Title: Engineer",
      "Job Grade 7",
      "Project 123"
    ],
    "positiveHeaderExamples": [
      "job_title",
      "position_title",
      "employee_job_title",
      "english_job_title",
      "role_title",
      "occupation_title",
      "job_role",
      "title"
    ],
    "negativeHeaderExamples": [
      "job_code",
      "position_id",
      "employee_name",
      "department",
      "title_status",
      "job_grade",
      "role_id",
      "start_date"
    ],
    "explanation": "This semantic type identifies English job/position titles for individuals, including seniority prefixes, department qualifiers, and common role nouns, as well as widely used executive acronyms (CEO/CFO/CTO/VP etc.). The regex is constrained to alphabetic tokens with limited separators, disallowing digits and generic department/team terms to avoid overreach. Use it to classify columns or values that represent a person's professional role or occupation.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:44:17.450783"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_UNION_NAME_IN",
    "description": "Complete official names of Indian states and union territories (e.g., \"Uttar Pradesh\", \"Puducherry\"). Expects the full canonical name without abbreviations or suffixes such as \"State\" or \"UT\".",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(Andaman and Nicobar Islands|Andhra Pradesh|Arunachal Pradesh|Assam|Bihar|Chandigarh|Chhattisgarh|Dadra and Nagar Haveli and Daman and Diu|Delhi|Goa|Gujarat|Haryana|Himachal Pradesh|Jammu and Kashmir|Jharkhand|Karnataka|Kerala|Ladakh|Lakshadweep|Madhya Pradesh|Maharashtra|Manipur|Meghalaya|Mizoram|Nagaland|Odisha|Puducherry|Punjab|Rajasthan|Sikkim|Tamil Nadu|Telangana|Tripura|Uttar Pradesh|Uttarakhand|West Bengal)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5690,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bin[_ ]state[_ ]name\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "in_state_name"
        ],
        "negativeExamples": [
          "state_code"
        ]
      },
      {
        "regExp": "(?i).*\\bindia\\b.*\\b(state|province)\\b.*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "india_state_name"
        ],
        "negativeExamples": [
          "province_id"
        ]
      },
      {
        "regExp": "(?i).*\\b(state|province|ut|union[_ ]territory)\\b.*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_or_ut_name"
        ],
        "negativeExamples": [
          "region_name"
        ]
      },
      {
        "regExp": "(?i).*\\b(st|prov|ut)\\b[_ ]?\\b(nm|name)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "st_name"
        ],
        "negativeExamples": [
          "ut_code"
        ]
      },
      {
        "regExp": "(?i).*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Andhra Pradesh",
      "Tamil Nadu",
      "Uttar Pradesh",
      "West Bengal",
      "Delhi",
      "Jammu and Kashmir",
      "Dadra and Nagar Haveli and Daman and Diu",
      "Andaman and Nicobar Islands"
    ],
    "negativeContentExamples": [
      "Uttar Pradesh State",
      "Jammu & Kashmir",
      "Pondicherry",
      "Orissa",
      "Andaman & Nicobar Islands",
      "Dadra & Nagar Haveli and Daman & Diu",
      "NCT of Delhi",
      "West Bengal, India"
    ],
    "positiveHeaderExamples": [
      "in_state_name",
      "india_state_name",
      "state_or_ut_name",
      "indian_province_name",
      "st_name",
      "ut_nm",
      "state_name_in",
      "indian_state_or_union_territory"
    ],
    "negativeHeaderExamples": [
      "state_code",
      "in_state_code",
      "province_id",
      "country_name",
      "billing_state",
      "us_state_name",
      "region_name",
      "territory_code"
    ],
    "explanation": "Identifies cells containing the complete, official names of Indian states and union territories. Useful for address normalization, geographic aggregation, and validation against canonical Indian administrative subdivisions. Excludes abbreviations (e.g., UP, UK), legacy names (e.g., Orissa, Pondicherry), variants with ampersands, and values with extra qualifiers such as \"State\" or country suffixes.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:44:17.837159"
  },
  {
    "resultType": "generated",
    "semanticType": "TELEPHONE",
    "description": "Telephone number: a telecommunications contact identifier representing a voice-capable line. Supports common national and international formats with optional country code (+), grouping by spaces, hyphens, or dots, and optional parentheses around area codes.",
    "pluginType": "regex",
    "regexPattern": "\\b(\\+?[0-9]{1,3}[\\s.-])?(\\([0-9]{3}\\)[\\s.-]?[0-9]{3}[\\s.-][0-9]{4}|[0-9]{3}[\\s.-][0-9]{3}[\\s.-][0-9]{4}|[0-9]{2,4}[\\s.-][0-9]{3,4}[\\s.-][0-9]{3,4}|[0-9]{7,12})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5820,
    "headerPatterns": [
      {
        "regExp": "(?i).*(customer|contact|primary|work|home|mobile).*(phone|telephone).*(number|no|nbr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_phone_number"
        ],
        "negativeExamples": [
          "contact_email"
        ]
      },
      {
        "regExp": "(?i).*(customer|contact|user|client).*(phone|telephone).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "contact_phone"
        ],
        "negativeExamples": [
          "contact_id"
        ]
      },
      {
        "regExp": "(?i).*(mobile|cell).*(phone|ph).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mobile_ph"
        ],
        "negativeExamples": [
          "mobile_plan"
        ]
      },
      {
        "regExp": "(?i).*(telephone|tel).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "telephone"
        ],
        "negativeExamples": [
          "telemetry"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "number"
        ],
        "negativeExamples": [
          "email"
        ]
      }
    ],
    "positiveContentExamples": [
      "+1 212 555 0198",
      "(415) 867-5309",
      "020-7946-0958",
      "212-555-1234",
      "212.555.1234",
      "5551234",
      "+44-20-7946-0958",
      "0491 570 156"
    ],
    "negativeContentExamples": [
      "1-800-FLOWERS",
      "+1 (212) 555-12345",
      "212--555-1234",
      "(212)5551234",
      "212 555 12 34",
      "+44 (0)20 7946 0958",
      "555-1234567",
      "212 555 123456"
    ],
    "positiveHeaderExamples": [
      "customer_phone_number",
      "phone",
      "mobile_phone",
      "contact_tel",
      "telephone_number",
      "work_phone",
      "primary_phone",
      "cell_number"
    ],
    "negativeHeaderExamples": [
      "fax_number",
      "emergency_contact_name",
      "email_address",
      "ip_address",
      "phone_extension",
      "contact_id",
      "device_model",
      "street_address"
    ],
    "explanation": "IDENTITY.TELEPHONE classifies values that represent telephone numbers across common national and international formats. The pattern emphasizes structured digit groupings with clear separators, optional country codes, and typical area-code formatting, while avoiding over-broad matches to generic numeric identifiers.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:44:19.439946"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_AU",
    "description": "Complete Australian state or territory designation in full long-form (e.g., NEW SOUTH WALES, AUSTRALIAN CAPITAL TERRITORY). Intended for datasets that store the fully spelled-out names of Australian states and territories, not abbreviations or codes.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "NEW SOUTH WALES",
      "VICTORIA",
      "QUEENSLAND",
      "WESTERN AUSTRALIA",
      "SOUTH AUSTRALIA",
      "TASMANIA",
      "NORTHERN TERRITORY",
      "AUSTRALIAN CAPITAL TERRITORY"
    ],
    "backout": "^[A-Z]+( [A-Z]+){0,3}$",
    "confidenceThreshold": 94,
    "priority": 5610,
    "headerPatterns": [
      {
        "regExp": "(?i).*(au|australia|australian).*(state|territory).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "australian_state_name"
        ],
        "negativeExamples": [
          "au_state_code"
        ]
      },
      {
        "regExp": "(?i).*(australia|australian|au).*(state|territory).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "australian_state"
        ],
        "negativeExamples": [
          "au_region_name"
        ]
      },
      {
        "regExp": "(?i).*(aus|au).*state.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "aus_state_name"
        ],
        "negativeExamples": [
          "state_name_code"
        ]
      },
      {
        "regExp": "(?i).*state.*territory.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_territory_name"
        ],
        "negativeExamples": [
          "territory_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "NEW SOUTH WALES",
      "VICTORIA",
      "QUEENSLAND",
      "WESTERN AUSTRALIA",
      "SOUTH AUSTRALIA",
      "TASMANIA",
      "NORTHERN TERRITORY",
      "AUSTRALIAN CAPITAL TERRITORY"
    ],
    "negativeContentExamples": [
      "NSW",
      "NEW SOUTH WALES, AU",
      "WESTERN AUS",
      "SOUTH AUSTRALIAN",
      "NORTHERN TERR.",
      "AUSTRALIAN CAPITAL TER",
      "NEW SOUTHWALES",
      "QUEENSLAND STATE"
    ],
    "positiveHeaderExamples": [
      "au_state_name",
      "australian_state_name",
      "state_territory_name_au",
      "state_name_australia",
      "full_state_name_au",
      "aus_state_territory_full_name",
      "au_state_full_name",
      "australian_territory_state_name"
    ],
    "negativeHeaderExamples": [
      "au_state_code",
      "state_abbrev_au",
      "province_name_ca",
      "country_name",
      "region",
      "state_id",
      "postcode_au",
      "timezone_name"
    ],
    "explanation": "This semantic type targets full written names of Australian states and territories. It is implemented as a finite list for precision and to avoid confusion with abbreviations or codes. Use when the data field contains the complete designation (e.g., AUSTRALIAN CAPITAL TERRITORY) rather than short forms like NSW or ACT.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:44:20.802505"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS2_EN",
    "description": "Secondary building/location identifier line for postal addresses in English, typically containing unit, apartment, suite, floor, room, department, building, or attention/care-of information.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(ATTN|C/O|CARE OF)\\b[ .:-]*[A-Z][A-Z .'-]{1,40}\\b|\\b(APT|APARTMENT|UNIT|SUITE|STE|FL|FLOOR|BLDG|BUILDING|RM|ROOM|DEPT|DEPARTMENT|FLAT|LOT|TOWER|LEVEL|LVL|LOBBY|LBBY)\\b[ .#-]*[A-Z0-9]{1,5}([ -][A-Z0-9]{1,5}){0,2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 5720,
    "headerPatterns": [
      {
        "regExp": "(?i).*(address[_ ]?line[_ ]?2|address2|addr2|street[_ ]?address[_ ]?2).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "address_line2"
        ],
        "negativeExamples": [
          "address_line1"
        ]
      },
      {
        "regExp": "(?i).*(secondary[_ ]?address|address[_ ]?second|second[_ ]?address).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "secondary_address"
        ],
        "negativeExamples": [
          "secondary_email"
        ]
      },
      {
        "regExp": "(?i).*\\b(apt|apartment|suite|ste|unit|bldg|building|floor|fl|room|rm)\\b.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "apartment_unit"
        ],
        "negativeExamples": [
          "apparent_value"
        ]
      },
      {
        "regExp": "(?i).*\\b(addr|street)\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "addr_details"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "shipping_address"
        ],
        "negativeExamples": [
          "location"
        ]
      }
    ],
    "positiveContentExamples": [
      "Apt 4B",
      "Unit 305",
      "Suite 210",
      "Ste 5",
      "Bldg A",
      "Floor 2",
      "Room 301",
      "C/O Admin Office"
    ],
    "negativeContentExamples": [
      "Rm",
      "Suite-",
      "Care Of",
      "Attention:",
      "Avenue 12",
      "Floorplan B",
      "Address 2",
      "BuildingName"
    ],
    "positiveHeaderExamples": [
      "address_line2",
      "address_line_2",
      "address2",
      "addr2",
      "street_address2",
      "secondary_address",
      "unit_or_suite",
      "apartment_suite"
    ],
    "negativeHeaderExamples": [
      "line2",
      "house_number",
      "city",
      "zip_code",
      "country",
      "coordinates",
      "residence",
      "location_detail"
    ],
    "explanation": "This semantic type targets the second line of street addresses where secondary unit or delivery attention information is typically stored (e.g., apartment/suite/unit numbers, building identifiers, floors, rooms, departments, ATTN/C/O lines). It emphasizes recognizable tokens followed by concise identifiers to avoid overbroad matches. Typical use cases include classifying and validating address_line2 fields in CRM, ecommerce checkout, and shipping datasets.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:44:21.593122"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS_EN",
    "description": "english_street_address: complete English-formatted street location. Expects a leading building number, street name words, a recognized street suffix (e.g., St, Avenue, Rd), optional directional (N, SW) before or after the suffix, and optional unit designator (e.g., Apt, Ste).",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{1,6}[A-Za-z]?\\s+((N|S|E|W|NE|NW|SE|SW)\\s+)?([A-Za-z0-9][A-Za-z0-9'-]*\\s+){1,4}(Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Lane|Ln|Drive|Dr|Court|Ct|Place|Pl|Parkway|Pkwy|Terrace|Ter|Way|Highway|Hwy|Route|Rte|Circle|Cir|Square|Sq)\\s*((N|S|E|W|NE|NW|SE|SW)\\s*)?(\\s*(Apt|Unit|Suite|Ste|Fl|Floor|Bldg|#)\\s*[A-Za-z0-9-]+)?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5760,
    "headerPatterns": [
      {
        "regExp": "(?i).*street.*address.*en.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "street_address_en"
        ],
        "negativeExamples": [
          "email_address"
        ]
      },
      {
        "regExp": "(?i).*(shipping|billing).*(street).*(address).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "shipping_street_address"
        ],
        "negativeExamples": [
          "shipping_address_line2"
        ]
      },
      {
        "regExp": "(?i).*(mailing|residential|home).*(street).*(address|addr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "residential_street_address"
        ],
        "negativeExamples": [
          "home_address_line1"
        ]
      },
      {
        "regExp": "(?i).*street.*(addr|address).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "street_addr"
        ],
        "negativeExamples": [
          "postal_address"
        ]
      },
      {
        "regExp": "(?i).*(addr|address).*(street|st).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "primary_address_st"
        ],
        "negativeExamples": [
          "ip_address"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "address"
        ],
        "negativeExamples": [
          "postal_code"
        ]
      }
    ],
    "positiveContentExamples": [
      "221B Baker St",
      "742 Evergreen Terrace",
      "1600 Pennsylvania Ave NW",
      "123 N Main St Apt 5B",
      "500 W 5th St Unit 101",
      "75 King George Blvd",
      "3 Market Square",
      "12 High Street"
    ],
    "negativeContentExamples": [
      "PO Box 123",
      "742 Evergreen",
      "Baker Street",
      "Main St",
      "1600 Pennsylvania NW",
      "Intersection of Main and 1st",
      "Unit 5B",
      "123 Calle Mayor"
    ],
    "positiveHeaderExamples": [
      "street_address_en",
      "shipping_street_address",
      "billing_street_address",
      "residential_street_address",
      "home_street_address",
      "street_addr",
      "primary_address_st",
      "mailing_street_address"
    ],
    "negativeHeaderExamples": [
      "email_address",
      "ip_address",
      "postal_code",
      "city",
      "country",
      "address_type",
      "street_name",
      "country_code"
    ],
    "explanation": "This semantic type identifies English-formatted street addresses at the street-line level, including a leading house/building number, street name, a recognized street suffix, optional pre/post directional, and optional secondary unit designator. It is suited for detecting Address Line 1 fields and similar columns containing street-level locations in English-language datasets.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:44:25.349259"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.SUBURB_AU",
    "description": "Australian residential locality (suburb) name as used in addresses. Values are suburb/locality names only, without state/territory codes or postcodes.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Za-z][A-Za-z']*[A-Za-z])([- ]([A-Za-z][A-Za-z']*[A-Za-z])){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 5710,
    "headerPatterns": [
      {
        "regExp": "(?i).*(au|australia|australian).*(residential|address).*(suburb|locality).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "au_residential_suburb"
        ],
        "negativeExamples": [
          "au_residential_state"
        ]
      },
      {
        "regExp": "(?i).*(australia|au).*(suburb|locality).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "australia_suburb"
        ],
        "negativeExamples": [
          "australia_state"
        ]
      },
      {
        "regExp": "(?i).*address.*(suburb|locality).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "address_suburb"
        ],
        "negativeExamples": [
          "address_city"
        ]
      },
      {
        "regExp": "(?i).*(addr|res|loc).*suburb.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "addr_suburb"
        ],
        "negativeExamples": [
          "addr_state"
        ]
      },
      {
        "regExp": "(?i).*suburb.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "suburb"
        ],
        "negativeExamples": [
          "city"
        ]
      }
    ],
    "positiveContentExamples": [
      "St Kilda",
      "North Ryde",
      "Port Macquarie",
      "Alice Springs",
      "Bondi Beach",
      "Wagga Wagga",
      "O'Connor",
      "Upper Mount Gravatt"
    ],
    "negativeContentExamples": [
      "North Ryde 2113",
      "St Kilda VIC",
      "Port Macquarie, NSW",
      "Bondi Beach NSW 2026",
      "O'Connor WA",
      "St. Kilda",
      "PO Box 123",
      "NSW"
    ],
    "positiveHeaderExamples": [
      "au_suburb",
      "suburb_au",
      "australian_locality",
      "address_suburb",
      "residential_suburb",
      "addr_suburb",
      "suburb_name_au",
      "locality_au"
    ],
    "negativeHeaderExamples": [
      "au_state",
      "postcode_au",
      "address_city",
      "town_name",
      "state_province",
      "street_name",
      "region_au",
      "address_line2"
    ],
    "explanation": "This semantic type identifies Australian suburb/locality names used in addresses and forms. The value regex accepts one to four alphabetic tokens (allowing internal apostrophes and spaces or hyphens as separators) to cover common suburb name structures like \"St Kilda\", \"Wagga Wagga\", and \"O'Connor\". It intentionally excludes digits, punctuation like commas, and state/territory abbreviations or postcodes to avoid matching full address lines. Use when a column contains the suburb/locality component of an Australian address.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:44:28.164306"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS_<LANGUAGE>",
    "description": "English-language street address values composed of a leading house number, optional pre-directional, street name tokens, an English street suffix (e.g., St, Ave, Rd), optional post-directional, and an optional unit designator with identifier (e.g., Apt 3B, Suite 400). This type targets normalized US/EN-style street lines rather than multi-line addresses or international formats.\nUnlike generic ADDRESS types, this focuses on a single street-line in English with explicit street suffixes and optional unit, and does not include city, region, or postal code components.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{1,6}(-\\d{1,6})?[A-Za-z]?\\s+((N|S|E|W|NE|NW|SE|SW)\\s+)?(([A-Za-z0-9][A-Za-z0-9'.-]*\\s+){0,3}[A-Za-z0-9][A-Za-z0-9'.-]*\\s+)(Street|St|Road|Rd|Avenue|Ave|Boulevard|Blvd|Drive|Dr|Lane|Ln|Court|Ct|Terrace|Ter|Place|Pl|Way|Parkway|Pkwy|Circle|Cir|Square|Sq|Highway|Hwy|Trail|Trl)\\b(\\s+(N|S|E|W|NE|NW|SE|SW))?(\\s*,\\s*|\\s+)?((Apt|Unit|Suite|Ste|Fl|Floor|Bldg|Building|#)\\s*[A-Za-z0-9\\-]+)?",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5750,
    "headerPatterns": [
      {
        "regExp": "(?i).*(street[_ ]?address(_en|_english)?|address[_ ]?line1).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "street_address_en"
        ],
        "negativeExamples": [
          "ip_address"
        ]
      },
      {
        "regExp": "(?i).*(shipping|billing|mailing|service|residential).*(address|addr).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "billing_address_line"
        ],
        "negativeExamples": [
          "billing_name"
        ]
      },
      {
        "regExp": "(?i).*(addr[_ ]?line1|address1|addr1).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "address1"
        ],
        "negativeExamples": [
          "address2"
        ]
      },
      {
        "regExp": "(?i).*street.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "recipient_street"
        ],
        "negativeExamples": [
          "first_name"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "customer_address"
        ],
        "negativeExamples": [
          "email"
        ]
      }
    ],
    "positiveContentExamples": [
      "123 Main St",
      "221B Baker Street",
      "742 Evergreen Terrace",
      "1600 Pennsylvania Ave NW",
      "55 E 52nd Street",
      "350 Fifth Ave, Suite 400",
      "12-14 Broadway Rd",
      "500 W Elm St Apt 3B"
    ],
    "negativeContentExamples": [
      "123 Main",
      "Main Street",
      "12345",
      "1600 Pennsylvania",
      "742 Evergreen Ter.",
      "500 Elm Street Apt",
      "10 Rue de Rivoli",
      "NW 500 Elm St"
    ],
    "positiveHeaderExamples": [
      "shipping_street_address",
      "billing_address_line",
      "customer_address",
      "recipient_street",
      "address1",
      "service_location_address",
      "street_address_en",
      "mailing_address"
    ],
    "negativeHeaderExamples": [
      "ip_address",
      "email_address",
      "postal_code",
      "city",
      "country",
      "billing_name",
      "street_number",
      "address_status"
    ],
    "explanation": "This semantic type identifies single-line English street addresses with a house number, street name, and a recognized English street suffix, plus optional directional and unit information. It avoids over-broad matching by requiring a numeric lead-in and a suffix from a controlled set of English street types. Use this to detect and validate address_line1-style fields for US/EN-formatted addresses; it intentionally excludes city, state, postal code, and non-English street forms.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:44:29.226963"
  },
  {
    "resultType": "generated",
    "semanticType": "URI.URL",
    "description": "web_address: complete URL for network resource access",
    "pluginType": "regex",
    "regexPattern": "\\b(https|http|ftp)://(([A-Za-z0-9-]+\\.)+[A-Za-z]{2,63}|([0-9]{1,3}\\.){3}[0-9]{1,3})(:[0-9]{2,5})?(/[A-Za-z0-9._~\\-/%+]*)?(\\?[A-Za-z0-9._~\\-/%+&=]*)?(#[A-Za-z0-9._~\\-/%+&=]*)?",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5840,
    "headerPatterns": [
      {
        "regExp": "(?i).*(customer|user|profile|account).*(url|link|web.?address).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "profile_link"
        ],
        "negativeExamples": [
          "profile_name"
        ]
      },
      {
        "regExp": "(?i).*(page|landing|redirect|callback).*(url|link).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "redirect_url"
        ],
        "negativeExamples": [
          "page_title"
        ]
      },
      {
        "regExp": "(?i).*(website|homepage|site).*(url|link).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "website_url"
        ],
        "negativeExamples": [
          "website_name"
        ]
      },
      {
        "regExp": "(?i).*resource.*url.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "resource_url"
        ],
        "negativeExamples": [
          "resource_id"
        ]
      },
      {
        "regExp": "(?i).*(web|site|page).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "web_address"
        ],
        "negativeExamples": [
          "email_address"
        ]
      },
      {
        "regExp": "(?i).*url.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "page_url"
        ],
        "negativeExamples": [
          "uri_scheme"
        ]
      }
    ],
    "positiveContentExamples": [
      "https://example.com",
      "http://www.example.co.uk/path",
      "https://sub.domain.example.org:8080/api/v1/resources?id=123&sort=asc",
      "ftp://files.example.net/downloads/archive.zip",
      "https://192.168.1.10/login?next=/home#top",
      "http://example.com/path-with_chars~and%20spaces#section-2",
      "https://example.com/?q=test+search",
      "https://cdn.example.com/assets/img/logo.png"
    ],
    "negativeContentExamples": [
      "www.example.com/page",
      "http:/example.com",
      "https://example",
      "httpss://example.com",
      "mailto:user@example.com",
      "https://exa mple.com",
      "https://example..com",
      "http://example .com/path"
    ],
    "positiveHeaderExamples": [
      "website_url",
      "page_url",
      "profile_link",
      "redirect_url",
      "resource_url",
      "homepage_url",
      "callback_url",
      "web_address"
    ],
    "negativeHeaderExamples": [
      "email_address",
      "ip_address",
      "file_path",
      "page_title",
      "website_name",
      "uri_scheme",
      "domain_name",
      "resource_id"
    ],
    "explanation": "Identifies strings that are complete web addresses (URLs) including scheme (http, https, or ftp), hostname or IPv4 address, optional port, and optional path, query, and fragment. Use this type to detect fields that store clickable links or endpoints for web resources in logs, exports, and application data.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:44:30.789962"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_PROVINCE_NAME_NA",
    "description": "Complete North American state/province/territory full name (long form), including U.S. states and territories, Canadian provinces and territories, and Mexican states. Excludes abbreviations, short codes, and values with extra qualifiers such as country postfixes.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(Alabama|Alaska|Arizona|Arkansas|California|Colorado|Connecticut|Delaware|Florida|Georgia|Hawaii|Idaho|Illinois|Indiana|Iowa|Kansas|Kentucky|Louisiana|Maine|Maryland|Massachusetts|Michigan|Minnesota|Mississippi|Missouri|Montana|Nebraska|Nevada|New Hampshire|New Jersey|New Mexico|New York|North Carolina|North Dakota|Ohio|Oklahoma|Oregon|Pennsylvania|Rhode Island|South Carolina|South Dakota|Tennessee|Texas|Utah|Vermont|Virginia|Washington|West Virginia|Wisconsin|Wyoming|District of Columbia|American Samoa|Guam|Northern Mariana Islands|Puerto Rico|US Virgin Islands|Alberta|British Columbia|Manitoba|New Brunswick|Newfoundland and Labrador|Nova Scotia|Ontario|Prince Edward Island|Quebec|Saskatchewan|Northwest Territories|Nunavut|Yukon|Aguascalientes|Baja California|Baja California Sur|Campeche|Chiapas|Chihuahua|Coahuila|Colima|Durango|Guanajuato|Guerrero|Hidalgo|Jalisco|Mexico City|Ciudad de Mexico|Michoacan|Morelos|Nayarit|Nuevo Leon|Oaxaca|Puebla|Queretaro|Quintana Roo|San Luis Potosi|Sinaloa|Sonora|Tabasco|Tamaulipas|Tlaxcala|Veracruz|Yucatan|Zacatecas|State of Mexico|Estado de Mexico)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 5670,
    "headerPatterns": [
      {
        "regExp": "(?i).*na[_\\s-]*territory[_\\s-]*name.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "na_territory_name"
        ],
        "negativeExamples": [
          "na_territory_code"
        ]
      },
      {
        "regExp": "(?i).*(us|ca|mx)[_\\s-]*(state|province|territory)[_\\s-]*name.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "us_state_name"
        ],
        "negativeExamples": [
          "us_state_code"
        ]
      },
      {
        "regExp": "(?i).*state[_\\s-]*province[_\\s-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_province_name"
        ],
        "negativeExamples": [
          "state_province_code"
        ]
      },
      {
        "regExp": "(?i).*(state|province|territory)[_\\s-]*full[_\\s-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province_full_name"
        ],
        "negativeExamples": [
          "province_id"
        ]
      },
      {
        "regExp": "(?i).*(state|prov|territory|terr)[_\\s-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "territory_name"
        ],
        "negativeExamples": [
          "territory_number"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "California",
      "Newfoundland and Labrador",
      "Prince Edward Island",
      "District of Columbia",
      "Baja California Sur",
      "State of Mexico",
      "Ciudad de Mexico",
      "Northwest Territories"
    ],
    "negativeContentExamples": [
      "New York City",
      "Ontario, Canada",
      "TX",
      "Quebec City",
      "Baja California Norte",
      "Washington DC",
      "San Luis Potosi City",
      "British Columbia, CA"
    ],
    "positiveHeaderExamples": [
      "na_territory_name",
      "state_province_name",
      "us_state_name",
      "ca_province_name",
      "mx_state_name",
      "province_full_name",
      "territory_name",
      "state_full_name"
    ],
    "negativeHeaderExamples": [
      "state_code",
      "province_code",
      "territory_id",
      "city_name",
      "country_name",
      "us_state_abbrev",
      "region",
      "timezone"
    ],
    "explanation": "This semantic type identifies full-length names of North American first-level administrative divisions: U.S. states and territories, Canadian provinces and territories, and Mexican states. It is intended for columns containing the complete designation of these jurisdictions rather than abbreviations or codes. Typical use cases include normalizing location attributes, validating address components, and disambiguating administrative geography fields in customer, logistics, and government datasets.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:44:35.032197"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS3_EN",
    "description": "Address line 3 in English: tertiary building location specification such as apartment, suite, unit, room, floor, or building sub-unit identifiers. Typical values include a sub-premise keyword followed by a number and/or short letter token (e.g., \"Apt 4B\", \"Suite 210\").",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(apt[.]?|apartment|suite|ste[.]?|unit|flat|room|rm[.]?|floor|fl[.]?|level|lvl[.]?|bldg[.]?|building|tower|block|dept|department)\\b[ .-]*#?[ ]?\\b([A-Z]?[0-9]{1,4}[A-Z]?|[A-Z]{1,3})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 5730,
    "headerPatterns": [
      {
        "regExp": "(?i).*(address|addr).*(line|ln)[ _-]?3.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "address_line3"
        ],
        "negativeExamples": [
          "address_line2"
        ]
      },
      {
        "regExp": "(?i).*street.*address.*3.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "street_address3"
        ],
        "negativeExamples": [
          "street_address2"
        ]
      },
      {
        "regExp": "(?i).*(address|addr)[ _-]?3.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "address3"
        ],
        "negativeExamples": [
          "address2"
        ]
      },
      {
        "regExp": "(?i).*(line|ln)[ _-]?3.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "line3"
        ],
        "negativeExamples": [
          "line2"
        ]
      },
      {
        "regExp": "(?i).*(address|addr).*(tertiary|third).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "address_tertiary"
        ],
        "negativeExamples": [
          "address_secondary"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "address"
        ],
        "negativeExamples": [
          "street"
        ]
      }
    ],
    "positiveContentExamples": [
      "Apt 4B",
      "Apartment 12",
      "Suite 210",
      "Ste. 5",
      "Unit #7",
      "Room 12A",
      "Floor 3",
      "Building B2"
    ],
    "negativeContentExamples": [
      "4B Apt",
      "Apartment Building 4",
      "Unit B-2",
      "Suite #",
      "Room 12 A",
      "Building South",
      "Address Line 3",
      "BLK D"
    ],
    "positiveHeaderExamples": [
      "address_line3",
      "addr_line_3",
      "street_address3",
      "address3",
      "line3",
      "address_tertiary",
      "address_line_3_en",
      "addr3"
    ],
    "negativeHeaderExamples": [
      "address_line2",
      "street_address",
      "address2",
      "line2",
      "address_secondary",
      "city",
      "postal_code",
      "apt_number"
    ],
    "explanation": "This semantic type identifies tertiary address components commonly stored in Address Line 3 fields, focusing on sub-premise keywords (e.g., apt, suite, unit, room, floor, building) followed by a compact identifier such as a number with optional short letter. It is useful for parsing or validating datasets where address sub-units are separated into multiple lines, ensuring line 3 contains internal location details rather than street names or cities.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:44:52.060225"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_MARKER_EN",
    "description": "Identifies English street/thoroughfare suffix markers (e.g., ST, STREET, RD, ROAD, AVE, AVENUE) used as the classification suffix for a roadway. Intended for fields that store only the suffix token separate from the street name or number.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "ST",
      "STREET",
      "RD",
      "ROAD",
      "AVE",
      "AVENUE",
      "BLVD",
      "BOULEVARD",
      "LN",
      "LANE",
      "DR",
      "DRIVE",
      "CT",
      "COURT",
      "PKWY",
      "PARKWAY",
      "HWY",
      "HIGHWAY",
      "WAY",
      "PL",
      "PLACE",
      "TER",
      "TERRACE",
      "SQ",
      "SQUARE"
    ],
    "backout": "^[A-Za-z]{2,10}\\.?$",
    "confidenceThreshold": 97,
    "priority": 5770,
    "headerPatterns": [
      {
        "regExp": "(?i).*(street|thoroughfare).*(type|suffix|marker).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "street_type"
        ],
        "negativeExamples": [
          "street_name"
        ]
      },
      {
        "regExp": "(?i).*street.*(suffix|marker).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "street_suffix"
        ],
        "negativeExamples": [
          "street_number"
        ]
      },
      {
        "regExp": "(?i).*(addr|address).*st.*type.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "addr_st_type"
        ],
        "negativeExamples": [
          "address_line1"
        ]
      },
      {
        "regExp": "(?i).*(road|rd).*type.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "road_type"
        ],
        "negativeExamples": [
          "road_name"
        ]
      },
      {
        "regExp": "(?i).*(street|thoroughfare|road).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "street"
        ],
        "negativeExamples": [
          "state"
        ]
      },
      {
        "regExp": "(?i).*type.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "type"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "ST",
      "STREET",
      "RD",
      "ROAD",
      "AVE",
      "AVENUE",
      "BLVD",
      "BOULEVARD"
    ],
    "negativeContentExamples": [
      "St.",
      "Main St",
      "STATE",
      "DRIVEWAY",
      "RD-1",
      "Avenue 5",
      "SQR",
      "HWAY"
    ],
    "positiveHeaderExamples": [
      "street_type",
      "thoroughfare_suffix",
      "addr_st_type",
      "street_marker",
      "road_type",
      "street_abbrev",
      "thoroughfare_marker",
      "street_suffix"
    ],
    "negativeHeaderExamples": [
      "street_name",
      "full_address",
      "address_line1",
      "street_number",
      "road_name",
      "apartment",
      "unit",
      "intersection"
    ],
    "explanation": "This semantic type captures only the English roadway suffix term, commonly stored as a separate field to normalize addresses and support parsing and geocoding. It distinguishes tokens like ST, RD, AVE, and their full forms from the rest of the address components. Use this for columns that contain the street classification marker only, not the full street name or number.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:45:01.075923"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_NAME_EN",
    "description": "Complete English street name including the street type suffix (e.g., Street, Avenue, Road). Intended for standalone street names without house numbers or other address elements.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z][a-z]+|[A-Z][a-z]+'[A-Za-z]+|[A-Z][a-z]+-[A-Z][a-z]+|[1-9][0-9]{0,2}(st|nd|rd|th))( (of|the|and|[A-Z][a-z]+|[A-Z][a-z]+'[A-Za-z]+|[A-Z][a-z]+-[A-Z][a-z]+|[1-9][0-9]{0,2}(st|nd|rd|th))){0,4} (Street|St[.]?|Avenue|Ave[.]?|Road|Rd[.]?|Boulevard|Blvd[.]?|Lane|Ln[.]?|Drive|Dr[.]?|Court|Ct[.]?|Place|Pl[.]?|Terrace|Ter[.]?|Way|Parkway|Pkwy[.]?|Crescent|Cres[.]?|Highway|Hwy[.]?|Square|Sq[.]?|Trail|Trl[.]?|Close|Alley|Circle|Gardens)",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 5800,
    "headerPatterns": [
      {
        "regExp": "(?i).*complete.*street.*name.*(english|en).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "complete_street_name_en"
        ],
        "negativeExamples": [
          "street_name"
        ]
      },
      {
        "regExp": "(?i).*(english|en).*(street.*name|streetname).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "english_street_name"
        ],
        "negativeExamples": [
          "street_number_en"
        ]
      },
      {
        "regExp": "(?i).*(street|st)[_ ]*(name|nm).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "street_nm_en"
        ],
        "negativeExamples": [
          "road_name"
        ]
      },
      {
        "regExp": "(?i).*street.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "street_info"
        ],
        "negativeExamples": [
          "road_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Baker Street",
      "Elm St.",
      "King's Road",
      "Fifth Avenue",
      "42nd Street",
      "O'Connell Street",
      "Maple Lane",
      "Parkview Drive"
    ],
    "negativeContentExamples": [
      "221B Baker Street",
      "Main",
      "MainStreet",
      "Main St, Springfield",
      "Apt 5 Baker Street",
      "3 Avenue",
      "Baker St #12",
      "Highway 101"
    ],
    "positiveHeaderExamples": [
      "complete_street_name_en",
      "street_name_en",
      "street_full_name_english",
      "english_street_name",
      "street_nm_en",
      "en_street_name",
      "streetname_en",
      "english_full_street_name"
    ],
    "negativeHeaderExamples": [
      "street_number_en",
      "road_code",
      "address_line1",
      "city_name_en",
      "country_name",
      "street_type",
      "name_en",
      "postal_code"
    ],
    "explanation": "This semantic type identifies full English street names that include the terminal street type (e.g., Street, Ave, Rd). It excludes full addresses with house numbers, unit designators, or city/state information, and requires the street type to appear at the end of the value.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:45:03.859780"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_PROVINCE_NA",
    "description": "na_state_province: North American territorial code designation",
    "pluginType": "regex",
    "regexPattern": "\\b(AL|AK|AZ|AR|CA|CO|CT|DE|DC|FL|GA|HI|ID|IL|IN|IA|KS|KY|LA|ME|MD|MA|MI|MN|MS|MO|MT|NE|NV|NH|NJ|NM|NY|NC|ND|OH|OK|OR|PA|RI|SC|SD|TN|TX|UT|VT|VA|WA|WV|WI|WY|PR|GU|VI|AS|MP|AB|BC|MB|NB|NL|NS|NT|NU|ON|PE|QC|SK|YT)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5660,
    "headerPatterns": [
      {
        "regExp": "(?i).*na.*state.*prov.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "na_state_province_code"
        ],
        "negativeExamples": [
          "state_province_code"
        ]
      },
      {
        "regExp": "(?i).*state.*prov.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_province_code"
        ],
        "negativeExamples": [
          "state_province_name"
        ]
      },
      {
        "regExp": "(?i).*prov.*state.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province_state_code"
        ],
        "negativeExamples": [
          "province_state_name"
        ]
      },
      {
        "regExp": "(?i).*st.*prov.*cd.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "st_prov_cd"
        ],
        "negativeExamples": [
          "state_code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "CA",
      "NY",
      "QC",
      "AB",
      "PR",
      "DC",
      "NT",
      "WY"
    ],
    "negativeContentExamples": [
      "C-A",
      "CAL",
      "QB",
      "Q C",
      "ON1",
      "NWT",
      "USA",
      "MX"
    ],
    "positiveHeaderExamples": [
      "na_state_province_code",
      "state_prov_code",
      "province_state_code",
      "us_ca_state_code",
      "st_prov_cd",
      "state_abbr_code",
      "territory_state_code",
      "region_subdivision_code"
    ],
    "negativeHeaderExamples": [
      "country_code",
      "postal_code",
      "province_name",
      "state",
      "area_code",
      "timezone_code",
      "country_subdivision_name",
      "city_code"
    ],
    "explanation": "Two-letter postal/territorial abbreviations for U.S. states, U.S. territories, and Canadian provinces/territories. Useful for standardizing and validating North American state/province code fields across heterogeneous datasets.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:45:51.171638"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_IT",
    "description": "Italian territory: provincial administrative division. Represents full Italian province names and metropolitan provinces written as proper names with Italian orthography, including spaces, hyphens, apostrophes, and selected connecting particles. Excludes province codes, abbreviations, and values containing punctuation beyond hyphen or apostrophe.",
    "pluginType": "regex",
    "regexPattern": "\\b((L['\u2019])?[A-Z\u00c0-\u00d6\u00d8-\u00de][a-z\u00e0-\u00f6\u00f8-\u00ff]{1,24}(( |-|'|\u2019)((L['\u2019])?[A-Z\u00c0-\u00d6\u00d8-\u00de][a-z\u00e0-\u00f6\u00f8-\u00ff]{1,24}|di|del|della|dei|degli|delle|dell|e)){0,4})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 5480,
    "headerPatterns": [
      {
        "regExp": "(?i).*(italian|italy|italia).*(province|provincia).*(name|nome).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "italian_province_name"
        ],
        "negativeExamples": [
          "province_code"
        ]
      },
      {
        "regExp": "(?i).*(province|provincia).*name.*it.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province_name_it"
        ],
        "negativeExamples": [
          "province_name_us"
        ]
      },
      {
        "regExp": "(?i).*(province|provincia).*(name|nome).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "provincia_nome"
        ],
        "negativeExamples": [
          "city_name"
        ]
      },
      {
        "regExp": "(?i).*(prov|prv).*(name|nome).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "prov_name"
        ],
        "negativeExamples": [
          "prov_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Roma",
      "Milano",
      "Torino",
      "Reggio Calabria",
      "L'Aquila",
      "Forl\u00ec-Cesena",
      "Barletta-Andria-Trani",
      "Monza e della Brianza"
    ],
    "negativeContentExamples": [
      "RM",
      "Milano (MI)",
      "Roma, IT",
      "Reggio nell'Emilia",
      "la Spezia",
      "L 'Aquila",
      "Verona-SUD",
      "Vibo Valentia (VV)"
    ],
    "positiveHeaderExamples": [
      "italian_province_name",
      "province_name_it",
      "provincia_nome",
      "prov_name",
      "italy_prov_name",
      "it_province",
      "province_name",
      "nome_provincia"
    ],
    "negativeHeaderExamples": [
      "region_name",
      "city_name",
      "province_code",
      "state_name",
      "postal_code",
      "province_number",
      "country",
      "county_name"
    ],
    "explanation": "This semantic type identifies the full name of an Italian province or metropolitan province. It expects proper-case Italian names and permits separators commonly found in Italian toponyms (spaces, hyphens, apostrophes) and selected connecting particles (e, di, del, della, dei, degli, delle, dell). Use it to classify province-level administrative names in Italian datasets where headers indicate provincial naming rather than codes.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:46:10.963121"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_UK",
    "description": "UK territory: historic county designation. Values are expected to be historic county names as commonly referenced in the UK context (e.g., shire-based names, certain legacy forms prefixed by \"County\", and notable compound forms). This focuses on traditional/historic counties rather than modern administrative or ceremonial counties.",
    "pluginType": "regex",
    "regexPattern": "\\b(County\\s+[A-Z][a-z]+|[A-Z][a-z]+shire|[A-Z][a-z]+-shire|[A-Z][a-z]+sex|[A-Z][a-z]+land|[A-Z][a-z]+ness|[A-Z][a-z]+\\s+and\\s+[A-Z][a-z]+)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 5280,
    "headerPatterns": [
      {
        "regExp": "(?i).*historic.*county.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "historic_county"
        ],
        "negativeExamples": [
          "county_code"
        ]
      },
      {
        "regExp": "(?i).*(uk|gb|british).*(county|shire).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "uk_county"
        ],
        "negativeExamples": [
          "country"
        ]
      },
      {
        "regExp": "(?i).*(traditional|ancient).*shire.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "traditional_shire"
        ],
        "negativeExamples": [
          "state_province"
        ]
      },
      {
        "regExp": "(?i).*(cnty|cty).*(uk|gb).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cnty_uk"
        ],
        "negativeExamples": [
          "province"
        ]
      },
      {
        "regExp": "(?i).*county.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "county"
        ],
        "negativeExamples": [
          "country"
        ]
      }
    ],
    "positiveContentExamples": [
      "Yorkshire",
      "Lancashire",
      "County Durham",
      "Monmouthshire",
      "Inverness-shire",
      "Ross and Cromarty",
      "Caithness",
      "Westmorland"
    ],
    "negativeContentExamples": [
      "City of London",
      "North Yorkshire",
      "County of Kent",
      "Durham County",
      "Ross & Cromarty",
      "Inverness shire",
      "South Sussex",
      "Greater London"
    ],
    "positiveHeaderExamples": [
      "historic_county",
      "uk_historic_county",
      "ancient_county",
      "traditional_shire",
      "uk_county",
      "gb_county",
      "county_uk",
      "cnty_uk"
    ],
    "negativeHeaderExamples": [
      "county_code",
      "country",
      "state_province",
      "province",
      "region",
      "county_name",
      "current_county",
      "city"
    ],
    "explanation": "This semantic type targets traditional UK historic counties. The value pattern emphasizes common morphological cues such as the 'shire' and 'sex' suffixes, legacy 'County <Name>' forms, select geographic endings like 'land' and 'ness', and the notable compound 'Ross and Cromarty' style. Use this type when columns contain historic county designations rather than modern administrative or ceremonial areas.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:47:01.342669"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_NAME_BARE_EN",
    "description": "Core English street name without the street type/suffix token (e.g., omits 'Street', 'St', 'Road', 'Rd', 'Avenue', etc.). Accepts multi-word or hyphen-separated names, ordinals (e.g., '42nd'), and apostrophes within names.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Za-z]+('[A-Za-z]+)?|\\d{1,3}(st|nd|rd|th))([ -]([A-Za-z]+('[A-Za-z]+)?|\\d{1,3}(st|nd|rd|th))){0,4}\\b(?!\\s+(street|st|road|rd|avenue|ave|boulevard|blvd|lane|ln|drive|dr|way|court|ct|place|pl|terrace|ter|circle|cir|alley|aly|parkway|pkwy|highway|hwy|route|rte|square|sq|trail|trl|row|close|mews)\\b)",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 5790,
    "headerPatterns": [
      {
        "regExp": "(?i).*(street).*name.*(bare|base|core|no\\s*suffix).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "street_name_bare"
        ],
        "negativeExamples": [
          "full_street_name"
        ]
      },
      {
        "regExp": "(?i).*(address|roadway).*(street|road).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "address_street_name"
        ],
        "negativeExamples": [
          "street_address"
        ]
      },
      {
        "regExp": "(?i).*(street).*name.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "street_name"
        ],
        "negativeExamples": [
          "street_type"
        ]
      },
      {
        "regExp": "(?i).*\\bst\\b.*name.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "st_name"
        ],
        "negativeExamples": [
          "first_name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "street"
        ]
      }
    ],
    "positiveContentExamples": [
      "Main",
      "Elm",
      "Old Mill",
      "King's",
      "O'Connell",
      "42nd",
      "Martin Luther King",
      "Queen Anne"
    ],
    "negativeContentExamples": [
      "Main St",
      "Elm Street",
      "Old Mill Road",
      "King's Way",
      "42nd Avenue",
      "Martin Luther King Blvd",
      "N Main St",
      "7th St E"
    ],
    "positiveHeaderExamples": [
      "street_name_bare",
      "base_street_name",
      "core_street_name",
      "street_name_no_suffix",
      "address_street_name",
      "road_name_core",
      "bare_street_name"
    ],
    "negativeHeaderExamples": [
      "street",
      "street_type",
      "street_suffix",
      "full_street_name",
      "street_address",
      "city_name",
      "postal_code"
    ],
    "explanation": "Identifies bare English street names that intentionally exclude the street type/suffix token. Useful for datasets where street names are split into base name and suffix, enabling normalization, joining with gazetteers, and standardized address parsing without suffix noise.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:50:32.167647"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_NAME_BARE_<LANGUAGE>",
    "description": "Bare street name in English: the core street identifier without any thoroughfare type suffix (e.g., Street, St, Avenue, Ave, Road, Rd, etc.). Intended for the normalized base component of a street or road name prior to appending the street type.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(((?!(st|street|ave|avenue|rd|road|dr|drive|ln|lane|blvd|boulevard|ct|court|pl|place|pkwy|parkway|hwy|highway|ter|terrace|way|sq|square)\\b)[A-Za-z]+([.'-][A-Za-z]+)*)|(([A-Za-z]+([.'-][A-Za-z]+)*[ -]){1,4}(?!(st|street|ave|avenue|rd|road|dr|drive|ln|lane|blvd|boulevard|ct|court|pl|place|pkwy|parkway|hwy|highway|ter|terrace|way|sq|square)\\b)[A-Za-z]+([.'-][A-Za-z]+)*))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 5780,
    "headerPatterns": [
      {
        "regExp": "(?i).*street.*name.*bare.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "street_name_bare"
        ],
        "negativeExamples": [
          "street_type"
        ]
      },
      {
        "regExp": "(?i).*(bare|base).*(street|thoroughfare).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "base_street_name"
        ],
        "negativeExamples": [
          "street_suffix"
        ]
      },
      {
        "regExp": "(?i).*(road|street|thoroughfare).*core.*name.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "road_core_name"
        ],
        "negativeExamples": [
          "core_street_type"
        ]
      },
      {
        "regExp": "(?i).*(st|str|rd|ave).*name.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "st_name"
        ],
        "negativeExamples": [
          "st_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Main",
      "Old Mill",
      "King's Cross",
      "Maple Grove",
      "Queen Anne",
      "St John",
      "Martin Luther King",
      "Broadway"
    ],
    "negativeContentExamples": [
      "Main Street",
      "Main St",
      "Old Mill Road",
      "Elm Ave",
      "Maple Lane",
      "Queen Anne Way",
      "Martin Luther King Boulevard",
      "First Avenue"
    ],
    "positiveHeaderExamples": [
      "street_name_bare",
      "base_street_name",
      "road_core_name",
      "thoroughfare_base_name",
      "bare_thoroughfare_name",
      "primary_street_name",
      "st_name",
      "street_base_name"
    ],
    "negativeHeaderExamples": [
      "street_type",
      "street_suffix",
      "address_line1",
      "street_code",
      "road_class",
      "thoroughfare_type",
      "street_id",
      "location"
    ],
    "explanation": "This semantic type targets the base component of English street names, excluding any trailing thoroughfare type terms such as Street/St, Avenue/Ave, Road/Rd, Boulevard/Blvd, Lane/Ln, Court/Ct, Place/Pl, Parkway/Pkwy, Highway/Hwy, Terrace/Ter, Way, or Square/Sq. It is useful when address parsing or normalization separates the core name from the street type, enabling consistent matching, deduplication, and join keys across datasets.",
    "description_pattern": "P5",
    "generated_at": "2025-08-10T17:52:55.606716"
  }
]
[
  {
    "resultType": "generated",
    "semanticType": "AIRPORT_CODE.IATA",
    "description": "This code consists of exactly three uppercase alphabetic characters that serve as the universal identifier for airports in airline ticketing and flight operations. The code contains only letters with no numbers, spaces, or punctuation marks.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 2220,
    "headerPatterns": [
      {
        "regExp": "(?i).*(airport).*(iata).*(code).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Airport IATA Code"
        ],
        "negativeExamples": [
          "Airline Code"
        ]
      },
      {
        "regExp": "(?i).*(iata).*(airport).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IATA Airport"
        ],
        "negativeExamples": [
          "Airport Name"
        ]
      },
      {
        "regExp": "(?i).*(airport).*(code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Airport Code"
        ],
        "negativeExamples": [
          "Airline Code"
        ]
      },
      {
        "regExp": "(?i).*(iata).*(code).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "IATA Code"
        ],
        "negativeExamples": [
          "ICAO Code"
        ]
      },
      {
        "regExp": "(?i).*(code).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "LAX",
      "JFK",
      "CDG",
      "HND",
      "DXB",
      "SYD",
      "GRU",
      "YYZ"
    ],
    "negativeContentExamples": [
      "jfk",
      "LAX1",
      "J F K",
      "LA-X",
      "LHR_",
      "4LG",
      "KLAX",
      "LA"
    ],
    "positiveHeaderExamples": [
      "Airport Code",
      "IATA Code",
      "Airport",
      "Airport IATA Code",
      "IATA Airport",
      "IATA Airport Code",
      "AirportCode",
      "IATA"
    ],
    "negativeHeaderExamples": [
      "Airport Name",
      "City",
      "Airline Code",
      "ICAO Code",
      "Airline",
      "Country Code",
      "City Code",
      "Airport Identifier"
    ],
    "explanation": "Identifies three-letter IATA airport codes used in ticketing and flight operations. The value pattern requires exactly three uppercase letters with no digits, spaces, or punctuation, enforced via a word-bounded regex. This type is intentionally strict to avoid collisions with other code fields and free-text airport names.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:12:50.025017"
  },
  {
    "resultType": "generated",
    "semanticType": "EMAIL",
    "description": "An email address consisting of a local part, an at-symbol, and a domain. The local part begins with an alphanumeric character and may include dots, underscores, percent signs, plus signs, and hyphens. The domain is composed of one or more labels separated by dots; each label starts with an alphanumeric character and may contain hyphens.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z0-9][A-Za-z0-9._%+-]{0,63}@[A-Za-z0-9][A-Za-z0-9-]{0,61}(\\.[A-Za-z0-9][A-Za-z0-9-]{0,61})+\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 2620,
    "headerPatterns": [
      {
        "regExp": "(?i).*(contact|primary|work|personal).*email.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Contact Email Address"
        ],
        "negativeExamples": [
          "Contact Mailing Address"
        ]
      },
      {
        "regExp": "(?i).*(customer|user|account|employee).*email.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Customer Email"
        ],
        "negativeExamples": [
          "Customer Name"
        ]
      },
      {
        "regExp": "(?i).*(e[-_ ]?mail).*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Email ID"
        ],
        "negativeExamples": [
          "User ID"
        ]
      },
      {
        "regExp": "(?i).*(contact).*mail.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Contact Mail"
        ],
        "negativeExamples": [
          "Postal Mail"
        ]
      },
      {
        "regExp": "(?i).*email.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Email"
        ],
        "negativeExamples": [
          "Website"
        ]
      }
    ],
    "positiveContentExamples": [
      "john.doe@example.com",
      "jane_doe+news@sub.example.co.uk",
      "alex-99@company.org",
      "user.name@service.io",
      "support@my-domain.net",
      "a123@x.co",
      "sales%team@biz-mail.com",
      "billing@customers.example.com"
    ],
    "negativeContentExamples": [
      "john.doe@example",
      ".john@example.com",
      "john doe@example.com",
      "john.doe@.example.com",
      "john.doe@example..com",
      "john.doe@exam_ple.com",
      "john.doeexample.com",
      "john.doe@-example.com"
    ],
    "positiveHeaderExamples": [
      "Email",
      "Email Address",
      "Contact Email",
      "Primary Email",
      "Customer Email",
      "User Email",
      "Email ID",
      "Work Email"
    ],
    "negativeHeaderExamples": [
      "Phone Number",
      "Name",
      "Website",
      "Postal Address",
      "Contact Name",
      "User ID",
      "Mailing Address",
      "URL"
    ],
    "explanation": "Identifies and validates email addresses with a balanced, FTA-compatible regex that avoids anchors and favors clear token boundaries. Useful for profiling, validation, and auto-mapping fields containing contact email addresses across varied datasets.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:12:51.545166"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.ISBN",
    "description": "This identifier consists of thirteen digits arranged in five groups separated by hyphens, including prefix, country/language group, publisher, title number, and check digit. The format follows international standards with consistent hyphenation patterns based on registration groups.",
    "pluginType": "regex",
    "regexPattern": "\\b97[89]-\\d{1,5}-\\d{1,7}-\\d{1,7}-\\d\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2270,
    "headerPatterns": [
      {
        "regExp": "(?i).*isbn[-_ ]?13.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISBN-13"
        ],
        "negativeExamples": [
          "Publication Year"
        ]
      },
      {
        "regExp": "(?i).*book.*isbn.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Book ISBN"
        ],
        "negativeExamples": [
          "Book Title"
        ]
      },
      {
        "regExp": "(?i).*isbn[-_ ]?code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISBN Code"
        ],
        "negativeExamples": [
          "ISBN Index"
        ]
      },
      {
        "regExp": "(?i).*isbn.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISBN"
        ],
        "negativeExamples": [
          "ISIN"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Author"
        ]
      }
    ],
    "positiveContentExamples": [
      "978-1-4028-9462-6",
      "978-0-306-40615-7",
      "979-10-90636-07-1",
      "978-3-16-148410-0",
      "978-1-86197-876-9",
      "978-0-545-01022-1",
      "979-8-7654-3210-5",
      "979-12-200-1234-8"
    ],
    "negativeContentExamples": [
      "9781402894626",
      "978-1-4028-9462-X",
      "977-1-4028-9462-4",
      "978-1-4028-9462",
      "978-1-4028-9462-65",
      "978-1-4028-94A2-6",
      "978-1-4028--9462-6",
      "978_1_4028_9462_6"
    ],
    "positiveHeaderExamples": [
      "ISBN",
      "Book ISBN",
      "ISBN-13",
      "ISBN Code",
      "Book ISBN-13",
      "Printed ISBN",
      "Publication ISBN"
    ],
    "negativeHeaderExamples": [
      "Book Title",
      "Author",
      "Publication Year",
      "ISIN",
      "ISSN",
      "Barcode",
      "Library ID"
    ],
    "explanation": "Detects hyphenated ISBN-13 codes with five groups, starting with 978 or 979 and ending in a single numeric check digit. Useful for classifying bibliographic identifiers in library, publishing, and retail datasets where the hyphenated presentation is expected.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:12:51.922412"
  },
  {
    "resultType": "generated",
    "semanticType": "EPOCH.MILLISECONDS",
    "description": "This type captures Unix timestamp values expressed in milliseconds precision for high-resolution time measurement and logging systems. The values represent time as a large integer count of milliseconds from the Unix epoch without any formatting, separators, or textual date components.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{13}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2630,
    "headerPatterns": [
      {
        "regExp": "(?i).*unix.*timestamp.*ms.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "unix_timestamp_ms"
        ],
        "negativeExamples": [
          "Unix Timestamp"
        ]
      },
      {
        "regExp": "(?i).*epoch.*ms.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "epoch_ms"
        ],
        "negativeExamples": [
          "epoch_seconds"
        ]
      },
      {
        "regExp": "(?i).*unix.*timestamp.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Unix Timestamp"
        ],
        "negativeExamples": [
          "Timestamp"
        ]
      },
      {
        "regExp": "(?i).*time.*millis.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Time Millis"
        ],
        "negativeExamples": [
          "Time Micros"
        ]
      },
      {
        "regExp": "(?i).*timestamp.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Timestamp"
        ],
        "negativeExamples": [
          "Time"
        ]
      }
    ],
    "positiveContentExamples": [
      "1000000000000",
      "1234567890123",
      "1609459200000",
      "1640995200000",
      "1672531200000",
      "1696118400000",
      "1704067200000",
      "1735689600000"
    ],
    "negativeContentExamples": [
      "1697040000",
      "1697040000000000",
      "169704000000",
      "16970400000000",
      "1,697,040,000,000",
      "1697040000000ms",
      "-1697040000000",
      "1697040000000.0"
    ],
    "positiveHeaderExamples": [
      "Timestamp",
      "Unix Timestamp",
      "Time Millis",
      "epoch_ms",
      "unix_timestamp_ms",
      "event_timestamp_ms",
      "unix timestamp ms"
    ],
    "negativeHeaderExamples": [
      "Date",
      "Time",
      "Formatted Date",
      "timestamp_seconds",
      "epoch_microseconds",
      "iso8601_timestamp",
      "datetime"
    ],
    "explanation": "EPOCH.MILLISECONDS identifies unformatted 13-digit integers representing milliseconds since the Unix epoch. It is useful for parsing and validating log timestamps, event times, and telemetry where time is recorded as millisecond-precision integers.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:12:55.375389"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.EAN13",
    "description": "This barcode consists of exactly thirteen numeric digits including a calculated check digit for error detection and validation. The identifier contains only numbers with no letters, spaces, hyphens, or other formatting characters.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{13}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 2250,
    "headerPatterns": [
      {
        "regExp": "(?i).*ean[-_ ]?13.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "EAN13"
        ],
        "negativeExamples": [
          "ISBN-10"
        ]
      },
      {
        "regExp": "(?i).*isbn[-_ ]?13.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISBN-13"
        ],
        "negativeExamples": [
          "UPC Code"
        ]
      },
      {
        "regExp": "(?i).*(bar[-_ ]?code|barcode).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Barcode"
        ],
        "negativeExamples": [
          "Product Name"
        ]
      },
      {
        "regExp": "(?i).*check[-_ ]?digit.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Check Digit"
        ],
        "negativeExamples": [
          "Price"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "EAN-13 Code"
        ],
        "negativeExamples": [
          "Serial Number"
        ]
      }
    ],
    "positiveContentExamples": [
      "4006381333931",
      "5901234123457",
      "9780306406157",
      "0123456789012",
      "1234567890128",
      "5012345678900",
      "8712345678906",
      "0000000000000"
    ],
    "negativeContentExamples": [
      "123456789012",
      "12345678901234",
      "1234 567890128",
      "123-4567890128",
      "12345678901A8",
      "9780306406158",
      "5012345678901",
      "0000000000001"
    ],
    "positiveHeaderExamples": [
      "EAN13",
      "Barcode",
      "ISBN-13",
      "EAN-13",
      "ISBN13",
      "Barcode Number",
      "EAN-13 Code",
      "Check Digit"
    ],
    "negativeHeaderExamples": [
      "Product Name",
      "Price",
      "UPC Code",
      "ISBN-10",
      "QR Code",
      "Serial Number",
      "SKU",
      "Product ID"
    ],
    "explanation": "Detects 13-digit numeric barcodes consistent with EAN-13/ISBN-13 formats using a strict 13-digit token pattern with word boundaries. Useful for validating product identifiers and book ISBN-13 values where only digits are allowed and the string is exactly 13 characters long.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:12:58.130652"
  },
  {
    "resultType": "generated",
    "semanticType": "AIRLINE.IATA_CODE",
    "description": "Standardized airline identification codes used in booking systems and flight operations. Each value is exactly two uppercase letters with no digits, punctuation, or spaces.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 2200,
    "headerPatterns": [
      {
        "regExp": "(?i).*airline.*iata.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Airline IATA Code"
        ],
        "negativeExamples": [
          "Airport Code"
        ]
      },
      {
        "regExp": "(?i).*airline.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Airline Code"
        ],
        "negativeExamples": [
          "Airline Name"
        ]
      },
      {
        "regExp": "(?i).*iata.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IATA Code"
        ],
        "negativeExamples": [
          "Booking Code"
        ]
      },
      {
        "regExp": "(?i).*carrier.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Carrier Code"
        ],
        "negativeExamples": [
          "Carrier"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "AA",
      "BA",
      "LH",
      "AF",
      "EK",
      "SQ",
      "DL",
      "QF"
    ],
    "negativeContentExamples": [
      "A1",
      "ABC",
      "A",
      "Aa",
      "\u00c4B",
      "A-B",
      "A B",
      "AB3"
    ],
    "positiveHeaderExamples": [
      "Airline Code",
      "IATA Code",
      "Carrier",
      "Airline IATA Code",
      "Carrier Code",
      "Airline Identifier"
    ],
    "negativeHeaderExamples": [
      "Airline Name",
      "Flight Number",
      "Airport Code",
      "Aircraft Code",
      "Booking Code",
      "Airline Country"
    ],
    "explanation": "Identifies two-letter uppercase airline IATA codes in datasets, enabling accurate parsing and validation of carrier identifiers in manifests, ticketing, and operational data. The pattern enforces exactly two ASCII uppercase letters, rejecting digits, punctuation, whitespace, and non-ASCII characters. Header patterns target columns labeled with airline/carrier and IATA code terminology, with a final primitive fallback on 'code' to integrate into broader schemas.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:12:58.376270"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.LUHN",
    "description": "A numeric identifier where the final digit is a checksum computed by the Luhn algorithm. The value contains only digits, with no spaces, hyphens, or other separators, and typically spans between 8 and 19 digits to cover common Luhn-using identifiers such as payment card PANs and IMEIs.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{8,19}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 92,
    "priority": 2290,
    "headerPatterns": [
      {
        "regExp": "(?i).*credit.*card.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Credit Card Number"
        ],
        "negativeExamples": [
          "Card Type"
        ]
      },
      {
        "regExp": "(?i).*card.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Card Number"
        ],
        "negativeExamples": [
          "Cardholder Name"
        ]
      },
      {
        "regExp": "(?i).*imei.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IMEI"
        ],
        "negativeExamples": [
          "Expiration Date"
        ]
      },
      {
        "regExp": "(?i).*(cc|pan).*num.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "PAN num"
        ],
        "negativeExamples": [
          "Card Type"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Number"
        ],
        "negativeExamples": [
          "Card Type"
        ]
      }
    ],
    "positiveContentExamples": [
      "79927398713",
      "4532015112830366",
      "4111111111111111",
      "6011111111111117",
      "378282246310005",
      "490154203237518",
      "30569309025904"
    ],
    "negativeContentExamples": [
      "4111111111111112",
      "79927398714",
      "3566-0020-2036-0505",
      "49015420323751A",
      "1234567",
      "12345678901234567890",
      "ID4532015112830366"
    ],
    "positiveHeaderExamples": [
      "Credit Card Number",
      "Card Number",
      "IMEI",
      "PAN",
      "CC Number",
      "IMEI Number",
      "Card Num",
      "Primary Account Number"
    ],
    "negativeHeaderExamples": [
      "Card Type",
      "Cardholder Name",
      "Expiration Date",
      "Security Code",
      "Cardholder",
      "Card Expiry",
      "Billing Zip Code",
      "Issuer Identification"
    ],
    "explanation": "This semantic type targets digit-only identifiers that implement the Luhn checksum, such as payment card primary account numbers and IMEI device IDs. It restricts matches to 8\u201319 consecutive digits without separators, aligning with common Luhn-based identifier lengths. Use when you need to detect fields likely to contain Luhn-valid numeric identifiers; downstream validation routines can apply the actual Luhn check for verification.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:12:58.714208"
  },
  {
    "resultType": "generated",
    "semanticType": "EPOCH.SECONDS",
    "description": "This type captures Unix timestamp values expressed in seconds precision for standard time measurement and system operations. The values represent time as an integer count of seconds from the Unix epoch without any formatting, separators, or textual date components.",
    "pluginType": "regex",
    "regexPattern": "\\b(1|2)\\d{9}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 2640,
    "headerPatterns": [
      {
        "regExp": "(?i).*unix.*timestamp.*sec.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "unix timestamp seconds"
        ],
        "negativeExamples": [
          "Unix Timestamp"
        ]
      },
      {
        "regExp": "(?i).*unix.*timestamp.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Unix Timestamp"
        ],
        "negativeExamples": [
          "Epoch Time"
        ]
      },
      {
        "regExp": "(?i).*epoch.*time.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Epoch Time"
        ],
        "negativeExamples": [
          "Formatted Date"
        ]
      },
      {
        "regExp": "(?i).*(epoch|unix).*sec.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "epoch_seconds"
        ],
        "negativeExamples": [
          "Date"
        ]
      },
      {
        "regExp": "(?i).*timestamp.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Timestamp"
        ],
        "negativeExamples": [
          "Time"
        ]
      }
    ],
    "positiveContentExamples": [
      "1609459200",
      "1700000000",
      "1685577600",
      "1234567890",
      "2000000000",
      "1451606400",
      "1500000000",
      "2147483647"
    ],
    "negativeContentExamples": [
      "1690000000000",
      "170000000",
      "-1700000000",
      "1700000000.0",
      "1_700_000_000",
      "01609459200",
      "3000000000",
      "170000000O"
    ],
    "positiveHeaderExamples": [
      "Timestamp",
      "Unix Timestamp",
      "Epoch Time",
      "unix timestamp seconds",
      "epoch_seconds",
      "ts_epoch_sec",
      "event_timestamp"
    ],
    "negativeHeaderExamples": [
      "Date",
      "Time",
      "Formatted Date",
      "timestamp_ms",
      "created_at",
      "timecode",
      "epoch_millis",
      "duration_seconds"
    ],
    "explanation": "Identifies integers representing Unix time in seconds (10-digit values beginning with 1 or 2), avoiding ambiguity with generic numbers or millisecond-based timestamps. Useful for detecting raw system timestamps and normalizing time fields stored as seconds since 1970-01-01.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:01.124179"
  },
  {
    "resultType": "generated",
    "semanticType": "DAY.FULL_<LOCALE>",
    "description": "Captures full English weekday names for date display and internationalization in the en locale. Values are the complete day-of-week names using correct spelling and standard capitalization in English.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "MONDAY",
      "TUESDAY",
      "WEDNESDAY",
      "THURSDAY",
      "FRIDAY",
      "SATURDAY",
      "SUNDAY"
    ],
    "backout": "^[A-Za-z]{6,9}$",
    "confidenceThreshold": 98,
    "priority": 2600,
    "headerPatterns": [
      {
        "regExp": "(?i).*day[^a-z0-9]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Day Name"
        ],
        "negativeExamples": [
          "Day Number"
        ]
      },
      {
        "regExp": "(?i).*day[^a-z0-9]*of[^a-z0-9]*week.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Day of Week"
        ],
        "negativeExamples": [
          "Week Number"
        ]
      },
      {
        "regExp": "(?i).*week[^a-z0-9]*day.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Weekday"
        ],
        "negativeExamples": [
          "Weekend"
        ]
      },
      {
        "regExp": "(?i).*dow.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "DOW"
        ],
        "negativeExamples": [
          "Day of Week"
        ]
      },
      {
        "regExp": "(?i).*day.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Day"
        ],
        "negativeExamples": [
          "Month"
        ]
      }
    ],
    "positiveContentExamples": [
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday",
      "Sunday"
    ],
    "negativeContentExamples": [
      "Mon",
      "Monday 1",
      "Monday-",
      "Monday,",
      "monday",
      "Montag",
      "Thursdays"
    ],
    "positiveHeaderExamples": [
      "Day Name",
      "Day of Week",
      "Weekday",
      "Weekday Name",
      "DOW",
      "Day"
    ],
    "negativeHeaderExamples": [
      "Day Number",
      "Month",
      "Year",
      "Week Number",
      "Weekend",
      "Day Count"
    ],
    "explanation": "This semantic type identifies full English weekday names, which are useful for validating and standardizing day-of-week fields in datasets where the values are spelled-out day names rather than numeric or abbreviated forms. Use it to detect columns containing Monday through Sunday in English, ensuring clean locale-specific day labels.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:02.090403"
  },
  {
    "resultType": "generated",
    "semanticType": "CURRENCY_CODE.ISO-4217",
    "description": "This type represents standardized currency codes established by the International Organization for Standardization for global financial systems. The codes consist of exactly three uppercase alphabetic characters that uniquely identify national and international currencies without spaces or punctuation.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2570,
    "headerPatterns": [
      {
        "regExp": "(?i).*iso.*currency.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISO Currency Code"
        ],
        "negativeExamples": [
          "ISO Country Code"
        ]
      },
      {
        "regExp": "(?i).*currency.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Currency Code"
        ],
        "negativeExamples": [
          "Currency Name"
        ]
      },
      {
        "regExp": "(?i).*iso.*currency.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISO Currency"
        ],
        "negativeExamples": [
          "ISO Language"
        ]
      },
      {
        "regExp": "(?i).*currency.*symbol.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Currency Symbol"
        ],
        "negativeExamples": [
          "Currency Amount"
        ]
      },
      {
        "regExp": "(?i).*ccy.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CCY Code"
        ],
        "negativeExamples": [
          "CCY Name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "USD",
      "EUR",
      "GBP",
      "JPY",
      "AUD",
      "CAD",
      "CHF",
      "INR"
    ],
    "negativeContentExamples": [
      "usd",
      "Usd",
      "US",
      "EURO",
      "EUR1",
      "EU R",
      "US$",
      "USD-"
    ],
    "positiveHeaderExamples": [
      "Currency Code",
      "ISO Currency",
      "Currency Symbol",
      "ISO Currency Code",
      "Base Currency Code",
      "Payment Currency Code",
      "CCY Code",
      "Currency ISO"
    ],
    "negativeHeaderExamples": [
      "Currency Name",
      "Exchange Rate",
      "Country",
      "Currency Amount",
      "ISO Country Code",
      "Language Code",
      "Country Code",
      "Currency"
    ],
    "explanation": "Use this semantic type to detect and validate ISO 4217 currency codes in datasets, ensuring values are three uppercase letters with no spaces or punctuation. It is suitable for fields that store base or transaction currency codes, pricing currency fields, and financial reporting dimensions. The header patterns progress from highly specific references to ISO currency code to the primitive term code to balance precision with recall while avoiding over-broad matches.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:03.489654"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE_PAIR.DECIMAL",
    "description": "This coordinate pair consists of two decimal numbers separated by a comma and optional space, representing latitude first followed by longitude. The format follows standard GPS conventions with positive values for north/east and negative values for south/west hemispheres.",
    "pluginType": "regex",
    "regexPattern": "-?((90(\\.0+)?)|([0-8]?\\d(\\.\\d+)?))\\s*,\\s*-?((180(\\.0+)?)|(1[0-7]\\d(\\.\\d+)?)|([0-9]?\\d(\\.\\d+)?))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 2460,
    "headerPatterns": [
      {
        "regExp": "(?i).*gps.*coordinate.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "GPS Coordinates"
        ],
        "negativeExamples": [
          "Longitude"
        ]
      },
      {
        "regExp": "(?i).*\\blat\\b.*\\blong\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Lat Long"
        ],
        "negativeExamples": [
          "Latitude"
        ]
      },
      {
        "regExp": "(?i).*coordinate.*pair.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Coordinate Pair"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*geo.*coord.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Geographic Coordinates"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      },
      {
        "regExp": "(?i).*coordinate.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Coordinates"
        ],
        "negativeExamples": [
          "Longitude"
        ]
      }
    ],
    "positiveContentExamples": [
      "37.7749, -122.4194",
      "-33.8688, 151.2093",
      "0, 0",
      "45.0, 9.999",
      "90, 180",
      "-90.0, -180.0",
      "12.345678, -98.765432",
      "8.5, 170.25"
    ],
    "negativeContentExamples": [
      "91, -122.4194",
      "37.7749 -122.4194",
      "37.7749, -181",
      "N37.77, W122.41",
      "37.7749,122.4194W",
      "-90.0001, 0",
      "45.0, -180.0001",
      "37, -122, 45"
    ],
    "positiveHeaderExamples": [
      "Coordinates",
      "Lat Long",
      "GPS Coordinates",
      "Coordinate Pair",
      "LatLon",
      "Geographic Coordinates",
      "GPS Lat Long"
    ],
    "negativeHeaderExamples": [
      "Latitude",
      "Longitude",
      "Address",
      "City",
      "ZIP Code",
      "Location Name",
      "GPS Altitude"
    ],
    "explanation": "Identifies latitude/longitude coordinate pairs in decimal degrees with a comma separator and optional space, ordered as latitude first and longitude second. Useful for detecting GPS-style coordinate columns for mapping, geocoding, and spatial analytics.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:06.017686"
  },
  {
    "resultType": "generated",
    "semanticType": "COLOR.HEX",
    "description": "This color representation begins with a hash symbol followed by exactly six hexadecimal characters representing red, green, and blue color intensities. The code uses digits 0-9 and uppercase letters A-F with no spaces or additional formatting.",
    "pluginType": "regex",
    "regexPattern": "#[0-9A-F]{6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 2330,
    "headerPatterns": [
      {
        "regExp": "(?i).*hex.*color.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Hex Color Code"
        ],
        "negativeExamples": [
          "Color Name"
        ]
      },
      {
        "regExp": "(?i).*color.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Color Code"
        ],
        "negativeExamples": [
          "Brand Color"
        ]
      },
      {
        "regExp": "(?i).*hex.*color.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Hex Color"
        ],
        "negativeExamples": [
          "RGB Values"
        ]
      },
      {
        "regExp": "(?i).*color.*value.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Color Value"
        ],
        "negativeExamples": [
          "Customer Value"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "#000000",
      "#FFFFFF",
      "#123ABC",
      "#A1B2C3",
      "#C0FFEE",
      "#BADA55",
      "#00A1FF",
      "#F00F0F"
    ],
    "negativeContentExamples": [
      "#abc123",
      "00A1FF",
      "#12345",
      "#1234567",
      "#G0A1FF",
      "#A1 FF00",
      "##00A1FF",
      "#A1F"
    ],
    "positiveHeaderExamples": [
      "Color Code",
      "Hex Color",
      "Color Value",
      "Hex Color Code",
      "Hex Code",
      "Web Color Code",
      "Color Hex Code",
      "Hexadecimal Color"
    ],
    "negativeHeaderExamples": [
      "Color Name",
      "RGB Values",
      "Brand Color",
      "RGB Code",
      "Background Color",
      "Customer Code",
      "Pantone Code",
      "Value"
    ],
    "explanation": "Identifies six-character hexadecimal RGB color codes prefixed by a hash, constrained to uppercase A\u2013F and digits with no separators or whitespace. Useful for validating style, design, and web color fields where strict HEX formatting is required.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:06.384819"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.NORTHING",
    "description": "This coordinate represents the vertical position in a map projection measured as distance north from a baseline or grid origin. The value is typically a decimal number expressed in linear units like meters with positive values indicating northward direction.",
    "pluginType": "regex",
    "regexPattern": "\\b[1-9][0-9]{5,7}([.][0-9]+)?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 2450,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bnorthing\\s*value\\b.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Northing Value"
        ],
        "negativeExamples": [
          "Longitude Value"
        ]
      },
      {
        "regExp": "(?i).*\\bnorthing\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Northing"
        ],
        "negativeExamples": [
          "Latitude"
        ]
      },
      {
        "regExp": "(?i).*\\by\\s*coordinate\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Y Coordinate"
        ],
        "negativeExamples": [
          "X Coordinate"
        ]
      },
      {
        "regExp": "(?i).*(\\by[_\\s-]?coord\\b|\\bcoord[_\\s-]?y\\b).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Y-Coord"
        ],
        "negativeExamples": [
          "Coord-X"
        ]
      },
      {
        "regExp": "(?i).*\\bcoordinate\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Coordinate"
        ],
        "negativeExamples": [
          "Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "4456789",
      "7321456.75",
      "2500000",
      "9876543.2",
      "1000000",
      "7654321",
      "1234567.0"
    ],
    "negativeContentExamples": [
      "12345",
      "123456789",
      "0123456",
      "654321.",
      "-654321",
      "123 4567",
      "1234.5678",
      "7654321m"
    ],
    "positiveHeaderExamples": [
      "Northing",
      "Y Coordinate",
      "Northing Value",
      "Grid Y",
      "Y-Coord",
      "Coordinate Y"
    ],
    "negativeHeaderExamples": [
      "Latitude",
      "Longitude",
      "Address",
      "Easting",
      "X Coordinate",
      "Postal Code"
    ],
    "explanation": "Northing values are typically large positive numeric distances (often in meters) representing displacement northward in a projected coordinate system grid. This type focuses on validating numeric-only tokens that look like projected Y-axis distances and leverages header context (e.g., 'northing', 'Y coordinate') to distinguish from other numeric fields. It is useful for spatial datasets using projected grids (e.g., engineering surveys, GIS exports) where vertical grid distances must be recognized distinctly from easting or geographic lat/long.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:08.548277"
  },
  {
    "resultType": "generated",
    "semanticType": "COLOR.TEXT_EN",
    "description": "Standard English color terms expressed as natural-language names of colors and hues. Values are typically single words or simple two-word/ hyphenated compounds (e.g., \"light blue\", \"off-white\") without numbers, codes, or technical color-space specifications.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b((light|dark|bright|pale|deep|royal|hot|sky|forest|sea|slate|off|baby|dusty|electric|neon|pastel|soft|vivid)[ -])?(black|white|red|green|blue|yellow|orange|purple|violet|pink|brown|gray|grey|beige|cyan|magenta|maroon|navy|teal|olive|gold|silver|bronze|lavender|turquoise|aquamarine|charcoal|cream|ivory|peach|mint|mustard|tan|salmon|coral|plum|burgundy|khaki|lime|fuchsia|azure|scarlet|crimson|sapphire|emerald|amber|apricot|mauve|ochre|ocher|cerulean|cobalt|vermilion|vermillion|chartreuse)([ -](green|blue|gray|grey))?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 2340,
    "headerPatterns": [
      {
        "regExp": "(?i).*primary[ _-]color[ _-]name.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Primary Color Name"
        ],
        "negativeExamples": [
          "Primary Color Code"
        ]
      },
      {
        "regExp": "(?i).*color[ _-]name.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Color Name"
        ],
        "negativeExamples": [
          "Color Code"
        ]
      },
      {
        "regExp": "(?i).*primary[ _-]color.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Primary Color"
        ],
        "negativeExamples": [
          "Hex Value"
        ]
      },
      {
        "regExp": "(?i).*(clr|col)[ _-]?name.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "clr name"
        ],
        "negativeExamples": [
          "clr code"
        ]
      },
      {
        "regExp": "(?i).*color.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Color"
        ],
        "negativeExamples": [
          "RGB"
        ]
      }
    ],
    "positiveContentExamples": [
      "red",
      "blue",
      "green",
      "light blue",
      "navy",
      "off white",
      "forest green",
      "slate gray"
    ],
    "negativeContentExamples": [
      "#ff0000",
      "rgb(255,0,0)",
      "blueish",
      "skyblue",
      "red-2",
      "slategray",
      "primary red",
      "blue/green"
    ],
    "positiveHeaderExamples": [
      "Color",
      "Color Name",
      "Primary Color",
      "Base Color",
      "Preferred Color",
      "Accent Color",
      "Color Label"
    ],
    "negativeHeaderExamples": [
      "Color Code",
      "Hex Value",
      "RGB",
      "Color Hex",
      "HSV",
      "CMYK",
      "Pantone"
    ],
    "explanation": "This semantic type recognizes human-friendly English color names rather than codes. It is useful for labeling, UI theming, survey responses, and attributes where colors are described textually (e.g., \"navy\", \"light blue\"). It intentionally excludes numeric or technical representations such as hex codes, RGB/HSV/CMYK tuples, and standardized catalog identifiers.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:09.070624"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.SEDOL",
    "description": "This security identifier consists of six alphanumeric characters followed by a single check digit calculated for validation purposes. The code uses uppercase letters and numbers with no spaces, hyphens, or other punctuation marks.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z0-9]{6}[0-9]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 2300,
    "headerPatterns": [
      {
        "regExp": "(?i).*sedol.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "SEDOL Code"
        ],
        "negativeExamples": [
          "Company Name"
        ]
      },
      {
        "regExp": "(?i).*uk.*security.*id.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "UK Security ID"
        ],
        "negativeExamples": [
          "Stock Price"
        ]
      },
      {
        "regExp": "(?i).*sedol.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SEDOL"
        ],
        "negativeExamples": [
          "Exchange"
        ]
      },
      {
        "regExp": "(?i).*security.*id.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Security Identifier"
        ],
        "negativeExamples": [
          "Stock Price"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "0263494",
      "B0YBKJ7",
      "A1B2C30",
      "ZZZZZZ0",
      "9ABCDE1",
      "1234567",
      "H5K3LM2",
      "00ABCD3"
    ],
    "negativeContentExamples": [
      "B0YBKJZ",
      "b0YBKJ7",
      "AB12-CD3",
      "AB12 CD3",
      "ABCDE7",
      "A1B2C3D4",
      "123456A",
      "A1B2C#3"
    ],
    "positiveHeaderExamples": [
      "SEDOL",
      "SEDOL Code",
      "UK Security ID",
      "Security Identifier",
      "Sedol ID",
      "UK SEDOL",
      "Security ID Code",
      "Security Code"
    ],
    "negativeHeaderExamples": [
      "Company Name",
      "Stock Price",
      "Exchange",
      "ISIN",
      "Ticker Symbol",
      "CUSIP",
      "Currency Code",
      "Country Code"
    ],
    "explanation": "SEDOL is a seven-character security identifier where the first six characters are uppercase alphanumeric and the final character is a numeric check digit. This pattern enforces uppercase letters and digits only, no separators or punctuation, and uses word boundaries to prevent partial matches within longer strings. Header patterns progress from specific SEDOL references to general 'code', reducing ambiguity with other security identifiers.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:11.314716"
  },
  {
    "resultType": "generated",
    "semanticType": "FREE_TEXT",
    "description": "This type captures open-ended text fields that contain human-readable content without predefined formats or constraints. The values represent natural language text including sentences, phrases, and paragraphs with variable length and content depending on the specific use case.",
    "pluginType": "regex",
    "regexPattern": "[A-Za-z][A-Za-z0-9 ,.'\";:()!%?\\-#&/\\+]{5,}\\s+[A-Za-z0-9 ,.'\";:()!%?\\-#&/\\+]{3,}",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2670,
    "headerPatterns": [
      {
        "regExp": "(?i).*(customer|order|product).*(description|notes|comments).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_description"
        ],
        "negativeExamples": [
          "order_id"
        ]
      },
      {
        "regExp": "(?i).*description.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Description"
        ],
        "negativeExamples": [
          "Date"
        ]
      },
      {
        "regExp": "(?i).*(notes|note).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Notes"
        ],
        "negativeExamples": [
          "Price"
        ]
      },
      {
        "regExp": "(?i).*(comments|comment|remarks|memo).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Comments"
        ],
        "negativeExamples": [
          "Email"
        ]
      },
      {
        "regExp": "(?i).*text.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Text"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Customer reported intermittent connectivity during peak hours.",
      "Please deliver to the side entrance after 5 pm.",
      "Item arrived damaged; replacement requested.",
      "High priority issue affecting multiple users.",
      "Payment processed successfully. Thank you!",
      "Color may vary slightly between batches.",
      "The quick brown fox jumps over the lazy dog.",
      "Use caution when handling fragile components."
    ],
    "negativeContentExamples": [
      "ID-12345",
      "2023-07-31",
      "john.doe@example.com",
      "N/A",
      "Yes",
      "1234567890",
      "SKU-AB-99",
      "OK"
    ],
    "positiveHeaderExamples": [
      "Description",
      "Notes",
      "Comments",
      "Customer Description",
      "Product Notes",
      "User Comments",
      "Remarks",
      "Text"
    ],
    "negativeHeaderExamples": [
      "ID",
      "Date",
      "Price",
      "Email",
      "SKU",
      "Quantity",
      "Code",
      "DOB"
    ],
    "explanation": "FREE_TEXT identifies columns that hold unstructured, natural-language content such as descriptions, notes, comments, and general text fields. It is intentionally broad and should be used when no more specific semantic type applies. The value regex emphasizes the presence of letters, at least one space, and common punctuation to distinguish free-form narrative text from codes, dates, and single-token values.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:12.036481"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.CUSIP",
    "description": "This security identifier consists of eight alphanumeric characters followed by a single check digit for validation purposes. The code uses uppercase letters and numbers with no spaces, hyphens, or other punctuation marks.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z0-9]{8}[0-9]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2240,
    "headerPatterns": [
      {
        "regExp": "(?i).*cusip.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CUSIP Code"
        ],
        "negativeExamples": [
          "CUSIP"
        ]
      },
      {
        "regExp": "(?i).*cusip.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CUSIP ID"
        ],
        "negativeExamples": [
          "Security ID"
        ]
      },
      {
        "regExp": "(?i).*cusip.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CUSIP"
        ],
        "negativeExamples": [
          "ISIN"
        ]
      },
      {
        "regExp": "(?i).*security.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Security ID"
        ],
        "negativeExamples": [
          "Account ID"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "A1B2C3D40",
      "Z9X8Y7W61",
      "123456789",
      "AB12CD345",
      "H0J1K2L38",
      "NNNNNNNN0",
      "0A1B2C3D4",
      "Q7W6E5R48"
    ],
    "negativeContentExamples": [
      "AB12CD34E",
      "ab12CD345",
      "AB12-CD345",
      "AB12 CD345",
      "AB12CD34",
      "AB12CD3456",
      "AB12CD34_5",
      "12345678X"
    ],
    "positiveHeaderExamples": [
      "CUSIP",
      "Security ID",
      "CUSIP Code",
      "CUSIP ID",
      "Security Identifier",
      "CUSIP Number"
    ],
    "negativeHeaderExamples": [
      "Ticker Symbol",
      "Company Name",
      "Stock Price",
      "ISIN",
      "SEDOL",
      "Security Type",
      "Account ID"
    ],
    "explanation": "Identifies CUSIP-style security identifiers composed of eight uppercase alphanumeric characters followed by a single numeric check digit. The value regex enforces length, allowed characters, and the numeric trailing check digit while forbidding spaces or punctuation. Header patterns proceed from explicit 'CUSIP Code' and 'CUSIP ID' to broader 'Security ID' and finally the primitive 'code' to support varying column naming conventions. Use alongside domain context when possible, as the regex verifies structure but not the computed check digit.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:15.572366"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.ISO-3166-2",
    "description": "Two-letter uppercase country identifiers conforming to ISO 3166-1 alpha-2. Values are exactly two A\u2013Z characters with no digits, spaces, or punctuation, intended to represent countries and territories.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2480,
    "headerPatterns": [
      {
        "regExp": "(?i).*iso.*country.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "ISO Country Code"
        ],
        "negativeExamples": [
          "Country Name"
        ]
      },
      {
        "regExp": "(?i).*country.*alpha.*2.*code.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Country Alpha-2 Code"
        ],
        "negativeExamples": [
          "Country Alpha-3 Code"
        ]
      },
      {
        "regExp": "(?i).*country.*code.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Country Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*iso2.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISO2 Code"
        ],
        "negativeExamples": [
          "ISO3 Code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "US",
      "GB",
      "FR",
      "DE",
      "JP",
      "CN",
      "BR",
      "IN"
    ],
    "negativeContentExamples": [
      "us",
      "USA",
      "U2",
      "D E",
      "D-E",
      "1N",
      "FR.",
      "GB1"
    ],
    "positiveHeaderExamples": [
      "Country Code",
      "ISO Country",
      "Country",
      "ISO Country Code",
      "Country Alpha-2 Code",
      "ISO2 Code",
      "Country ISO2",
      "Country Abbreviation Code"
    ],
    "negativeHeaderExamples": [
      "Country Name",
      "State",
      "Language",
      "Postal Code",
      "Country Alpha-3 Code",
      "Currency Code",
      "Nationality",
      "Region Name"
    ],
    "explanation": "This semantic type identifies ISO 3166-1 alpha-2 country codes, enforcing exactly two uppercase letters with word boundaries to avoid matching longer tokens. It is suitable for columns labeled as country code fields and datasets where countries are represented by their two-letter codes rather than names or alpha-3 codes.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:15.979294"
  },
  {
    "resultType": "generated",
    "semanticType": "CONTINENT.TEXT_EN",
    "description": "This represents the complete name of a continental region using proper English terminology and capitalization. The name consists of one or more words identifying major landmasses without abbreviations, codes, or country-specific references.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AFRICA",
      "ANTARCTICA",
      "ASIA",
      "EUROPE",
      "NORTH AMERICA",
      "SOUTH AMERICA",
      "OCEANIA",
      "AUSTRALIA"
    ],
    "backout": "^[A-Z]{3,12}( [A-Z]{3,12})?$",
    "confidenceThreshold": 98,
    "priority": 2390,
    "headerPatterns": [
      {
        "regExp": "(?i).*continent.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Continent Name"
        ],
        "negativeExamples": [
          "Continent Code"
        ]
      },
      {
        "regExp": "(?i).*geo.*continent.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Geo Continent"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*continental.*region.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Continental Region"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*continent.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Continent"
        ],
        "negativeExamples": [
          "Region"
        ]
      }
    ],
    "positiveContentExamples": [
      "Africa",
      "Antarctica",
      "Asia",
      "Europe",
      "North America",
      "South America",
      "Oceania",
      "Australia"
    ],
    "negativeContentExamples": [
      "north america",
      "N. America",
      "EUROPE",
      "SouthAmerica",
      "North-America",
      "Asia Pacific",
      "Sub-Saharan Africa",
      "Eurasia"
    ],
    "positiveHeaderExamples": [
      "Continent",
      "Continent Name",
      "Continental Region",
      "Geo Continent",
      "Primary Continent",
      "Customer Continent Name",
      "Destination Continent",
      "Home Continent"
    ],
    "negativeHeaderExamples": [
      "Country",
      "City",
      "Continent Code",
      "Country Name",
      "Region",
      "Continent ID",
      "Timezone",
      "Nation"
    ],
    "explanation": "This semantic type captures the standard English names of continents as they commonly appear in datasets, ensuring full words and proper capitalization (e.g., North America, Europe). It is useful for classification of geographic dimensions at the continent level and for validating fields that should contain only continent names, not codes or subregional descriptors.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:17.581602"
  },
  {
    "resultType": "generated",
    "semanticType": "DAY.ABBR_<LOCALE>",
    "description": "This type captures abbreviated weekday names as they appear in different locales and language contexts for date formatting and display purposes. The values represent standardized short forms of weekday names, typically three characters long, following locale-specific conventions and linguistic rules. The <LOCALE> placeholder indicates a single locale; the list of values must be curated per specific locale rather than mixing multiple locales.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "MON",
      "TUE",
      "WED",
      "THU",
      "FRI",
      "SAT",
      "SUN"
    ],
    "backout": "^[A-Z]{2,4}$",
    "confidenceThreshold": 97,
    "priority": 2580,
    "headerPatterns": [
      {
        "regExp": "(?i).*(day|weekday).*abbr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Day Abbr"
        ],
        "negativeExamples": [
          "Day Name"
        ]
      },
      {
        "regExp": "(?i).*day.*of.*week.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Day of Week"
        ],
        "negativeExamples": [
          "Month"
        ]
      },
      {
        "regExp": "(?i).*(dow|wkday).*abbr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "DOW Abbr"
        ],
        "negativeExamples": [
          "Date"
        ]
      },
      {
        "regExp": "(?i).*weekday.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Weekday Abbr"
        ],
        "negativeExamples": [
          "Week Number"
        ]
      },
      {
        "regExp": "(?i).*day.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Day"
        ],
        "negativeExamples": [
          "Month Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "MON",
      "TUE",
      "WED",
      "THU",
      "FRI",
      "SAT",
      "SUN"
    ],
    "negativeContentExamples": [
      "MON.",
      "TUES",
      "THUR",
      "WEDS",
      "FR",
      "SA",
      "SUNN",
      "MONDAY"
    ],
    "positiveHeaderExamples": [
      "Day Abbr",
      "Day of Week",
      "Weekday Abbr",
      "DOW Abbr",
      "DayOfWeek Abbr",
      "Weekday Short"
    ],
    "negativeHeaderExamples": [
      "Day Name",
      "Month",
      "Date",
      "Day Number",
      "Calendar Day",
      "Week Number",
      "Month Name"
    ],
    "explanation": "Abbreviated weekday values are a small, finite set for a given locale, making a list-based classifier ideal. Use this type to identify columns containing short weekday names (e.g., MON, TUE) for locale-aware parsing, formatting, and validation. The backout regex provides a broader shape for graceful degradation when the list is incomplete.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:17.926354"
  },
  {
    "resultType": "generated",
    "semanticType": "COLOR.TEXT_NL",
    "description": "This represents standard color terminology using common Dutch words that describe visual appearance and hue characteristics. The names are typically lowercase single words following Dutch linguistic patterns without numeric values or technical specifications.",
    "pluginType": "regex",
    "regexPattern": "\\b((licht|donker)?(rood|oranje|geel|groen|blauw|paars|roze|bruin|zwart|wit|grijs|beige|lila|violet|cyaan|magenta|turquoise|turkoois))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 2360,
    "headerPatterns": [
      {
        "regExp": "(?i).*kleurnaam.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Kleurnaam"
        ],
        "negativeExamples": [
          "Kleurcode"
        ]
      },
      {
        "regExp": "(?i).*primaire\\s*kleur.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Primaire Kleur"
        ],
        "negativeExamples": [
          "RGB"
        ]
      },
      {
        "regExp": "(?i).*(hoofdkleur|accentkleur|basiskleur).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Basiskleur"
        ],
        "negativeExamples": [
          "Hex Waarde"
        ]
      },
      {
        "regExp": "(?i).*kleur\\s*(omschrijving|label).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Kleur Omschrijving"
        ],
        "negativeExamples": [
          "Kleurcode"
        ]
      },
      {
        "regExp": "(?i).*kleur.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Kleur"
        ],
        "negativeExamples": [
          "Kleurcode"
        ]
      }
    ],
    "positiveContentExamples": [
      "rood",
      "blauw",
      "groen",
      "geel",
      "oranje",
      "paars",
      "lichtgroen",
      "grijs"
    ],
    "negativeContentExamples": [
      "Rood",
      "Donkerblauw",
      "licht blauw",
      "licht-blauw",
      "blauw3",
      "RAL9010",
      "rgb(255,0,0)",
      "#rood"
    ],
    "positiveHeaderExamples": [
      "Kleur",
      "Kleurnaam",
      "Primaire Kleur",
      "Basiskleur",
      "Accentkleur",
      "Kleur Omschrijving",
      "Productkleur"
    ],
    "negativeHeaderExamples": [
      "Kleurcode",
      "Hex Waarde",
      "RGB",
      "Hex Kleur",
      "Kleur-ID",
      "Pantone",
      "CMYK"
    ],
    "explanation": "This semantic type identifies Dutch color names written as single, lowercase words representing hues and common color descriptors. It is useful for classifying fields that store human-readable color labels rather than encoded or numeric specifications, enabling clear distinction from color codes or formats like HEX or RGB.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:18.006575"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE_PAIR.DECIMAL_PAREN",
    "description": "This coordinate pair consists of two decimal numbers separated by a comma and enclosed in parentheses, representing latitude first followed by longitude. The format follows mathematical conventions with positive values for north/east and negative values for south/west hemispheres.",
    "pluginType": "regex",
    "regexPattern": "\\b\\(\\s*[+-]?\\d{1,2}(\\.\\d+)?\\s*,\\s*[+-]?\\d{1,3}(\\.\\d+)?\\s*\\)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 2470,
    "headerPatterns": [
      {
        "regExp": "(?i).*(location|map|gps).*(lat).*(lon).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Location (lat, lon)"
        ],
        "negativeExamples": [
          "Longitude"
        ]
      },
      {
        "regExp": "(?i).*coordinate.*pair.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Coordinate Pair"
        ],
        "negativeExamples": [
          "Coordinates"
        ]
      },
      {
        "regExp": "(?i).*(gps|geo|map).*(coordinate|coords).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "GPS Coordinates"
        ],
        "negativeExamples": [
          "GPS Time"
        ]
      },
      {
        "regExp": "(?i).*(lat).*(long|lon).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Lat Long Pair"
        ],
        "negativeExamples": [
          "Latitude"
        ]
      },
      {
        "regExp": "(?i).*coordinates.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Coordinates"
        ],
        "negativeExamples": [
          "Street Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "(37.7749, -122.4194)",
      "(-33.8688, 151.2093)",
      "(0, 0)",
      "(+12.5, -45.75)",
      "(-90, 0)",
      "(23.456789, 54.123456)",
      "(-45.123456, 170.654321)",
      "( 34 , -118.25 )"
    ],
    "negativeContentExamples": [
      "(37.7749 -122.4194)",
      "37.7749, -122.4194",
      "[37.7749, -122.4194]",
      "(lat: 37.7749, lon: -122.4194)",
      "(12.34;-56.78)",
      "(12.34, -56.78, 10)",
      "( 12,34 , -56,78 )",
      "(N37.7749, W122.4194)"
    ],
    "positiveHeaderExamples": [
      "GPS Position",
      "Location Coords",
      "Coordinates",
      "Lat Long Pair",
      "Geo Coordinates",
      "Map Position",
      "Coordinate Pair",
      "Location (lat, lon)"
    ],
    "negativeHeaderExamples": [
      "Latitude",
      "Longitude",
      "Street Address",
      "City",
      "GPS Time",
      "Postal Code",
      "Name",
      "Location ID"
    ],
    "explanation": "Identifies latitude/longitude coordinate pairs formatted as decimal numbers within parentheses and separated by a comma, e.g., (lat, lon). Useful for datasets storing point locations in a compact mathematical style, including optional signs and optional fractional parts, with flexible spacing. The regex is strict about parentheses and comma separation to avoid confusion with other location-related fields.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:20.955766"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.LONGITUDE_DMS",
    "description": "This coordinate format expresses angular distance from the prime meridian using whole degrees, minutes (0-59), and seconds (0-59) followed by E for east or W for west. The format uses degree symbols, apostrophes for minutes, quotation marks for seconds, and directional letters.",
    "pluginType": "regex",
    "regexPattern": "\\b(180|1[0-7][0-9]|[0-9]{1,2})\u00b0\\s*([0-5][0-9])'\\s*([0-5][0-9](\\.[0-9]+)?)\"\\s*[EW]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 2440,
    "headerPatterns": [
      {
        "regExp": "(?i).*longitude.*dms.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Longitude DMS"
        ],
        "negativeExamples": [
          "Decimal Longitude"
        ]
      },
      {
        "regExp": "(?i).*(long|longitude).*(degrees|deg).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Long Degrees"
        ],
        "negativeExamples": [
          "Latitude"
        ]
      },
      {
        "regExp": "(?i).*longitude.*(coord|coords|coordinate|coordinates).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Longitude Coords"
        ],
        "negativeExamples": [
          "Location"
        ]
      },
      {
        "regExp": "(?i).*(lon).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "lon"
        ],
        "negativeExamples": [
          "lat"
        ]
      },
      {
        "regExp": "(?i).*longitude.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Longitude"
        ],
        "negativeExamples": [
          "Latitude"
        ]
      }
    ],
    "positiveContentExamples": [
      "0\u00b000'00\"E",
      "73\u00b059'08\"E",
      "123\u00b045'56\"W",
      "180\u00b000'00\"W",
      "179\u00b059'59\"E",
      "09\u00b005'05\"E",
      "105\u00b007'30.5\"W",
      "100\u00b000'00\"E"
    ],
    "negativeContentExamples": [
      "123\u00b045'60\"E",
      "181\u00b000'00\"W",
      "90\u00b060'00\"E",
      "123\u00b045'56\"N",
      "123 45'56\"E",
      "123\u00b045'56E",
      "123\u00b045\"56'E",
      "W 123\u00b045'56\""
    ],
    "positiveHeaderExamples": [
      "Longitude DMS",
      "Long Degrees",
      "Longitude Coords",
      "Longitude Degrees Minutes Seconds",
      "Lon DMS",
      "Geographic Longitude"
    ],
    "negativeHeaderExamples": [
      "Latitude",
      "Decimal Longitude",
      "Location",
      "Lat DMS",
      "Longitude Decimal Degrees",
      "Coords",
      "GPS",
      "Bearing"
    ],
    "explanation": "Identifies longitude values expressed in degrees, minutes, and seconds (DMS) with an E or W suffix. Useful for parsing and validating geographic longitude fields that are stored in classical DMS notation rather than decimal degrees.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:21.263990"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.UPC",
    "description": "This barcode consists of exactly twelve numeric digits including a calculated check digit for error detection and scanning validation. The identifier contains only numbers with no letters, spaces, hyphens, or other formatting characters.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{12}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 2310,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bupc\\b.*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "UPC Code"
        ],
        "negativeExamples": [
          "Promo Code"
        ]
      },
      {
        "regExp": "(?i).*\\bproduct\\b.*\\bupc\\b.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Product UPC"
        ],
        "negativeExamples": [
          "Product Code"
        ]
      },
      {
        "regExp": "(?i).*\\bupc\\b.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "UPC"
        ],
        "negativeExamples": [
          "Barcode"
        ]
      },
      {
        "regExp": "(?i).*\\bbar\\s*code\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Barcode"
        ],
        "negativeExamples": [
          "Area Code"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Price"
        ]
      }
    ],
    "positiveContentExamples": [
      "012345678905",
      "036000291452",
      "042100005264",
      "681131123456",
      "095011015300",
      "850000123456",
      "730143330005",
      "400638133393"
    ],
    "negativeContentExamples": [
      "12345678901",
      "1234567890123",
      "12345678901A",
      "1234 5678 9012",
      "123-456789012",
      "00000000000",
      "01234567890O",
      "01234567"
    ],
    "positiveHeaderExamples": [
      "UPC",
      "Barcode",
      "UPC Code",
      "Product UPC",
      "Item UPC",
      "UPC Number",
      "Product Barcode"
    ],
    "negativeHeaderExamples": [
      "Product Name",
      "Price",
      "Brand",
      "Product ID",
      "SKU",
      "EAN",
      "Serial Number"
    ],
    "explanation": "Identifies Universal Product Code (UPC) values that are exactly 12 digits with no separators or letters. Useful for validating retail product identifiers captured from scanners or catalogs and distinguishing UPC fields from other product identifiers such as SKU or EAN.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:21.790774"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.LATITUDE_DECIMAL",
    "description": "This coordinate represents angular distance north or south of the equatorial plane using decimal notation ranging from -90 to +90 degrees. Positive values indicate northern hemisphere locations while negative values represent southern hemisphere positions.",
    "pluginType": "regex",
    "regexPattern": "\\b[+-]?((90)(\\.0+)?|(([1-8]\\d)|(\\d))(\\.\\d+)?)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 2410,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\b(lat|latitude)\\b.*\\b(dd|decimal|dec)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Lat_Decimal"
        ],
        "negativeExamples": [
          "Longitude_Decimal"
        ]
      },
      {
        "regExp": "(?i).*\\blatitude\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Latitude"
        ],
        "negativeExamples": [
          "Longitude"
        ]
      },
      {
        "regExp": "(?i).*\\blat\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Lat"
        ],
        "negativeExamples": [
          "Lng"
        ]
      },
      {
        "regExp": "(?i).*\\b(y)[ _-]*\\b(coordinate|coord)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Y Coordinate"
        ],
        "negativeExamples": [
          "X Coordinate"
        ]
      },
      {
        "regExp": "(?i).*\\bcoordinate\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Coordinate"
        ],
        "negativeExamples": [
          "Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "0",
      "-0.75",
      "45.123456",
      "-23.5",
      "+89.9999",
      "90",
      "-90",
      "8.0"
    ],
    "negativeContentExamples": [
      "90.0001",
      "-90.0001",
      "100",
      "-91",
      "45.",
      "08.123",
      "90.0N",
      "N45.0"
    ],
    "positiveHeaderExamples": [
      "Latitude",
      "Lat",
      "Y Coordinate",
      "Latitude_DD",
      "Lat Decimal",
      "Lat_Decimal",
      "Y Coord",
      "Latitude (Decimal)"
    ],
    "negativeHeaderExamples": [
      "Longitude",
      "Address",
      "City",
      "X Coordinate",
      "Lng",
      "Lat/Long",
      "Postal Code",
      "Geo Point"
    ],
    "explanation": "This semantic type identifies decimal latitude values in the range -90 to 90 inclusive, with optional sign and optional fractional part. It is suitable for geospatial datasets, mapping, and geocoding pipelines where latitude is stored as decimal degrees (DD) without directional suffixes.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:22.448307"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.TEXT_EN",
    "description": "This represents the complete country name using proper English terminology and capitalization conventions. The name may include multiple words and follows standard English linguistic patterns but excludes abbreviations, codes, or non-English translations.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z][a-z]+(['-][A-Z][a-z]+)*)\\b(\\s(and|of|the|&)\\s([A-Z][a-z]+(['-][A-Z][a-z]+)*)|\\s([A-Z][a-z]+(['-][A-Z][a-z]+)*)){0,5}",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 2510,
    "headerPatterns": [
      {
        "regExp": "(?i).*(country[\\s_]*name|name[\\s_]*of[\\s_]*country).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Country Name"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*(country[\\s_]*(english|en)|english[\\s_]*country).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Country English"
        ],
        "negativeExamples": [
          "State"
        ]
      },
      {
        "regExp": "(?i).*\\bcountry\\b(?!.*\\bcode\\b).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Country"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*\\b(nation|natn|ctry)\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Nation"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*\\bname\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "United States",
      "United Kingdom",
      "South Africa",
      "New Zealand",
      "Saudi Arabia",
      "Czech Republic",
      "Papua New Guinea",
      "Timor-Leste"
    ],
    "negativeContentExamples": [
      "USA",
      "U.S.A.",
      "United states",
      "Ontario",
      "New York City",
      "Europe",
      "Republic of 123",
      "United_States"
    ],
    "positiveHeaderExamples": [
      "Country",
      "Country Name",
      "Nation",
      "Country English",
      "English Country",
      "Country Full Name",
      "Name of Country",
      "Country (EN)"
    ],
    "negativeHeaderExamples": [
      "Country Code",
      "State",
      "City",
      "ISO Country Code",
      "Province",
      "Territory",
      "Language",
      "Postal Code"
    ],
    "explanation": "This type identifies complete country names written in English with conventional capitalization, allowing multi-word names and common connectors like and, of, or the. It excludes abbreviations, codes, and non-English or transliterated forms, focusing on full, properly capitalized country names suitable for human-readable datasets.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:24.739288"
  },
  {
    "resultType": "generated",
    "semanticType": "CITY",
    "description": "This represents the official name of a populated place with municipal status, typically containing multiple words and proper capitalization. The name may include directional indicators, geographic descriptors, or historical references but excludes abbreviations or postal codes.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z][a-z]{2,}|[A-Z][a-z]{1,}[-'][A-Z][a-z]{1,})(\\s([A-Z][a-z]{2,}|[a-z]{2,3}|[A-Z][a-z]{1,}[-'][A-Z][a-z]{1,})){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2320,
    "headerPatterns": [
      {
        "regExp": "(?i).*(shipping|billing|mailing|residence|office).*city.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "shipping_city_name"
        ],
        "negativeExamples": [
          "shipping_state_name"
        ]
      },
      {
        "regExp": "(?i).*(city|town).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "city_name"
        ],
        "negativeExamples": [
          "country_name"
        ]
      },
      {
        "regExp": "(?i).*(home|billing|shipping|residence|office).*city.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "home_city"
        ],
        "negativeExamples": [
          "home_country"
        ]
      },
      {
        "regExp": "(?i).*municipality.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality"
        ],
        "negativeExamples": [
          "county"
        ]
      },
      {
        "regExp": "(?i).*location.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Location"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      },
      {
        "regExp": "(?i).*city.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "City"
        ],
        "negativeExamples": [
          "State"
        ]
      }
    ],
    "positiveContentExamples": [
      "New York",
      "Los Angeles",
      "San Francisco",
      "Rio de Janeiro",
      "Oklahoma City",
      "Saint Louis",
      "Fort Lauderdale",
      "Las Vegas"
    ],
    "negativeContentExamples": [
      "NYC",
      "St. Louis",
      "New York, NY",
      "SanFrancisco",
      "Los angeles",
      "Washington DC",
      "St Louis",
      "N. York"
    ],
    "positiveHeaderExamples": [
      "City",
      "Town",
      "Location",
      "city_name",
      "home_city",
      "municipality",
      "shipping_city_name",
      "billing_city"
    ],
    "negativeHeaderExamples": [
      "Country",
      "State",
      "ZIP Code",
      "County",
      "Province",
      "Postal Code",
      "State Code",
      "Street Address"
    ],
    "explanation": "Identifies values that look like official city or municipality names written in proper case, optionally including short lowercase connectors (e.g., de, of) and internal hyphen/apostrophe compounds. Useful for classifying residence, billing, or office city fields while avoiding abbreviations, codes, and mixed alphanumeric strings.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:25.999719"
  },
  {
    "resultType": "generated",
    "semanticType": "CRYPTOCURRENCY.TEXT_EN",
    "description": "This type captures the complete names of digital currencies used in blockchain-based financial systems and cryptocurrency trading. The values represent established cryptocurrency names using proper capitalization and standard terminology without symbols, abbreviations, or ticker codes.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z][A-Za-z]*[a-z][A-Za-z]*)( [A-Z][A-Za-z]*[a-z][A-Za-z]*){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 2550,
    "headerPatterns": [
      {
        "regExp": "(?i).*cryptocurrency.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Cryptocurrency Name"
        ],
        "negativeExamples": [
          "Crypto Symbol"
        ]
      },
      {
        "regExp": "(?i).*crypto.*currency.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Crypto Currency Name"
        ],
        "negativeExamples": [
          "Wallet Address"
        ]
      },
      {
        "regExp": "(?i).*digital.*currency.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Digital Currency Name"
        ],
        "negativeExamples": [
          "Price"
        ]
      },
      {
        "regExp": "(?i).*digital.*currency.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Digital Currency"
        ],
        "negativeExamples": [
          "Currency Code"
        ]
      },
      {
        "regExp": "(?i).*cryptocurrency.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Cryptocurrency"
        ],
        "negativeExamples": [
          "Crypto Symbol"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Crypto Name"
        ],
        "negativeExamples": [
          "Token Ticker"
        ]
      }
    ],
    "positiveContentExamples": [
      "Bitcoin",
      "Ethereum",
      "Litecoin",
      "Dogecoin",
      "Cardano",
      "Solana",
      "Polkadot",
      "Stellar Lumens"
    ],
    "negativeContentExamples": [
      "BTC",
      "ETH",
      "bitcoin",
      "Ethereum 2.0",
      "Binance-Coin",
      "USD Coin",
      "Cardano ADA",
      "XRP"
    ],
    "positiveHeaderExamples": [
      "Cryptocurrency",
      "Crypto Name",
      "Digital Currency",
      "Cryptocurrency Name",
      "Crypto Currency Name",
      "Digital Currency Name"
    ],
    "negativeHeaderExamples": [
      "Crypto Symbol",
      "Price",
      "Wallet Address",
      "Currency Code",
      "Token Ticker",
      "Account Name",
      "Transaction Name"
    ],
    "explanation": "Use this semantic type to identify full, human-readable cryptocurrency names in English, such as Bitcoin or Stellar Lumens. It excludes tickers, symbols, codes, and values containing numerals or special symbols. The pattern expects one to four capitalized word tokens composed only of letters, supporting names like Bitcoin Cash and Basic Attention Token while rejecting BTC, ETH, or entries like Ethereum 2.0.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:26.067258"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.LATITUDE_DMS",
    "description": "This coordinate format expresses angular distance from the equator using whole degrees, minutes (0-59), and seconds (0-59) followed by N for north or S for south. The format uses degree symbols, apostrophes for minutes, quotation marks for seconds, and directional letters.",
    "pluginType": "regex",
    "regexPattern": "\\b(([0-8]?\\d|90)\u00b0\\s?([0-5]?\\d)[\u2032']\\s?([0-5]?\\d)[\u2033\"]\\s?[NS])\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 2420,
    "headerPatterns": [
      {
        "regExp": "(?i).*latitude.*dms.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Latitude DMS"
        ],
        "negativeExamples": [
          "Longitude DMS"
        ]
      },
      {
        "regExp": "(?i).*\\blat\\b.*dms.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lat dms"
        ],
        "negativeExamples": [
          "latest dms"
        ]
      },
      {
        "regExp": "(?i).*latitude.*coord.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Latitude Coords"
        ],
        "negativeExamples": [
          "Longitude Coordinates"
        ]
      },
      {
        "regExp": "(?i).*\\blat\\b.*deg.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Lat Degrees"
        ],
        "negativeExamples": [
          "Lat Direction"
        ]
      },
      {
        "regExp": "(?i).*latitude.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Latitude"
        ],
        "negativeExamples": [
          "Longitude"
        ]
      }
    ],
    "positiveContentExamples": [
      "45\u00b030'15\"N",
      "07\u00b005'09\"S",
      "90\u00b000'00\"N",
      "12\u00b034\u203256\u2033N",
      "08\u00b007'06\" S",
      "3\u00b05'7\"N",
      "85\u00b059\u203259\u2033S",
      "00\u00b000'01\"N"
    ],
    "negativeContentExamples": [
      "45\u00b030'N",
      "45.5042 N",
      "91\u00b000'00\"N",
      "45\u00b060'00\"N",
      "45\u00b030'60\"N",
      "45\u00b030\"15\"N",
      "045\u00b030'15\"N",
      "45\u00b030'15\"E"
    ],
    "positiveHeaderExamples": [
      "Latitude DMS",
      "Lat Degrees",
      "Latitude Coords",
      "lat dms",
      "latitude degrees minutes seconds",
      "gps latitude dms",
      "latitude coordinate",
      "lat deg min sec"
    ],
    "negativeHeaderExamples": [
      "Longitude",
      "Decimal Latitude",
      "Location",
      "lat long",
      "latitude decimal",
      "gps longitude dms",
      "coord",
      "coordinate system"
    ],
    "explanation": "Identifies latitude values expressed in Degrees-Minutes-Seconds with a trailing N or S direction, using the degree (\u00b0), minute (\u2032 or '), and second (\u2033 or \") symbols. Useful for parsing geospatial fields that store human-readable latitude coordinates in DMS notation and distinguishing them from longitude or decimal-degree fields.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:26.947226"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.ISO-3166-3",
    "description": "Three-letter uppercase alphabetic country codes compliant with ISO 3166-1 alpha-3. Values contain exactly three A\u2013Z letters with no digits, spaces, or punctuation.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 2490,
    "headerPatterns": [
      {
        "regExp": "(?i).*(iso[-_ ]?3166[-_ ]?1.*alpha[-_ ]?3).*(country).*(code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISO 3166-1 Alpha-3 Country Code"
        ],
        "negativeExamples": [
          "ISO 3166-1 Alpha-2 Country Code"
        ]
      },
      {
        "regExp": "(?i).*(country).*(iso[-_ ]?3|alpha[-_ ]?3|three[-_ ]?letter).*(code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Country ISO3 Code"
        ],
        "negativeExamples": [
          "Country ISO2 Code"
        ]
      },
      {
        "regExp": "(?i).*(iso[-_ ]?3|alpha[-_ ]?3|3[-_ ]?letter).*(country).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISO3 Country"
        ],
        "negativeExamples": [
          "ISO Country"
        ]
      },
      {
        "regExp": "(?i).*(country).*(code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Country Code"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "USA",
      "FRA",
      "DEU",
      "BRA",
      "IND",
      "ZAF",
      "MEX",
      "JPN"
    ],
    "negativeContentExamples": [
      "US",
      "USA1",
      "Usa",
      "U S A",
      "USA-",
      "USAF",
      "U_A",
      "3SA"
    ],
    "positiveHeaderExamples": [
      "Country Code",
      "ISO3 Country",
      "Three Letter Country",
      "Country ISO3 Code",
      "ISO 3166-1 Alpha-3 Country Code",
      "3 Letter Country Code",
      "Country Alpha-3",
      "ISO3C"
    ],
    "negativeHeaderExamples": [
      "Country Name",
      "Two Letter Code",
      "Continent",
      "ISO Code",
      "Country",
      "Country ISO2 Code",
      "Region Code",
      "Language Code"
    ],
    "explanation": "This semantic type detects ISO 3166-1 alpha-3 country codes, which are exactly three uppercase letters with no digits, spaces, or punctuation. It is suited for columns labeled with ISO3 or alpha-3 terminology such as Country ISO3 Code and for datasets storing standardized three-letter country identifiers.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:27.797023"
  },
  {
    "resultType": "generated",
    "semanticType": "FILENAME",
    "description": "This type captures complete filenames as they appear in file systems and directory listings including the base name and file extension. The values represent file identifiers using alphanumeric characters, dots, spaces, underscores, hyphens, and parentheses, while excluding full path information or directory separators.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z0-9][A-Za-z0-9 _().-]{0,100}\\.[A-Za-z0-9]{1,10}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2650,
    "headerPatterns": [
      {
        "regExp": "(?i).*(file[ _-]*name|filename).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "File Name"
        ],
        "negativeExamples": [
          "File Path"
        ]
      },
      {
        "regExp": "(?i).*(document[ _-]*name|base[ _-]*name|basename).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Base Name"
        ],
        "negativeExamples": [
          "Base Path"
        ]
      },
      {
        "regExp": "(?i).*(file|document).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Filename"
        ],
        "negativeExamples": [
          "Folder"
        ]
      },
      {
        "regExp": "(?i).*(fname|docname).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "fname"
        ],
        "negativeExamples": [
          "fpath"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Title"
        ]
      }
    ],
    "positiveContentExamples": [
      "report_Q3-2024.csv",
      "invoice-000123.pdf",
      "Photo 12 (final).jpg",
      "backup_2025-01-07.tar.gz",
      "data_export_v2.xlsx",
      "presentation.draft.pptx",
      "archive.7z",
      "project-plan v3.TXT"
    ],
    "negativeContentExamples": [
      "C:\\Users\\alex\\report.csv",
      "/var/log/syslog",
      "notes",
      ".env",
      "myfile.",
      "report csv",
      "file/name.txt",
      "name\\file.txt"
    ],
    "positiveHeaderExamples": [
      "Filename",
      "File Name",
      "Document Name",
      "Base Name",
      "Original File Name",
      "Attachment Filename",
      "Upload File Name"
    ],
    "negativeHeaderExamples": [
      "File Path",
      "Folder",
      "Extension",
      "Directory",
      "Document Type",
      "File Size",
      "URL"
    ],
    "explanation": "Use this semantic type to detect standalone filenames that include a base name and an extension, without any directory or path components. It is suitable for identifying file identifiers in exports, logs, and metadata columns where only the filename (not full path) is stored.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:28.055502"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.ISIN",
    "description": "This identifier begins with a two-letter country code followed by a nine-character national security identifier and concludes with a single check digit. The code uses uppercase letters and numbers without spaces, hyphens, or other punctuation marks.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2}[A-Z0-9]{9}[0-9]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2280,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bsecurity\\b.*\\bisin\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Security ISIN"
        ],
        "negativeExamples": [
          "Security CUSIP"
        ]
      },
      {
        "regExp": "(?i).*\\binternational\\b.*\\bsecurit.*\\bidentif.*\\bnumber\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "International Securities Identification Number"
        ],
        "negativeExamples": [
          "International Security ID"
        ]
      },
      {
        "regExp": "(?i).*\\binstrument\\b.*\\bisin\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Instrument ISIN"
        ],
        "negativeExamples": [
          "Instrument ID"
        ]
      },
      {
        "regExp": "(?i).*\\bisin\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISIN"
        ],
        "negativeExamples": [
          "SEDOL"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISIN Code"
        ],
        "negativeExamples": [
          "Ticker Symbol"
        ]
      }
    ],
    "positiveContentExamples": [
      "USABC1234567",
      "GB00A1B2C3D4",
      "DE123456ABC8",
      "FR9Z8Y7X6W55",
      "JP1ABC2DEF39",
      "CAA1B2C3D4E6",
      "AUZZZ111AAA2",
      "NL3Q2W1E4R56"
    ],
    "negativeContentExamples": [
      "UsABC1234567",
      "USABC123456",
      "USABC12345678",
      "US-ABC1234567",
      "USABC123456X",
      "U3ABC1234567",
      "USABC1234!67",
      "DE123456ABCD"
    ],
    "positiveHeaderExamples": [
      "ISIN",
      "Security ISIN",
      "International Security ID",
      "Instrument ISIN",
      "ISIN Code",
      "International Securities Identification Number",
      "ISIN Number"
    ],
    "negativeHeaderExamples": [
      "Company Name",
      "Ticker Symbol",
      "Stock Price",
      "Security CUSIP",
      "SEDOL",
      "Order ID",
      "Account Number",
      "Country Code"
    ],
    "explanation": "Identifies International Securities Identification Numbers (ISIN) in datasets using a strict structural regex: two uppercase letters (country code), nine uppercase alphanumeric characters, and a final numeric check digit with no separators. Useful for validating and classifying security identifiers in financial data columns where values are stored without spaces or punctuation.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:30.152304"
  },
  {
    "resultType": "generated",
    "semanticType": "CONTINENT.CODE_EN",
    "description": "Two-letter uppercase alphabetic codes representing continental regions using common English initials (no digits, spaces, or punctuation). Examples include AF, AS, EU, NA, SA, OC, and AN.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AF",
      "AN",
      "AS",
      "EU",
      "NA",
      "OC",
      "SA"
    ],
    "backout": "^[A-Z]{2}$",
    "confidenceThreshold": 98,
    "priority": 2380,
    "headerPatterns": [
      {
        "regExp": "(?i).*continent.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Continent Code"
        ],
        "negativeExamples": [
          "Continent Name"
        ]
      },
      {
        "regExp": "(?i).*continent.*(abbr|abbrev|abbreviation).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Continent Abbr"
        ],
        "negativeExamples": [
          "Continent"
        ]
      },
      {
        "regExp": "(?i).*region.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Region Code"
        ],
        "negativeExamples": [
          "Region Name"
        ]
      },
      {
        "regExp": "(?i).*cont.*(code|abbr).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Cont Code"
        ],
        "negativeExamples": [
          "Geo Code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "AF",
      "AN",
      "AS",
      "EU",
      "NA",
      "OC",
      "SA"
    ],
    "negativeContentExamples": [
      "Eu",
      "EU ",
      "E U",
      "E-U",
      "E.U",
      "E1",
      "EUA",
      "OC1"
    ],
    "positiveHeaderExamples": [
      "Continent Code",
      "Continent Abbr",
      "Region Code",
      "Continent Abbreviation",
      "Continent 2 Letter Code",
      "Cont Code",
      "Region Abbr"
    ],
    "negativeHeaderExamples": [
      "Continent Name",
      "Country",
      "Location",
      "Continent",
      "Region Name",
      "Country Code",
      "Geo Code"
    ],
    "explanation": "A compact, finite set of two-letter uppercase codes that denote continents based on English names, suitable for validating and classifying fields that store continent abbreviations. Use when columns are expected to contain only sanctioned continent initials (e.g., AF, EU, NA) without digits, punctuation, or whitespace.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:30.564132"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.ABA",
    "description": "This identifier consists of exactly nine numeric digits that uniquely identify a US bank or credit union for automated clearing house transactions. The number includes a mathematical checksum for validation and contains no letters, spaces, or special characters.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{9}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 2230,
    "headerPatterns": [
      {
        "regExp": "(?i).*routing.*transit.*number.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Routing Transit Number"
        ],
        "negativeExamples": [
          "Transit Number"
        ]
      },
      {
        "regExp": "(?i).*routing.*number.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Routing Number"
        ],
        "negativeExamples": [
          "Account Number"
        ]
      },
      {
        "regExp": "(?i).*aba.*number.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "ABA Number"
        ],
        "negativeExamples": [
          "Bank Number"
        ]
      },
      {
        "regExp": "(?i).*rtn.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "RTN"
        ],
        "negativeExamples": [
          "TIN"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Number"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "021000021",
      "111000025",
      "026009593",
      "071000013",
      "121000358",
      "322271724",
      "031101279",
      "084309310"
    ],
    "negativeContentExamples": [
      "0210000210",
      "02100002",
      "0210-00021",
      "0210 00021",
      "021_000_021",
      "021.000.021",
      "02100002A",
      "A21000021"
    ],
    "positiveHeaderExamples": [
      "ABA Number",
      "Routing Number",
      "RTN",
      "Routing Transit Number",
      "ABA Routing Number",
      "ACH Routing Number",
      "Bank RTN",
      "US Routing Number"
    ],
    "negativeHeaderExamples": [
      "Account Number",
      "Bank Name",
      "SWIFT Code",
      "IBAN",
      "Customer Number",
      "Branch Code",
      "Transit Number",
      "Sort Code"
    ],
    "explanation": "ABA routing numbers are 9-digit identifiers used to route ACH and other bank transactions in the United States. This semantic type detects tokens that are exactly nine digits with no separators or letters. It is useful for validating and classifying columns storing US bank routing numbers labeled as routing number, ABA number, or RTN. While the pattern enforces strict numeric length, systems may perform additional checksum validation outside the regex to ensure authenticity.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:33.490486"
  },
  {
    "resultType": "generated",
    "semanticType": "DIRECTION",
    "description": "This type identifies cardinal and intercardinal directions used in navigation, mapping, and geographic reference systems. The values represent standard compass directions using conventional English terminology without abbreviations, coordinates, or relative directional references.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "NORTH",
      "SOUTH",
      "EAST",
      "WEST",
      "NORTHEAST",
      "NORTHWEST",
      "SOUTHEAST",
      "SOUTHWEST"
    ],
    "backout": "^(NORTH|SOUTH|EAST|WEST|NORTHEAST|NORTHWEST|SOUTHEAST|SOUTHWEST)$",
    "confidenceThreshold": 98,
    "priority": 2610,
    "headerPatterns": [
      {
        "regExp": "(?i).*compass.*direction.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Compass Direction"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*cardinal.*direction.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Cardinal Direction"
        ],
        "negativeExamples": [
          "Location"
        ]
      },
      {
        "regExp": "(?i).*intercardinal.*direction.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Intercardinal Direction"
        ],
        "negativeExamples": [
          "Distance"
        ]
      },
      {
        "regExp": "(?i).*(compass|cardinal).*dir.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Cardinal Dir"
        ],
        "negativeExamples": [
          "Directory"
        ]
      },
      {
        "regExp": "(?i).*direction.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Direction"
        ],
        "negativeExamples": [
          "Orientation"
        ]
      }
    ],
    "positiveContentExamples": [
      "North",
      "South",
      "East",
      "West",
      "Northeast",
      "Northwest",
      "Southeast",
      "Southwest"
    ],
    "negativeContentExamples": [
      "NE",
      "N",
      "North East",
      "North-East",
      "East-Southeast",
      "North by northwest",
      "Eastward",
      "Northerly"
    ],
    "positiveHeaderExamples": [
      "Direction",
      "Cardinal Direction",
      "Compass Direction",
      "Intercardinal Direction",
      "Wind Direction",
      "Cardinal Dir"
    ],
    "negativeHeaderExamples": [
      "Address",
      "Location",
      "Distance",
      "Orientation",
      "Heading",
      "Geo Bearing",
      "Compass",
      "Coordinates"
    ],
    "explanation": "This semantic type detects spelled-out cardinal and intercardinal compass directions, excluding abbreviations and relative phrases. It is useful for datasets where the direction value is expressed as a full English term (e.g., North, Southwest) rather than codes or numeric bearings.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:35.360022"
  },
  {
    "resultType": "generated",
    "semanticType": "FULL_ADDRESS_EN",
    "description": "This type captures complete mailing addresses as they appear in English-language contexts for postal delivery and location identification. The values represent full address strings combining street address, city, state abbreviation, and postal code with comma separators following standard US addressing conventions.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{1,6}\\s+[A-Za-z0-9.\\- ]{1,40}\\s+(Ave|Avenue|St|Street|Rd|Road|Blvd|Boulevard|Ln|Lane|Dr|Drive|Ct|Court|Way|Ter|Terrace|Pl|Place)\\b,\\s+[A-Za-z.\\- ]{2,40}\\b,\\s+[A-Z]{2}\\s+\\d{5}(-\\d{4})?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 2680,
    "headerPatterns": [
      {
        "regExp": "(?i).*(full|complete)\\s+address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Full Address"
        ],
        "negativeExamples": [
          "Street Address"
        ]
      },
      {
        "regExp": "(?i).*(mailing|shipping)\\s+address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Mailing Address"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*(full|complete)\\s*addr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Full Addr"
        ],
        "negativeExamples": [
          "Address Line 1"
        ]
      },
      {
        "regExp": "(?i).*(mail|ship).*(addr|address).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Full Mailing Address"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Complete Address"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "123 Main St, Springfield, IL 62704",
      "4567 Elm Road, Dayton, OH 45402",
      "89 Broadway Blvd, Denver, CO 80203",
      "742 Evergreen Terrace, Springfield, OR 97403",
      "500 Fifth Ave, New York, NY 10110",
      "2600 Hall Ln, Austin, TX 78701",
      "12 Oak Court, Tampa, FL 33602",
      "9800 Sunset Drive, Miami, FL 33173"
    ],
    "negativeContentExamples": [
      "123 Main St, Springfield 62704",
      "123 Main, Springfield, IL 62704",
      "Main St, Springfield, IL 62704",
      "123 Main St Springfield, IL 62704",
      "123 Main St, Springfield, Illinois 62704",
      "123 Main St, Springfield, IL 6270",
      "123 Main St, Springfield, IL 62704-123",
      "123 Main St, Springfield, IL"
    ],
    "positiveHeaderExamples": [
      "Full Address",
      "Mailing Address",
      "Complete Address",
      "Customer Full Address",
      "Full Mailing Address",
      "Shipping Address",
      "Complete Mailing Address",
      "Full Addr"
    ],
    "negativeHeaderExamples": [
      "Street Address",
      "City",
      "ZIP Code",
      "State",
      "Address Line 1",
      "Address Line 2",
      "Postal Code",
      "Billing City"
    ],
    "explanation": "This semantic type identifies single-line US-style full addresses containing a street number and street name with a recognized suffix, followed by city, state (2-letter abbreviation), and ZIP or ZIP+4, separated by commas. It is intended to distinguish complete mailing address fields from partial address components such as street-only, city, or postal code columns.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:37.111763"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.TEXT_NL",
    "description": "Captures full country names written in Dutch for identification and documentation purposes. Values are complete Dutch country names using standard Dutch spelling and conventions, without abbreviations, codes, or non-Dutch language forms.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z\u00c0-\u00d6\u00d8-\u00de][a-z\u00e0-\u00f6\u00f8-\u00ff]{2,}([-' ][A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]{2,}){0,5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 2530,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\blandnaam\\b.*\\b(nl|nederlands|nederlandse)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "landnaam_nl"
        ],
        "negativeExamples": [
          "landnaam_en"
        ]
      },
      {
        "regExp": "(?i).*\\bland\\b.*\\b(naam|benaming|tekst)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "land_naam"
        ],
        "negativeExamples": [
          "landcode"
        ]
      },
      {
        "regExp": "(?i).*\\bnatie\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Natie"
        ],
        "negativeExamples": [
          "Nationaliteit"
        ]
      },
      {
        "regExp": "(?i).*\\bcountry\\b.*\\b(nl|dutch)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "country_nl"
        ],
        "negativeExamples": [
          "country_code"
        ]
      },
      {
        "regExp": "(?i).*\\bland\\b(?!\\s*code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Land"
        ],
        "negativeExamples": [
          "Landcode"
        ]
      }
    ],
    "positiveContentExamples": [
      "Nederland",
      "Belgi\u00eb",
      "Duitsland",
      "Verenigd Koninkrijk",
      "Verenigde Staten",
      "Bosni\u00eb en Herzegovina",
      "Ivoorkust",
      "Nieuw-Zeeland"
    ],
    "negativeContentExamples": [
      "NL",
      "BE",
      "Landcode NL",
      "Nederland 2023",
      "Stad: Amsterdam",
      "Europa",
      "Zuid-Holland",
      "Nederland - NL"
    ],
    "positiveHeaderExamples": [
      "Land",
      "Landnaam",
      "Natie",
      "country_nl",
      "land_naam",
      "land_nederlandse_naam",
      "land_tekst",
      "nederlandse_landnaam"
    ],
    "negativeHeaderExamples": [
      "Landcode",
      "Provincie",
      "Stad",
      "CountryCode",
      "Nationaliteit",
      "Land_id",
      "Continent",
      "Plaats"
    ],
    "explanation": "This semantic type identifies full country names expressed in Dutch (e.g., Nederland, Verenigd Koninkrijk, Bosni\u00eb en Herzegovina). It excludes abbreviations, ISO codes, mixed-language labels, and values that include extra qualifiers like years or codes. Use when a column stores the human-readable Dutch country name rather than codes or other geography types.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:40.250642"
  },
  {
    "resultType": "generated",
    "semanticType": "COMPANY_NAME",
    "description": "This represents the complete corporate name including any legal suffixes such as Corporation, Inc., LLC, or Ltd. The name typically includes proper capitalization and may contain multiple words, punctuation, and legal designations but excludes stock symbols or abbreviations.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b[A-Z0-9][A-Za-z0-9&'\u2019.,-]*(\\s+[A-Z0-9][A-Za-z0-9&'\u2019.,-]*){0,6}\\s+(Inc\\.?|Incorporated|Corporation|Corp\\.?|LLC|L\\.L\\.C\\.|Ltd\\.?|Limited|Company|Co\\.)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2370,
    "headerPatterns": [
      {
        "regExp": "(?i).*legal.*company.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Legal Company Name"
        ],
        "negativeExamples": [
          "Company Name"
        ]
      },
      {
        "regExp": "(?i).*(company|corporate|corporation|organization).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Registered Company Name"
        ],
        "negativeExamples": [
          "Industry"
        ]
      },
      {
        "regExp": "(?i).*(co|corp|org).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Org Name"
        ],
        "negativeExamples": [
          "Stock Symbol"
        ]
      },
      {
        "regExp": "(?i).*(company|corporation|organization).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Organization"
        ],
        "negativeExamples": [
          "Employee Count"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Corporate Name"
        ],
        "negativeExamples": [
          "Company Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Acme, Inc.",
      "Global Holdings LLC",
      "Sunrise Technologies Ltd.",
      "Apex Innovations Corporation",
      "North River Foods, Inc.",
      "Summit Ventures L.L.C.",
      "Orion Systems Limited",
      "The Widget Company"
    ],
    "negativeContentExamples": [
      "Acme",
      "Acme Widgets",
      "AAPL",
      "John Doe",
      "Global Holdings L.L.C",
      "The Widget Co",
      "North River Foods, Incorporateded",
      "Beta Holdings LLP"
    ],
    "positiveHeaderExamples": [
      "Company Name",
      "Organization",
      "Corporation",
      "Legal Company Name",
      "Registered Company Name",
      "Corporate Name",
      "Org Name",
      "Co Name"
    ],
    "negativeHeaderExamples": [
      "Stock Symbol",
      "Industry",
      "Employee Count",
      "Contact Name",
      "Company Code",
      "Invoice Number"
    ],
    "explanation": "This semantic type identifies complete corporate or organizational names that include a recognized legal designator (e.g., Inc., LLC, Ltd., Corporation). It is useful for distinguishing true company names from generic labels, stock tickers, or person names in datasets, and for normalizing or validating fields expected to contain registered business names.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:40.968055"
  },
  {
    "resultType": "generated",
    "semanticType": "HONORIFIC_EN",
    "description": "This type captures formal titles and prefixes used before personal names in English language correspondence and formal documentation. The values represent established honorific terms including punctuation when applicable, following standard English linguistic and social conventions for respectful address.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "MR.",
      "MR",
      "MRS.",
      "MRS",
      "MS.",
      "MS",
      "MISS",
      "MX.",
      "MX",
      "DR.",
      "DR",
      "PROF.",
      "PROF",
      "REV.",
      "REV",
      "SIR",
      "DAME",
      "LADY",
      "LORD",
      "FR.",
      "HON.",
      "CAPT.",
      "COL.",
      "GEN.",
      "LT."
    ],
    "backout": "^[A-Z]{2,5}[.]?$",
    "confidenceThreshold": 96,
    "priority": 2750,
    "headerPatterns": [
      {
        "regExp": "(?i).*person.*honorific.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "person_honorific"
        ],
        "negativeExamples": [
          "job_title"
        ]
      },
      {
        "regExp": "(?i).*name.*prefix.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name_prefix"
        ],
        "negativeExamples": [
          "name_suffix"
        ]
      },
      {
        "regExp": "(?i).*courtesy.*title.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "courtesy_title"
        ],
        "negativeExamples": [
          "job_title"
        ]
      },
      {
        "regExp": "(?i).*salutation.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "salutation"
        ],
        "negativeExamples": [
          "greeting_text"
        ]
      },
      {
        "regExp": "(?i).*title.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Title"
        ],
        "negativeExamples": [
          "First Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "Mr.",
      "MR",
      "Mrs",
      "Ms.",
      "Dr",
      "Prof.",
      "Sir",
      "Rev."
    ],
    "negativeContentExamples": [
      "Mister",
      "Ms-",
      "Dr. John",
      "Sr.",
      "MR..",
      "Hon Judge",
      "Prof,",
      "Mx/"
    ],
    "positiveHeaderExamples": [
      "Title",
      "Honorific",
      "Prefix",
      "Name Prefix",
      "Person Title",
      "Salutation",
      "Courtesy Title"
    ],
    "negativeHeaderExamples": [
      "First Name",
      "Last Name",
      "Full Name",
      "Suffix",
      "Job Title",
      "Middle Name",
      "Display Name",
      "Greeting"
    ],
    "explanation": "English honorifics are short, conventional tokens that precede a personal name and convey courtesy, status, profession, or rank (e.g., Mr., Ms, Dr., Prof., Sir). This semantic type helps standardize respectful forms of address and is useful for parsing or formatting names, normalizing salutations, and enforcing etiquette in correspondence. It intentionally excludes job titles, name suffixes (e.g., Jr., III), and multi-word phrases that go beyond the core honorific token.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:44.424850"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.LONGITUDE_DECIMAL",
    "description": "This coordinate represents angular distance east or west of the Greenwich meridian using decimal notation ranging from -180 to +180 degrees. Positive values indicate eastern hemisphere locations while negative values represent western hemisphere positions.",
    "pluginType": "regex",
    "regexPattern": "\\b[+-]?((180(\\.0+)?)|(1[0-7]\\d(\\.\\d+)?)|([1-9]?\\d(\\.\\d+)?))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 2430,
    "headerPatterns": [
      {
        "regExp": "(?i).*longitude.*decimal.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Decimal Longitude"
        ],
        "negativeExamples": [
          "Longitude Value"
        ]
      },
      {
        "regExp": "(?i).*\\blongitude\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Longitude"
        ],
        "negativeExamples": [
          "Latitude"
        ]
      },
      {
        "regExp": "(?i).*\\blon(gitude)?\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Long"
        ],
        "negativeExamples": [
          "long_text"
        ]
      },
      {
        "regExp": "(?i).*\\bx coordinate\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "X Coordinate"
        ],
        "negativeExamples": [
          "Y Coordinate"
        ]
      },
      {
        "regExp": "(?i).*coordinate.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Coordinate"
        ],
        "negativeExamples": [
          "Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "-73.9857",
      "0",
      "+45.0",
      "179.9999",
      "-0.123",
      "180",
      "-180",
      "12.345678"
    ],
    "negativeContentExamples": [
      "180.0001",
      "-180.0001",
      "200",
      "-200.5",
      "181",
      "+181.0",
      "12.34.56",
      "45\u00b012'"
    ],
    "positiveHeaderExamples": [
      "Longitude",
      "Long",
      "X Coordinate",
      "Lon",
      "Decimal Longitude",
      "Geo X",
      "Long (deg)",
      "Longitude Value"
    ],
    "negativeHeaderExamples": [
      "Latitude",
      "Address",
      "City",
      "Y Coordinate",
      "Lat",
      "Location",
      "Geo Y",
      "State"
    ],
    "explanation": "Identifies decimal degree longitudes, including optional sign and optional fractional component, within the inclusive range -180 to 180. Useful for geospatial datasets where the X axis or longitudinal position is stored as a numeric token in decimal degrees. The regex uses word boundaries to avoid matching within larger strings and enforces valid numeric ranges to reduce false positives with generic numbers.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:46.479920"
  },
  {
    "resultType": "generated",
    "semanticType": "CREDIT_CARD_TYPE",
    "description": "Identifies the commercial brand or network of a payment card used in financial transactions, expressed as the standard marketed name (e.g., Visa, Mastercard, American Express). Values represent card networks/brands only, without abbreviations (except where the brand itself is an initialism) and without account-specific details.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "VISA",
      "MASTERCARD",
      "AMERICAN EXPRESS",
      "DISCOVER",
      "JCB",
      "UNIONPAY",
      "DINERS CLUB",
      "MAESTRO",
      "RUPAY",
      "MIR",
      "ELO",
      "HIPERCARD",
      "BANCONTACT",
      "CARTE BANCAIRE",
      "GIROCARD",
      "DANKORT",
      "INTERAC",
      "VERVE",
      "TROY",
      "BC CARD"
    ],
    "backout": "^[A-Z][A-Z ]{1,24}$",
    "confidenceThreshold": 93,
    "priority": 2540,
    "headerPatterns": [
      {
        "regExp": "(?i).*credit.*card.*type.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Credit Card Type"
        ],
        "negativeExamples": [
          "Card Number"
        ]
      },
      {
        "regExp": "(?i).*card.*type.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Card Type"
        ],
        "negativeExamples": [
          "Cardholder Name"
        ]
      },
      {
        "regExp": "(?i).*card.*brand.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Card Brand"
        ],
        "negativeExamples": [
          "Brand Name"
        ]
      },
      {
        "regExp": "(?i).*card.*network.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Card Network"
        ],
        "negativeExamples": [
          "Network Card"
        ]
      },
      {
        "regExp": "(?i).*payment.*network.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Payment Network"
        ],
        "negativeExamples": [
          "Payment Method"
        ]
      },
      {
        "regExp": "(?i).*brand.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Brand"
        ],
        "negativeExamples": [
          "Type"
        ]
      }
    ],
    "positiveContentExamples": [
      "Visa",
      "Mastercard",
      "American Express",
      "Discover",
      "JCB",
      "UnionPay",
      "Diners Club",
      "Maestro"
    ],
    "negativeContentExamples": [
      "AMEX",
      "Master Card",
      "AmericanExpress",
      "Discover Card",
      "Visa Debit",
      "Union Pay",
      "DinersClub",
      "J C B"
    ],
    "positiveHeaderExamples": [
      "Card Type",
      "Credit Card Type",
      "Card Brand",
      "Card Network",
      "Payment Network",
      "Payment Card Type"
    ],
    "negativeHeaderExamples": [
      "Card Number",
      "Cardholder Name",
      "Expiration Date",
      "Cardholder Number",
      "Payment Method",
      "Network ID"
    ],
    "explanation": "This semantic type is used to detect columns containing card brand/network names for payment processing, analytics, or data normalization. It helps standardize and validate values for the card network field without including account details or numbers.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:46.881943"
  },
  {
    "resultType": "generated",
    "semanticType": "GENDER.TEXT_JA",
    "description": "This type captures gender designations as they are expressed in Japanese language for demographic data collection and personal identification purposes. The values represent standard gender terminology using Japanese characters and linguistic conventions without abbreviations or English translations.",
    "pluginType": "regex",
    "regexPattern": "(\u7537\u6027|\u5973\u6027|\u305d\u306e\u4ed6|\u4e0d\u660e|\u7121\u56de\u7b54|\u672a\u56de\u7b54|\u672a\u8a2d\u5b9a|\u672a\u6307\u5b9a|\u975e\u516c\u958b|\u56de\u7b54\u3057\u306a\u3044|\u3069\u3061\u3089\u3067\u3082\u306a\u3044|\u7121\u6027\u5225|\u30c8\u30e9\u30f3\u30b9\u30b8\u30a7\u30f3\u30c0\u30fc|\u30ce\u30f3\u30d0\u30a4\u30ca\u30ea\u30fc|X\u30b8\u30a7\u30f3\u30c0\u30fc)",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2700,
    "headerPatterns": [
      {
        "regExp": "(?i).*(\u9867\u5ba2|\u4f1a\u54e1|\u60a3\u8005|\u5f93\u696d\u54e1|\u30e6\u30fc\u30b6\u30fc).*(\u6027\u5225|\u30b8\u30a7\u30f3\u30c0\u30fc).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u60a3\u8005\u6027\u5225"
        ],
        "negativeExamples": [
          "\u60a3\u8005\u5e74\u9f62"
        ]
      },
      {
        "regExp": "(?i).*(\u6027\u5225|\u30b8\u30a7\u30f3\u30c0\u30fc).*(\u533a\u5206|\u5206\u985e|\u7a2e\u5225|\u30b3\u30fc\u30c9).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u6027\u5225\u533a\u5206"
        ],
        "negativeExamples": [
          "\u6027\u5225\u6bd4"
        ]
      },
      {
        "regExp": "(?i).*(\u6027|\u30bb\u30c3\u30af\u30b9).*(\u533a\u5206|\u5206\u985e|\u7a2e\u5225|\u60c5\u5831).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u6027\u533a\u5206"
        ],
        "negativeExamples": [
          "\u59d3\u533a\u5206"
        ]
      },
      {
        "regExp": "(?i).*gender.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "user_gender"
        ],
        "negativeExamples": [
          "user_id"
        ]
      },
      {
        "regExp": "(?i).*(\u6027\u5225|\u30b8\u30a7\u30f3\u30c0\u30fc).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u6027\u5225"
        ],
        "negativeExamples": [
          "\u540d\u524d"
        ]
      }
    ],
    "positiveContentExamples": [
      "\u7537\u6027",
      "\u5973\u6027",
      "\u305d\u306e\u4ed6",
      "\u4e0d\u660e",
      "\u7121\u56de\u7b54",
      "\u672a\u8a2d\u5b9a",
      "\u3069\u3061\u3089\u3067\u3082\u306a\u3044",
      "\u30c8\u30e9\u30f3\u30b9\u30b8\u30a7\u30f3\u30c0\u30fc"
    ],
    "negativeContentExamples": [
      "\u7537 \u6027",
      "\u7537-\u6027",
      "\u5973\u6027\u8005",
      "\u975e\u516c\u8868",
      "\u672a\u8a2d",
      "\u56de\u7b54\u306a\u3057",
      "\u30ce\u30f3\u30d0\u30a4\u30ca\u30ea",
      "X \u30b8\u30a7\u30f3\u30c0\u30fc"
    ],
    "positiveHeaderExamples": [
      "\u6027\u5225",
      "\u30b8\u30a7\u30f3\u30c0\u30fc",
      "\u6027",
      "\u6027\u5225\u533a\u5206",
      "\u9867\u5ba2\u6027\u5225",
      "\u30e6\u30fc\u30b6\u30fc_\u30b8\u30a7\u30f3\u30c0\u30fc",
      "\u6027\u533a\u5206",
      "gender"
    ],
    "negativeHeaderExamples": [
      "\u540d\u524d",
      "\u5e74\u9f62",
      "\u56fd\u7c4d",
      "\u59d3",
      "\u6027\u6bd4",
      "\u6027\u5225\u6bd4",
      "\u5e02\u533a\u753a\u6751",
      "\u96fb\u8a71\u756a\u53f7"
    ],
    "explanation": "GENDER.TEXT_JA identifies Japanese-language gender labels typically found in demographic fields, including common options for unknown, undisclosed, or non-binary entries. It is intended to classify column values that explicitly state a person's gender in Japanese text rather than codes or numeric encodings.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:47.418007"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.TEXT_ES",
    "description": "Captura nombres completos de pa\u00edses escritos en espa\u00f1ol para fines de identificaci\u00f3n y documentaci\u00f3n. Los valores representan denominaciones est\u00e1ndar en espa\u00f1ol, respetando la ortograf\u00eda y acentuaci\u00f3n del idioma, sin abreviaturas ni formas en otros idiomas.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc]+([ -]((de|del|la|las|los|y|san|santa)|[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00dc][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1\u00fc]+)){0,6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 2520,
    "headerPatterns": [
      {
        "regExp": "(?i).*(nombre).*(del|de).*(pa[i\u00ed]s).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Nombre del Pa\u00eds"
        ],
        "negativeExamples": [
          "C\u00f3digo del Pa\u00eds"
        ]
      },
      {
        "regExp": "(?i).*(pa[i\u00ed]s).*(nombre|texto).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Nombre Pa\u00eds"
        ],
        "negativeExamples": [
          "Ciudad"
        ]
      },
      {
        "regExp": "(?i).*(naci[o\u00f3]n).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Naci\u00f3n"
        ],
        "negativeExamples": [
          "Estado"
        ]
      },
      {
        "regExp": "(?i).*(nac).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "NAC"
        ],
        "negativeExamples": [
          "Pa\u00eds"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Espa\u00f1a",
      "M\u00e9xico",
      "Brasil",
      "Argentina",
      "Estados Unidos",
      "Reino Unido",
      "Rep\u00fablica Dominicana",
      "Costa de Marfil"
    ],
    "negativeContentExamples": [
      "EE.UU.",
      "U.S.A.",
      "UK",
      "Estados unidos",
      "republica dominicana",
      "Espa\u00f1a1",
      "Pa\u00eds: Espa\u00f1a",
      "M\u00e9xico D.F."
    ],
    "positiveHeaderExamples": [
      "Pa\u00eds",
      "Nombre del Pa\u00eds",
      "Naci\u00f3n",
      "Lista de Pa\u00edses",
      "Pa\u00eds de Residencia",
      "Pa\u00eds de Origen",
      "Nombre Pa\u00eds",
      "Pa\u00eds (ES)"
    ],
    "negativeHeaderExamples": [
      "C\u00f3digo del Pa\u00eds",
      "Estado",
      "Ciudad",
      "C\u00f3digo ISO",
      "Provincia",
      "Departamento",
      "Municipio",
      "Pa\u00eds ISO"
    ],
    "explanation": "Este tipo sem\u00e1ntico identifica valores que son nombres de pa\u00edses escritos en espa\u00f1ol con ortograf\u00eda y acentuaci\u00f3n correctas, incluyendo nombres compuestos con conectores como \"de\", \"del\", \"la\", \"las\", \"los\" o \"y\". Es \u00fatil para normalizar, validar y clasificar columnas que contienen el nombre del pa\u00eds en espa\u00f1ol, diferenci\u00e1ndolas de c\u00f3digos o abreviaturas.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:50.085504"
  },
  {
    "resultType": "generated",
    "semanticType": "DAY.DIGITS",
    "description": "Captures the numeric calendar day component as standalone integers from 1 to 31, without leading zeros or additional formatting. Typical values are simple day numbers used within date fields or temporal data.",
    "pluginType": "regex",
    "regexPattern": "\\b([1-9]|[12][0-9]|3[01])\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 2590,
    "headerPatterns": [
      {
        "regExp": "(?i).*(day).*(of).*(month).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Day of Month"
        ],
        "negativeExamples": [
          "Day Name"
        ]
      },
      {
        "regExp": "(?i).*(date).*(number).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Date Number"
        ],
        "negativeExamples": [
          "Year"
        ]
      },
      {
        "regExp": "(?i).*(month).*(day).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Month Day"
        ],
        "negativeExamples": [
          "Month"
        ]
      },
      {
        "regExp": "(?i).*(day).*(num|no).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Day Num"
        ],
        "negativeExamples": [
          "Year Num"
        ]
      },
      {
        "regExp": "(?i).*day.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Day"
        ],
        "negativeExamples": [
          "Month"
        ]
      }
    ],
    "positiveContentExamples": [
      "1",
      "2",
      "9",
      "10",
      "15",
      "28",
      "30",
      "31"
    ],
    "negativeContentExamples": [
      "00",
      "01",
      "32",
      "7th",
      "31st",
      "4e",
      "99",
      "12th"
    ],
    "positiveHeaderExamples": [
      "Day",
      "Day of Month",
      "Date Number",
      "Day No",
      "DOM",
      "Month Day",
      "Calendar Day",
      "Day Num"
    ],
    "negativeHeaderExamples": [
      "Month",
      "Year",
      "Day Name",
      "Weekday",
      "Day of Week",
      "Payment Date",
      "Month Number",
      "Year Num"
    ],
    "explanation": "This semantic type identifies integer day-of-month values from 1 to 31 with no leading zeros and no additional formatting, suitable for columns that store just the day component of a date. It avoids matching formatted or suffixed variants (e.g., 01, 3rd, 12th) and values outside the calendar day range.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:50.233313"
  },
  {
    "resultType": "generated",
    "semanticType": "FILENAME_EXT",
    "description": "This type captures file extensions as they appear at the end of filenames to identify file formats and types. The values represent standardized extension indicators starting with a period followed by alphabetic or alphanumeric characters without spaces or additional punctuation.",
    "pluginType": "regex",
    "regexPattern": "\\.[A-Za-z0-9]{1,8}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 2660,
    "headerPatterns": [
      {
        "regExp": "(?i).*file.*extension.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "File Extension"
        ],
        "negativeExamples": [
          "File Size"
        ]
      },
      {
        "regExp": "(?i).*filename.*extension.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Filename Extension"
        ],
        "negativeExamples": [
          "Filename"
        ]
      },
      {
        "regExp": "(?i).*file.*type.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "File Type"
        ],
        "negativeExamples": [
          "Content Type"
        ]
      },
      {
        "regExp": "(?i).*file[_ ]?ext.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "File_Extension"
        ],
        "negativeExamples": [
          "File Path"
        ]
      },
      {
        "regExp": "(?i).*extension.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Extension"
        ],
        "negativeExamples": [
          "Type"
        ]
      }
    ],
    "positiveContentExamples": [
      ".pdf",
      ".DOCX",
      ".7z",
      ".jpeg",
      ".csv",
      ".mp4",
      ".xlsx",
      ".html"
    ],
    "negativeContentExamples": [
      "pdf",
      ".123456789",
      ".abcdefghij",
      ".a1b2c3d4e",
      ".",
      "._doc",
      "./tmp",
      "txt"
    ],
    "positiveHeaderExamples": [
      "File Extension",
      "Extension",
      "File Type",
      "Filename Extension",
      "File_Extension",
      "Document Extension",
      "File Ext",
      "Attachment Extension"
    ],
    "negativeHeaderExamples": [
      "Filename",
      "File Size",
      "File Path",
      "Content Type",
      "MIME Type",
      "File Name",
      "Path",
      "Created Date"
    ],
    "explanation": "Identifies standalone file extension tokens (e.g., .pdf, .docx) that denote the format of a file. Use this type when a column contains only the extension string rather than a full filename or path. Header patterns prioritize explicit mentions of file extension and common abbreviations to reduce ambiguity with filename or path fields.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:51.165907"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.BSN_NL",
    "description": "This type identifies the BSN, a 9-digit citizen service number used in the Netherlands for government and administrative purposes. The number consists of exactly nine numerical digits without any letters, spaces, or special characters.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{9}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 2780,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bburgerservicenummer\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Burgerservicenummer"
        ],
        "negativeExamples": [
          "Adres"
        ]
      },
      {
        "regExp": "(?i).*\\bbsn\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "BSN"
        ],
        "negativeExamples": [
          "Naam"
        ]
      },
      {
        "regExp": "(?i).*\\bcitizen\\b.*\\bnumber\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Citizen Number"
        ],
        "negativeExamples": [
          "Telefoon"
        ]
      },
      {
        "regExp": "(?i).*\\bid\\b.*\\bnumber\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Gov ID Number"
        ],
        "negativeExamples": [
          "Email"
        ]
      },
      {
        "regExp": "(?i).*\\bnumber\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "National Number"
        ],
        "negativeExamples": [
          "Naam"
        ]
      }
    ],
    "positiveContentExamples": [
      "123456789",
      "001234567",
      "730194652",
      "420681357",
      "056789123",
      "214365870",
      "908172635",
      "150739284"
    ],
    "negativeContentExamples": [
      "12345678",
      "1234567890",
      "123 456 789",
      "123-456-789",
      "A23456789",
      "12345678B",
      "123.456.789",
      "00000000"
    ],
    "positiveHeaderExamples": [
      "BSN",
      "Burgerservicenummer",
      "Citizen Number",
      "National ID Number",
      "Gov ID Number",
      "NL BSN",
      "Burger Service Number",
      "National Number"
    ],
    "negativeHeaderExamples": [
      "Naam",
      "Adres",
      "Telefoon",
      "Email",
      "Postcode",
      "Geboortedatum",
      "Account",
      "Order ID"
    ],
    "explanation": "Dutch BSN values are precisely 9 digits with no separators or letters. This type is useful for recognizing and validating columns that contain Dutch citizen service numbers in administrative datasets where the header or data suggest a national identifier. The header patterns prioritize explicit Dutch terminology and common English equivalents, backing off to more general identifier-number constructs and finally the primitive 'number' term.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:51.877281"
  },
  {
    "resultType": "generated",
    "semanticType": "CHECKDIGIT.IBAN",
    "description": "This account number begins with a two-letter country code followed by two check digits and up to thirty additional alphanumeric characters representing the domestic bank account. The format varies by country but always includes validation digits and contains no spaces or punctuation.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z]{2}[0-9]{2}[A-Za-z0-9]{10,30}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 2260,
    "headerPatterns": [
      {
        "regExp": "(?i).*international.*bank.*account.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "International Bank Account Number"
        ],
        "negativeExamples": [
          "Bank Name"
        ]
      },
      {
        "regExp": "(?i).*iban.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IBAN"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*bank.*account.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Bank Account"
        ],
        "negativeExamples": [
          "Account Number"
        ]
      },
      {
        "regExp": "(?i).*(iban|intl).*acct.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IBAN Acct"
        ],
        "negativeExamples": [
          "Customer Account"
        ]
      },
      {
        "regExp": "(?i).*account.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "International Account"
        ],
        "negativeExamples": [
          "Bank Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "DE89370400440532013000",
      "GB29NWBK60161331926819",
      "FR1420041010050500013M02606",
      "NL91ABNA0417164300",
      "IT60X0542811101000000123456",
      "ES9121000418450200051332",
      "PL61109010140000071219812874",
      "GR1601101250000000012300695"
    ],
    "negativeContentExamples": [
      "DE89 370400440532013000",
      "GB29-NWBK60161331926819",
      "FR14!20041010050500013M02606",
      "DE8A370400440532013000",
      "GB2ANWBK60161331926819",
      "NL91ABNA0417",
      "AA12ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890",
      "IT600542811101000000123456000000000000000000000"
    ],
    "positiveHeaderExamples": [
      "IBAN",
      "Bank Account",
      "International Account",
      "International Bank Account Number",
      "IBAN Number",
      "Bank Account ID",
      "International Account Number",
      "IBAN Acct"
    ],
    "negativeHeaderExamples": [
      "Account Number",
      "Bank Name",
      "Country Code",
      "SWIFT Code",
      "Routing Number",
      "Customer Account",
      "Account Code",
      "Domestic Account Number"
    ],
    "explanation": "Identifies International Bank Account Numbers (IBANs) based on their structural pattern: two-letter country code, two check digits, and an alphanumeric Basic Bank Account Number segment with no spaces or punctuation. Useful for validating and classifying columns containing IBAN-like account identifiers in international payments, banking, and financial reconciliation datasets.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:51.919310"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.NI_UK",
    "description": "This type captures the UK National Insurance Number, used for social security and employment purposes throughout Britain. The identifier consists of two letters followed by six digits and ends with a single letter, with no spaces or separators in its canonical form.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z]{2}[0-9]{6}[A-Za-z]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 2830,
    "headerPatterns": [
      {
        "regExp": "(?i).*(national[\\s_]*insurance).*(number|no|num|nino).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "National Insurance Number"
        ],
        "negativeExamples": [
          "Insurance Policy Number"
        ]
      },
      {
        "regExp": "(?i).*\\bnino\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "NINO"
        ],
        "negativeExamples": [
          "VIN"
        ]
      },
      {
        "regExp": "(?i).*\\bni[\\s_]*(number|no|num)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "NI No"
        ],
        "negativeExamples": [
          "NI Name"
        ]
      },
      {
        "regExp": "(?i).*\\bnational[\\s_]*insurance\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "National Insurance"
        ],
        "negativeExamples": [
          "Insurance"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Status"
        ]
      }
    ],
    "positiveContentExamples": [
      "AB123456C",
      "QQ123456D",
      "JT987654A",
      "HM123456B",
      "ZX000001Z",
      "LP765432K",
      "RN112233M"
    ],
    "negativeContentExamples": [
      "AB123456",
      "A123456C",
      "AB12345C",
      "AB1234567C",
      "AB1234567",
      "AB123456CC",
      "AB 123456 C",
      "AB-123456-C"
    ],
    "positiveHeaderExamples": [
      "NI Number",
      "National Insurance",
      "NINO",
      "National Insurance Number",
      "NI No",
      "NI ID",
      "NINO Number",
      "NI Identifier"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Address",
      "Employer",
      "Country Code",
      "Tax ID",
      "Passport Number",
      "Insurance Policy Number",
      "Social Security Number"
    ],
    "explanation": "IDENTITY.NI_UK detects UK National Insurance Numbers in their canonical, compact form: two letters, six digits, and a final letter without separators. The regex uses word boundaries and explicit token lengths to avoid overmatching and excludes spaces, hyphens, or other delimiters. Header patterns progress from very specific phrases (e.g., National Insurance Number) through common abbreviations (NINO, NI No) to the primitive concept of a generic code. This type is suitable for validating and classifying UK NINO fields in HR, payroll, and compliance datasets where the canonical unspaced form is expected.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:51.978548"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.SIN_CA",
    "description": "This type captures the Canadian Social Insurance Number, a federal identifier required for work authorization and government services. The number consists of nine digits often formatted with spaces or hyphens in groups of three digits each for readability purposes.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{3}[ -]?\\d{3}[ -]?\\d{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 2860,
    "headerPatterns": [
      {
        "regExp": "(?i).*social.*insurance.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Social Insurance Number"
        ],
        "negativeExamples": [
          "Insurance Number"
        ]
      },
      {
        "regExp": "(?i).*sin.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SIN Number"
        ],
        "negativeExamples": [
          "PIN Number"
        ]
      },
      {
        "regExp": "(?i).*social.*insurance.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Social Insurance"
        ],
        "negativeExamples": [
          "National Insurance"
        ]
      },
      {
        "regExp": "(?i).*\\bsin\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SIN"
        ],
        "negativeExamples": [
          "SSN"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Number"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "123456789",
      "123 456 789",
      "123-456-789",
      "271 830 945",
      "604-219-337",
      "846382105",
      "940 112 763",
      "502-774-918"
    ],
    "negativeContentExamples": [
      "123 456 78",
      "123 45 6789",
      "123.456.789",
      "123-456789",
      "A23 456 789",
      "123 456 7890",
      "12 345 6789",
      "12345678"
    ],
    "positiveHeaderExamples": [
      "SIN",
      "Social Insurance Number",
      "SIN Number",
      "Social Insurance",
      "SIN No",
      "Applicant SIN",
      "Soc Ins Num",
      "SIN (CA)"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Address",
      "Employer",
      "Insurance Number",
      "SSN",
      "National Insurance Number",
      "Taxpayer Number",
      "Account Number"
    ],
    "explanation": "Identifies Canadian Social Insurance Numbers in datasets by matching nine digits that may be grouped with single spaces or hyphens (3-3-3). Useful for validating and extracting national identity numbers specific to Canada from HR, payroll, and government-related records. This pattern focuses on structural format and does not enforce checksum validation; downstream logic can add checksum verification if required.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:56.448308"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.INDIVIDUAL_NUMBER_JA",
    "description": "Identifies the Japanese Individual Number (My Number), a national identifier used for social security and taxation purposes. Values are exactly 12 ASCII digits with no letters, spaces, or separators.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{12}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2810,
    "headerPatterns": [
      {
        "regExp": "(?i).*(japan|jp).*(my.*number|individual.*number).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Japan Individual Number"
        ],
        "negativeExamples": [
          "JP Phone Number"
        ]
      },
      {
        "regExp": "(?i).*(\u500b\u4eba\u756a\u53f7|\u30de\u30a4\u30ca\u30f3\u30d0\u30fc).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "\u500b\u4eba\u756a\u53f7"
        ],
        "negativeExamples": [
          "\u96fb\u8a71\u756a\u53f7"
        ]
      },
      {
        "regExp": "(?i).*my.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "My Number"
        ],
        "negativeExamples": [
          "My Identifier"
        ]
      },
      {
        "regExp": "(?i).*(individual|personal).*number.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Personal Number"
        ],
        "negativeExamples": [
          "Personal Name"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Number"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "123456789012",
      "001234567890",
      "987654321098",
      "210987654321",
      "314159265358",
      "555555555555",
      "709384756120",
      "420000111222"
    ],
    "negativeContentExamples": [
      "12345678901",
      "1234567890123",
      "1234-5678-9012",
      "123456 789012",
      "A23456789012",
      "\uff11\uff12\uff13\uff14\uff15\uff16\uff17\uff18\uff19\uff10\uff11\uff12",
      "1234567890O2",
      "12345678901a"
    ],
    "positiveHeaderExamples": [
      "\u30de\u30a4\u30ca\u30f3\u30d0\u30fc",
      "\u500b\u4eba\u756a\u53f7",
      "My Number",
      "Japan Individual Number",
      "JP My Number",
      "Japan My Number",
      "\u65e5\u672c\u500b\u4eba\u756a\u53f7",
      "\u500b\u4eba\u756a\u53f7\u30de\u30a4\u30ca\u30f3\u30d0\u30fc"
    ],
    "negativeHeaderExamples": [
      "\u6c0f\u540d",
      "\u4f4f\u6240",
      "\u96fb\u8a71\u756a\u53f7",
      "\u9867\u5ba2ID",
      "Tax ID",
      "Passport",
      "Customer Identifier",
      "Email Address"
    ],
    "explanation": "This semantic type targets Japanese Individual Numbers (My Number) appearing as exactly twelve ASCII digits with no separators or extra characters. It is intended for columns storing resident national identifiers used for social security and taxation workflows, and should not match formatted variants with hyphens, spaces, or non-ASCII digits.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:13:58.443227"
  },
  {
    "resultType": "generated",
    "semanticType": "AIRLINE.TEXT_EN",
    "description": "Complete legal or trading name of an airline carrier as it appears in official documents and marketing materials. Names typically include descriptors such as \"Airlines\", \"Airways\", or \"Air Lines\" and may contain spaces, punctuation, and corporate suffixes (e.g., Inc., Co., Ltd.).",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b[a-z][a-z0-9'&().,\\/-]*(\\s+[a-z0-9'&().,\\/-]+)*\\s+(airlines|airways|air\\s+lines)(\\s*,?\\s+(inc|inc\\.|ltd|ltd\\.|llc|corp|corp\\.|co|co\\.|plc|s\\.a\\.|s\\.a|sa|ag|gmbh|corporation|company|limited))?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2210,
    "headerPatterns": [
      {
        "regExp": "(?i).*airline.*name.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Airline Name"
        ],
        "negativeExamples": [
          "Airline Code"
        ]
      },
      {
        "regExp": "(?i).*carrier.*name.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Carrier Name"
        ],
        "negativeExamples": [
          "Carrier Code"
        ]
      },
      {
        "regExp": "(?i).*airline.*company.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Airline Company"
        ],
        "negativeExamples": [
          "Aircraft Company"
        ]
      },
      {
        "regExp": "(?i).*(airln|airlns|airwy|airw|airl).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Airln Name"
        ],
        "negativeExamples": [
          "Airln Code"
        ]
      },
      {
        "regExp": "(?i).*(airline|carrier).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Airline"
        ],
        "negativeExamples": [
          "Aircraft Type"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Delta Air Lines",
      "British Airways",
      "Qatar Airways",
      "Ethiopian Airlines",
      "Hawaiian Airlines, Inc.",
      "All Nippon Airways Co., Ltd.",
      "JetBlue Airways Corporation",
      "China Airlines"
    ],
    "negativeContentExamples": [
      "Delta",
      "Qantas",
      "Ryanair",
      "Southwest Co.",
      "American Air",
      "Lufthansa Group",
      "Air Line Pilots Association",
      "Aircraft Maintenance Services"
    ],
    "positiveHeaderExamples": [
      "Airline Name",
      "Carrier Name",
      "Airline Company",
      "Operating Airline Name",
      "Marketing Carrier Name",
      "Airline Legal Name",
      "Airline Trade Name",
      "Carrier Company Name"
    ],
    "negativeHeaderExamples": [
      "Airline Code",
      "Flight Number",
      "Aircraft Type",
      "Carrier Code",
      "IATA Airline Code",
      "Tail Number",
      "Aircraft Manufacturer",
      "Flight Date"
    ],
    "explanation": "Identifies full airline carrier names in English that include standard industry descriptors such as Airlines, Airways, or Air Lines, optionally followed by corporate suffixes. Useful for differentiating airline name fields from code fields and other aviation attributes. The pattern emphasizes the presence of these key terms to avoid confusing airline names with general company names, aircraft terms, or codes.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:00.956133"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.DUNS",
    "description": "This type represents the DUNS number, a proprietary business identifier created by Dun & Bradstreet for tracking commercial entities globally. The identifier consists of exactly nine digits with no alphabetic characters, spaces, or punctuation marks.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{9}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2790,
    "headerPatterns": [
      {
        "regExp": "(?i).*d[-_ ]?u[-_ ]?n[-_ ]?s.*number.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "DUNS Number"
        ],
        "negativeExamples": [
          "Company Number"
        ]
      },
      {
        "regExp": "(?i).*duns.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "DUNS ID"
        ],
        "negativeExamples": [
          "Customer ID"
        ]
      },
      {
        "regExp": "(?i).*d[-_ ]?u[-_ ]?n[-_ ]?s.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "D-U-N-S"
        ],
        "negativeExamples": [
          "Industry"
        ]
      },
      {
        "regExp": "(?i).*id.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Identifier"
        ],
        "negativeExamples": [
          "Name"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "Number"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "123456789",
      "001234567",
      "550123456",
      "765432100",
      "246813579",
      "000000001",
      "999999999",
      "100200300"
    ],
    "negativeContentExamples": [
      "123-456-789",
      "12345678",
      "1234567890",
      "123 456 789",
      "A23456789",
      "12345678B",
      "1234567_9",
      "01234 5678"
    ],
    "positiveHeaderExamples": [
      "DUNS Number",
      "DUNS",
      "D-U-N-S",
      "company duns",
      "duns_id",
      "duns no",
      "duns number",
      "dunsid"
    ],
    "negativeHeaderExamples": [
      "Company Name",
      "Industry",
      "Revenue",
      "Tax ID",
      "Registration Number",
      "Account Number",
      "Customer ID",
      "SIC Code"
    ],
    "explanation": "IDENTITY.DUNS detects DUNS numbers that are exactly nine digits with no spaces, hyphens, or letters. It is suitable for columns storing Dun & Bradstreet identifiers used to track commercial entities. The regex enforces strict numeric length and rejects formatted variants like hyphenated or spaced values.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:01.116142"
  },
  {
    "resultType": "generated",
    "semanticType": "GENDER.TEXT_ZH",
    "description": "This type captures gender designations as they are expressed in Chinese language for demographic data collection and personal identification purposes. The values represent standard gender terminology using Chinese characters and linguistic conventions without abbreviations or alternative language forms.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "\u7537",
      "\u5973",
      "\u7537\u6027",
      "\u5973\u6027",
      "\u7537\u58eb",
      "\u5973\u58eb",
      "\u7537\u5b50",
      "\u5973\u5b50",
      "\u96c4\u6027",
      "\u96cc\u6027"
    ],
    "backout": "^[\u7537\u5973\u96c4\u96cc][\u6027\u5b50\u58eb]?$",
    "confidenceThreshold": 97,
    "priority": 2710,
    "headerPatterns": [
      {
        "regExp": "(?i).*(\u6027\u522b).*(\u4e2d\u6587|zh|cn).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u6027\u522b_\u4e2d\u6587"
        ],
        "negativeExamples": [
          "\u6027\u522b\u4ee3\u7801"
        ]
      },
      {
        "regExp": "(?i).*(\u7528\u6237|\u5ba2\u6237|\u4eba\u5458|\u5458\u5de5).*\u6027\u522b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u7528\u6237\u6027\u522b"
        ],
        "negativeExamples": [
          "\u7528\u6237\u5e74\u9f84"
        ]
      },
      {
        "regExp": "(?i).*\u6027\u522b.*\u5206\u7c7b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u6027\u522b\u5206\u7c7b"
        ],
        "negativeExamples": [
          "\u804c\u4f4d\u5206\u7c7b"
        ]
      },
      {
        "regExp": "(?i).*\u7537\u5973.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u7537\u5973"
        ],
        "negativeExamples": [
          "\u59d3\u540d"
        ]
      },
      {
        "regExp": "(?i).*\u6027\u522b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u6027\u522b"
        ],
        "negativeExamples": [
          "\u56fd\u7c4d"
        ]
      }
    ],
    "positiveContentExamples": [
      "\u7537",
      "\u5973",
      "\u7537\u6027",
      "\u5973\u6027",
      "\u7537\u58eb",
      "\u5973\u58eb",
      "\u7537\u5b50",
      "\u5973\u5b50"
    ],
    "negativeContentExamples": [
      "\u9633\u6027",
      "\u9634\u6027",
      "\u7537\u5973\u4e0d\u9650",
      "\u5973\u88c5",
      "\u6027\u522b\u4e0d\u8be6",
      "\u7537\u7ae5",
      "\u5973\u751f",
      "\u7537/\u5973"
    ],
    "positiveHeaderExamples": [
      "\u6027\u522b",
      "\u6027",
      "\u7537\u5973",
      "\u7528\u6237\u6027\u522b",
      "\u6027\u522b\u5206\u7c7b",
      "\u6027\u522b_\u4e2d\u6587",
      "\u6027\u522b\u6807\u8bc6",
      "\u5ba2\u6237\u6027\u522b"
    ],
    "negativeHeaderExamples": [
      "\u59d3\u540d",
      "\u5e74\u9f84",
      "\u56fd\u7c4d",
      "\u6027\u522b\u4ee3\u7801",
      "\u6027\u522b\u7801",
      "\u6027\u80fd",
      "\u59d3"
    ],
    "explanation": "GENDER.TEXT_ZH identifies Chinese-language gender labels commonly used in demographic datasets. It is intended for columns containing explicit gender terms in Chinese characters rather than codes or abbreviations, enabling precise detection and normalization of gender fields in Chinese data.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:03.530431"
  },
  {
    "resultType": "generated",
    "semanticType": "HASH.SHA1_HEX",
    "description": "This type captures SHA-1 hash digest values used for file integrity checking, digital signatures, and data verification purposes. The values represent 160-bit hash outputs encoded as hexadecimal strings using lowercase letters and digits without spaces or separators.",
    "pluginType": "regex",
    "regexPattern": "\\b[a-f0-9]{40}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2730,
    "headerPatterns": [
      {
        "regExp": "(?i).*sha[_ -]?1.*hash.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SHA1 Hash"
        ],
        "negativeExamples": [
          "SHA256 Hash"
        ]
      },
      {
        "regExp": "(?i).*sha[_ -]?1.*checksum.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SHA-1 Checksum"
        ],
        "negativeExamples": [
          "MD5 Checksum"
        ]
      },
      {
        "regExp": "(?i).*sha[_ -]?1.*digest.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SHA1 Digest"
        ],
        "negativeExamples": [
          "File Digest"
        ]
      },
      {
        "regExp": "(?i).*sha[_ -]?1.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SHA1"
        ],
        "negativeExamples": [
          "SHA256"
        ]
      },
      {
        "regExp": "(?i).*hash.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Hash"
        ],
        "negativeExamples": [
          "Checksum"
        ]
      }
    ],
    "positiveContentExamples": [
      "da39a3ee5e6b4b0d3255bfef95601890afd80709",
      "a9993e364706816aba3e25717850c26c9cd0d89d",
      "2fd4e1c67a2d28fced849ee1bb76e7391b93eb12",
      "aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d",
      "7c222fb2927d828af22f592134e8932480637c0d",
      "3b5d5c3712955042212316173ccf37be800a3e0a",
      "5baa61e4c9b93f3f0682250b6cf8331b7ee68fd8",
      "356a192b7913b04c54574d18c28d46e6395428ab"
    ],
    "negativeContentExamples": [
      "2FD4E1C67A2D28FCED849EE1BB76E7391B93EB12",
      "2fd4e1c67a2d28fced849ee1bb76e7391b93eb1",
      "2fd4e1c67a2d28fced849ee1bb76e7391b93eb12f",
      "2fd4e1c67a2d28fced849ee1bb76e7391b93eb1z",
      "aaf4c61d-dcc5e8a2-dabede0f-3b482cd9-aea9434d",
      "aaf4c61ddcc5 e8a2dabede0f3b482cd9aea9434d",
      "5d41402abc4b2a76b9719d911017c592",
      "Aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d"
    ],
    "positiveHeaderExamples": [
      "SHA1 Hash",
      "Hash",
      "Checksum",
      "SHA-1 Checksum",
      "SHA1 Digest",
      "SHA1",
      "SHA Hash"
    ],
    "negativeHeaderExamples": [
      "Filename",
      "File Size",
      "Password",
      "SHA256 Hash",
      "MD5 Hash",
      "Digital Signature",
      "File Checksum Type",
      "Certificate Fingerprint"
    ],
    "explanation": "This semantic type identifies SHA-1 digests represented as exactly 40 lowercase hexadecimal characters with no spaces or separators. It is suitable for columns storing file checksums, content identifiers, or integrity verification tokens where the algorithm is specifically SHA-1.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:05.298170"
  },
  {
    "resultType": "generated",
    "semanticType": "GENDER.TEXT_<LANGUAGE>",
    "description": "Textual gender identity values expressed in a specific language, covering common self-identifiers such as male, female, non-binary, agender, and related terms. This type focuses on written-out words and phrases (including hyphenated forms) rather than single-letter codes or numeric encodings.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "MALE",
      "FEMALE",
      "MAN",
      "WOMAN",
      "NON-BINARY",
      "NONBINARY",
      "TRANSGENDER MAN",
      "TRANSGENDER WOMAN",
      "TRANS MAN",
      "TRANS WOMAN",
      "AGENDER",
      "GENDERFLUID",
      "GENDERQUEER",
      "INTERSEX",
      "TWO-SPIRIT",
      "OTHER",
      "PREFER NOT TO SAY",
      "DECLINE TO STATE",
      "UNKNOWN",
      "UNSPECIFIED",
      "NEUTROIS",
      "BIGENDER",
      "DEMIBOY",
      "DEMIGIRL"
    ],
    "backout": "^[A-Z][A-Z \\-]{1,29}$",
    "confidenceThreshold": 93,
    "priority": 2690,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bgender\\b.*\\bidentity\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Gender Identity"
        ],
        "negativeExamples": [
          "Nationality"
        ]
      },
      {
        "regExp": "(?i).*\\bsex at birth\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Sex at Birth"
        ],
        "negativeExamples": [
          "Age"
        ]
      },
      {
        "regExp": "(?i).*\\b(sex|gender)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Sex"
        ],
        "negativeExamples": [
          "Name"
        ]
      },
      {
        "regExp": "(?i).*\\b(gndr|sx)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Gndr"
        ],
        "negativeExamples": [
          "DOB"
        ]
      },
      {
        "regExp": "(?i).*\\bgender\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Gender"
        ],
        "negativeExamples": [
          "Title"
        ]
      }
    ],
    "positiveContentExamples": [
      "Male",
      "Female",
      "Man",
      "Woman",
      "Non-binary",
      "Agender",
      "Genderqueer",
      "Two-Spirit"
    ],
    "negativeContentExamples": [
      "M",
      "F",
      "Non binary",
      "Transwoman",
      "Prefer not say",
      "Sex: Male",
      "Feminine",
      "Other:"
    ],
    "positiveHeaderExamples": [
      "Gender",
      "Sex",
      "Gender Identity",
      "Sex at Birth",
      "User Gender",
      "Patient Sex",
      "Customer Gender",
      "Legal Gender"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Age",
      "Nationality",
      "Title",
      "Country",
      "DOB",
      "Marital Status",
      "Category"
    ],
    "explanation": "This semantic type identifies textual gender identity values in a given language, including common self-descriptors and inclusive terms. It is intended for columns where responses are written out as words or phrases, accommodating spaces and hyphens. The list-based approach restricts matches to a curated set of values, while the backout ensures reasonable shape control for unforeseen entries. Typical use cases include survey responses, account profiles, patient demographics, and HR datasets.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:05.317037"
  },
  {
    "resultType": "generated",
    "semanticType": "COLOR.TEXT_ES",
    "description": "This represents standard color terminology using common Spanish words that describe visual appearance and hue characteristics. The names are typically lowercase single words following Spanish linguistic patterns without numeric values or technical specifications.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "ROJO",
      "AZUL",
      "VERDE",
      "AMARILLO",
      "NARANJA",
      "MORADO",
      "VIOLETA",
      "ROSA",
      "NEGRO",
      "BLANCO",
      "GRIS",
      "MARR\u00d3N",
      "CAF\u00c9",
      "BEIGE",
      "CELESTE",
      "TURQUESA",
      "P\u00daRPURA",
      "MAGENTA",
      "CIAN",
      "FUCSIA",
      "GRANATE",
      "LILA",
      "DORADO",
      "PLATEADO",
      "OCRE"
    ],
    "backout": "^[A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1\u00e1\u00e9\u00ed\u00f3\u00fa\u00fc\u00f1]{3,12}$",
    "confidenceThreshold": 93,
    "priority": 2350,
    "headerPatterns": [
      {
        "regExp": "(?i).*nombre.*color.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Nombre del Color"
        ],
        "negativeExamples": [
          "C\u00f3digo de Color"
        ]
      },
      {
        "regExp": "(?i).*color.*primari[oa].*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Color Primario"
        ],
        "negativeExamples": [
          "Color Secundario"
        ]
      },
      {
        "regExp": "(?i).*color.*texto.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Color Texto"
        ],
        "negativeExamples": [
          "Valor Hexadecimal"
        ]
      },
      {
        "regExp": "(?i).*col.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "col"
        ],
        "negativeExamples": [
          "Tono"
        ]
      },
      {
        "regExp": "(?i).*color.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Color"
        ],
        "negativeExamples": [
          "Tama\u00f1o"
        ]
      }
    ],
    "positiveContentExamples": [
      "rojo",
      "azul",
      "verde",
      "amarillo",
      "morado",
      "marr\u00f3n",
      "turquesa",
      "p\u00farpura"
    ],
    "negativeContentExamples": [
      "rojo claro",
      "azul-marino",
      "verde2",
      "#FF0000",
      "RGB",
      "cian.",
      "color",
      "marron"
    ],
    "positiveHeaderExamples": [
      "Color",
      "Nombre del Color",
      "Color Primario",
      "Color Base",
      "Tono",
      "Color Texto",
      "Nombre Color",
      "Color Espa\u00f1ol"
    ],
    "negativeHeaderExamples": [
      "C\u00f3digo de Color",
      "Valor Hexadecimal",
      "RGB",
      "Color Hex",
      "C\u00f3digo RGB",
      "Pantone",
      "Id Color",
      "Color ID"
    ],
    "explanation": "COLOR.TEXT_ES identifies single-word Spanish color names used as descriptive text values in datasets, such as product catalogs, design attributes, or UI labels. It excludes color codes and multi-word shade descriptions, focusing on common lexical color terms rather than technical specifications.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:06.209666"
  },
  {
    "resultType": "generated",
    "semanticType": "MONTH.ABBR_<LOCALE>",
    "description": "Captures abbreviated month names used in locale-specific date formatting and display. Values are the standardized short forms of month names, typically three characters long, representing the twelve months for a given locale. For this locale-specific variant, values are provided as three-letter uppercase abbreviations.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "JAN",
      "FEB",
      "MAR",
      "APR",
      "MAY",
      "JUN",
      "JUL",
      "AUG",
      "SEP",
      "OCT",
      "NOV",
      "DEC"
    ],
    "backout": "^([A-Z]{3})$",
    "confidenceThreshold": 98,
    "priority": 3000,
    "headerPatterns": [
      {
        "regExp": "(?i).*month.*abbr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Month Abbr"
        ],
        "negativeExamples": [
          "Month Name"
        ]
      },
      {
        "regExp": "(?i).*month.*short.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Month Short"
        ],
        "negativeExamples": [
          "Month Name"
        ]
      },
      {
        "regExp": "(?i).*mon.*abbr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Mon Abbr"
        ],
        "negativeExamples": [
          "Day Abbr"
        ]
      },
      {
        "regExp": "(?i).*mth.*abbr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Mth Abbr"
        ],
        "negativeExamples": [
          "Year Abbr"
        ]
      },
      {
        "regExp": "(?i).*month.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Month"
        ],
        "negativeExamples": [
          "Day"
        ]
      }
    ],
    "positiveContentExamples": [
      "JAN",
      "FEB",
      "MAR",
      "APR",
      "MAY",
      "JUN",
      "JUL",
      "AUG"
    ],
    "negativeContentExamples": [
      "Jan",
      "SEPT",
      "JAN.",
      "M\u00c4R",
      "MAR-2024",
      "J",
      "OCTOBER",
      "Q1"
    ],
    "positiveHeaderExamples": [
      "Month Abbr",
      "Month",
      "Month Short",
      "Mon Abbr",
      "Month Abbreviation",
      "Mth Abbr",
      "Month Short Name",
      "Short Month"
    ],
    "negativeHeaderExamples": [
      "Month Name",
      "Day",
      "Year",
      "Full Month",
      "Month Code",
      "Day Abbr",
      "Month Index",
      "Week"
    ],
    "explanation": "This semantic type targets columns storing abbreviated month names for a specific locale, where values are the 12 standardized three-letter uppercase month abbreviations. It is ideal for parsing or validating compact month indicators in date-related datasets. The backout pattern constrains the domain to three uppercase letters, while the list enforces the exact set of valid abbreviations. The header patterns prioritize explicit indicators like 'month abbr' and 'month short' before falling back to the primitive 'month' term.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:06.806895"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.EIN_US",
    "description": "This type captures the Employer Identification Number, a unique 9-digit federal tax ID assigned by the Internal Revenue Service to US businesses. The number is formatted with a hyphen separating the first two digits from the remaining seven digits.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{2}-\\d{7}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2800,
    "headerPatterns": [
      {
        "regExp": "(?i).*employer.*identification.*number.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Employer Identification Number"
        ],
        "negativeExamples": [
          "Company Name"
        ]
      },
      {
        "regExp": "(?i).*(employer|business).*id.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Employer ID"
        ],
        "negativeExamples": [
          "Employee Count"
        ]
      },
      {
        "regExp": "(?i).*\\bein\\b.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "EIN"
        ],
        "negativeExamples": [
          "SSN"
        ]
      },
      {
        "regExp": "(?i).*tax.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Tax ID"
        ],
        "negativeExamples": [
          "Company Name"
        ]
      },
      {
        "regExp": "(?i).*\\bid\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "ID"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "12-3456789",
      "98-7654321",
      "01-2345678",
      "45-6789012",
      "83-0192837",
      "36-9999999",
      "27-0001234"
    ],
    "negativeContentExamples": [
      "123-456789",
      "12-345678",
      "12-34567890",
      "12 3456789",
      "12\u20133456789",
      "1-23456789",
      "12-3456-789",
      "12-345678a"
    ],
    "positiveHeaderExamples": [
      "EIN",
      "Employer ID",
      "Tax ID",
      "Employer Identification Number",
      "Federal Tax ID",
      "Business Tax ID",
      "IRS EIN",
      "Employer Tax ID"
    ],
    "negativeHeaderExamples": [
      "Company Name",
      "SSN",
      "Employee Count",
      "Customer ID",
      "VAT Number",
      "DUNS Number",
      "Phone Number",
      "Account Number"
    ],
    "explanation": "Employer Identification Numbers (EINs) are standardized US business identifiers consisting of two digits, a hyphen, and seven digits. This pattern targets correctly formatted EINs while rejecting near-miss variations such as missing hyphens, wrong digit counts, or non-digit characters. It is useful for validating and classifying columns that store US federal tax IDs for organizations.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:14.096319"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.NPI_US",
    "description": "This type identifies the National Provider Identifier, a standardized healthcare provider identifier mandated for use in US healthcare transactions. The number consists of exactly ten numerical digits with no alphabetic characters, spaces, or formatting symbols.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{10}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 2840,
    "headerPatterns": [
      {
        "regExp": "(?i).*national.*provider.*identifier.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "National Provider Identifier"
        ],
        "negativeExamples": [
          "National Patient Identifier"
        ]
      },
      {
        "regExp": "(?i).*npi.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "NPI Number"
        ],
        "negativeExamples": [
          "Phone Number"
        ]
      },
      {
        "regExp": "(?i).*provider.*npi.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Provider NPI"
        ],
        "negativeExamples": [
          "Provider Name"
        ]
      },
      {
        "regExp": "(?i).*provider.*id.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Provider ID"
        ],
        "negativeExamples": [
          "Patient ID"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Number"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "1234567890",
      "0001234567",
      "8392017465",
      "5678901234",
      "9081726354",
      "2468135790",
      "1357924680",
      "7418529630"
    ],
    "negativeContentExamples": [
      "123456789",
      "01234567890",
      "123-456-7890",
      "12345 67890",
      "123456789A",
      "NPI1234567890",
      "(1234567890)",
      "1234567890 "
    ],
    "positiveHeaderExamples": [
      "NPI",
      "Provider ID",
      "NPI Number",
      "National Provider Identifier",
      "Provider NPI",
      "US NPI",
      "Provider Identifier Number",
      "NPI ID"
    ],
    "negativeHeaderExamples": [
      "Provider Name",
      "Specialty",
      "Address",
      "National Patient Identifier",
      "Patient ID",
      "Tax ID",
      "Phone Number",
      "Postal Code"
    ],
    "explanation": "The IDENTITY.NPI_US semantic type detects US National Provider Identifiers as exactly ten digits with no spaces, letters, or punctuation. It is useful for validating and classifying provider identifiers in healthcare datasets, ensuring fields intended for NPIs are properly formatted and distinct from other identifiers or numbers.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:15.578382"
  },
  {
    "resultType": "generated",
    "semanticType": "GUID",
    "description": "A lowercase hyphenated GUID/UUID in the canonical 8-4-4-4-12 format using only hexadecimal digits [0-9a-f] and hyphens as separators. No braces, spaces, or alternative punctuation are allowed; all letters must be lowercase.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2720,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bguid\\b.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "GUID"
        ],
        "negativeExamples": [
          "Guide Code"
        ]
      },
      {
        "regExp": "(?i).*\\buuid\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "UUID"
        ],
        "negativeExamples": [
          "Audio ID"
        ]
      },
      {
        "regExp": "(?i).*\\bunique[_ ]?(id|identifier)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Unique ID"
        ],
        "negativeExamples": [
          "User Identifier"
        ]
      },
      {
        "regExp": "(?i).*\\b(global|globally)\\b.*\\bunique\\b.*\\b(identifier|id)\\b.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Globally Unique Identifier"
        ],
        "negativeExamples": [
          "Global Region ID"
        ]
      },
      {
        "regExp": "(?i).*\\bid\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "ID"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "550e8400-e29b-41d4-a716-446655440000",
      "3f2504e0-4f89-11d3-9a0c-0305e82c3301",
      "0a1b2c3d-4e5f-6789-abcd-0123456789ab",
      "ffffffff-ffff-ffff-ffff-ffffffffffff",
      "00000000-0000-0000-0000-000000000000",
      "1a2b3c4d-5e6f-1a2b-9c0d-1e2f3a4b5c6d",
      "a1b2c3d4-e5f6-1234-abcd-ef0123456789",
      "9b2d1cfe-8a76-4b3c-9d2e-7f6a5b4c3d2e"
    ],
    "negativeContentExamples": [
      "550E8400-E29B-41D4-A716-446655440000",
      "550e8400e29b41d4a716446655440000",
      "550e8400-e29b-41d4-a716-44665544000",
      "{550e8400-e29b-41d4-a716-446655440000}",
      "550e8400-e29b-41d4-a716-44665544zzzz",
      "550e8400-e29b-41d4-a716-4466-55440000",
      "550e8400_e29b_41d4_a716_446655440000",
      "550e8400-e29b-41d4-a716-4466554400001"
    ],
    "positiveHeaderExamples": [
      "GUID",
      "UUID",
      "Unique ID",
      "Unique Identifier",
      "Record GUID",
      "user_uuid",
      "primary_guid",
      "Globally Unique Identifier"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Description",
      "Created Date",
      "Customer Code",
      "Transaction Number",
      "File Hash",
      "Reference Number",
      "Profile Key"
    ],
    "explanation": "This semantic type identifies canonical lowercase GUID/UUID strings used as stable unique identifiers in datasets. It enforces the exact hyphenated 8-4-4-4-12 structure with lowercase hexadecimal characters only, rejecting uppercase, missing/extra separators, braces, and other punctuation.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:15.886756"
  },
  {
    "resultType": "generated",
    "semanticType": "LANGUAGE.ISO-639-1",
    "description": "This type identifies ISO 639-1 language codes, which are internationally standardized two-character alphabetic codes for language identification. The codes consist of exactly two lowercase letters derived from the language names and are used for internationalization and localization purposes.",
    "pluginType": "regex",
    "regexPattern": "\\b[a-z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2960,
    "headerPatterns": [
      {
        "regExp": "(?i).*(iso)[ _-]*639[ _-]*1.*language.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISO 639-1 Language Code"
        ],
        "negativeExamples": [
          "Three Letter Code"
        ]
      },
      {
        "regExp": "(?i).*(iso).*language.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISO Language Code"
        ],
        "negativeExamples": [
          "Language Name"
        ]
      },
      {
        "regExp": "(?i).*(iso).*language.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISO Language"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(lang).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Lang Code"
        ],
        "negativeExamples": [
          "Language Name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "en",
      "es",
      "fr",
      "de",
      "zh",
      "ar",
      "pt",
      "ru"
    ],
    "negativeContentExamples": [
      "EN",
      "eng",
      "e1",
      "e",
      "en-US",
      "fr_ca",
      "pt-BR",
      "zh-Hant"
    ],
    "positiveHeaderExamples": [
      "Language Code",
      "ISO Language",
      "Lang Code",
      "ISO 639-1 Language Code",
      "Locale Language Code",
      "UI Language Code"
    ],
    "negativeHeaderExamples": [
      "Language Name",
      "Country",
      "Three Letter Code",
      "Region Code",
      "ISO 639-2",
      "Locale"
    ],
    "explanation": "This semantic type targets fields containing strictly two-letter lowercase ISO 639-1 language codes (e.g., en, es, fr). It is useful for identifying columns that store standardized language identifiers used in internationalization, localization, and content negotiation. The pattern enforces exactly two lowercase alphabetic characters with word boundaries to avoid partial or embedded matches.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:16.131739"
  },
  {
    "resultType": "generated",
    "semanticType": "MACADDRESS",
    "description": "This type identifies Media Access Control addresses, which are unique identifiers assigned to network hardware devices by manufacturers. The address consists of six groups of two hexadecimal digits separated by colons or hyphens, representing a 48-bit identifier for network interface cards.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9A-Fa-f]{2}([-:])([0-9A-Fa-f]{2}\\1){4}[0-9A-Fa-f]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2990,
    "headerPatterns": [
      {
        "regExp": "(?i).*mac.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "MAC Address"
        ],
        "negativeExamples": [
          "IP Address"
        ]
      },
      {
        "regExp": "(?i).*hardware.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Hardware Address"
        ],
        "negativeExamples": [
          "Email Address"
        ]
      },
      {
        "regExp": "(?i).*network.*mac.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Network MAC"
        ],
        "negativeExamples": [
          "Network Name"
        ]
      },
      {
        "regExp": "(?i).*hw.*addr.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "HW Addr"
        ],
        "negativeExamples": [
          "Home Address"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "00:1A:2B:3C:4D:5E",
      "aa:bb:cc:dd:ee:ff",
      "0A-1B-2C-3D-4E-5F",
      "12:34:56:78:9A:BC",
      "FF-FF-FF-FF-FF-FF",
      "01-23-45-67-89-ab",
      "a1:b2:c3:d4:e5:f6",
      "9c-ef-00-12-34-56"
    ],
    "negativeContentExamples": [
      "00:1A:2B:3C:4D",
      "00:1A:2B:3C:4D:5E:6F",
      "0:1A:2B:3C:4D:5E",
      "00:1G:2B:3C:4D:5E",
      "001A:2B:3C:4D:5E",
      "00-1A:2B-3C:4D-5E",
      "00 1A 2B 3C 4D 5E",
      "001A.2B3C.4D5E"
    ],
    "positiveHeaderExamples": [
      "MAC Address",
      "Hardware Address",
      "Network MAC",
      "Device MAC Address",
      "Physical Address",
      "MAC"
    ],
    "negativeHeaderExamples": [
      "IP Address",
      "Device Name",
      "Network Name",
      "IPv6 Address",
      "Serial Number",
      "Machine ID"
    ],
    "explanation": "MAC addresses are hardware-level identifiers typically written as six pairs of hexadecimal digits with consistent separators (colon or hyphen). This pattern ensures exactly six pairs, enforces valid hex characters, and requires the same separator throughout, reducing false positives from other address-like strings.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:17.116419"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.SSN_CH",
    "description": "This type identifies the Swiss AHV social security number in its standardized printed format with dots as separators. It begins with the country code 756 followed by two groups of four digits and a final two-digit checksum, formatted as 756.XXXX.XXXX.XX.",
    "pluginType": "regex",
    "regexPattern": "\\b756\\.[0-9]{4}\\.[0-9]{4}\\.[0-9]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2870,
    "headerPatterns": [
      {
        "regExp": "(?i).*ahv.*nummer.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "AHV Nummer"
        ],
        "negativeExamples": [
          "Sozialversicherungsnummer"
        ]
      },
      {
        "regExp": "(?i).*(swiss|ch).*(ahv|ssn).*(number|nummer|nr).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Swiss AHV number"
        ],
        "negativeExamples": [
          "AHV Beitrag"
        ]
      },
      {
        "regExp": "(?i).*sozialversicherungsnummer.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Sozialversicherungsnummer"
        ],
        "negativeExamples": [
          "Kundennummer"
        ]
      },
      {
        "regExp": "(?i).*(ssn|ahv).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "SSN"
        ],
        "negativeExamples": [
          "ASN"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Number"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "756.9217.0769.85",
      "756.1234.5678.97",
      "756.0001.2345.67",
      "756.4020.8090.12",
      "756.9999.8888.00",
      "756.1111.2222.33",
      "756.7000.1000.45",
      "756.3456.7890.19"
    ],
    "negativeContentExamples": [
      "757.1234.5678.97",
      "756.1234.5678.9",
      "756.12345.5678.97",
      "756-1234-5678-97",
      "756.1234.5678.9X",
      "0756.1234.5678.97",
      "756.1234.5678.970",
      "756.1234.5678 97"
    ],
    "positiveHeaderExamples": [
      "AHV Nummer",
      "SSN",
      "Sozialversicherungsnummer",
      "Swiss AHV number",
      "CH SSN",
      "AHV-Nr",
      "CH_AHV_NUMMER"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Adresse",
      "Telefon",
      "Kundennummer",
      "Steuernummer",
      "Passport Number",
      "ID Code"
    ],
    "explanation": "Swiss AHV numbers are 13-digit identifiers formatted with dots: 756.XXXX.XXXX.XX, where 756 is the Swiss country code and the last two digits serve as a checksum. This semantic type targets the printed/delimited representation, enabling reliable extraction and validation-by-shape in datasets such as HR, benefits, or taxation records. The regex focuses on the standardized dotted format and does not compute or verify the checksum.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:22.070680"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.MIDDLE",
    "description": "This type captures middle names as they appear in personal identification and formal documentation between first and last names. The values represent additional given names using standard spelling conventions without including first names, surnames, titles, or middle initials.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z][a-z]{1,29})([-'][A-Z][a-z]{1,29})?(\\s[A-Z][a-z]{1,29}([-'][A-Z][a-z]{1,29})?)?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3070,
    "headerPatterns": [
      {
        "regExp": "(?i).*(person|customer|applicant).*(middle|second).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "applicant middle name"
        ],
        "negativeExamples": [
          "applicant last name"
        ]
      },
      {
        "regExp": "(?i).*(middle|second).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Middle Name"
        ],
        "negativeExamples": [
          "First Name"
        ]
      },
      {
        "regExp": "(?i).*(mname|m_name|midname).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mname"
        ],
        "negativeExamples": [
          "lname"
        ]
      },
      {
        "regExp": "(?i).*middle.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Middle"
        ],
        "negativeExamples": [
          "midpoint"
        ]
      },
      {
        "regExp": "(?i).*second.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Second Name"
        ],
        "negativeExamples": [
          "Second Address"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "email"
        ]
      }
    ],
    "positiveContentExamples": [
      "Anne",
      "Marie",
      "Lee",
      "Paul",
      "Sofia",
      "Jean-Luc",
      "Mary Jane",
      "Joelle"
    ],
    "negativeContentExamples": [
      "A",
      "J.",
      "John Paul Jones",
      "MARIE",
      "R J",
      "Mary-J",
      "O'",
      "Anne Marie Claire"
    ],
    "positiveHeaderExamples": [
      "Middle Name",
      "Second Name",
      "Middle",
      "applicant middle name",
      "mname",
      "customer second name"
    ],
    "negativeHeaderExamples": [
      "First Name",
      "Last Name",
      "Full Name",
      "middle_initial",
      "surname",
      "contact name"
    ],
    "explanation": "NAME.MIDDLE identifies a person's middle given name(s), excluding initials, titles, and surnames. It targets one or two given-name tokens, allowing internal hyphens or apostrophes, and is best used alongside header context to distinguish middle names from first or last names.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:22.135763"
  },
  {
    "resultType": "generated",
    "semanticType": "MONTH.FULL_<LOCALE>",
    "description": "This type captures the twelve full month names in English (e.g., January, February), using complete, properly spelled month names as they typically appear in user-facing date displays and internationalized content. It is intended for identifying textual month values rather than numeric representations.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "JANUARY",
      "FEBRUARY",
      "MARCH",
      "APRIL",
      "MAY",
      "JUNE",
      "JULY",
      "AUGUST",
      "SEPTEMBER",
      "OCTOBER",
      "NOVEMBER",
      "DECEMBER"
    ],
    "backout": "^[A-Za-z]{3,9}$",
    "confidenceThreshold": 97,
    "priority": 3020,
    "headerPatterns": [
      {
        "regExp": "(?i).*full[ _-]*month[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Full Month Name"
        ],
        "negativeExamples": [
          "Month Name"
        ]
      },
      {
        "regExp": "(?i).*month[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Month Name"
        ],
        "negativeExamples": [
          "Month Number"
        ]
      },
      {
        "regExp": "(?i).*(mnth|mo)[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Mnth Name"
        ],
        "negativeExamples": [
          "Day Name"
        ]
      },
      {
        "regExp": "(?i).*month.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Month"
        ],
        "negativeExamples": [
          "Season"
        ]
      }
    ],
    "positiveContentExamples": [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August"
    ],
    "negativeContentExamples": [
      "Jan",
      "FEB",
      "September 2021",
      "02",
      "Aug.",
      "Mar-2018",
      "Sept",
      "Januari"
    ],
    "positiveHeaderExamples": [
      "Month Name",
      "Month",
      "Full Month",
      "Full Month Name",
      "Month Label",
      "Calendar Month Name",
      "Month Text"
    ],
    "negativeHeaderExamples": [
      "Month Number",
      "Day",
      "Season",
      "Month ID",
      "Fiscal Month Number",
      "Date",
      "Quarter",
      "Week"
    ],
    "explanation": "This semantic type is designed to detect columns containing full English month names, enabling accurate parsing and normalization of month text in datasets and internationalized interfaces. It is useful for validating user-entered month fields, normalizing date displays, and mapping localized month names to canonical forms.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:23.485009"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.AADHAAR_IN",
    "description": "This type captures the Aadhaar number, a 12-digit numerical identifier assigned to Indian residents by UIDAI. Values must consist of exactly twelve digits with no letters, special characters, or separators in the basic form.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{12}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2770,
    "headerPatterns": [
      {
        "regExp": "(?i).*aadhaar.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Aadhaar Number"
        ],
        "negativeExamples": [
          "Phone Number"
        ]
      },
      {
        "regExp": "(?i).*aadhaar.*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Aadhaar ID"
        ],
        "negativeExamples": [
          "Employee ID"
        ]
      },
      {
        "regExp": "(?i).*aadhaar.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Aadhaar No"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*\\buid\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "UID"
        ],
        "negativeExamples": [
          "GUID"
        ]
      },
      {
        "regExp": "(?i).*\\bid\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ID"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "123456789012",
      "987654321098",
      "430812769154",
      "600345890127",
      "219876543210",
      "772301459682",
      "056789123456",
      "345067891234"
    ],
    "negativeContentExamples": [
      "12345678901",
      "1234567890123",
      "1234 5678 9012",
      "1234-5678-9012",
      "123456789O12",
      "A123456789012",
      "01234567890123",
      "12345678 9012"
    ],
    "positiveHeaderExamples": [
      "Aadhaar Number",
      "Aadhaar ID",
      "UID",
      "Aadhaar No",
      "Resident Aadhaar ID",
      "UID Number",
      "Primary UID",
      "Aadhaar Identifier"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Address",
      "Phone Number",
      "National ID",
      "Employee ID",
      "Tax ID",
      "Passport Number",
      "Customer ID"
    ],
    "explanation": "This semantic type identifies Aadhaar numbers in datasets where values are exactly 12 digits with no separators or letters. It is useful for recognizing and validating Aadhaar fields in records to support masking, tokenization, or data quality checks. The header patterns favor columns explicitly labeled with Aadhaar-related terms to reduce false positives against generic ID fields.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:24.970280"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.NHS_UK",
    "description": "This type represents the NHS number, a patient identifier used throughout the UK healthcare system for medical record tracking and service delivery. The number consists of ten digits and may be displayed with single spaces for readability but contains only numerical characters.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{3}\\s?\\d{3}\\s?\\d{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 2820,
    "headerPatterns": [
      {
        "regExp": "(?i).*nhs.*number.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "NHS Number"
        ],
        "negativeExamples": [
          "Health Number"
        ]
      },
      {
        "regExp": "(?i).*nhs.*id.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "NHS ID"
        ],
        "negativeExamples": [
          "Employee ID"
        ]
      },
      {
        "regExp": "(?i).*health.*number.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Health Number"
        ],
        "negativeExamples": [
          "Hospital Number"
        ]
      },
      {
        "regExp": "(?i).*nhs.*num.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "NHS Num"
        ],
        "negativeExamples": [
          "Order Num"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Number"
        ],
        "negativeExamples": [
          "Date"
        ]
      }
    ],
    "positiveContentExamples": [
      "943 476 5919",
      "1234567890",
      "401 023 0043",
      "987 654 3210",
      "070 123 4567",
      "2223334445",
      "555 000 1234",
      "319 847 6502"
    ],
    "negativeContentExamples": [
      "123-456-7890",
      "12345678901",
      "123 4567 890",
      "123 45 67890",
      "12345678O0",
      "12 3456 7890",
      "123  456  7890",
      "123/456/7890"
    ],
    "positiveHeaderExamples": [
      "NHS Number",
      "NHS ID",
      "Health Number",
      "NHS Patient Number",
      "NHS Identifier",
      "National Health Number",
      "NHS No",
      "Patient NHS Number"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Address",
      "Date of Birth",
      "Patient ID",
      "Hospital Number",
      "Insurance Number",
      "National ID",
      "Health Record ID"
    ],
    "explanation": "IDENTITY.NHS_UK identifies UK NHS numbers appearing as ten digits, optionally formatted with single spaces in a 3-3-4 grouping. It excludes non-digit separators (such as hyphens or slashes), alphabetic characters, and digit counts other than ten. Use this type to detect and validate patient identifiers in UK healthcare datasets, particularly where headers reference NHS or health numbers.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:25.034836"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.PERSONNUMMER_SE",
    "description": "This type represents the Swedish personal identity number, which encodes birth date information followed by a unique individual identifier. The number consists of ten digits where the first six represent YYMMDD birth date and the last four provide individual identification and gender information.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{2}(0[1-9]|1[0-2])(0[1-9]|[12][0-9]|3[01])[+-]?[0-9]{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2850,
    "headerPatterns": [
      {
        "regExp": "(?i).*(swedish|se).*personnummer.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Swedish Personnummer"
        ],
        "negativeExamples": [
          "Norwegian Personnummer"
        ]
      },
      {
        "regExp": "(?i).*(swedish|se).*(personal|person).*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Swedish Personal ID"
        ],
        "negativeExamples": [
          "Employee ID"
        ]
      },
      {
        "regExp": "(?i).*personnummer.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Personnummer"
        ],
        "negativeExamples": [
          "Person Name"
        ]
      },
      {
        "regExp": "(?i).*(pnr|persnr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Pnr"
        ],
        "negativeExamples": [
          "PNL"
        ]
      },
      {
        "regExp": "(?i).*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ID"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "850709-1234",
      "8507091234",
      "700101+1234",
      "921231-0042",
      "000101-2386",
      "9912011237",
      "650215+4321",
      "740101-7890"
    ],
    "negativeContentExamples": [
      "19850709-1234",
      "850709--1234",
      "850709 1234",
      "850709-123",
      "850709-12345",
      "851309-1234",
      "850000-1234",
      "SE850709-1234"
    ],
    "positiveHeaderExamples": [
      "Personnummer",
      "Personal ID",
      "Swedish ID",
      "Swedish Personnummer",
      "SE Person ID",
      "Pnr"
    ],
    "negativeHeaderExamples": [
      "Namn",
      "Adress",
      "Telefon",
      "Person Name",
      "Postal Code",
      "National Number"
    ],
    "explanation": "Swedish personal identity numbers commonly appear as YYMMDD-XXXX, YYMMDD+XXXX, or compact YYMMDDXXXX. This type validates a two-digit year, two-digit month, and two-digit day followed by an optional separator (+ or -) and four digits. It is suitable for identifying and validating Swedish personnummer in datasets while minimizing false positives through date-range checks for month and day and strict token boundaries.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:25.071244"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.VAT_<COUNTRY>",
    "description": "This type captures VAT registration numbers, which are unique tax identifiers assigned to businesses by tax authorities for value-added tax purposes. The format and length vary significantly by country but generally consists of alphanumeric characters with possible country-specific prefixes or formatting rules.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z]{2}[- ]?)?[A-Z0-9]{8,12}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 2890,
    "headerPatterns": [
      {
        "regExp": "(?i).*vat.*registration.*(number|no|id).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "VAT Registration Number"
        ],
        "negativeExamples": [
          "Tax ID"
        ]
      },
      {
        "regExp": "(?i).*(value[ -]?added[ -]?tax).*(number|no|id).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Value Added Tax Number"
        ],
        "negativeExamples": [
          "Company Name"
        ]
      },
      {
        "regExp": "(?i).*vat.*(number|no|id).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "VAT Number"
        ],
        "negativeExamples": [
          "Revenue"
        ]
      },
      {
        "regExp": "(?i).*tax.*(id|number|no).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Tax ID"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*id.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ID"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "DE123456789",
      "FR12A3456789",
      "GB123456789",
      "IT12345678901",
      "NL123456789B01",
      "ESX1234567X",
      "PL1234567890",
      "BE0123456789"
    ],
    "negativeContentExamples": [
      "DE1234567",
      "FR1234567890123",
      "GB 1234567",
      "DE12345A",
      "NL123456789B0123",
      "de1234567",
      "BE 0123 456 789",
      "GB-123-4567"
    ],
    "positiveHeaderExamples": [
      "VAT Number",
      "Tax ID",
      "VAT ID",
      "VAT Registration Number",
      "Value Added Tax Number",
      "Business VAT ID",
      "EU VAT Number",
      "VAT No"
    ],
    "negativeHeaderExamples": [
      "Company Name",
      "Revenue",
      "Country",
      "Tax Code",
      "Customer ID",
      "Invoice Number",
      "VAT Rate",
      "Tax Amount"
    ],
    "explanation": "IDENTITY.VAT_<COUNTRY> identifies business VAT registration numbers, optionally beginning with a two-letter country prefix followed by an 8\u201312 character alphanumeric sequence. It is useful for validating and classifying VAT identifiers in invoices, registrations, and compliance datasets across multiple countries.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:25.798981"
  },
  {
    "resultType": "generated",
    "semanticType": "INDUSTRY_CODE.NAICS",
    "description": "This type represents NAICS codes, which are hierarchical industry classification numbers used for statistical and regulatory purposes across North America. The code consists of exactly six digits where each digit level provides increasingly specific industry categorization from sector to industry detail.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 2910,
    "headerPatterns": [
      {
        "regExp": "(?i).*naics.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "NAICS Code"
        ],
        "negativeExamples": [
          "Industry Code"
        ]
      },
      {
        "regExp": "(?i).*industry.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Industry Code"
        ],
        "negativeExamples": [
          "Industry Name"
        ]
      },
      {
        "regExp": "(?i).*naics6.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "NAICS6"
        ],
        "negativeExamples": [
          "NAICS"
        ]
      },
      {
        "regExp": "(?i).*naics.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "NAICS"
        ],
        "negativeExamples": [
          "Business Type"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "221114",
      "311612",
      "541330",
      "236220",
      "518210",
      "624410",
      "423450",
      "722511"
    ],
    "negativeContentExamples": [
      "22111",
      "3116120",
      "54A330",
      "A236220",
      "518-210",
      "624 410",
      "42345",
      "72251A"
    ],
    "positiveHeaderExamples": [
      "NAICS Code",
      "Industry Code",
      "NAICS",
      "NAICS Classification",
      "NAICS6",
      "NAICS Industry Code",
      "NAICS6 Code"
    ],
    "negativeHeaderExamples": [
      "Industry Name",
      "Business Type",
      "Company Name",
      "Industry Description",
      "Business Category",
      "Sector",
      "Company Type"
    ],
    "explanation": "NAICS is a numeric industry classification where valid values are exactly six digits. This type is useful for identifying and validating NAICS codes in datasets, supporting tasks like industry segmentation, regulatory reporting, and analytics. Content validation relies on a strict six-digit pattern, while header patterns prioritize explicit NAICS mentions and code terminology to minimize false positives.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:25.926543"
  },
  {
    "resultType": "generated",
    "semanticType": "IPADDRESS.IPV4",
    "description": "This type identifies IPv4 addresses, which are 32-bit numerical identifiers used to uniquely identify devices on IP networks. The address consists of four decimal numbers separated by dots, where each number ranges from 0 to 255 representing one octet of the address.",
    "pluginType": "regex",
    "regexPattern": "\\b(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\\.(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2930,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bipv4\\b.*\\b(address|addr)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IPv4 Address"
        ],
        "negativeExamples": [
          "IP Address"
        ]
      },
      {
        "regExp": "(?i).*\\b(source|dest|client|server|public|private)\\b.*\\b(ip|ipv4)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Source IP"
        ],
        "negativeExamples": [
          "MAC Address"
        ]
      },
      {
        "regExp": "(?i).*\\b(ipv4|ip4)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IPv4"
        ],
        "negativeExamples": [
          "IP"
        ]
      },
      {
        "regExp": "(?i).*\\bip\\b.*\\b(address|addr)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IP Address"
        ],
        "negativeExamples": [
          "IPv6 Address"
        ]
      },
      {
        "regExp": "(?i).*\\bip\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IP"
        ],
        "negativeExamples": [
          "Domain Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "192.168.1.1",
      "10.0.0.254",
      "172.16.0.1",
      "8.8.8.8",
      "1.2.3.4",
      "0.0.0.0",
      "255.255.255.255",
      "203.0.113.10"
    ],
    "negativeContentExamples": [
      "256.100.0.1",
      "192.168.1",
      "192.168.1.1.1",
      "192.168.01.1",
      "1.2.3.-4",
      "1.2.3.4:80",
      "999.0.0.1",
      "192.168.1.1/24"
    ],
    "positiveHeaderExamples": [
      "IP Address",
      "IPv4",
      "IP",
      "Client IP",
      "Source IP",
      "Public IP",
      "IPv4 Address",
      "Device IP"
    ],
    "negativeHeaderExamples": [
      "Domain Name",
      "MAC Address",
      "Port Number",
      "Hostname",
      "URL",
      "Email Address",
      "Subnet Mask",
      "IPv6"
    ],
    "explanation": "IPv4 addresses are four decimal octets separated by dots, with each octet constrained to the range 0\u2013255. This semantic type helps detect and validate IPv4 address fields in datasets, ensuring values adhere to the expected numeric and structural constraints for IPv4 networking.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:30.665395"
  },
  {
    "resultType": "generated",
    "semanticType": "IMEI",
    "description": "Identifies the International Mobile Equipment Identity, a globally unique 15\u2011digit identifier assigned to mobile devices by manufacturers. The IMEI encodes manufacturer, model, and a device sequence plus a check digit. The expected representation is either a contiguous 15\u2011digit number or grouped as 8-6-1 using spaces or hyphens.",
    "pluginType": "regex",
    "regexPattern": "\\b(\\d{15}|\\d{8}[- ]\\d{6}[- ]\\d)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2900,
    "headerPatterns": [
      {
        "regExp": "(?i).*device.*imei.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Device IMEI"
        ],
        "negativeExamples": [
          "Device ID"
        ]
      },
      {
        "regExp": "(?i).*phone.*imei.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Phone IMEI"
        ],
        "negativeExamples": [
          "Phone Number"
        ]
      },
      {
        "regExp": "(?i).*mobile.*imei.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Mobile IMEI"
        ],
        "negativeExamples": [
          "Mobile Model"
        ]
      },
      {
        "regExp": "(?i).*imei[_ ]?(number|no).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IMEI Number"
        ],
        "negativeExamples": [
          "Serial Number"
        ]
      },
      {
        "regExp": "(?i).*imei.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IMEI"
        ],
        "negativeExamples": [
          "MEID"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "356938035643809",
      "490154203237518",
      "004401234567890",
      "869170030123456",
      "352099001761481",
      "357022004204282",
      "35693803-564380-9",
      "35693803 564380 9"
    ],
    "negativeContentExamples": [
      "35693803564380",
      "3569380356438097",
      "35693803-56438-09",
      "35693803564380A",
      "35693803_564380_9",
      "35-693803-564380-9",
      "35693-803564-3809",
      "35693803564 3809"
    ],
    "positiveHeaderExamples": [
      "IMEI",
      "Device IMEI",
      "Phone IMEI",
      "Mobile IMEI",
      "IMEI Number",
      "IMEI Code",
      "IMEI No"
    ],
    "negativeHeaderExamples": [
      "Phone Number",
      "Model",
      "Brand",
      "Device ID",
      "Serial Number",
      "MEID",
      "IMSI"
    ],
    "explanation": "This semantic type targets International Mobile Equipment Identity values. It accepts either a contiguous 15\u2011digit IMEI or a formatted variant split into 8-6-1 with spaces or hyphens. Use it to identify and validate device identity columns in telecom or device inventory datasets while avoiding broader identifiers like general device IDs or subscriber identifiers.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:33.237032"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.MIDDLE_INITIAL",
    "description": "Captures middle-name initials as found in abbreviated personal name formats and formal documentation. Values are a single alphabetic character that may be followed by a period, representing the abbreviated middle name.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z]\\.?>?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3080,
    "headerPatterns": [
      {
        "regExp": "(?i).*middle[ _-]*initial.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Middle Initial"
        ],
        "negativeExamples": [
          "Middle Name"
        ]
      },
      {
        "regExp": "(?i).*m[._ -]*initial.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "M Initial"
        ],
        "negativeExamples": [
          "Full Name"
        ]
      },
      {
        "regExp": "(?i).*\\bmi\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "MI"
        ],
        "negativeExamples": [
          "Middle"
        ]
      },
      {
        "regExp": "(?i).*initial.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Initial"
        ],
        "negativeExamples": [
          "First Name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Initial"
        ]
      }
    ],
    "positiveContentExamples": [
      "A",
      "B.",
      "c",
      "D.",
      "e.",
      "Z",
      "m."
    ],
    "negativeContentExamples": [
      "JR.",
      "J-K",
      "A.B",
      "JJ",
      "1.",
      ".",
      "J..",
      "J R"
    ],
    "positiveHeaderExamples": [
      "Middle Initial",
      "Middle",
      "Initial",
      "MI",
      "M Initial",
      "M. Initial",
      "Middle I"
    ],
    "negativeHeaderExamples": [
      "First Name",
      "Middle Name",
      "Full Name",
      "Suffix",
      "Initials",
      "Middle Initials",
      "Given Name",
      "First Initial"
    ],
    "explanation": "This semantic type is intended for single-character middle name abbreviations commonly used in personal name fields where space is limited or standardized formats are enforced. It helps distinguish middle initials from full middle names or other name components for parsing and normalization workflows.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:35.636390"
  },
  {
    "resultType": "generated",
    "semanticType": "LANGUAGE.ISO-639-2",
    "description": "This type identifies ISO 639-2 language codes, which are internationally standardized three-character alphabetic codes providing more comprehensive language coverage than the two-letter standard. The codes consist of exactly three lowercase letters and include both bibliographic and terminologic variants for some languages.",
    "pluginType": "regex",
    "regexPattern": "\\b[a-z]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 2970,
    "headerPatterns": [
      {
        "regExp": "(?i).*iso.*639.*2.*language.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISO 639-2 Language Code"
        ],
        "negativeExamples": [
          "Two Letter Code"
        ]
      },
      {
        "regExp": "(?i).*iso.*639.*2.*lang.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISO 639-2 Lang Code"
        ],
        "negativeExamples": [
          "ISO 639-1 Language Code"
        ]
      },
      {
        "regExp": "(?i).*iso.*language.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ISO Language"
        ],
        "negativeExamples": [
          "Language Name"
        ]
      },
      {
        "regExp": "(?i).*lang.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Lang Code"
        ],
        "negativeExamples": [
          "Lang Name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Language Code"
        ],
        "negativeExamples": [
          "Language Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "eng",
      "fra",
      "fre",
      "deu",
      "ger",
      "spa",
      "zho",
      "chi"
    ],
    "negativeContentExamples": [
      "EN",
      "Eng",
      "ENg",
      "en",
      "en1",
      "e-ng",
      "e ng",
      "en_g"
    ],
    "positiveHeaderExamples": [
      "Language Code",
      "ISO Language",
      "Lang Code",
      "ISO 639-2 Language Code",
      "ISO 639-2",
      "ISO Language Code",
      "ISO6392 Lang Code",
      "Language 3-letter Code"
    ],
    "negativeHeaderExamples": [
      "Language Name",
      "Country",
      "Two Letter Code",
      "ISO 639-1",
      "Locale",
      "Country Code",
      "Two-Letter Language Code",
      "Region"
    ],
    "explanation": "This semantic type detects three-letter ISO 639-2 language codes. It matches exactly three lowercase alphabetic characters as a standalone token and is intended for columns storing standardized language codes, including bibliographic and terminologic variants. Header patterns emphasize ISO and code context to reduce false positives when the value pattern alone could be ambiguous.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:35.900112"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.SUFFIX",
    "description": "This type captures name suffixes that appear after personal names to denote generational relationships, professional qualifications, or honorific designations. The values represent standard suffix abbreviations and designations used in formal naming conventions without including the preceding personal names.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "JR",
      "JR.",
      "SR",
      "SR.",
      "II",
      "III",
      "IV",
      "V",
      "VI",
      "VII",
      "VIII",
      "ESQ",
      "ESQ.",
      "MD",
      "M.D.",
      "PHD",
      "PH.D.",
      "DDS",
      "D.D.S.",
      "JD",
      "J.D.",
      "CPA",
      "RN",
      "MBA",
      "DO"
    ],
    "backout": "^(?:[IVX]{1,4}|[A-Z]{1,4}(\\.[A-Z]{1,4}){0,3}\\.?)$",
    "confidenceThreshold": 95,
    "priority": 3090,
    "headerPatterns": [
      {
        "regExp": "(?i).*name.*suffix.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name Suffix"
        ],
        "negativeExamples": [
          "Full Name"
        ]
      },
      {
        "regExp": "(?i).*person.*name.*suffix.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Person Name Suffix"
        ],
        "negativeExamples": [
          "Person Name"
        ]
      },
      {
        "regExp": "(?i).*suffix.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Suffix"
        ],
        "negativeExamples": [
          "Prefix"
        ]
      },
      {
        "regExp": "(?i).*(generation|generational).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Generation"
        ],
        "negativeExamples": [
          "Gender"
        ]
      },
      {
        "regExp": "(?i).*sfx.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Sfx"
        ],
        "negativeExamples": [
          "Suffixation"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "JR.",
      "SR",
      "III",
      "IV",
      "PH.D.",
      "M.D.",
      "ESQ",
      "CPA"
    ],
    "negativeContentExamples": [
      "JR SMITH",
      "SENIOR",
      "IV.",
      "P H D",
      "MD-",
      "ESQ,",
      "IIX",
      "JNR"
    ],
    "positiveHeaderExamples": [
      "Name Suffix",
      "Suffix",
      "Generation",
      "Person Name Suffix",
      "Name Gen",
      "Sfx",
      "Generational Indicator"
    ],
    "negativeHeaderExamples": [
      "First Name",
      "Last Name",
      "Full Name",
      "Prefix",
      "Middle Name",
      "Title",
      "Gender"
    ],
    "explanation": "Name suffix values are short tokens that follow a person's name to indicate generation (e.g., II, III, Jr, Sr) or professional/honorific qualifications (e.g., MD, PhD, Esq). This type isolates just the suffix token itself without any accompanying name or punctuation beyond what is standard for the suffix. It is useful for cleaning, parsing, and standardizing personal name fields by separating suffix information from given and family names.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:40.157712"
  },
  {
    "resultType": "generated",
    "semanticType": "LANGUAGE.TEXT_EN",
    "description": "This type captures natural language names as they are commonly expressed in English text and international communication. The values represent complete language names using standard English terminology and conventional spelling without abbreviated forms or codes.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z][a-z]{2,})([- ][A-Z][a-z]{2,}){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 2980,
    "headerPatterns": [
      {
        "regExp": "(?i).*language.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Language Name"
        ],
        "negativeExamples": [
          "Language Code"
        ]
      },
      {
        "regExp": "(?i).*spoken.*language.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Spoken Language"
        ],
        "negativeExamples": [
          "Programming Language"
        ]
      },
      {
        "regExp": "(?i).*lang.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Lang Name"
        ],
        "negativeExamples": [
          "Lang Code"
        ]
      },
      {
        "regExp": "(?i).*language.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Language"
        ],
        "negativeExamples": [
          "Country"
        ]
      }
    ],
    "positiveContentExamples": [
      "English",
      "Spanish",
      "Mandarin Chinese",
      "Brazilian Portuguese",
      "Old Church Slavonic",
      "Serbo-Croatian",
      "Canadian French",
      "Tamil"
    ],
    "negativeContentExamples": [
      "EN",
      "en-US",
      "English (US)",
      "Portuguese - Brazil",
      "Spanish/English",
      "english",
      "ENGLISH",
      "JavaScript"
    ],
    "positiveHeaderExamples": [
      "Language",
      "Language Name",
      "Spoken Language",
      "Primary Language",
      "Preferred Language",
      "Lang Name"
    ],
    "negativeHeaderExamples": [
      "Language Code",
      "Country",
      "Dialect",
      "Programming Language",
      "Country Name",
      "Locale",
      "Region",
      "Lang Code"
    ],
    "explanation": "Identifies full natural language names written in English without abbreviations or codes. Typical matches include single- or multi-token, title-cased names and common hyphenated forms (e.g., Serbo-Croatian). The pattern is strict enough to exclude codes, locales, and programming languages, while header patterns focus on columns clearly labeled as language names.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:42.100488"
  },
  {
    "resultType": "generated",
    "semanticType": "PERIOD.HALF",
    "description": "This type identifies half-year period designations as they appear in business reporting, academic scheduling, and temporal data organization. The values represent standardized half-year indicators using common abbreviations or descriptive terms to denote six-month periods within annual cycles.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(H\\s?(1|2)|(1|2)\\s?H|HY\\s?(1|2)|FIRST\\s+HALF|SECOND\\s+HALF)\\b([\\s\\-\\/]*(FY\\s?\\d{2,4}|\\d{4}|\\d{2}))?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 3120,
    "headerPatterns": [
      {
        "regExp": "(?i).*(half[\\s_\\-]*year|year[\\s_\\-]*half).*(fy|fiscal).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Half Year FY"
        ],
        "negativeExamples": [
          "Full Year FY"
        ]
      },
      {
        "regExp": "(?i).*(half[\\s_\\-]*year|year[\\s_\\-]*half).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Year Half"
        ],
        "negativeExamples": [
          "Quarter Year"
        ]
      },
      {
        "regExp": "(?i).*(\\b(h1|h2|1h|2h|hy|hy1|hy2)\\b).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "H1"
        ],
        "negativeExamples": [
          "Q1"
        ]
      },
      {
        "regExp": "(?i).*\\b(first\\s+half|second\\s+half)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Second Half"
        ],
        "negativeExamples": [
          "Second Quarter"
        ]
      },
      {
        "regExp": "(?i).*\\bhalf\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Half"
        ],
        "negativeExamples": [
          "Month"
        ]
      }
    ],
    "positiveContentExamples": [
      "H1 2023",
      "H2 2023",
      "1H 2021",
      "HY1 2022",
      "First Half 2020",
      "Second Half 2019",
      "H1 FY24",
      "H2-18"
    ],
    "negativeContentExamples": [
      "Q2 2023",
      "2023 H3",
      "FY2023",
      "06/2023",
      "S1 2022",
      "2HY 2021",
      "H 2020",
      "Half-Yearly 2023"
    ],
    "positiveHeaderExamples": [
      "Half Year",
      "Half",
      "Year Half",
      "Fiscal Half",
      "Half-Year Period",
      "HY",
      "H1/H2",
      "Semester"
    ],
    "negativeHeaderExamples": [
      "Quarter",
      "Month",
      "Full Year",
      "Fiscal Quarter",
      "Q1",
      "Year",
      "Half-Yearly",
      "Monthly Period"
    ],
    "explanation": "PERIOD.HALF targets values that explicitly denote a half-year period using common formats such as H1/H2, 1H/2H, HY1/HY2, or the descriptive forms First Half/Second Half, optionally paired with a 2- or 4-digit year or an FY year marker. It is useful for classifying time-based aggregations in financial reporting and academic scheduling where data is grouped by six-month spans.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:44.148500"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_BG",
    "description": "This type identifies Bulgarian postal codes as they appear in addressing and mail delivery systems within Bulgaria. The codes consist of exactly four numerical digits assigned to specific cities, regions, and postal delivery areas for efficient mail processing and routing.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 3230,
    "headerPatterns": [
      {
        "regExp": "(?i).*(bulgar|bg).*post.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Bulgarian Postal Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*\u043f\u043e\u0449\u0435\u043d\u0441\u043a\u0438.*\u043a\u043e\u0434.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u041f\u043e\u0449\u0435\u043d\u0441\u043a\u0438 \u043a\u043e\u0434"
        ],
        "negativeExamples": [
          "\u0413\u0440\u0430\u0434"
        ]
      },
      {
        "regExp": "(?i).*post.*code.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "City Code"
        ]
      },
      {
        "regExp": "(?i).*zip.*code.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "ZIP Code"
        ],
        "negativeExamples": [
          "Zip Area"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "1000",
      "1421",
      "1756",
      "4000",
      "5300",
      "7012",
      "8230",
      "9101"
    ],
    "negativeContentExamples": [
      "123",
      "12345",
      "12 34",
      "14-21",
      "1A34",
      "A234",
      "1421B",
      "12.34"
    ],
    "positiveHeaderExamples": [
      "\u041f\u043e\u0449\u0435\u043d\u0441\u043a\u0438 \u043a\u043e\u0434",
      "Postal Code",
      "Code",
      "Bulgarian Postal Code",
      "BG Postal Code",
      "Postcode",
      "ZIP Code"
    ],
    "negativeHeaderExamples": [
      "\u0413\u0440\u0430\u0434",
      "City",
      "Address",
      "Region Code",
      "Area Code",
      "Country",
      "Postal Area"
    ],
    "explanation": "Bulgarian postal codes are exactly four digits with no letters or separators. This semantic type helps identify columns containing these codes in mixed-language datasets and distinguishes them from other numeric identifiers by relying on header context and a strict four-digit token pattern.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:46.099465"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_CO",
    "description": "This type identifies Colombian postal codes as they appear in addressing and mail delivery systems within Colombia. The codes consist of exactly six numerical digits assigned to specific cities, departments, and postal delivery zones for efficient mail processing and routing.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3250,
    "headerPatterns": [
      {
        "regExp": "(?i).*colombia.*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Colombia Postal Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*c[o\u00f3]digo.*postal.*co.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "C\u00f3digo Postal CO"
        ],
        "negativeExamples": [
          "C\u00f3digo Postal"
        ]
      },
      {
        "regExp": "(?i).*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "ZIP"
        ]
      },
      {
        "regExp": "(?i).*zip.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ZIP Code"
        ],
        "negativeExamples": [
          "ZIP"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "City"
        ]
      }
    ],
    "positiveContentExamples": [
      "110111",
      "050001",
      "080020",
      "130001",
      "170004",
      "250051",
      "760001",
      "680006"
    ],
    "negativeContentExamples": [
      "11011",
      "1101111",
      "110 111",
      "110-111",
      "11A111",
      "CP110111",
      "110111CO",
      "110.111"
    ],
    "positiveHeaderExamples": [
      "C\u00f3digo Postal",
      "Postal Code",
      "ZIP",
      "C\u00f3digo Postal CO",
      "Colombia Postal Code",
      "ZIP Code",
      "Codigo Postal",
      "CP Colombia"
    ],
    "negativeHeaderExamples": [
      "Ciudad",
      "City",
      "Address",
      "State",
      "Street",
      "Pa\u00eds",
      "Provincia",
      "Region"
    ],
    "explanation": "Colombian postal codes are exactly six digits. This type uses a tight content regex with word boundaries to match only six consecutive digits, and header patterns in English and Spanish to disambiguate from generic six-digit identifiers. It is useful for validating and classifying address datasets where the column is expected to contain Colombia-specific postal codes.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:46.366349"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_AU",
    "description": "This type identifies Australian postal codes as they appear in addressing and mail delivery systems throughout Australia. The codes consist of exactly four numerical digits assigned to specific geographic regions, suburbs, and localities for efficient mail processing and delivery routing.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 3220,
    "headerPatterns": [
      {
        "regExp": "(?i).*(au|australia).*post.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "AU Postal Code"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*(postcode|post.*code).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Postcode"
        ],
        "negativeExamples": [
          "State"
        ]
      },
      {
        "regExp": "(?i).*(zip|pcode).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "ZIP"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "Region"
        ]
      }
    ],
    "positiveContentExamples": [
      "2000",
      "3000",
      "0800",
      "4217",
      "6000",
      "4870",
      "2601",
      "2026"
    ],
    "negativeContentExamples": [
      "200",
      "12345",
      "2O00",
      "20 00",
      "A200",
      "3000A",
      "2000-",
      "20.00"
    ],
    "positiveHeaderExamples": [
      "Postal Code",
      "Postcode",
      "ZIP",
      "AU Postal Code",
      "Australian Postcode",
      "PostalCode",
      "Post Code",
      "ZIP Code"
    ],
    "negativeHeaderExamples": [
      "City",
      "State",
      "Address",
      "Country",
      "Region",
      "Province",
      "Street",
      "Suburb"
    ],
    "explanation": "Identifies Australian postal codes formatted as exactly four digits, suitable for validating and classifying address-related fields. The value regex uses word boundaries to ensure standalone four-digit codes and avoid partial matches within longer strings. Header patterns progress from explicit AU/Australia postal code variants to the primitive 'code' term to catch common naming variations.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:49.372083"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTIFIER",
    "description": "This type represents a unique alphanumeric code assigned to individual records, entities, or objects for identification purposes. Values typically contain a mix of letters and digits and may include limited separators such as hyphen or underscore.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b([A-Z]+[A-Z0-9]*[0-9][A-Z0-9]*|[0-9]+[A-Z][A-Z0-9]*)([_-][A-Z0-9]{2,10}){0,4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2760,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bunique[_\\s-]*(identifier|id)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Unique ID"
        ],
        "negativeExamples": [
          "ID"
        ]
      },
      {
        "regExp": "(?i).*\\b(record|entity|object)[_\\s-]*(identifier|id)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Record ID"
        ],
        "negativeExamples": [
          "Description"
        ]
      },
      {
        "regExp": "(?i).*\\b(guid|uid)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "GUID"
        ],
        "negativeExamples": [
          "Date"
        ]
      },
      {
        "regExp": "(?i).*\\bidentifier\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Identifier"
        ],
        "negativeExamples": [
          "Name"
        ]
      },
      {
        "regExp": "(?i).*\\bid\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ID"
        ],
        "negativeExamples": [
          "Paid Amount"
        ]
      }
    ],
    "positiveContentExamples": [
      "A1B2C3",
      "CUST9",
      "U7_X9",
      "ACC2-XYZ4",
      "R3D2-77",
      "ID99_XY",
      "P4-QR8",
      "inv7a-01"
    ],
    "negativeContentExamples": [
      "INV-2023-001",
      "123456",
      "ABCDEF",
      "ID/123",
      "A-12345",
      "X YZ-123",
      "#ID99",
      "0000-0000"
    ],
    "positiveHeaderExamples": [
      "ID",
      "Identifier",
      "Unique ID",
      "Record ID",
      "Entity Identifier",
      "GUID",
      "UID",
      "Unique Identifier"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Description",
      "Date",
      "Status",
      "Amount",
      "Address",
      "Phone Number",
      "Created Date"
    ],
    "explanation": "Use this semantic type to detect columns containing general-purpose identifiers for records or entities, typically composed of alphanumeric tokens and optional separators like hyphen or underscore. It is intentionally conservative to reduce false positives by requiring a mix of letters and digits and avoiding purely alphabetic or numeric strings.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:56.948697"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.AGE",
    "description": "This type captures individual ages as they appear in demographic data, personal records, and age-related analysis using numerical year values. The values represent current age in completed years without fractional components, typically ranging from birth to advanced elderly ages.",
    "pluginType": "regex",
    "regexPattern": "\\b(0|[1-9]|[1-9]\\d|1[01]\\d|120)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 3150,
    "headerPatterns": [
      {
        "regExp": "(?i).*person.*age.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Person Age"
        ],
        "negativeExamples": [
          "Birth Year"
        ]
      },
      {
        "regExp": "(?i).*years.*old.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Years Old"
        ],
        "negativeExamples": [
          "Date of Birth"
        ]
      },
      {
        "regExp": "(?i).*customer.*age.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Customer Age"
        ],
        "negativeExamples": [
          "Name"
        ]
      },
      {
        "regExp": "(?i).*demograph.*age.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Demographic Age"
        ],
        "negativeExamples": [
          "DOB"
        ]
      },
      {
        "regExp": "(?i).*age.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Age"
        ],
        "negativeExamples": [
          "Age Group"
        ]
      }
    ],
    "positiveContentExamples": [
      "0",
      "1",
      "7",
      "12",
      "18",
      "35",
      "65",
      "120"
    ],
    "negativeContentExamples": [
      "-1",
      "121",
      "200",
      "07",
      "18.5",
      "30 years",
      "99+",
      "03"
    ],
    "positiveHeaderExamples": [
      "Age",
      "Person Age",
      "Years Old",
      "Customer Age",
      "Patient Age",
      "Demographic Age",
      "User Age"
    ],
    "negativeHeaderExamples": [
      "Birth Year",
      "Date of Birth",
      "Name",
      "Age Group",
      "DOB",
      "Birthdate"
    ],
    "explanation": "Represents a person's age in whole years, suitable for demographic, healthcare, and customer analytics datasets. Values are integers without units or decimals, typically within plausible human age ranges. Header cues emphasize human-centric age fields (e.g., person age, years old) to distinguish from birth dates or year fields.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:57.288781"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.RACE_EN",
    "description": "This type captures racial and ethnic designations as they appear in demographic surveys, census forms, and diversity analysis using complete descriptive terminology. The values represent standard racial and ethnic categories following established demographic classification systems with full English language terms. Values are full English descriptors, not abbreviations or codes.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "WHITE",
      "BLACK OR AFRICAN AMERICAN",
      "ASIAN",
      "AMERICAN INDIAN OR ALASKA NATIVE",
      "NATIVE HAWAIIAN OR OTHER PACIFIC ISLANDER",
      "HISPANIC OR LATINO",
      "NOT HISPANIC OR LATINO",
      "TWO OR MORE RACES",
      "MIDDLE EASTERN OR NORTH AFRICAN",
      "SOME OTHER RACE",
      "PREFER NOT TO SAY",
      "DECLINE TO STATE",
      "OTHER",
      "UNKNOWN",
      "EAST ASIAN",
      "SOUTH ASIAN",
      "AFRO-CARIBBEAN",
      "NORTH AFRICAN"
    ],
    "backout": "^[A-Z][A-Z /-]{2,49}$",
    "confidenceThreshold": 93,
    "priority": 3200,
    "headerPatterns": [
      {
        "regExp": "(?i).*(race|ethnic).*group.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Racial Group"
        ],
        "negativeExamples": [
          "Race Code"
        ]
      },
      {
        "regExp": "(?i).*(race|ethnicity).*category.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Race Category"
        ],
        "negativeExamples": [
          "Racial Group"
        ]
      },
      {
        "regExp": "(?i).*race[_ ]?grp.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "race_grp"
        ],
        "negativeExamples": [
          "race_code"
        ]
      },
      {
        "regExp": "(?i).*(race|ethnicity).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Race"
        ],
        "negativeExamples": [
          "Nationality"
        ]
      }
    ],
    "positiveContentExamples": [
      "WHITE",
      "BLACK OR AFRICAN AMERICAN",
      "ASIAN",
      "AMERICAN INDIAN OR ALASKA NATIVE",
      "NATIVE HAWAIIAN OR OTHER PACIFIC ISLANDER",
      "HISPANIC OR LATINO",
      "TWO OR MORE RACES",
      "MIDDLE EASTERN OR NORTH AFRICAN"
    ],
    "negativeContentExamples": [
      "BLACK",
      "AFRICAN AMERICAN",
      "WHITE (NON-HISPANIC)",
      "HISPANIC/ LATINO",
      "ASIAN PACIFIC ISLANDER",
      "TWO OR MORE",
      "RACE: ASIAN",
      "ETHNICITY UNKNOWN"
    ],
    "positiveHeaderExamples": [
      "Race",
      "Ethnicity",
      "Racial Group",
      "Race Category",
      "Ethnicity Group",
      "Ethnic Category"
    ],
    "negativeHeaderExamples": [
      "Race Code",
      "Nationality",
      "Country",
      "Language",
      "Customer Segment",
      "Postal Code",
      "Race Score",
      "Ethnicity Code"
    ],
    "explanation": "PERSON.RACE_EN identifies columns containing full English racial or ethnic descriptors used in demographics and diversity reporting (e.g., Black or African American, White, Hispanic or Latino). It targets human-readable category labels rather than compact codes, ensuring precise classification of survey-style responses.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:14:57.460263"
  },
  {
    "resultType": "generated",
    "semanticType": "IDENTITY.SSN_FR",
    "description": "This type represents the French social security number, officially called the INSEE number (Num\u00e9ro d'Inscription au R\u00e9pertoire, NIR), a 15-digit identifier encoding sex, year and month of birth, place code, an individual sequence, and a two-digit validation key. Values may appear as a continuous 15-digit string or formatted with spaces or hyphens between groups.",
    "pluginType": "regex",
    "regexPattern": "\\b[12]([\\s-]?[0-9]){14}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2880,
    "headerPatterns": [
      {
        "regExp": "(?i).*num[e\u00e9]ro.*insee.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Num\u00e9ro INSEE"
        ],
        "negativeExamples": [
          "Nom"
        ]
      },
      {
        "regExp": "(?i).*(s[e\u00e9]curit[e\u00e9].*sociale).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "S\u00e9curit\u00e9 Sociale"
        ],
        "negativeExamples": [
          "Adresse"
        ]
      },
      {
        "regExp": "(?i).*(nir|nss|insee).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "INSEE"
        ],
        "negativeExamples": [
          "Date de Naissance"
        ]
      },
      {
        "regExp": "(?i).*(national.*identification|national.*id|social.*security).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "National Identification"
        ],
        "negativeExamples": [
          "Code Postal"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Identification Code"
        ],
        "negativeExamples": [
          "Given Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "184127512345678",
      "284037512345690",
      "1 99 12 75 001 123 45",
      "2 03 01 13 456 789 30",
      "1-84-12-75-123-456-78",
      "2 07 09 20 321 654 12",
      "1 62 01 01 100 200 15",
      "2 85 12 75 123 456 97"
    ],
    "negativeContentExamples": [
      "384127512345678",
      "18412751234567",
      "2 84 12 75 123 456 789",
      "012345678901234",
      "X84127512345678",
      "1 84 12 75 AB3 456 78",
      "2-84-12-75-123-45-78",
      "2 84-12 75-123 456_78"
    ],
    "positiveHeaderExamples": [
      "Num\u00e9ro INSEE",
      "S\u00e9curit\u00e9 Sociale",
      "INSEE",
      "Num\u00e9ro S\u00e9curit\u00e9 Sociale",
      "NIR",
      "NSS",
      "National Identification",
      "French Social Security Number"
    ],
    "negativeHeaderExamples": [
      "Nom",
      "Adresse",
      "Date de Naissance",
      "Code Postal",
      "T\u00e9l\u00e9phone",
      "Email",
      "Num\u00e9ro de Client",
      "IBAN"
    ],
    "explanation": "French INSEE/NIR social security numbers are 15 digits and may be written contiguously or grouped with spaces or hyphens. The pattern enforces a leading gender digit (1 or 2) followed by 14 additional digits with optional separators, avoiding anchors to remain FTA-compatible while preventing over-broad matches.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:00.716527"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_CA",
    "description": "This type identifies Canadian postal codes as they appear in addressing and mail delivery systems throughout Canada. The codes follow a specific pattern of alternating letters and numbers in six characters, typically formatted with a space between the third and fourth characters for readability. The pattern permits either upper or lower case letters and accepts the format with or without the space.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b[ABCEGHJ-NPRSTVXY][0-9][ABCEGHJ-NPRSTV-Z] ?[0-9][ABCEGHJ-NPRSTV-Z][0-9]\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3240,
    "headerPatterns": [
      {
        "regExp": "(?i).*canad.*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Canadian Postal Code"
        ],
        "negativeExamples": [
          "Postal Code (CA)"
        ]
      },
      {
        "regExp": "(?i).*canad.*zip.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Canadian ZIP"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      },
      {
        "regExp": "(?i).*(postal.*code|postcode).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postcode"
        ],
        "negativeExamples": [
          "Tracking Code"
        ]
      },
      {
        "regExp": "(?i).*(pcode|pcode_ca|postal[_ ]?cd).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "pcode_ca"
        ],
        "negativeExamples": [
          "area code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "number"
        ]
      }
    ],
    "positiveContentExamples": [
      "K1A 0B1",
      "H0H 0H0",
      "M5V 3L9",
      "V6B 1A1",
      "T2P 2N1",
      "B3J 2K9",
      "R2C 4A5",
      "Y1A 0A1"
    ],
    "negativeContentExamples": [
      "K1A-0B1",
      "K1A0B",
      "W1A 0B1",
      "O1A 0B1",
      "K1D 0B1",
      "K1A 0Q1",
      "M5V 3L",
      "M5V3L9X"
    ],
    "positiveHeaderExamples": [
      "Postal Code",
      "Postcode",
      "Canadian ZIP",
      "CA Postal Code",
      "Postal Code (CA)",
      "Canada PostalCode",
      "PCode_CA",
      "Canadian Postcode"
    ],
    "negativeHeaderExamples": [
      "City",
      "Province",
      "Address",
      "Area Code",
      "ZIP Code",
      "Postal",
      "Country Code",
      "Billing Code"
    ],
    "explanation": "This semantic type targets Canadian postal codes with the canonical letter-digit-letter digit-letter-digit structure, allowing an optional single space between the third and fourth characters. It enforces Canadian-specific letter constraints (excluding D, F, I, O, Q, U in letter positions and disallowing W/Z in the first position) to reduce false positives from other alphanumeric identifiers. Use this to reliably identify Canadian mailing codes in address datasets or forms.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:01.217628"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_SE",
    "description": "This type identifies postal codes used within Sweden's postal system for mail sorting and delivery services. The structure consists of three digits, followed by a single space, then two additional digits without other formatting.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{3} [0-9]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 3340,
    "headerPatterns": [
      {
        "regExp": "(?i).*(sweden|swedish|se).*(postnummer|postal.*code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SE Postal Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*postnummer.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postnummer"
        ],
        "negativeExamples": [
          "Postort"
        ]
      },
      {
        "regExp": "(?i).*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "Postal Address"
        ]
      },
      {
        "regExp": "(?i).*(zip).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ZIP"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "111 22",
      "123 45",
      "752 36",
      "903 12",
      "412 63",
      "981 07",
      "217 62",
      "442 45"
    ],
    "negativeContentExamples": [
      "11122",
      "111-22",
      "SE 111 22",
      "SE-111 22",
      "11 122",
      "111 2A",
      "A11 22",
      "111 222"
    ],
    "positiveHeaderExamples": [
      "Postnummer",
      "Postal Code",
      "ZIP",
      "SE Postal Code",
      "Sweden Postnummer",
      "Customer ZIP Code",
      "Billing Postal Code",
      "Delivery Postnummer"
    ],
    "negativeHeaderExamples": [
      "Stad",
      "City",
      "Address",
      "Postort",
      "Country",
      "Province",
      "Street",
      "Region"
    ],
    "explanation": "Identifies Swedish postal codes formatted as three digits, a single space, and two digits (e.g., 123 45). Useful for validating and standardizing address components specific to Sweden, ensuring consistent parsing and geocoding workflows. The regex uses word boundaries to constrain matching to a standalone code token, avoiding prefixes or alternative separators.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:02.484271"
  },
  {
    "resultType": "generated",
    "semanticType": "PERIOD.YEAR_RANGE",
    "description": "This type captures year ranges as they appear in temporal data, historical records, and validity specifications using start and end year notation. The values represent time spans formatted with beginning and ending years connected by separators to indicate continuous or discrete time periods.",
    "pluginType": "regex",
    "regexPattern": "\\b[12][0-9]{3}\\b[ ]*([-\u2013\u2014/])[ ]*\\b[12][0-9]{3}\\b|\\b[12][0-9]{3}\\b[ ]+(to|through|thru)[ ]+\\b[12][0-9]{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 3140,
    "headerPatterns": [
      {
        "regExp": "(?i).*year[ _-]*range.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Year Range"
        ],
        "negativeExamples": [
          "Year"
        ]
      },
      {
        "regExp": "(?i).*date[ _-]*range.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Date Range"
        ],
        "negativeExamples": [
          "Single Date"
        ]
      },
      {
        "regExp": "(?i).*(year[ _-]*(interval|span|window)).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Year Interval"
        ],
        "negativeExamples": [
          "Month Range"
        ]
      },
      {
        "regExp": "(?i).*(years).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Years"
        ],
        "negativeExamples": [
          "Year"
        ]
      },
      {
        "regExp": "(?i).*date.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Date"
        ],
        "negativeExamples": [
          "Status"
        ]
      }
    ],
    "positiveContentExamples": [
      "1999-2003",
      "1980\u20131989",
      "2001 / 2005",
      "2010 to 2012",
      "2020\u20132021",
      "1990 through 1992",
      "1200-1300",
      "2000 - 2000"
    ],
    "negativeContentExamples": [
      "1999-03",
      "99-2003",
      "2020-2021-2022",
      "2020/202A",
      "FY2019-2020",
      "2000 to2005",
      "2005 \u2013",
      "20052007"
    ],
    "positiveHeaderExamples": [
      "Year Range",
      "Years",
      "Date Range",
      "Year Interval",
      "Time Range",
      "Years Covered",
      "Coverage Years",
      "Validity Years"
    ],
    "negativeHeaderExamples": [
      "Year",
      "Month",
      "Single Date",
      "Start Year",
      "End Year",
      "Age Range",
      "Timestamp",
      "Day"
    ],
    "explanation": "Identifies values that represent a start and end year connected by a clear separator, such as a hyphen, dash, slash, or the words 'to', 'through', or 'thru'. Useful for parsing validity windows, historical spans, and coverage periods where only years are provided. Patterns are constrained to four-digit years between 1000 and 2999 with explicit separators to avoid ambiguous matches.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:03.231330"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.MARITAL_STATUS_EN",
    "description": "This type captures marital status designations as they appear in demographic data, legal documents, and personal records using standard English terminology. The values represent recognized relationship states following conventional marital status categories without abbreviated forms or informal descriptions.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "SINGLE",
      "NEVER MARRIED",
      "MARRIED",
      "DIVORCED",
      "WIDOWED",
      "SEPARATED",
      "LEGALLY SEPARATED",
      "ANNULLED",
      "CIVIL UNION",
      "DOMESTIC PARTNERSHIP",
      "REGISTERED PARTNERSHIP",
      "COMMON LAW MARRIED"
    ],
    "backout": "^[A-Z ]{6,30}$",
    "confidenceThreshold": 96,
    "priority": 3180,
    "headerPatterns": [
      {
        "regExp": "(?i).*person.*marital[ _-]status.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Person Marital Status"
        ],
        "negativeExamples": [
          "Marital Status"
        ]
      },
      {
        "regExp": "(?i).*marital[ _-]status.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Marital Status"
        ],
        "negativeExamples": [
          "Marital Category"
        ]
      },
      {
        "regExp": "(?i).*marriage[ _-]status.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Marriage Status"
        ],
        "negativeExamples": [
          "Marriage Date"
        ]
      },
      {
        "regExp": "(?i).*relationship[ _-]status.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Relationship Status"
        ],
        "negativeExamples": [
          "Relationship Type"
        ]
      },
      {
        "regExp": "(?i).*mrtl.*status.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "MRTL Status"
        ],
        "negativeExamples": [
          "Rel Status"
        ]
      },
      {
        "regExp": "(?i).*status.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Status"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Single",
      "Never Married",
      "Married",
      "Divorced",
      "Widowed",
      "Separated",
      "Civil Union",
      "Domestic Partnership"
    ],
    "negativeContentExamples": [
      "Married (Separated)",
      "Marrried",
      "Single Parent",
      "Engaged",
      "Separated/Divorced",
      "Divorce",
      "Widower",
      "Status: Married"
    ],
    "positiveHeaderExamples": [
      "Marital Status",
      "Marriage Status",
      "Relationship Status",
      "Person Marital Status",
      "Applicant Marital Status",
      "Customer Marriage Status",
      "Marital Status Description"
    ],
    "negativeHeaderExamples": [
      "Age",
      "Gender",
      "Name",
      "Marriage Date",
      "Relationship Type",
      "Status Code",
      "Employment Status",
      "Customer Status"
    ],
    "explanation": "Identifies English-language marital status values in datasets where the field explicitly stores the spelled-out relationship state rather than a code or abbreviation. Useful for demographic analytics, eligibility rules, and identity record linking where normalized marital status terms are expected. This type intentionally excludes abbreviated codes (e.g., M, S, D, W), informal phrases, and compound or decorated values.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:04.054525"
  },
  {
    "resultType": "generated",
    "semanticType": "SSN",
    "description": "This type represents US Social Security Numbers used for individual identification and government benefit administration. The format consists of three digits, followed by a hyphen, two digits, another hyphen, then four final digits creating a structured nine-digit identifier.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{3}-\\d{2}-\\d{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3410,
    "headerPatterns": [
      {
        "regExp": "(?i).*(social[ _-]?security[ _-]?number).*",
        "confidence": 99,
        "mandatory": true,
        "positiveExamples": [
          "Social Security Number"
        ],
        "negativeExamples": [
          "Security Number"
        ]
      },
      {
        "regExp": "(?i).*(social[ _-]?security).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Social Security"
        ],
        "negativeExamples": [
          "Security Question"
        ]
      },
      {
        "regExp": "(?i).*(ssn).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "SSN"
        ],
        "negativeExamples": [
          "Session"
        ]
      },
      {
        "regExp": "(?i).*(soc[ _-]?sec).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Soc Sec"
        ],
        "negativeExamples": [
          "Account Sec"
        ]
      },
      {
        "regExp": "(?i).*(number).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Number"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "123-45-6789",
      "987-65-4321",
      "555-12-3456",
      "620-99-0001",
      "732-08-9045",
      "041-20-9876",
      "219-54-3012"
    ],
    "negativeContentExamples": [
      "123456789",
      "12-345-6789",
      "123-456-789",
      "123-45-678",
      "123-45-67890",
      "12A-45-6789",
      "123 -45-6789",
      "123_45_6789"
    ],
    "positiveHeaderExamples": [
      "SSN",
      "Social Security Number",
      "Social Security",
      "SSN Number",
      "Soc Sec Number",
      "SocialSecurity"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Date of Birth",
      "Tax ID",
      "Customer Name",
      "Birthdate",
      "National ID"
    ],
    "explanation": "IDENTITY.SSN detects hyphenated US Social Security Numbers in the form NNN-NN-NNNN using strict digit and separator placement. It is suited for identifying personal identifiers in datasets where the SSN appears in normalized, hyphenated format and column names reference Social Security.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:05.622806"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.DATE_OF_BIRTH",
    "description": "This type captures birth dates as they appear in personal identification documents, records, and biographical data using various date formatting conventions. The values represent complete birth dates including year, month, and day components formatted according to different regional and international date standards.",
    "pluginType": "regex",
    "regexPattern": "\\b((19[0-9]{2}|20[0-9]{2})[-/.](0?[1-9]|1[0-2])[-/.](0?[1-9]|[12][0-9]|3[01])|(0?[1-9]|1[0-2])[-/.](0?[1-9]|[12][0-9]|3[01])[-/.](19[0-9]{2}|20[0-9]{2})|(0?[1-9]|[12][0-9]|3[01])[-/.](0?[1-9]|1[0-2])[-/.](19[0-9]{2}|20[0-9]{2})|(0?[1-9]|[12][0-9]|3[01])\\s+([Jj]an(uary)?|[Ff]eb(ruary)?|[Mm]ar(ch)?|[Aa]pr(il)?|[Mm]ay|[Jj]un(e)?|[Jj]ul(y)?|[Aa]ug(ust)?|[Ss]ep(t)?(ember)?|[Oo]ct(ober)?|[Nn]ov(ember)?|[Dd]ec(ember)?)\\s+(19[0-9]{2}|20[0-9]{2})|([Jj]an(uary)?|[Ff]eb(ruary)?|[Mm]ar(ch)?|[Aa]pr(il)?|[Mm]ay|[Jj]un(e)?|[Jj]ul(y)?|[Aa]ug(ust)?|[Ss]ep(t)?(ember)?|[Oo]ct(ober)?|[Nn]ov(ember)?|[Dd]ec(ember)?)\\s+(0?[1-9]|[12][0-9]|3[01]),?\\s+(19[0-9]{2}|20[0-9]{2}))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 3170,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bdate[\\s_]*of[\\s_]*birth\\b.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Date of Birth"
        ],
        "negativeExamples": [
          "Issue Date"
        ]
      },
      {
        "regExp": "(?i).*\\bbirth[\\s_]*date\\b.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Birth Date"
        ],
        "negativeExamples": [
          "Birth Year"
        ]
      },
      {
        "regExp": "(?i).*\\bdob\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "DOB"
        ],
        "negativeExamples": [
          "job_title"
        ]
      },
      {
        "regExp": "(?i).*(\\bbdate\\b|birth[\\s_]*dt\\b).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "bdate"
        ],
        "negativeExamples": [
          "update_date"
        ]
      },
      {
        "regExp": "(?i).*\\bbirth\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "birth"
        ],
        "negativeExamples": [
          "Name"
        ]
      },
      {
        "regExp": "(?i).*\\bdate\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "date"
        ],
        "negativeExamples": [
          "Age"
        ]
      }
    ],
    "positiveContentExamples": [
      "1990-07-15",
      "07/15/1990",
      "15/07/1990",
      "1990/07/15",
      "15 Jul 1990",
      "July 15, 1990",
      "02.03.2001",
      "1 Apr 1975"
    ],
    "negativeContentExamples": [
      "07/15/90",
      "1990-15-07",
      "32/01/1990",
      "1990-07-15T00:00:00",
      "1990/07",
      "19900715",
      "1990_07_15",
      "15 Jul, 90"
    ],
    "positiveHeaderExamples": [
      "Date of Birth",
      "Birth Date",
      "DOB",
      "date_of_birth",
      "birth_dt",
      "bdate",
      "person_dob"
    ],
    "negativeHeaderExamples": [
      "Age",
      "Birth Year",
      "Name",
      "anniversary_date",
      "issue_date",
      "signup_date",
      "due_date"
    ],
    "explanation": "This semantic type identifies complete birth dates in common numeric and month-name formats, covering year-first, month-first, and day-first styles with clear separators and full four-digit years. It is suitable for columns storing personal date of birth values for identity verification, compliance checks, and demographic analytics.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:06.181567"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_FR",
    "description": "This type identifies French postal codes used for mail delivery across France and its territories. The structure requires exactly five numeric digits arranged consecutively without any separators, alphabetic characters, or formatting.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3280,
    "headerPatterns": [
      {
        "regExp": "(?i).*(code[ _-]?postal[ _-]?(fr|france)|french[ _-]?postal[ _-]?code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code Postal FR"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*(code[ _-]?postal|postal[ _-]?code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "City Code"
        ]
      },
      {
        "regExp": "(?i).*(\\bcp\\b|code[ _-]?postal).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CP"
        ],
        "negativeExamples": [
          "CPU"
        ]
      },
      {
        "regExp": "(?i).*postal.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal"
        ],
        "negativeExamples": [
          "Post Date"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "City"
        ]
      }
    ],
    "positiveContentExamples": [
      "75001",
      "13008",
      "31000",
      "97110",
      "97200",
      "97400",
      "97600",
      "98800"
    ],
    "negativeContentExamples": [
      "7500",
      "750010",
      "75 001",
      "75001-1234",
      "F-75001",
      "7500A",
      "FR75001",
      "7 5001"
    ],
    "positiveHeaderExamples": [
      "Code Postal",
      "CP",
      "Postal Code",
      "Code Postal FR",
      "French Postal Code",
      "Postcode FR"
    ],
    "negativeHeaderExamples": [
      "Ville",
      "City",
      "Address",
      "Province",
      "Country",
      "Street"
    ],
    "explanation": "French postal codes are five consecutive digits with no spaces, hyphens, or letters. This type helps validate and classify columns containing French metropolitan and overseas postal codes across diverse datasets.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:10.464790"
  },
  {
    "resultType": "generated",
    "semanticType": "PERIOD.QUARTER",
    "description": "This type identifies quarterly period designations as they appear in business reporting, financial analysis, and temporal data organization. The values represent standardized quarter indicators using common abbreviations to denote three-month periods within annual business or calendar cycles.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b((Q|QTR|QUARTER)\\s*[1-4]((\\s*[-/ ]\\s*)(FY\\s*)?((19|20)\\d{2}|\\d{2}))?)\\b|\\b(((FY\\s*)?((19|20)\\d{2}|\\d{2}))(\\s*[-/ ]\\s*|\\s+)(Q|QTR|QUARTER)\\s*[1-4])\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 3130,
    "headerPatterns": [
      {
        "regExp": "(?i).*(\\bquarterly\\b).*(\\bperiod\\b).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Quarterly Period"
        ],
        "negativeExamples": [
          "Quarterly Revenue"
        ]
      },
      {
        "regExp": "(?i).*(\\byear\\b).*(\\bquarter\\b).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Year Quarter"
        ],
        "negativeExamples": [
          "Half Year"
        ]
      },
      {
        "regExp": "(?i).*(\\bfiscal\\b).*(\\bquarter\\b).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Fiscal Quarter"
        ],
        "negativeExamples": [
          "Fiscal Year"
        ]
      },
      {
        "regExp": "(?i).*(\\bqtr\\b).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "QTR"
        ],
        "negativeExamples": [
          "Qty"
        ]
      },
      {
        "regExp": "(?i).*(\\bquarter\\b).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Quarter"
        ],
        "negativeExamples": [
          "Month"
        ]
      }
    ],
    "positiveContentExamples": [
      "Q1",
      "Q4 2024",
      "2023 Q3",
      "Q2-2021",
      "2020/Q4",
      "Quarter 2",
      "QTR3 2019",
      "FY24 Q1"
    ],
    "negativeContentExamples": [
      "Q5 2023",
      "Quarter 0",
      "H1 2024",
      "2023-Q0",
      "Q-3 2023",
      "2023Q4A",
      "04-2023",
      "Quarterly"
    ],
    "positiveHeaderExamples": [
      "Quarter",
      "Year Quarter",
      "Quarterly Period",
      "Fiscal Quarter",
      "Quarter Number",
      "QTR"
    ],
    "negativeHeaderExamples": [
      "Half Year",
      "Month",
      "Full Year",
      "Quarterly Revenue",
      "Quarter Start Date",
      "Quarterly Target"
    ],
    "explanation": "Identifies quarter indicators in datasets, supporting common formats such as Q1, Q2 2024, 2023 Q3, Quarter 2, QTR4 2019, and fiscal notations like FY24 Q1. Useful for classifying period fields used in financial and operational reporting where records are organized by quarter.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:10.815379"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_NL",
    "description": "This type identifies postal codes used in the Netherlands postal system for mail routing and delivery. The structure consists of four digits, followed by a single space, then two uppercase letters without additional formatting.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{4} [A-Z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3320,
    "headerPatterns": [
      {
        "regExp": "(?i).*(postal\\s*code|postcode).*nl.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "NL Postcode"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*postcode.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postcode"
        ],
        "negativeExamples": [
          "ZIP"
        ]
      },
      {
        "regExp": "(?i).*(postal\\s*code|zip\\s*code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*zip.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ZIP"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "Street"
        ]
      }
    ],
    "positiveContentExamples": [
      "1011 AB",
      "3512 BN",
      "2611 ES",
      "3011 AA",
      "7559 ZZ",
      "9401 HH",
      "4834 RD",
      "9999 XX"
    ],
    "negativeContentExamples": [
      "1011AB",
      "101 AB",
      "10111 AB",
      "1011 A",
      "1011 ABC",
      "1011 aB",
      "1011  AB",
      "1011-AB"
    ],
    "positiveHeaderExamples": [
      "Postcode",
      "Postal Code",
      "ZIP",
      "NL Postcode",
      "Netherlands Postal Code",
      "Delivery Postcode",
      "Customer ZIP",
      "Post Code"
    ],
    "negativeHeaderExamples": [
      "Stad",
      "City",
      "Address",
      "Street",
      "Province",
      "Country",
      "County",
      "Region"
    ],
    "explanation": "This semantic type captures the Dutch postal code format of four digits, a single space, and two uppercase letters (e.g., 1234 AB). It is useful for validating and classifying address-related fields specific to the Netherlands in customer, shipment, and location datasets.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:11.185649"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.LAST_FIRST",
    "description": "This type represents full personal names in the formal last name, first name format commonly used in official documents, directories, and alphabetical listings. The values combine family names and given names with a comma and space separator in the surname-first ordering convention.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z][A-Za-z'-]*( [A-Za-z][A-Za-z'-]*){0,3}, [A-Za-z][A-Za-z'-]*\\.?( [A-Za-z][A-Za-z'-]*\\.?)?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 3060,
    "headerPatterns": [
      {
        "regExp": "(?i).*last.*first.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Last First Name"
        ],
        "negativeExamples": [
          "First Name"
        ]
      },
      {
        "regExp": "(?i).*(surname.*given.*name|family.*given.*name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Surname Given Name"
        ],
        "negativeExamples": [
          "Email Address"
        ]
      },
      {
        "regExp": "(?i).*(last.*first|surname.*given).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Last First"
        ],
        "negativeExamples": [
          "Full Name"
        ]
      },
      {
        "regExp": "(?i).*(lname.*fname|ln.*fn|lf.*name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "lname_fname"
        ],
        "negativeExamples": [
          "last_name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Email Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "Smith, John",
      "O'Neil, Patrick",
      "Garcia Marquez, Gabriel",
      "De la Cruz, Juan",
      "Johnson, Mary Ann",
      "Nguyen, T.",
      "Lee, Ji-hoon",
      "Van Buren, Martin"
    ],
    "negativeContentExamples": [
      "John Smith",
      "Smith John",
      "Smith,John",
      "De la Cruz , Juan",
      ", John",
      "Smith,  John",
      "123, John",
      "Garcia, Maria, Elena"
    ],
    "positiveHeaderExamples": [
      "Full Name",
      "Name",
      "Last First Name",
      "Surname Given Name",
      "Last, First Name",
      "lname_fname",
      "Last First"
    ],
    "negativeHeaderExamples": [
      "First Name",
      "Last Name",
      "Email Address",
      "Given Name",
      "Surname",
      "Billing Address",
      "Username"
    ],
    "explanation": "This semantic type captures personal names written in the format 'Last, First' with a mandatory comma and single space after the surname. It supports multi-token surnames (e.g., compound family names), hyphens and apostrophes, and allows an optional second given-name token or initial. Use this to identify fields where names are organized for alphabetical listings or official records in surname-first order.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:11.797368"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.FIRST_LAST",
    "description": "This type represents full personal names formatted in the first name followed by last name order, which is common in Western naming conventions. The values combine given names and family names separated by a single space without including middle names, titles, or additional name components.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z][a-z]{1,}([-'][A-Z][a-z]{1,})? [A-Z][a-z]{1,}([-'][A-Z][a-z]{1,})?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3040,
    "headerPatterns": [
      {
        "regExp": "(?i).*full[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Full Name"
        ],
        "negativeExamples": [
          "First Name"
        ]
      },
      {
        "regExp": "(?i).*person[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Person Name"
        ],
        "negativeExamples": [
          "Username"
        ]
      },
      {
        "regExp": "(?i).*first[ _-]*last[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "First Last Name"
        ],
        "negativeExamples": [
          "Last Name"
        ]
      },
      {
        "regExp": "(?i).*(cust|client|contact)[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Customer Name"
        ],
        "negativeExamples": [
          "Customer Number"
        ]
      },
      {
        "regExp": "(?i).*(fname[ _-]*lname|first[ _-]*last).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fname_lname"
        ],
        "negativeExamples": [
          "lname"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Email Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "John Smith",
      "Mary-Jane O'Connor",
      "Alice Brown",
      "Peter O'Toole",
      "Anna-Marie Clarke",
      "David Johnson",
      "Sarah Lee",
      "Robert King"
    ],
    "negativeContentExamples": [
      "John A Smith",
      "Dr John Smith",
      "John Smith Jr",
      "John  Smith",
      "JOHN SMITH",
      "John",
      "Smith, John",
      "John-Smith"
    ],
    "positiveHeaderExamples": [
      "Full Name",
      "Name",
      "Person Name",
      "First Last Name",
      "Customer Name",
      "fname_lname"
    ],
    "negativeHeaderExamples": [
      "First Name",
      "Last Name",
      "Email Address",
      "Username",
      "Customer Number",
      "Given Name"
    ],
    "explanation": "This semantic type targets two-token personal names in the order First Last, separated by a single space, with optional internal hyphen or apostrophe in each token (e.g., Mary-Jane, O'Connor). It excludes middle names/initials, prefixes (titles), and suffixes. Typical use cases include customer, employee, or contact lists where a concise first\u2013last format is expected.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:12.507755"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.CANTON_CH",
    "description": "This type represents official Swiss canton codes used for identifying federal states within Switzerland's administrative system. The format consists of exactly two uppercase letters derived from the canton names without spaces, numbers, or special characters.",
    "pluginType": "regex",
    "regexPattern": "\\b(AG|AI|AR|BE|BL|BS|FR|GE|GL|GR|JU|LU|NE|NW|OW|SG|SH|SO|SZ|TG|TI|UR|VD|VS|ZG|ZH)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3420,
    "headerPatterns": [
      {
        "regExp": "(?i).*(swiss|ch).*(canton|kanton|kt).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CH Canton Code"
        ],
        "negativeExamples": [
          "Canton Name"
        ]
      },
      {
        "regExp": "(?i).*(canton|kanton|kt).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Canton Code"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*(canton|kanton|kt).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Kanton"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(kt).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "KT Code"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "ZH",
      "BE",
      "LU",
      "GR",
      "VS",
      "GE",
      "TI",
      "AG"
    ],
    "negativeContentExamples": [
      "zh",
      "ZH1",
      "Z H",
      "ZZ",
      "CH",
      "BE-",
      "ARL",
      "VD/VS"
    ],
    "positiveHeaderExamples": [
      "Canton Code",
      "Kanton",
      "Canton",
      "CH Canton Code",
      "Swiss Kanton Code",
      "KT Code",
      "Canton Abbrev",
      "Canton ID"
    ],
    "negativeHeaderExamples": [
      "Canton Name",
      "Country",
      "City",
      "Country Code",
      "Province Code",
      "County Code",
      "Canton Description",
      "Region"
    ],
    "explanation": "Swiss canton codes are a fixed set of two-letter uppercase abbreviations for Switzerland\u2019s 26 cantons. Use this type to validate and classify columns or fields that contain these codes (e.g., for regional segmentation, mapping, or administrative reporting). The pattern enumerates the valid codes and uses word boundaries to avoid accidental matches within longer strings.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:13.024108"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_UK",
    "description": "This type captures UK postcodes used for mail routing throughout the United Kingdom postal system. The format includes an outward code of letters and numbers, followed by a space, then an inward code of one digit and two letters.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z][0-9][A-Z]|[A-Z][0-9]{2}|[A-Z]{2}[0-9][A-Z]|[A-Z]{2}[0-9]{2}|[A-Z]{2}[0-9]|[A-Z][0-9])\\s[0-9][A-Z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3350,
    "headerPatterns": [
      {
        "regExp": "(?i).*(uk|gb|united kingdom).*(post.?code|postcode|zip).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "UK Postcode"
        ],
        "negativeExamples": [
          "Postcode"
        ]
      },
      {
        "regExp": "(?i).*(postcode|post.?code|zip.?code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Post Code"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*\\b(pcode|p\\.?.?code)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "PCode"
        ],
        "negativeExamples": [
          "PC"
        ]
      },
      {
        "regExp": "(?i).*\\bzip\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ZIP"
        ],
        "negativeExamples": [
          "ZIPCODE"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "ZIP"
        ]
      }
    ],
    "positiveContentExamples": [
      "EC1A 1BB",
      "W1A 0AX",
      "M1 1AE",
      "B33 8TH",
      "CR2 6XH",
      "DN55 1PT",
      "SW1W 0NY",
      "L1 8JQ"
    ],
    "negativeContentExamples": [
      "EC1A1BB",
      "sw1a 1aa",
      "EC1A 11B",
      "E111 1BB",
      "W1A 0A",
      "SW1W-0NY",
      "M1 1AEJ",
      "AA 1BB"
    ],
    "positiveHeaderExamples": [
      "Postcode",
      "Post Code",
      "UK ZIP",
      "UK Postcode",
      "Postal Code",
      "GB Post Code",
      "ZIP Code",
      "Customer Postcode"
    ],
    "negativeHeaderExamples": [
      "City",
      "County",
      "Address",
      "Country Code",
      "Error Code",
      "ZIP+4",
      "Area Code",
      "Province"
    ],
    "explanation": "Detects UK postal codes (postcodes) in data by enforcing standard outward\u2013inward structure with a mandatory single space and uppercase alphanumeric tokens. Useful for address validation, geocoding, and normalization of UK address fields in customer, logistics, and compliance datasets.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:13.067143"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.ZIP5_PLUS4_US",
    "description": "This type captures extended US postal codes used for precise mail delivery within the United States Postal Service system. The format consists of five digits, followed by a hyphen, then four additional digits creating a nine-digit postal identifier.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{5}-\\d{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3370,
    "headerPatterns": [
      {
        "regExp": "(?i).*zip[ _-]*\\+4.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "ZIP+4"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      },
      {
        "regExp": "(?i).*zip[ _-]*plus[ _-]*4.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "zip_plus_4"
        ],
        "negativeExamples": [
          "zip5"
        ]
      },
      {
        "regExp": "(?i).*extended[ _-]*zip.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Extended ZIP"
        ],
        "negativeExamples": [
          "Extended"
        ]
      },
      {
        "regExp": "(?i).*zip[ _-]*code.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "ZIP Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "ZIP"
        ]
      }
    ],
    "positiveContentExamples": [
      "02138-1234",
      "10001-0001",
      "30303-1234",
      "85001-4321",
      "48226-7890",
      "94105-0012",
      "60614-0987",
      "73102-3456"
    ],
    "negativeContentExamples": [
      "02138",
      "021381234",
      "02138 - 1234",
      "02138\u20131234",
      "2138-1234",
      "02138-123",
      "02138-12345",
      "A2138-1234"
    ],
    "positiveHeaderExamples": [
      "ZIP+4",
      "ZIP Code",
      "Extended ZIP",
      "zip_plus_4",
      "zip_code_plus4",
      "recipient_zip+4",
      "postal_code_plus_4",
      "usps_zip+4"
    ],
    "negativeHeaderExamples": [
      "City",
      "State",
      "ZIP Code",
      "Zip",
      "Zip4",
      "Zip5",
      "Postal Code",
      "Address Code"
    ],
    "explanation": "This semantic type detects the USPS ZIP+4 format used in U.S. addresses, enabling precise routing and delivery. Values must be exactly five digits, a hyphen, and four digits, with no spaces or other separators.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:13.845536"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_DE",
    "description": "This type identifies German postal codes (Postleitzahl) as they appear in addressing and mail delivery systems within Germany. The codes consist of exactly five numerical digits assigned to specific cities, districts, and postal delivery areas following the German postal system structure.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 3260,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\b(de|deu|germany|german)\\b.*\\bpostal\\b.*\\bcode\\b.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "DE Postal Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*\\bpostleitzahl\\b.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Postleitzahl"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*\\bplz\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "PLZ"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*\\bpostal\\b.*\\bcode\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "10115",
      "01067",
      "20095",
      "50667",
      "80331",
      "60549",
      "30159",
      "68159"
    ],
    "negativeContentExamples": [
      "1011",
      "101150",
      "D-10115",
      "10 115",
      "0106O",
      "10115-0001",
      "A1015",
      "1011-5"
    ],
    "positiveHeaderExamples": [
      "Postleitzahl",
      "PLZ",
      "Postal Code",
      "DE Postal Code",
      "German Postal Code",
      "Postleitzahl DE",
      "Empf\u00e4nger PLZ",
      "PLZ DE"
    ],
    "negativeHeaderExamples": [
      "Stadt",
      "City",
      "Address",
      "ZIP Code",
      "Province",
      "Area Code",
      "Name",
      "Country"
    ],
    "explanation": "German postal codes are exactly five digits and may include leading zeros. This semantic type uses a strict digit count with word boundaries to avoid matching embedded digit sequences, and header patterns prioritize German-specific terms like Postleitzahl and PLZ to distinguish from other 5-digit numeric fields.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:18.327479"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.ZIP5_US",
    "description": "This type represents standard US postal codes used for mail routing throughout the United States Postal Service network. The format consists of exactly five consecutive numeric digits without spaces, hyphens, or any additional formatting characters.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3380,
    "headerPatterns": [
      {
        "regExp": "(?i).*zip[-_ ]?code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ZIP Code"
        ],
        "negativeExamples": [
          "ZIP+4"
        ]
      },
      {
        "regExp": "(?i).*postal[-_ ]?code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*zip5.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ZIP5"
        ],
        "negativeExamples": [
          "State"
        ]
      },
      {
        "regExp": "(?i).*zip.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ZIP"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "City"
        ]
      }
    ],
    "positiveContentExamples": [
      "00501",
      "02139",
      "07030",
      "10001",
      "30309",
      "60611",
      "85001",
      "94105"
    ],
    "negativeContentExamples": [
      "1234",
      "123456",
      "12345-6789",
      "12 345",
      "12345A",
      "A12345",
      "12.345",
      "0000"
    ],
    "positiveHeaderExamples": [
      "ZIP Code",
      "ZIP",
      "Postal Code",
      "ZIP5",
      "ZipCode",
      "US ZIP Code",
      "Primary ZIP"
    ],
    "negativeHeaderExamples": [
      "City",
      "State",
      "ZIP+4",
      "Country",
      "Address",
      "Area Code",
      "Province",
      "Postal"
    ],
    "explanation": "This semantic type targets five-digit U.S. ZIP codes with no additional formatting, enabling precise identification of standard USPS ZIP5 fields. It is useful for validating and classifying datasets where ZIP5 values appear as standalone numeric tokens without ZIP+4 extensions or separators.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:21.638392"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.LAST",
    "description": "This type captures family names or surnames as they appear in personal identification and formal documentation across different cultures. The values represent last names using standard spelling and formatting conventions without including given names, middle names, or honorific titles.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]+(['\u2019\\-][A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]{2,})?)( [A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]+(['\u2019\\-][A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]{2,})?){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3050,
    "headerPatterns": [
      {
        "regExp": "(?i).*(last.*name|name.*last).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Customer Last Name"
        ],
        "negativeExamples": [
          "Full Name"
        ]
      },
      {
        "regExp": "(?i).*surname.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Surname"
        ],
        "negativeExamples": [
          "Middle Name"
        ]
      },
      {
        "regExp": "(?i).*family.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Family Name"
        ],
        "negativeExamples": [
          "First Name"
        ]
      },
      {
        "regExp": "(?i).*(person|applicant|customer).*(last|family).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Applicant Family Name"
        ],
        "negativeExamples": [
          "Account Name"
        ]
      },
      {
        "regExp": "(?i).*(lname|l_name|last_nm|sur_name|sname).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "l_name"
        ],
        "negativeExamples": [
          "first_nm"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Smith",
      "O'Connor",
      "D\u2019Angelo",
      "Garc\u00eda",
      "Nguyen",
      "van der Meer",
      "De la Cruz",
      "Al-Saud"
    ],
    "negativeContentExamples": [
      "Mr. Smith",
      "Smith Jr.",
      "Smith, John",
      "J.",
      "O' Brian",
      "SM1TH",
      "O''Connor",
      "Jean-Luc."
    ],
    "positiveHeaderExamples": [
      "Last Name",
      "Surname",
      "Family Name",
      "Customer Last Name",
      "User Surname",
      "Applicant Family Name",
      "l_name",
      "last_nm"
    ],
    "negativeHeaderExamples": [
      "First Name",
      "Full Name",
      "Middle Name",
      "Given Name",
      "Contact Name",
      "Display Name",
      "Account Name",
      "Username"
    ],
    "explanation": "NAME.LAST identifies standalone family names/surnames, including multi-token names with particles (e.g., van, de, la) and names containing hyphens or apostrophes. It supports diacritics and common punctuation within names while excluding titles, suffixes, initials, and compound person strings that include given names. Typical use cases include validating and classifying fields that specifically store a person's last/family name in customer, applicant, or identity records.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:21.895094"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_PT",
    "description": "This type represents postal codes used within Portugal's postal system for mail routing and delivery. The format consists of four digits, followed by a hyphen, then three additional digits creating a structured seven-digit identifier.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{4}-\\d{3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3330,
    "headerPatterns": [
      {
        "regExp": "(?i).*(portugal|pt).*(c[o\u00f3]digo postal|postal code|postcode).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "PT Postal Code"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*(c[o\u00f3]digo postal|postal code|postcode).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "C\u00f3digo Postal"
        ],
        "negativeExamples": [
          "Cidade"
        ]
      },
      {
        "regExp": "(?i).*\\bcp\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CP"
        ],
        "negativeExamples": [
          "CEP"
        ]
      },
      {
        "regExp": "(?i).*\\bpostal\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal"
        ],
        "negativeExamples": [
          "Post"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "1000-001",
      "1200-123",
      "1990-099",
      "3000-456",
      "4000-010",
      "5000-999",
      "9000-111",
      "2765-001"
    ],
    "negativeContentExamples": [
      "1234 567",
      "1234-56",
      "12345-678",
      "12-345",
      "1234_567",
      "123a-456",
      "1234-56a",
      "123-4567"
    ],
    "positiveHeaderExamples": [
      "C\u00f3digo Postal",
      "CP",
      "Postal Code",
      "codigo_postal",
      "pt_postal_code",
      "postcode_pt",
      "codigo-postal",
      "Portugal Postal Code"
    ],
    "negativeHeaderExamples": [
      "Cidade",
      "City",
      "Address",
      "country",
      "province",
      "street",
      "postal area",
      "zip"
    ],
    "explanation": "Portuguese postal codes follow a strict 4-digit hyphen 3-digit format (NNNN-NNN). This semantic type targets that exact structure for datasets containing Portugal-specific postal codes and supports common header naming variants including Portuguese and English terms.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:24.376699"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_ES",
    "description": "This type represents postal codes used within Spain's postal system for mail sorting and delivery. The format consists of exactly five consecutive numeric digits with no spaces, letters, or special characters.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 3270,
    "headerPatterns": [
      {
        "regExp": "(?i).*customer.*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_postal_code"
        ],
        "negativeExamples": [
          "customer_postal_address"
        ]
      },
      {
        "regExp": "(?i).*codigo.*postal.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "C\u00f3digo Postal"
        ],
        "negativeExamples": [
          "Ciudad"
        ]
      },
      {
        "regExp": "(?i).*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*\\bcp\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CP"
        ],
        "negativeExamples": [
          "CPU"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "City"
        ]
      }
    ],
    "positiveContentExamples": [
      "28013",
      "08001",
      "46001",
      "41001",
      "29015",
      "35010",
      "15001",
      "07012"
    ],
    "negativeContentExamples": [
      "2801",
      "280130",
      "28 013",
      "28-013",
      "28A13",
      "2801B",
      "028.13",
      "28013.0"
    ],
    "positiveHeaderExamples": [
      "C\u00f3digo Postal",
      "CP",
      "Postal Code",
      "customer_postal_code",
      "billing_postal_code",
      "shipping_cp",
      "postal_code_es",
      "codigo_postal"
    ],
    "negativeHeaderExamples": [
      "Ciudad",
      "City",
      "Address",
      "Province Code",
      "Area Code",
      "Postal Address",
      "Country Code",
      "Zip Plus4"
    ],
    "explanation": "Spanish postal codes are five-digit numeric identifiers used for mail routing within Spain. This semantic type targets values that are exactly five digits with no separators or letters, using header cues like 'C\u00f3digo Postal', 'CP', and 'Postal Code' to reinforce intent.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:26.272667"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_UY",
    "description": "This type represents postal codes used within Uruguay's postal system for mail routing and delivery services. The format consists of exactly five consecutive numeric digits without spaces, hyphens, or any non-numeric formatting characters.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3360,
    "headerPatterns": [
      {
        "regExp": "(?i).*(uruguay|\\buy\\b).*(postal.*code|c[o\u00f3]digo.*postal).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Uruguay Postal Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*(shipping|billing|delivery|recipient|customer).*(postal.*code|c[o\u00f3]digo.*postal|\\bcp\\b).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Shipping C\u00f3digo Postal"
        ],
        "negativeExamples": [
          "C\u00f3digo Postal"
        ]
      },
      {
        "regExp": "(?i).*(postal.*code|c[o\u00f3]digo.*postal).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "C\u00f3digo Postal"
        ],
        "negativeExamples": [
          "Ciudad"
        ]
      },
      {
        "regExp": "(?i).*\\bcp\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "CP"
        ],
        "negativeExamples": [
          "CPU"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "11000",
      "11300",
      "12050",
      "20000",
      "25010",
      "30120",
      "45000",
      "60050"
    ],
    "negativeContentExamples": [
      "1234",
      "123456",
      "12 345",
      "12-345",
      "12A45",
      "A2345",
      "1234B",
      "123.45"
    ],
    "positiveHeaderExamples": [
      "C\u00f3digo Postal",
      "CP",
      "Postal Code",
      "Uruguay Postal Code",
      "Shipping C\u00f3digo Postal",
      "Delivery CP",
      "Customer Postal Code",
      "C\u00f3digo Postal UY"
    ],
    "negativeHeaderExamples": [
      "Ciudad",
      "City",
      "Address",
      "Country",
      "Province",
      "Zip Code",
      "Postal Area",
      "Location"
    ],
    "explanation": "Uruguay postal codes are strictly five digits with no separators or letters. This semantic type helps identify and validate columns containing Uruguayan postal codes in multilingual datasets, including English and Spanish headers and common abbreviations like CP.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:30.596140"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_MX",
    "description": "This type represents postal codes used within Mexico's national postal system for mail delivery services. The format consists of exactly five consecutive numeric digits with no spaces, letters, hyphens, or other formatting characters.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3310,
    "headerPatterns": [
      {
        "regExp": "(?i).*c[o\u00f3]digo.*postal.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "C\u00f3digo Postal"
        ],
        "negativeExamples": [
          "C\u00f3digo \u00c1rea"
        ]
      },
      {
        "regExp": "(?i).*postal.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*\\bcp\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CP"
        ],
        "negativeExamples": [
          "CPU"
        ]
      },
      {
        "regExp": "(?i).*postcode.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Postcode"
        ],
        "negativeExamples": [
          "Postdate"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "City"
        ]
      }
    ],
    "positiveContentExamples": [
      "01000",
      "06010",
      "10020",
      "27089",
      "52930",
      "64000",
      "87015",
      "99960"
    ],
    "negativeContentExamples": [
      "1234",
      "123456",
      "1234A",
      "12 345",
      "12-345",
      "AB123",
      "123 45",
      "A123B"
    ],
    "positiveHeaderExamples": [
      "C\u00f3digo Postal",
      "CP",
      "Postal Code",
      "Codigo Postal",
      "Postcode",
      "PostalCode"
    ],
    "negativeHeaderExamples": [
      "Ciudad",
      "City",
      "Address",
      "Country",
      "State",
      "Area Code"
    ],
    "explanation": "Recognizes Mexican postal codes as exactly five digits with no separators or letters. Useful for validating and standardizing address data fields specifically intended to store Mexico\u2019s C\u00f3digo Postal (CP). High threshold and cautious header patterns reduce ambiguity with other five-digit numeric fields.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:34.039331"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_IN",
    "description": "This type represents Indian Postal Index Numbers used for mail routing throughout India. The format requires exactly six consecutive numeric digits without spaces, hyphens, or any non-numeric characters.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{6}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 3290,
    "headerPatterns": [
      {
        "regExp": "(?i).*india.*pin.*code.*",
        "confidence": 99,
        "mandatory": true,
        "positiveExamples": [
          "India PIN Code"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*india.*postal.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Indian Postal Code"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*pin.*code.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "PIN Code"
        ],
        "negativeExamples": [
          "ZIP"
        ]
      },
      {
        "regExp": "(?i).*postal.*code.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Postal Code"
        ],
        "negativeExamples": [
          "State"
        ]
      },
      {
        "regExp": "(?i).*zip.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ZIP"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "560001",
      "110001",
      "400001",
      "700001",
      "600001",
      "302001",
      "500081",
      "682001"
    ],
    "negativeContentExamples": [
      "560 001",
      "560-001",
      "5600011",
      "56001",
      "A60001",
      "560O01",
      "560_001",
      "ZIP560001"
    ],
    "positiveHeaderExamples": [
      "PIN Code",
      "Postal Code",
      "ZIP",
      "India PIN Code",
      "Indian Postal Code",
      "Pincode",
      "Postcode",
      "ZIP Code"
    ],
    "negativeHeaderExamples": [
      "City",
      "State",
      "Address",
      "Area Code",
      "Country Code",
      "Zip+4",
      "Postal Zone",
      "PIN Status"
    ],
    "explanation": "Identifies Indian PIN codes in datasets by matching exactly six consecutive digits with word boundaries, rejecting spaces, hyphens, or alphabetic characters. Useful for validating and extracting Indian postal codes from address data, shipping records, and geolocation datasets.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:35.991704"
  },
  {
    "resultType": "generated",
    "semanticType": "CURRENCY.TEXT_EN",
    "description": "This type captures the complete names of currencies as they are expressed in English for international financial and economic contexts. The values represent standard currency terminology using proper English names without codes, symbols, or abbreviated forms.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b([a-z]{3,}(?: [a-z]{3,}){0,4} )?(afghani|ariary|baht|balboa|birr|bolivar|boliviano|cedi|colon|cordoba|dalasi|denar|dinar|dirham|dobra|dong|dram|escudo|euro|forint|franc|gourde|guarani|hryvnia|kip|krona|krone|kroner|kronor|kronur|kroon|kuna|kwacha|kwanza|lari|lek|leone|leu|lev|lilangeni|lira|loti|manat|metical|naira|ngultrum|new shekel|ouguiya|paanga|pataca|peso|pound sterling|pound|pula|quetzal|rand|real|reais|rial|riel|ringgit|riyal|ruble|rufiyaa|rupee|shekel|shilling|sol|som|somoni|taka|tala|tenge|tugrik|won|yen|yuan|zloty)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 2560,
    "headerPatterns": [
      {
        "regExp": "(?i).*(currency.*english.*name|english.*currency.*name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Currency English Name"
        ],
        "negativeExamples": [
          "Currency Name"
        ]
      },
      {
        "regExp": "(?i).*(official.*currency.*name|currency.*full.*name|currency.*long.*name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Official Currency Name"
        ],
        "negativeExamples": [
          "Currency Code"
        ]
      },
      {
        "regExp": "(?i).*(currency.*name|name.*of.*currency).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Currency Name"
        ],
        "negativeExamples": [
          "Currency"
        ]
      },
      {
        "regExp": "(?i).*(currency|monetary.*unit).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Currency"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(money|curr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Money"
        ],
        "negativeExamples": [
          "Amount"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "United States dollar",
      "Euro",
      "Japanese yen",
      "British pound sterling",
      "Swiss franc",
      "Indian rupee",
      "Chinese yuan",
      "Brazilian real"
    ],
    "negativeContentExamples": [
      "USD",
      "US dollar",
      "U.S. dollar",
      "\u20ac",
      "Canadian $",
      "British pounds sterling",
      "JPY",
      "Russian rouble"
    ],
    "positiveHeaderExamples": [
      "Currency",
      "Currency Name",
      "Money",
      "Currency English Name",
      "Currency Full Name",
      "Official Currency Name",
      "Monetary Unit Name",
      "Monetary Unit"
    ],
    "negativeHeaderExamples": [
      "Currency Code",
      "Exchange Rate",
      "Country",
      "Amount",
      "Price",
      "ISO Currency Code",
      "FX Rate",
      "Locale"
    ],
    "explanation": "CURRENCY.TEXT_EN identifies full English currency names such as \"United States dollar\" or \"Euro\" and excludes codes (e.g., USD), symbols (e.g., $), and abbreviated forms (e.g., US dollar). It is useful for datasets where the semantic meaning of the currency is expressed in natural language rather than standardized codes, enabling normalization, mapping to codes, and downstream currency-related analytics.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:37.495305"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_FIPS_US",
    "description": "This type represents US county FIPS codes used for federal statistical identification and data processing of American counties. The format consists of exactly five consecutive numeric digits with no spaces, letters, or special characters for standardized county referencing.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 3450,
    "headerPatterns": [
      {
        "regExp": "(?i).*county.*fips.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "County FIPS Code"
        ],
        "negativeExamples": [
          "State FIPS Code"
        ]
      },
      {
        "regExp": "(?i).*county.*fips.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "County FIPS"
        ],
        "negativeExamples": [
          "County Name"
        ]
      },
      {
        "regExp": "(?i).*fips.*county.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "FIPS County"
        ],
        "negativeExamples": [
          "FIPS State"
        ]
      },
      {
        "regExp": "(?i).*(cnty|co).*fips.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Cnty FIPS"
        ],
        "negativeExamples": [
          "County Code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "01001",
      "06037",
      "36061",
      "17031",
      "12086",
      "04013",
      "53033",
      "48201"
    ],
    "negativeContentExamples": [
      "1234",
      "123456",
      "12-345",
      "12 345",
      "1234A",
      "A1234",
      "0000O",
      "123_45"
    ],
    "positiveHeaderExamples": [
      "County FIPS",
      "FIPS Code",
      "County Code",
      "County FIPS Code",
      "FIPS County Code",
      "Cnty FIPS",
      "CO FIPS Code",
      "FIPS County"
    ],
    "negativeHeaderExamples": [
      "County Name",
      "State",
      "City",
      "ZIP Code",
      "State FIPS Code",
      "Country Code",
      "Postal Code",
      "County Identifier"
    ],
    "explanation": "This semantic type identifies US county-level FIPS codes formatted as exactly five digits. It is useful for joining, aggregating, and validating datasets keyed by county-level federal identifiers. The value regex enforces a strict five-digit token, while header patterns focus on columns explicitly labeled as county FIPS or closely related variants to reduce confusion with other five-digit codes such as ZIP codes.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:43.710957"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_HU",
    "description": "This type identifies Hungarian county names used for administrative identification within Hungary's governmental structure. The format consists of proper noun text strings representing official county names in Hungarian, using correct diacritics and hyphenation, without abbreviations or appended qualifiers.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "B\u00c1CS-KISKUN",
      "BARANYA",
      "B\u00c9K\u00c9S",
      "BORSOD-ABA\u00daJ-ZEMPL\u00c9N",
      "CSONGR\u00c1D-CSAN\u00c1D",
      "FEJ\u00c9R",
      "GY\u0150R-MOSON-SOPRON",
      "HAJD\u00da-BIHAR",
      "HEVES",
      "J\u00c1SZ-NAGYKUN-SZOLNOK",
      "KOM\u00c1ROM-ESZTERGOM",
      "N\u00d3GR\u00c1D",
      "PEST",
      "SOMOGY",
      "SZABOLCS-SZATM\u00c1R-BEREG",
      "TOLNA",
      "VAS",
      "VESZPR\u00c9M",
      "ZALA"
    ],
    "backout": "^[A-Z\u00c1\u00c9\u00cd\u00d3\u00d6\u0150\u00da\u00dc\u0170\\- ]{3,30}$",
    "confidenceThreshold": 98,
    "priority": 3460,
    "headerPatterns": [
      {
        "regExp": "(?i).*(hungarian[_ ]?county|county[_ ]?hu|megye[_ ]?hu).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Hungarian County"
        ],
        "negativeExamples": [
          "Region"
        ]
      },
      {
        "regExp": "(?i).*\\bhu\\b.*\\bcounty\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "HU County"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*\\bmegye\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Megye"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*\\bcty\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cty"
        ],
        "negativeExamples": [
          "city"
        ]
      },
      {
        "regExp": "(?i).*\\bcounty\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "County"
        ],
        "negativeExamples": [
          "Country"
        ]
      }
    ],
    "positiveContentExamples": [
      "B\u00e1cs-Kiskun",
      "Baranya",
      "B\u00e9k\u00e9s",
      "Borsod-Aba\u00faj-Zempl\u00e9n",
      "Csongr\u00e1d-Csan\u00e1d",
      "Gy\u0151r-Moson-Sopron",
      "J\u00e1sz-Nagykun-Szolnok",
      "Szabolcs-Szatm\u00e1r-Bereg"
    ],
    "negativeContentExamples": [
      "Budapest",
      "Csongr\u00e1d",
      "Bacs-Kiskun",
      "Borsod Aba\u00faj Zempl\u00e9n",
      "Gy\u0151r\u2013Moson\u2013Sopron",
      "Heves megye",
      "Veszprem",
      "Pest County"
    ],
    "positiveHeaderExamples": [
      "Megye",
      "County",
      "Hungarian County",
      "HU County",
      "Megye Name",
      "County (HU)",
      "County Hu"
    ],
    "negativeHeaderExamples": [
      "Country",
      "City",
      "Region",
      "County Code",
      "Province",
      "State",
      "Postal County"
    ],
    "explanation": "STATE_PROVINCE.COUNTY_HU recognizes the official set of Hungarian county names for use in administrative and geographic datasets. It is intended to validate county-level attributes where values are the canonical Hungarian names with correct diacritics and hyphenation, excluding English translations, outdated forms, appended words like 'megye', or variants missing accents.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:45.487908"
  },
  {
    "resultType": "generated",
    "semanticType": "POSTAL_CODE.POSTAL_CODE_JA",
    "description": "This type captures Japanese postal codes used for mail distribution across Japan. The format consists of three digits, followed by a hyphen, then four more digits, creating a seven-digit code with mandatory hyphen separation.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{3}-[0-9]{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3300,
    "headerPatterns": [
      {
        "regExp": "(?i).*(japan|jp).*(postal|zip).*(code).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "JP Postal Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*\u90f5\u4fbf\u756a\u53f7.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "\u90f5\u4fbf\u756a\u53f7"
        ],
        "negativeExamples": [
          "\u4f4f\u6240"
        ]
      },
      {
        "regExp": "(?i).*(address|location).*(postal|zip).*(code).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Address Postal Code"
        ],
        "negativeExamples": [
          "Location Code"
        ]
      },
      {
        "regExp": "(?i).*(postcode|zip).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Postcode"
        ],
        "negativeExamples": [
          "Area Code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Status"
        ]
      }
    ],
    "positiveContentExamples": [
      "100-0001",
      "060-0042",
      "150-0002",
      "530-0001",
      "900-0015",
      "980-0811",
      "160-0022",
      "003-0801"
    ],
    "negativeContentExamples": [
      "1000001",
      "100\u20130001",
      "100\u22120001",
      "100\u20110001",
      "10-00001",
      "100-001",
      "A00-0001",
      "\uff11\uff10\uff10-\uff10\uff10\uff10\uff11"
    ],
    "positiveHeaderExamples": [
      "\u90f5\u4fbf\u756a\u53f7",
      "Postal Code",
      "ZIP Code",
      "JP Postal Code",
      "Postcode",
      "Address Postal Code",
      "Japan ZIP Code"
    ],
    "negativeHeaderExamples": [
      "\u90fd\u5e02",
      "City",
      "Address",
      "Area Code",
      "Country Code",
      "Location",
      "Province"
    ],
    "explanation": "Detects fields containing Japanese postal codes in the strict NNN-NNNN format with a mandatory ASCII hyphen. Useful for validation, parsing, and standardization of address data. Values lacking the hyphen, using non-ASCII hyphen characters, incorrect digit counts, or non-ASCII digits are excluded.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:49.628187"
  },
  {
    "resultType": "generated",
    "semanticType": "SPATIAL.WKT",
    "description": "This type represents Well-Known Text formatted spatial geometries used in geographic information systems and spatial databases. The format begins with a geometry type keyword followed by parentheses containing coordinate values separated by spaces and commas.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(SRID=\\d+;\\s*)?(POINT|LINESTRING|POLYGON|MULTIPOINT|MULTILINESTRING|MULTIPOLYGON|GEOMETRYCOLLECTION)\\b(\\s+(Z|M|ZM))?\\s*\\([A-Z0-9\\-\\.\\s,()]+\\)",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 3400,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bwell\\b.*\\bknown\\b.*\\btext\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Well Known Text"
        ],
        "negativeExamples": [
          "GeoJSON"
        ]
      },
      {
        "regExp": "(?i).*\\bspatial\\b.*\\bwkt\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Spatial WKT"
        ],
        "negativeExamples": [
          "Coordinates"
        ]
      },
      {
        "regExp": "(?i).*\\bspatial\\b.*\\bgeometry\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Spatial Geometry"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*\\bwkt\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "WKT"
        ],
        "negativeExamples": [
          "WKID"
        ]
      },
      {
        "regExp": "(?i).*\\bgeometry\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Geometry"
        ],
        "negativeExamples": [
          "Geography"
        ]
      }
    ],
    "positiveContentExamples": [
      "POINT (30 10)",
      "LINESTRING (30 10, 10 30, 40 40)",
      "POLYGON ((30 10, 40 40, 20 40, 10 20, 30 10))",
      "MULTIPOINT ((10 40), (40 30), (20 20), (30 10))",
      "MULTILINESTRING ((10 10, 20 20), (30 30, 40 40))",
      "MULTIPOLYGON (((30 20, 45 40, 10 40, 30 20)))",
      "SRID=4326;POINT(-122.4194 37.7749)",
      "GEOMETRYCOLLECTION(POINT(4 6),LINESTRING(4 6,7 10))"
    ],
    "negativeContentExamples": [
      "POINT 30 10",
      "POINT()",
      "LINESTRING 30 10, 10 30",
      "GEOMETRYCOLLECTION POINT 4 6, LINESTRING 4 6, 7 10",
      "POINT[30 10]",
      "POINT(30; 10)",
      "MULTIPOLYGON()",
      "SRID=4326; POINT 30 10"
    ],
    "positiveHeaderExamples": [
      "WKT",
      "Well Known Text",
      "Spatial Geometry",
      "Geometry WKT",
      "Spatial WKT",
      "Geometry",
      "WKT Geometry"
    ],
    "negativeHeaderExamples": [
      "GeoJSON",
      "Coordinates",
      "Address",
      "Shapefile",
      "Lat Long",
      "EPSG Code",
      "Geohash"
    ],
    "explanation": "WKT is a compact, human-readable representation of vector geometries. This type is useful for detecting columns that store spatial objects in WKT form across GIS systems and spatial databases, supporting common geometry types and optional SRID and dimensionality tokens.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:52.970210"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_IE",
    "description": "Identifies Irish county names used for geographic and administrative purposes across the island of Ireland. Values are proper English county names without prefixes (e.g., no \"County\" or \"Co.\"), suffixes, abbreviations, or additional qualifiers.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(ANTRIM|ARMAGH|CARLOW|CAVAN|CLARE|CORK|DERRY|LONDONDERRY|DONEGAL|DOWN|DUBLIN|FERMANAGH|GALWAY|KERRY|KILDARE|KILKENNY|LAOIS|LEITRIM|LIMERICK|LONGFORD|LOUTH|MAYO|MEATH|MONAGHAN|OFFALY|ROSCOMMON|SLIGO|TIPPERARY|TYRONE|WATERFORD|WESTMEATH|WEXFORD|WICKLOW)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3470,
    "headerPatterns": [
      {
        "regExp": "(?i).*irish.*county.*name.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Irish County Name"
        ],
        "negativeExamples": [
          "Irish County Code"
        ]
      },
      {
        "regExp": "(?i).*(irish|ie).*county.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Irish County"
        ],
        "negativeExamples": [
          "Irish Country"
        ]
      },
      {
        "regExp": "(?i).*county.*name.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "County Name"
        ],
        "negativeExamples": [
          "Country Name"
        ]
      },
      {
        "regExp": "(?i).*county.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "County"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*\\b(cty|co)\\b.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CTY Name"
        ],
        "negativeExamples": [
          "Company Name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Dublin",
      "Cork",
      "Galway",
      "Limerick",
      "Kerry",
      "Antrim",
      "Londonderry",
      "Roscommon"
    ],
    "negativeContentExamples": [
      "County Dublin",
      "Co Dublin",
      "Dublin City",
      "Tipperary North",
      "Downpatrick",
      "Galway County",
      "Mayo, IE",
      "Offaly County Council"
    ],
    "positiveHeaderExamples": [
      "County",
      "Irish County",
      "County Name",
      "IE County",
      "Irish County Name",
      "Co Name",
      "CTY Name",
      "County (Ireland)"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Province",
      "City",
      "County Code",
      "Country Name",
      "State",
      "Region",
      "County ID"
    ],
    "explanation": "This semantic type targets cells containing only the official English names of Irish counties, with no prefixes (e.g., \"County\", \"Co.\"), suffixes, qualifiers, or punctuation. It is useful for normalizing geographic dimensions, validating location fields, and joining datasets on county-level geography across both the Republic of Ireland and Northern Ireland.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:53.131957"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_US",
    "description": "Identifies U.S. county names used for local administrative identification within American state governmental systems. Values are proper-noun text strings representing official county names in English and commonly include the word \"County\" as part of the designation.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z][A-Za-z'.-]+(\\s[A-Z][A-Za-z'.-]+){0,3}\\sCounty\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 3490,
    "headerPatterns": [
      {
        "regExp": "(?i).*(us|usa|united states).*(county).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "US County Name"
        ],
        "negativeExamples": [
          "FIPS Code"
        ]
      },
      {
        "regExp": "(?i).*(county)[ _-]*(name|nm).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "County Name"
        ],
        "negativeExamples": [
          "County Seat"
        ]
      },
      {
        "regExp": "(?i).*(us|usa|united states).*(county).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "US County"
        ],
        "negativeExamples": [
          "State"
        ]
      },
      {
        "regExp": "(?i).*county.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "County"
        ],
        "negativeExamples": [
          "City"
        ]
      }
    ],
    "positiveContentExamples": [
      "Los Angeles County",
      "Cook County",
      "Prince George's County",
      "St. Louis County",
      "San Juan County",
      "Queens County",
      "De Soto County",
      "King County"
    ],
    "negativeContentExamples": [
      "Los Angeles",
      "Los Angeles Co.",
      "King county",
      "St Louis Cnty",
      "San Juan County, NM",
      "County of Los Angeles",
      "King-County",
      "los angeles county"
    ],
    "positiveHeaderExamples": [
      "County",
      "County Name",
      "US County",
      "County_Name",
      "United States County Name",
      "CountyNm",
      "US_County_Name",
      "CountyName"
    ],
    "negativeHeaderExamples": [
      "State",
      "FIPS Code",
      "City",
      "County Seat",
      "Country",
      "Province",
      "Zip Code",
      "Parish"
    ],
    "explanation": "This semantic type targets strings that represent official U.S. county names, typically written as one to four capitalized tokens followed by the word \"County\". It is useful for datasets containing administrative geography fields at the county level and helps distinguish county name columns from state, city, or code-based identifiers.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:58.489331"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COMMUNE_IT",
    "description": "This type identifies Italian commune names used for municipal identification within Italy's administrative structure. The format consists of proper noun text strings representing official commune names in Italian without abbreviations or special formatting.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z][A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff']{1,24}(( [A-Z][A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff']{1,24})|(-[A-Z][A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff']{1,24})|( [a-z]{1,5})){0,4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 3440,
    "headerPatterns": [
      {
        "regExp": "(?i).*(comune|commune).*ital(y|ia).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Comune Italia"
        ],
        "negativeExamples": [
          "Municipality"
        ]
      },
      {
        "regExp": "(?i).*(ital(y|ia)).*(municipality|comune|commune).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Italy Municipality"
        ],
        "negativeExamples": [
          "Region Italy"
        ]
      },
      {
        "regExp": "(?i).*(municipality|comune|commune).*(name|nome).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Municipality Name"
        ],
        "negativeExamples": [
          "Municipality Code"
        ]
      },
      {
        "regExp": "(?i).*(municipality|comune|commune).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Municipality"
        ],
        "negativeExamples": [
          "Province"
        ]
      },
      {
        "regExp": "(?i).*\\b(com|muni)\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "com name"
        ],
        "negativeExamples": [
          "dept"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Roma",
      "Milano",
      "Torino",
      "L'Aquila",
      "Sant'Angelo Lodigiano",
      "San Martino di Lupari",
      "Castel del Piano",
      "Santa Maria Capua Vetere"
    ],
    "negativeContentExamples": [
      "roma",
      "Roma (RM)",
      "S. Martino",
      "Reggio Emilia 2",
      "Torino-1",
      "L\u2019Aquila",
      "Civitavecchia/Porto",
      "San Pietro in C."
    ],
    "positiveHeaderExamples": [
      "Comune",
      "Commune",
      "Municipality",
      "Comune Italia",
      "Municipality Name",
      "Italian Municipality",
      "Commune Name",
      "Municipality (IT)"
    ],
    "negativeHeaderExamples": [
      "Province",
      "Region",
      "Country",
      "City",
      "District",
      "Province Name",
      "Regional Code",
      "Country Name"
    ],
    "explanation": "Identifies values that are official Italian commune names written as proper nouns, optionally including common lowercase connecting particles (e.g., di, del) and allowing internal hyphens or apostrophes within tokens. Use this type to detect municipal-level locality fields in datasets focused on Italy, especially where the column header indicates a commune or municipality.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:15:59.508194"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.CANTON_NAME_CH",
    "description": "This type identifies official Swiss canton names used to designate the federal states within Switzerland's political structure. The values are the full canton names in their official language(s) without abbreviations or codes, including proper accents, spaces, and hyphens where applicable.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(Z\u00fcrich|Bern|Berne|Luzern|Uri|Schwyz|Obwalden|Nidwalden|Glarus|Zug|Fribourg|Freiburg|Solothurn|Basel-Stadt|Basel-Landschaft|Schaffhausen|Appenzell Ausserrhoden|Appenzell Innerrhoden|Sankt Gallen|Thurgau|Graub\u00fcnden|Grisons|Grigioni|Grischun|Aargau|Ticino|Vaud|Valais|Wallis|Neuch\u00e2tel|Gen\u00e8ve|Jura)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 3430,
    "headerPatterns": [
      {
        "regExp": "(?i).*swiss.*canton.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Swiss Canton Name"
        ],
        "negativeExamples": [
          "Swiss Canton Code"
        ]
      },
      {
        "regExp": "(?i).*(canton|kanton)\\s*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Canton Name"
        ],
        "negativeExamples": [
          "Kanton Code"
        ]
      },
      {
        "regExp": "(?i).*cantonal.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Cantonal Name"
        ],
        "negativeExamples": [
          "Cantonal Code"
        ]
      },
      {
        "regExp": "(?i).*(canton|kanton).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Canton"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Z\u00fcrich",
      "Gen\u00e8ve",
      "Appenzell Innerrhoden",
      "Basel-Landschaft",
      "Graub\u00fcnden",
      "Berne",
      "Ticino",
      "Valais"
    ],
    "negativeContentExamples": [
      "Zurich",
      "Geneve",
      "St. Gallen",
      "Basel Stadt",
      "Appenzell A.Rh.",
      "Grigione",
      "Neuchatel",
      "SanktGallen"
    ],
    "positiveHeaderExamples": [
      "Kanton",
      "Canton Name",
      "Canton",
      "Cantonal Name",
      "Swiss Canton Name",
      "Canton Full Name",
      "Official Canton Name"
    ],
    "negativeHeaderExamples": [
      "Canton Code",
      "Country",
      "City",
      "Canton ID",
      "State",
      "Province Code",
      "Country Name"
    ],
    "explanation": "Represents the canonical full names of Switzerland\u2019s 26 cantons in their official language(s), including diacritics and required separators (spaces and hyphens). It excludes abbreviations (e.g., St. for Sankt), codes (e.g., two-letter canton codes), translations into non-official languages, or names with added qualifiers or punctuation.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:00.692243"
  },
  {
    "resultType": "generated",
    "semanticType": "SPATIAL.GEOJSON",
    "description": "This type identifies GeoJSON formatted geometric objects used for spatial data representation in mapping and GIS applications. The structure follows JSON formatting with required type and coordinates fields, containing arrays of numeric coordinate pairs for geographic positioning.",
    "pluginType": "regex",
    "regexPattern": "\\b\"\\s*type\\s*\"\\s*:\\s*\"\\s*(Point|MultiPoint|LineString|MultiLineString|Polygon|MultiPolygon)\\s*\"\\s*,[^[]*\"\\s*coordinates\\s*\"\\s*:\\s*\\[\\s*(\\[\\s*){0,2}\\[\\s*-?\\d+(\\.\\d+)?\\s*,\\s*-?\\d+(\\.\\d+)?\\s*\\](\\s*,\\s*\\[\\s*-?\\d+(\\.\\d+)?\\s*,\\s*-?\\d+(\\.\\d+)?\\s*\\])*(\\s*\\]\\s*){0,2}\\s*\\]",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 3390,
    "headerPatterns": [
      {
        "regExp": "(?i).*geojson.*geometry.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "GeoJSON Geometry"
        ],
        "negativeExamples": [
          "Geometry Type"
        ]
      },
      {
        "regExp": "(?i).*spatial.*geojson.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Spatial GeoJSON"
        ],
        "negativeExamples": [
          "Spatial Data"
        ]
      },
      {
        "regExp": "(?i).*gis.*json.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "GIS JSON"
        ],
        "negativeExamples": [
          "GeoJSON"
        ]
      },
      {
        "regExp": "(?i).*geo.*json.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "GeoJSON"
        ],
        "negativeExamples": [
          "Geographic Data"
        ]
      },
      {
        "regExp": "(?i).*geojson.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "GeoJSON"
        ],
        "negativeExamples": [
          "JSON"
        ]
      }
    ],
    "positiveContentExamples": [
      "{\"type\":\"Point\",\"coordinates\":[-122.4194,37.7749]}",
      "{\"type\": \"LineString\", \"coordinates\": [[-73.98,40.75],[-73.99,40.76]]}",
      "{\"type\":\"Polygon\",\"coordinates\":[[[-80.19,25.76],[-80.20,25.77],[-80.21,25.76],[-80.19,25.76]]]}",
      "{\"type\":\"MultiPoint\",\"coordinates\":[[-122.4,37.8],[-122.5,37.7]]}",
      "{\"type\":\"MultiLineString\",\"coordinates\":[[[-73.98,40.75],[-73.99,40.76]],[[-73.97,40.74],[-73.96,40.73]]]}",
      "{\"type\":\"MultiPolygon\",\"coordinates\":[[[[-80.19,25.76],[-80.20,25.77],[-80.21,25.76],[-80.19,25.76]]]]}",
      "{\"type\":\"Polygon\",\"coordinates\":[[[-3.7,40.4],[-3.6,40.5],[-3.5,40.4],[-3.7,40.4]]],\"properties\":{\"name\":\"area\"}}"
    ],
    "negativeContentExamples": [
      "{\"type\":\"Point\",\"coordinates\":[\"-122.4194\",\"37.7749\"]}",
      "{\"type\":\"Point\",\"coordinate\":[-122.4194,37.7749]}",
      "{\"coordinates\":[-122.4194,37.7749]}",
      "{\"type\":\"Feature\",\"geometry\":{\"type\":\"Point\",\"coordinates\":[-122.4,37.8]}}",
      "POINT(-122.4194 37.7749)",
      "{\"type\":\"Point\",\"coordinates\":[-122.4194,37.7749,15.0]}",
      "{\"type\":\"LineString\",\"coordinates\":[-73.98,40.75,-73.99,40.76]}"
    ],
    "positiveHeaderExamples": [
      "GeoJSON",
      "Spatial Data",
      "Geographic Data",
      "GeoJSON Geometry",
      "GIS JSON",
      "Spatial GeoJSON",
      "Geometry JSON"
    ],
    "negativeHeaderExamples": [
      "Coordinates",
      "Address",
      "Location Name",
      "JSON",
      "WKT",
      "Geometry Type",
      "Lat Long"
    ],
    "explanation": "GeoJSON geometry identifies JSON-based spatial objects that include a geometry type and numeric coordinate arrays. It is useful for classifying columns that store serialized geometry records for mapping, GIS pipelines, and spatial analysis.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:03.120462"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_CA",
    "description": "This type identifies official Canadian province and territory names used within Canada's federal structure. Values are full English names without abbreviations, codes, or additional qualifiers.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "ALBERTA",
      "BRITISH COLUMBIA",
      "MANITOBA",
      "NEW BRUNSWICK",
      "NEWFOUNDLAND AND LABRADOR",
      "NOVA SCOTIA",
      "ONTARIO",
      "PRINCE EDWARD ISLAND",
      "QUEBEC",
      "SASKATCHEWAN",
      "NORTHWEST TERRITORIES",
      "NUNAVUT",
      "YUKON"
    ],
    "backout": "^[A-Z][A-Z ]{4,29}$",
    "confidenceThreshold": 97,
    "priority": 3640,
    "headerPatterns": [
      {
        "regExp": "(?i).*(canadian|canada|ca).*province.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Canadian Province Name"
        ],
        "negativeExamples": [
          "Province Code"
        ]
      },
      {
        "regExp": "(?i).*(province).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Province Name"
        ],
        "negativeExamples": [
          "Province Code"
        ]
      },
      {
        "regExp": "(?i).*(prov).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "prov_name"
        ],
        "negativeExamples": [
          "prov code"
        ]
      },
      {
        "regExp": "(?i).*(canadian|canada|ca).*province.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Canadian Province"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Alberta",
      "British Columbia",
      "Saskatchewan",
      "Quebec",
      "Prince Edward Island",
      "Northwest Territories",
      "Nunavut",
      "Yukon"
    ],
    "negativeContentExamples": [
      "AB",
      "B.C.",
      "Quebec City",
      "Ontario, Canada",
      "New Brunswick Province",
      "Nova-Scotia",
      "Northwest Territory",
      "Yukon Territory"
    ],
    "positiveHeaderExamples": [
      "Province",
      "Province Name",
      "Canadian Province",
      "Canadian Province Name",
      "Province (CA)",
      "Province - Canada",
      "Province of Canada",
      "Province English Name"
    ],
    "negativeHeaderExamples": [
      "Province Code",
      "Country",
      "Territory",
      "State",
      "Region",
      "Province Abbreviation",
      "Prov Code",
      "Province ID"
    ],
    "explanation": "This semantic type recognizes full English names of Canadian provinces and territories, ensuring values are complete, unabbreviated names like 'Alberta' or 'Prince Edward Island'. It is useful for validating location dimensions, standardizing geographic attributes, and distinguishing between full names and codes or abbreviations in Canadian datasets.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:08.053660"
  },
  {
    "resultType": "generated",
    "semanticType": "COUNTRY.TEXT_DE",
    "description": "This represents the complete country name using proper German terminology, capitalization, and linguistic conventions. The name may include multiple words and German-specific characters but excludes abbreviations, codes, or non-German translations.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z\u00c4\u00d6\u00dc][a-z\u00e4\u00f6\u00fc\u00df\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]+(-[A-Z\u00c4\u00d6\u00dc][a-z\u00e4\u00f6\u00fc\u00df\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]+)*)(\\s+(und|der|des|dem|die|von|vom|zum|zur))?(\\s+[A-Z\u00c4\u00d6\u00dc][a-z\u00e4\u00f6\u00fc\u00df\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]+(-[A-Z\u00c4\u00d6\u00dc][a-z\u00e4\u00f6\u00fc\u00df\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff]+)*){0,4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 2500,
    "headerPatterns": [
      {
        "regExp": "(?i).*(l\u00e4ndername|laendername|landname|staatsname).*(de|deutsch).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "laendername_de"
        ],
        "negativeExamples": [
          "laendercode_de"
        ]
      },
      {
        "regExp": "(?i).*(land|staat).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "staat_name"
        ],
        "negativeExamples": [
          "l\u00e4ndercode"
        ]
      },
      {
        "regExp": "(?i).*\\bl\u00e4nder\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "L\u00e4nder"
        ],
        "negativeExamples": [
          "L\u00e4ndercode"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Deutschland",
      "\u00d6sterreich",
      "Schweiz",
      "Vereinigtes K\u00f6nigreich",
      "Vereinigte Staaten",
      "Elfenbeink\u00fcste",
      "Bosnien und Herzegowina",
      "Papua-Neuguinea"
    ],
    "negativeContentExamples": [
      "DE",
      "DEU",
      "\u00f6sterreich",
      "\u00d6STERREICH",
      "Bosnien & Herzegowina",
      "Trinidad and Tobago",
      "Papua - Neuguinea",
      "PapuaNeuguinea"
    ],
    "positiveHeaderExamples": [
      "Land",
      "Staat",
      "L\u00e4nder",
      "L\u00e4ndername",
      "Land Name",
      "Staatsname",
      "Land DE",
      "Deutscher L\u00e4ndername"
    ],
    "negativeHeaderExamples": [
      "L\u00e4ndercode",
      "Stadt",
      "Sprache",
      "Region",
      "Kontinent",
      "ISO-Code",
      "Nation Code",
      "Country"
    ],
    "explanation": "Identifies full German-language country names, allowing for multi-word names, umlauts, and hyphenated compounds, and a single common lowercase connector such as 'und' or 'von'. It purposefully excludes codes, abbreviations, non-German translations, and malformed capitalization to reduce ambiguity.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:08.325616"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_IE",
    "description": "This type identifies traditional Irish province names used for cultural and geographic identification within Ireland. The format consists of proper noun text strings representing historic province names in English without abbreviations or special formatting characters.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "CONNACHT",
      "LEINSTER",
      "MUNSTER",
      "ULSTER"
    ],
    "backout": "^[A-Z]{6,8}$",
    "confidenceThreshold": 98,
    "priority": 3670,
    "headerPatterns": [
      {
        "regExp": "(?i).*irish.*province.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Irish Province Name"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      },
      {
        "regExp": "(?i).*province.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Province Name"
        ],
        "negativeExamples": [
          "Province Code"
        ]
      },
      {
        "regExp": "(?i).*irish.*province.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Irish Province"
        ],
        "negativeExamples": [
          "Province"
        ]
      },
      {
        "regExp": "(?i).*(prov|province).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "prov_name"
        ],
        "negativeExamples": [
          "prov_code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Connacht",
      "LEINSTER",
      "Munster",
      "ULSTER",
      "Leinster",
      "MUNSTER"
    ],
    "negativeContentExamples": [
      "Connaught",
      "Province of Ulster",
      "Leinster.",
      "Munster County",
      "Ulster (IE)",
      "Connacht-",
      "ULST ER",
      "leinster"
    ],
    "positiveHeaderExamples": [
      "Province",
      "Irish Province",
      "Province Name",
      "Province (IE)",
      "Province English Name",
      "Province of Ireland",
      "prov_name"
    ],
    "negativeHeaderExamples": [
      "County",
      "Country",
      "Region",
      "Province Code",
      "State",
      "Territory",
      "Region Name"
    ],
    "explanation": "This semantic type captures the set of traditional Irish provinces expressed as English proper names without abbreviations or additional qualifiers. It is useful for standardizing and validating province-level geographic fields in datasets specific to Ireland, ensuring only the four valid province names are accepted.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:10.789956"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.COUNTY_UK",
    "description": "This type identifies UK county names used for administrative and geographic identification throughout the United Kingdom. The format consists of proper noun text strings representing official county names in English without abbreviations or special formatting characters.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "BEDFORDSHIRE",
      "BERKSHIRE",
      "BUCKINGHAMSHIRE",
      "CAMBRIDGESHIRE",
      "CHESHIRE",
      "CORNWALL",
      "CUMBRIA",
      "DERBYSHIRE",
      "DEVON",
      "DORSET",
      "EAST SUSSEX",
      "ESSEX",
      "GLOUCESTERSHIRE",
      "GREATER LONDON",
      "GREATER MANCHESTER",
      "HAMPSHIRE",
      "HERTFORDSHIRE",
      "ISLE OF WIGHT",
      "KENT",
      "LANCASHIRE",
      "MERSEYSIDE",
      "NORTHUMBERLAND",
      "OXFORDSHIRE",
      "SOMERSET",
      "TYNE AND WEAR"
    ],
    "backout": "^[A-Z]+(?: [A-Z]+){0,4}$",
    "confidenceThreshold": 94,
    "priority": 3480,
    "headerPatterns": [
      {
        "regExp": "(?i).*uk.*county.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "UK County Name"
        ],
        "negativeExamples": [
          "Country Name"
        ]
      },
      {
        "regExp": "(?i).*(united kingdom|uk|gb).*county.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "United Kingdom County"
        ],
        "negativeExamples": [
          "US County"
        ]
      },
      {
        "regExp": "(?i).*county.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "County Name"
        ],
        "negativeExamples": [
          "Country Name"
        ]
      },
      {
        "regExp": "(?i).*(uk|gb).*cnty.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "UK Cnty"
        ],
        "negativeExamples": [
          "GB Country"
        ]
      },
      {
        "regExp": "(?i).*county.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "County"
        ],
        "negativeExamples": [
          "Country"
        ]
      }
    ],
    "positiveContentExamples": [
      "DEVON",
      "EAST SUSSEX",
      "GREATER LONDON",
      "GREATER MANCHESTER",
      "MERSEYSIDE",
      "OXFORDSHIRE",
      "TYNE AND WEAR",
      "LANCASHIRE"
    ],
    "negativeContentExamples": [
      "DEVONSHIRE",
      "EAST SUSSEX COUNTY",
      "GREATER LONDON AREA",
      "TYNE & WEAR",
      "MERSEY SIDE",
      "OXFORD SHIRE",
      "HERTFORDSHIRE, UK",
      "THE ISLE OF WIGHT"
    ],
    "positiveHeaderExamples": [
      "County",
      "UK County",
      "County Name",
      "United Kingdom County",
      "GB County",
      "UK Cnty"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Region",
      "City",
      "County Code",
      "County ID",
      "State",
      "Province",
      "Country Name"
    ],
    "explanation": "This semantic type targets UK county names presented as standard English proper nouns without abbreviations or extra qualifiers. It is useful for normalizing and validating location attributes such as residence county, registration county, or jurisdiction names within UK datasets. Detection leverages a curated set of representative county names alongside header cues focused on the term 'county' and UK context.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:12.422604"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_NL",
    "description": "This type identifies Netherlands province names used for regional administrative identification within the Dutch governmental structure. The format consists of proper noun text strings representing official province names in Dutch without abbreviations or special formatting characters.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "DRENTHE",
      "FLEVOLAND",
      "FRIESLAND",
      "GELDERLAND",
      "GRONINGEN",
      "LIMBURG",
      "NOORD-BRABANT",
      "NOORD-HOLLAND",
      "OVERIJSSEL",
      "UTRECHT",
      "ZEELAND",
      "ZUID-HOLLAND"
    ],
    "backout": "^[A-Za-z]{2,20}(\\-[A-Za-z]{2,20})?$",
    "confidenceThreshold": 98,
    "priority": 3690,
    "headerPatterns": [
      {
        "regExp": "(?i).*(netherlands|dutch).*province.*name.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Dutch Province Name"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      },
      {
        "regExp": "(?i).*(nl|nederland|netherlands).*province.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "NL Province"
        ],
        "negativeExamples": [
          "Province Code"
        ]
      },
      {
        "regExp": "(?i).*provincie.*naam.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Provincie Naam"
        ],
        "negativeExamples": [
          "Provincie Code"
        ]
      },
      {
        "regExp": "(?i).*province.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Province Name"
        ],
        "negativeExamples": [
          "Province Code"
        ]
      },
      {
        "regExp": "(?i).*(provincie|province).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Province"
        ],
        "negativeExamples": [
          "City"
        ]
      }
    ],
    "positiveContentExamples": [
      "Drenthe",
      "Flevoland",
      "Friesland",
      "Gelderland",
      "Groningen",
      "Limburg",
      "Noord-Brabant",
      "Noord-Holland"
    ],
    "negativeContentExamples": [
      "North Holland",
      "Frisia",
      "Noord Holland",
      "Zuid_Holland",
      "Gelderland (NL)",
      "Frysl\u00e2n",
      "Overijssel.",
      "Drenthe NL"
    ],
    "positiveHeaderExamples": [
      "Provincie",
      "Province",
      "Dutch Province",
      "Province Name",
      "NL Province",
      "Provincie Naam",
      "Netherlands Province"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Municipality",
      "City",
      "State",
      "Region",
      "Province Code",
      "County"
    ],
    "explanation": "This semantic type targets Dutch-language province names for the Netherlands, supporting curated validation for regional data fields. Using a finite, enumerated list ensures high precision and minimizes false positives, while the backout pattern provides a structured fallback for shape-based validation when list coverage is insufficient.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:12.546919"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_CO",
    "description": "This type identifies Colombian municipality names used for local administrative identification within Colombia's governmental structure. The format consists of proper noun text strings representing official municipality names in Spanish without abbreviations or special formatting characters.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00e1\u00e9\u00ed\u00f3\u00fa\u00fc\u00d1\u00f1]{2,}( [A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00e1\u00e9\u00ed\u00f3\u00fa\u00fc\u00d1\u00f1]{2,}){0,5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 3560,
    "headerPatterns": [
      {
        "regExp": "(?i).*colombian.*municipality.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Colombian Municipality"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*colombia.*municipio.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Municipio de Colombia"
        ],
        "negativeExamples": [
          "Department"
        ]
      },
      {
        "regExp": "(?i).*municipality.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Municipality"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*(muni|mpio).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Muni Name"
        ],
        "negativeExamples": [
          "Province"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Medell\u00edn",
      "Barranquilla",
      "Cartagena de Indias",
      "Santa Marta",
      "Bucaramanga",
      "C\u00facuta",
      "Ibagu\u00e9",
      "Villavicencio"
    ],
    "negativeContentExamples": [
      "Bogot\u00e1 D.C.",
      "Santa Marta 2",
      "San_Antero",
      "Cartagena de Indias, Colombia",
      "Medell\u00edn!",
      "Riohacha/",
      "C\u00facuta - Norte de Santander",
      "Neiva (Huila)"
    ],
    "positiveHeaderExamples": [
      "Municipio",
      "Municipality",
      "Colombian Municipality",
      "Municipality Name",
      "Municipio Nombre",
      "Muni Name",
      "Municipio de Colombia"
    ],
    "negativeHeaderExamples": [
      "Department",
      "Country",
      "City",
      "Municipality Code",
      "Province",
      "Region",
      "City Name"
    ],
    "explanation": "This semantic type captures the official Spanish names of Colombian municipalities as they would appear in administrative datasets, focusing on alphabetic tokens and spaces without abbreviations or special formatting. It is useful for normalizing and validating municipality fields in regional and national datasets where headers indicate municipality-related attributes.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:17.419251"
  },
  {
    "resultType": "generated",
    "semanticType": "HASH.SHA256_HEX",
    "description": "Captures SHA-256 hash digest values encoded as 64-character lowercase hexadecimal strings (a\u2013f, 0\u20139) without any spaces, prefixes, or separators. Commonly used for file integrity verification, blockchain data, and cryptographic validation.",
    "pluginType": "regex",
    "regexPattern": "\\b[a-f0-9]{64}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2740,
    "headerPatterns": [
      {
        "regExp": "(?i).*sha[-_ ]?256.*hash.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SHA256 Hash"
        ],
        "negativeExamples": [
          "SHA1 Hash"
        ]
      },
      {
        "regExp": "(?i).*file.*hash.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "File Hash"
        ],
        "negativeExamples": [
          "File Size"
        ]
      },
      {
        "regExp": "(?i).*sha[-_ ]?256.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "sha256"
        ],
        "negativeExamples": [
          "sha512"
        ]
      },
      {
        "regExp": "(?i).*(content|data).*hash.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "content_hash"
        ],
        "negativeExamples": [
          "Content Type"
        ]
      },
      {
        "regExp": "(?i).*hash.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Hash"
        ],
        "negativeExamples": [
          "Filename"
        ]
      }
    ],
    "positiveContentExamples": [
      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "9f86d081884c7d659a2feaa0c55ad015a3bf4f1b2b0b822cd15d6c15b0f00a08",
      "ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad",
      "248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1",
      "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824",
      "4bf5122f344554c15153d1bb1e8bde3f4b9afd1be2b4e6f25b98e65e61c7b1be",
      "7f83b1657ff1fc53b92dc18148a1d65dfc2d4b1fe9c7df677cd3b55fa5a4b39b",
      "ef797c8118f02d4c602d2eb0b2fbd8b20e39b6b8d1f6b4c6e0b6f1a1a0f9b3f1"
    ],
    "negativeContentExamples": [
      "E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855",
      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934cA495991b7852b855",
      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934cz495991b7852b855",
      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b85",
      "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855f",
      "sha256:e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855",
      "e3b0c442-98fc1c14-9afbf4c8-996fb924-27ae41e4-649b934c-a495991b-7852b855",
      "e3b0c44298fc1c149afbf4c8996fb924 27ae41e4649b934ca495991b7852b855"
    ],
    "positiveHeaderExamples": [
      "SHA256 Hash",
      "Hash",
      "File Hash",
      "sha256",
      "sha256_digest",
      "file_sha256",
      "content_hash",
      "sha256checksum"
    ],
    "negativeHeaderExamples": [
      "Filename",
      "File Size",
      "Password",
      "SHA1",
      "SHA512",
      "MD5",
      "File Path",
      "Encryption Key"
    ],
    "explanation": "This semantic type recognizes strictly 64-character lowercase hexadecimal SHA-256 digests with no separators or prefixes, suitable for identifying cryptographic hashes commonly found in security and integrity datasets. Use it to validate or classify columns that contain SHA-256 values derived from files, messages, or other payloads.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:18.564621"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.DISTRICT_NAME_IN",
    "description": "This type identifies Indian district names used for administrative identification within India's governmental structure. The format consists of proper noun text strings representing official district names in English or transliterated from local languages without abbreviations.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z][a-z]{2,})([- ]([A-Z][a-z]{2,}|[0-9]{1,3})){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3520,
    "headerPatterns": [
      {
        "regExp": "(?i).*(indian|india).*(district).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Indian District Name"
        ],
        "negativeExamples": [
          "District Code"
        ]
      },
      {
        "regExp": "(?i).*(district).*(name).*(in|india).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "District Name IN"
        ],
        "negativeExamples": [
          "District Names"
        ]
      },
      {
        "regExp": "(?i).*(district).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "District Name"
        ],
        "negativeExamples": [
          "District Code"
        ]
      },
      {
        "regExp": "(?i).*(dist).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Dist Name"
        ],
        "negativeExamples": [
          "State Name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Pune",
      "South Goa",
      "North 24 Parganas",
      "East Singhbhum",
      "Baramulla",
      "Kurnool",
      "New Delhi",
      "South Tripura"
    ],
    "negativeContentExamples": [
      "north 24 Parganas",
      "South goa",
      "South G0a",
      "SAS Nagar",
      "24 Parganas South",
      "N. 24 Parganas",
      "South 24Parganas",
      "South-24- parganas"
    ],
    "positiveHeaderExamples": [
      "District",
      "Indian District",
      "District Name",
      "Indian District Name",
      "District Name IN",
      "District (India)",
      "District Name English"
    ],
    "negativeHeaderExamples": [
      "State",
      "Country",
      "City",
      "Province",
      "Region",
      "County",
      "District Code"
    ],
    "explanation": "Identifies values that look like Indian district names written as capitalized proper nouns, optionally including a numeric token (e.g., 24) and multi-word or hyphenated forms. Intended for columns containing district names, not codes or abbreviations. The regex favors correctly capitalized tokens and excludes abbreviated or lowercase variants to reduce false positives.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:19.893099"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_MX",
    "description": "This type identifies Mexican municipality names used for local administrative identification within Mexico's governmental structure. The format consists of proper noun text strings representing official municipality names in Spanish without abbreviations or special formatting characters. Values are composed solely of letters (including Spanish diacritics) and spaces, beginning with an uppercase letter and containing 1\u20136 words.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1]+( [A-Za-z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1\u00e1\u00e9\u00ed\u00f3\u00fa\u00f1]{2,}){0,5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 3590,
    "headerPatterns": [
      {
        "regExp": "(?i).*(municipality|municipio|munic\u00edpio).*(mx|mexic\\w*).*(name|nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "municipality_mx_name"
        ],
        "negativeExamples": [
          "state_mx_name"
        ]
      },
      {
        "regExp": "(?i).*(mexico|mexican|mexicana|mx).*(municipality|municipio|munic\u00edpio).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Mexican Municipality"
        ],
        "negativeExamples": [
          "Municipality Code"
        ]
      },
      {
        "regExp": "(?i).*(municipality|municipio|munic\u00edpio).*(name|nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Municipality Name"
        ],
        "negativeExamples": [
          "State Name"
        ]
      },
      {
        "regExp": "(?i).*(mpio|mcpio).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mpio"
        ],
        "negativeExamples": [
          "Municipality Code"
        ]
      },
      {
        "regExp": "(?i).*municipality.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Municipality"
        ],
        "negativeExamples": [
          "City"
        ]
      }
    ],
    "positiveContentExamples": [
      "Benito Ju\u00e1rez",
      "San Pedro Garza Garc\u00eda",
      "General Escobedo",
      "Valle de Bravo",
      "San Crist\u00f3bal de las Casas",
      "L\u00e1zaro C\u00e1rdenas",
      "Jos\u00e9 Mar\u00eda Morelos",
      "Tlalnepantla de Baz"
    ],
    "negativeContentExamples": [
      "san pedro garza garc\u00eda",
      "Oth\u00f3n P. Blanco",
      "San Pedro Garza Garc\u00eda, NL",
      "San Pedro-Cholula",
      "Coyoac\u00e1n (CDMX)",
      "2 de Abril",
      "La Paz.",
      "Jos\u00e9 Maria Morelos y Pav\u00f3n"
    ],
    "positiveHeaderExamples": [
      "Munic\u00edpio",
      "Municipality",
      "Mexican Municipality",
      "Municipio",
      "Municipality Name",
      "Municipio MX",
      "Municipality (Mexico)"
    ],
    "negativeHeaderExamples": [
      "State",
      "Country",
      "City",
      "Province",
      "County",
      "State Name",
      "City Code"
    ],
    "explanation": "This semantic type targets strings that are official Mexican municipality names written in Spanish, consisting of alphabetic tokens (with Spanish diacritics) separated by single spaces, without abbreviations, punctuation, or appended state/country qualifiers. It is intended for columns labeled as municipality-related, especially those indicating Mexican context, and helps distinguish municipality names from states, countries, or city labels.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:21.315991"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.DEPARTMENT_CO",
    "description": "This type identifies Colombian department names used for regional administrative identification within Colombia's governmental structure. The format consists of proper noun text strings representing official department names in Spanish without abbreviations or special formatting characters.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(amazonas|antioquia|arauca|atl[a\u00e1]ntico|bol[i\u00ed]var|boyac[a\u00e1]|caldas|caquet[a\u00e1]|casanare|cauca|cesar|choc[o\u00f3]|c[o\u00f3]rdoba|cundinamarca|guain[i\u00ed]a|guaviare|huila|la guajira|magdalena|meta|nari[n\u00f1]o|norte de santander|putumayo|quind[i\u00ed]o|risaralda|san andr[e\u00e9]s y providencia|santander|sucre|tolima|valle del cauca|vaup[e\u00e9]s|vichada)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 3500,
    "headerPatterns": [
      {
        "regExp": "(?i).*(colombian|colombia).*(department|departamento).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Colombian Department"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(department|departamento).*(co|colombia).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Department CO"
        ],
        "negativeExamples": [
          "Department Code"
        ]
      },
      {
        "regExp": "(?i).*(dept|depto).*(co|colombia).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Depto CO"
        ],
        "negativeExamples": [
          "Dept Code"
        ]
      },
      {
        "regExp": "(?i).*(department|departamento).*(name|nombre).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Department Name"
        ],
        "negativeExamples": [
          "Department Code"
        ]
      },
      {
        "regExp": "(?i).*department.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Department"
        ],
        "negativeExamples": [
          "Municipality"
        ]
      }
    ],
    "positiveContentExamples": [
      "Antioquia",
      "Valle del Cauca",
      "Norte de Santander",
      "La Guajira",
      "C\u00f3rdoba",
      "Atl\u00e1ntico",
      "San Andr\u00e9s y Providencia",
      "Nari\u00f1o"
    ],
    "negativeContentExamples": [
      "Bogot\u00e1 D.C.",
      "Norte Santander",
      "San Andres Providencia",
      "Cundinamarca Colombia",
      "Valle del Cauca, Colombia",
      "Santander del Sur",
      "Guajira",
      "Santa Marta"
    ],
    "positiveHeaderExamples": [
      "Departamento",
      "Department",
      "Colombian Department",
      "Departamento Colombia",
      "Dept",
      "Depto",
      "Department Name"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Municipality",
      "City",
      "Province",
      "State",
      "Region",
      "Department Code"
    ],
    "explanation": "This semantic type is intended to detect cells containing the official names of Colombia's first-level administrative divisions (departamentos). It is useful for geospatial joins, regional analytics, and normalization of Colombian administrative geography. The regex enumerates the valid department names, allowing both accented and unaccented Spanish spellings while avoiding abbreviations or appended qualifiers.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:21.348395"
  },
  {
    "resultType": "generated",
    "semanticType": "MONTH.DIGITS",
    "description": "This type identifies numeric month values as they appear in date representations and calendar systems using integer notation. The values range from 1 to 12 corresponding to the twelve months of the Gregorian calendar, with consistent numerical mapping across systems.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "10",
      "11",
      "12",
      "01",
      "02",
      "03",
      "04",
      "05",
      "06",
      "07",
      "08",
      "09"
    ],
    "backout": "^(0?[1-9]|1[0-2])$",
    "confidenceThreshold": 96,
    "priority": 3010,
    "headerPatterns": [
      {
        "regExp": "(?i).*month.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Month Number"
        ],
        "negativeExamples": [
          "Month Name"
        ]
      },
      {
        "regExp": "(?i).*(numeric|digit|digits).*month.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Numeric Month"
        ],
        "negativeExamples": [
          "Year"
        ]
      },
      {
        "regExp": "(?i).*month.*(num|no|nbr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Month Num"
        ],
        "negativeExamples": [
          "Month Name"
        ]
      },
      {
        "regExp": "(?i).*(mth|mnth|mo).*(num|no).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Mth No"
        ],
        "negativeExamples": [
          "Mth Name"
        ]
      },
      {
        "regExp": "(?i).*month.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Month"
        ],
        "negativeExamples": [
          "Day"
        ]
      }
    ],
    "positiveContentExamples": [
      "1",
      "2",
      "3",
      "9",
      "10",
      "12",
      "01",
      "07"
    ],
    "negativeContentExamples": [
      "0",
      "13",
      "24",
      "21",
      "001",
      "2019",
      "99",
      "15"
    ],
    "positiveHeaderExamples": [
      "Month",
      "Month Number",
      "Numeric Month",
      "Month Num",
      "Month No",
      "Mth No",
      "Numeric Month Number"
    ],
    "negativeHeaderExamples": [
      "Month Name",
      "Day",
      "Year",
      "Month Text",
      "Quarter",
      "Week"
    ],
    "explanation": "Numeric month digits are commonly stored as standalone integers in transactional logs, reports, and normalized date dimension columns. This type helps identify fields that hold the month component as an integer (with or without a leading zero), enabling precise parsing, validation, and transformations when reconstructing dates or aggregating by month.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:24.551478"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.DISTRICT_NAME_PT",
    "description": "Identifies Portuguese district names used for administrative identification within Portugal's governmental structure. Values are proper-noun text strings representing official district names in Portuguese, without abbreviations or additional qualifiers.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AVEIRO",
      "BEJA",
      "BRAGA",
      "BRAGAN\u00c7A",
      "CASTELO BRANCO",
      "COIMBRA",
      "\u00c9VORA",
      "FARO",
      "GUARDA",
      "LEIRIA",
      "LISBOA",
      "PORTALEGRE",
      "PORTO",
      "SANTAR\u00c9M",
      "SET\u00daBAL",
      "VIANA DO CASTELO",
      "VILA REAL",
      "VISEU"
    ],
    "backout": "^[A-Za-z\u00c0-\u00ff]{2,20}( [A-Za-z\u00c0-\u00ff]{1,20}){0,3}$",
    "confidenceThreshold": 95,
    "priority": 3530,
    "headerPatterns": [
      {
        "regExp": "(?i).*(portuguese|pt).*(district|distrito|distr).*name.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "pt_district_name"
        ],
        "negativeExamples": [
          "pt_district_code"
        ]
      },
      {
        "regExp": "(?i).*(district|distrito|distr).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "district_name"
        ],
        "negativeExamples": [
          "district_code"
        ]
      },
      {
        "regExp": "(?i).*(portuguese|pt).*(district|distrito|distr).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Portuguese District"
        ],
        "negativeExamples": [
          "Portuguese Region"
        ]
      },
      {
        "regExp": "(?i).*(district|distrito|distr).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "District"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Lisboa",
      "Porto",
      "\u00c9vora",
      "Set\u00fabal",
      "Viana do Castelo",
      "Vila Real",
      "Castelo Branco",
      "Santar\u00e9m"
    ],
    "negativeContentExamples": [
      "Madeira",
      "A\u00e7ores",
      "Lisbon",
      "Setubal",
      "Evora",
      "Distrito de Braga",
      "Viana do Castello",
      "Vila Real de Santo Ant\u00f3nio"
    ],
    "positiveHeaderExamples": [
      "Portuguese District",
      "Distrito",
      "District",
      "district_name",
      "district_name_pt",
      "pt_district_name",
      "portuguese_district",
      "pt_district"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Region",
      "City",
      "province",
      "state",
      "county",
      "district_code",
      "district_number"
    ],
    "explanation": "This semantic type represents the official names of Portugal\u2019s 18 districts written in Portuguese. It is designed to classify columns that contain district names as plain text without prefixes (e.g., 'Distrito de') or suffixes, and without abbreviations. Typical uses include validating address-related attributes and standardizing administrative territorial fields.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:24.796057"
  },
  {
    "resultType": "generated",
    "semanticType": "INDUSTRY_EN",
    "description": "This type captures industry names as they are commonly expressed in English business terminology and classifications. The values represent broad economic sectors, specific industries, or business categories using standard commercial language and terminology.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(Agriculture|Automotive|Banking|Biotechnology|Chemicals|Construction|Consulting|Consumer Goods|Defense|Education|Energy|Entertainment|Financial Services|Finance|Food & Beverage|Healthcare|Health Care|Hospitality|Information Technology|Logistics|Manufacturing|Media|Mining|Nonprofit|Oil & Gas|Pharmaceuticals|Professional Services|Real Estate|Retail|Retail Trade|Technology|Telecommunications|Tourism|Transportation|Utilities|Wholesale)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2920,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\b(primary|main)\\b.*\\bindustry\\b.*\\bname\\b.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Primary Industry Name"
        ],
        "negativeExamples": [
          "Industry Name"
        ]
      },
      {
        "regExp": "(?i).*\\bindustry\\b.*\\bname\\b.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Industry Name"
        ],
        "negativeExamples": [
          "Company Name"
        ]
      },
      {
        "regExp": "(?i).*\\bbusiness\\b.*\\bsector\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Business Sector"
        ],
        "negativeExamples": [
          "Public Sector"
        ]
      },
      {
        "regExp": "(?i).*\\bindustry\\b.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Industry"
        ],
        "negativeExamples": [
          "Revenue"
        ]
      },
      {
        "regExp": "(?i).*\\bname\\b.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Information Technology",
      "Healthcare",
      "Manufacturing",
      "Oil & Gas",
      "Financial Services",
      "Retail Trade",
      "Real Estate",
      "Telecommunications"
    ],
    "negativeContentExamples": [
      "Tech",
      "Tech Sector",
      "Retailer",
      "Manufacturers",
      "Health Services",
      "Realty",
      "Utility Services",
      "Telecom"
    ],
    "positiveHeaderExamples": [
      "Industry",
      "Industry Name",
      "Business Sector",
      "Primary Industry",
      "Industry Category",
      "Sector"
    ],
    "negativeHeaderExamples": [
      "NAICS Code",
      "Company Name",
      "Revenue",
      "Employee Count",
      "Website",
      "Country Code"
    ],
    "explanation": "This semantic type identifies English-language industry names, including broad sectors and specific industries commonly used in business data (e.g., Healthcare, Manufacturing, Financial Services). It focuses on descriptive industry labels rather than coded taxonomies. Typical use cases include classifying a company's operating sector, segmenting markets, and normalizing free-text industry fields for analytics.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:25.482174"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_ZA",
    "description": "Identifies official South African province names in English used for regional administrative identification within South Africa. Values are the proper, full province names without abbreviations.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "EASTERN CAPE",
      "FREE STATE",
      "GAUTENG",
      "KWAZULU-NATAL",
      "LIMPOPO",
      "MPUMALANGA",
      "NORTH WEST",
      "NORTHERN CAPE",
      "WESTERN CAPE"
    ],
    "backout": "^[A-Z]+([ -][A-Z]+){0,2}$",
    "confidenceThreshold": 98,
    "priority": 3710,
    "headerPatterns": [
      {
        "regExp": "(?i).*south.*african.*province.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "South African Province Name"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      },
      {
        "regExp": "(?i).*south.*african.*province.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "South African Province"
        ],
        "negativeExamples": [
          "South African City"
        ]
      },
      {
        "regExp": "(?i).*(province|prov)[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Province Name"
        ],
        "negativeExamples": [
          "Province Code"
        ]
      },
      {
        "regExp": "(?i).*(province|prov).*(za|rsa).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Province_ZA"
        ],
        "negativeExamples": [
          "Province_US"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "title"
        ]
      }
    ],
    "positiveContentExamples": [
      "Gauteng",
      "KwaZulu-Natal",
      "Western Cape",
      "Eastern Cape",
      "Northern Cape",
      "Free State",
      "Limpopo",
      "Mpumalanga"
    ],
    "negativeContentExamples": [
      "KZN",
      "North-West",
      "FreeState",
      "KwaZulu Natal",
      "Gauteng Province",
      "NorthernCape",
      "Eastern-Cape",
      "Cape Town"
    ],
    "positiveHeaderExamples": [
      "Province",
      "South African Province",
      "Province Name",
      "ZA Province",
      "Province Name ZA",
      "Province_ZA",
      "RSA Province Name"
    ],
    "negativeHeaderExamples": [
      "Country",
      "District",
      "City",
      "Province Code",
      "Region",
      "State",
      "County",
      "Country Code"
    ],
    "explanation": "This semantic type targets the nine official provinces of South Africa, ensuring consistent identification of provincial-level administrative regions. It uses a closed list of canonical English names and a conservative backout pattern to prevent false positives while still allowing basic uppercase word and hyphen/space structures when list comparison is unavailable.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:25.866938"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.REGION_NAME_IT",
    "description": "This type captures the official names of Italian regions as they are used in government administration and official documentation. The values represent complete regional names using proper Italian spelling and linguistic conventions as established by the Italian constitutional system.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "ABRUZZO",
      "BASILICATA",
      "CALABRIA",
      "CAMPANIA",
      "EMILIA-ROMAGNA",
      "FRIULI VENEZIA GIULIA",
      "LAZIO",
      "LIGURIA",
      "LOMBARDIA",
      "MARCHE",
      "MOLISE",
      "PIEMONTE",
      "PUGLIA",
      "SARDEGNA",
      "SICILIA",
      "TOSCANA",
      "TRENTINO-ALTO ADIGE/S\u00dcDTIROL",
      "UMBRIA",
      "VALLE D'AOSTA",
      "VENETO"
    ],
    "backout": "^[A-Z\u00c0-\u00d6\u00d8-\u00dd][A-Z\u00c0-\u00d6\u00d8-\u00dd '/\u2019-]{2,40}$",
    "confidenceThreshold": 98,
    "priority": 3740,
    "headerPatterns": [
      {
        "regExp": "(?i).*italian.*region.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Italian Region Name"
        ],
        "negativeExamples": [
          "Italian Region Code"
        ]
      },
      {
        "regExp": "(?i).*italian.*region.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Italian Region"
        ],
        "negativeExamples": [
          "Italian Province"
        ]
      },
      {
        "regExp": "(?i).*regione.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Regione"
        ],
        "negativeExamples": [
          "Province"
        ]
      },
      {
        "regExp": "(?i).*(italian|italy|italia|\\bit\\b).*region.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IT Region"
        ],
        "negativeExamples": [
          "EU Region"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "LOMBARDIA",
      "TOSCANA",
      "VALLE D'AOSTA",
      "TRENTINO-ALTO ADIGE/S\u00dcDTIROL",
      "EMILIA-ROMAGNA",
      "FRIULI VENEZIA GIULIA",
      "SICILIA",
      "PIEMONTE"
    ],
    "negativeContentExamples": [
      "EMILIA ROMAGNA",
      "TRENTINO ALTO ADIGE",
      "VALLE DAOSTA",
      "SUDTIROL",
      "AOSTA VALLEY",
      "LOMBARDY",
      "FRIULI-VENEZIA-GIULIA",
      "PIEMONTE REGION"
    ],
    "positiveHeaderExamples": [
      "Regione",
      "Region",
      "Italian Region",
      "Italian Region Name",
      "Regione Italiana",
      "Region Name",
      "IT Region",
      "Nome Regione"
    ],
    "negativeHeaderExamples": [
      "Province",
      "Country",
      "City",
      "Region Code",
      "Country Region",
      "Area",
      "State",
      "Subdivision Code"
    ],
    "explanation": "This semantic type identifies official Italian region names, enabling precise validation, normalization, and enrichment of administrative geography fields. It is suitable for datasets containing region-level classifications, government records, and address components within Italy.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:25.867935"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_IT",
    "description": "This type represents official Italian province codes used for identifying provinces within Italy's administrative structure. The format consists of exactly two uppercase letters derived from the province names without spaces, numbers, or special characters.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3630,
    "headerPatterns": [
      {
        "regExp": "(?i).*italian.*province.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Italian Province Code"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      },
      {
        "regExp": "(?i).*province.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Province Code"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*(prov|prv).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Prov Code"
        ],
        "negativeExamples": [
          "Prov Name"
        ]
      },
      {
        "regExp": "(?i).*(italian.*province|provincia).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Provincia"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "MI",
      "RM",
      "TO",
      "FI",
      "NA",
      "BO",
      "GE",
      "BS"
    ],
    "negativeContentExamples": [
      "RMN",
      "mi",
      "M1",
      "R M",
      "RM-",
      "R",
      "ROMA",
      "\u00d3A"
    ],
    "positiveHeaderExamples": [
      "Provincia",
      "Province Code",
      "Italian Province",
      "Italian Province Code",
      "Prov Code",
      "Provincia Codice",
      "IT Province Code"
    ],
    "negativeHeaderExamples": [
      "Province Name",
      "Region",
      "Country",
      "Postal Code",
      "State Code",
      "City",
      "Area Code"
    ],
    "explanation": "Italian province codes are two-letter uppercase abbreviations representing provinces in Italy. This semantic type targets values that are exactly two uppercase letters and relies on context from column headers to distinguish them from other two-letter codes. Typical uses include geospatial joins, regional aggregations, and validation of administrative identifiers in Italian datasets.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:27.712427"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.REGION_NAME_PE",
    "description": "This type captures the official names of Peruvian regions as they are used in national administration and geographic identification. The values represent complete regional names using proper Spanish spelling and standard formatting as established by Peruvian territorial organization.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AMAZONAS",
      "\u00c1NCASH",
      "APUR\u00cdMAC",
      "AREQUIPA",
      "AYACUCHO",
      "CAJAMARCA",
      "CALLAO",
      "CUSCO",
      "HUANCAVELICA",
      "HU\u00c1NUCO",
      "ICA",
      "JUN\u00cdN",
      "LA LIBERTAD",
      "LAMBAYEQUE",
      "LIMA",
      "LORETO",
      "MADRE DE DIOS",
      "MOQUEGUA",
      "PASCO",
      "PIURA",
      "PUNO",
      "SAN MART\u00cdN",
      "TACNA",
      "TUMBES",
      "UCAYALI"
    ],
    "backout": "^[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00d1 ]{3,20}$",
    "confidenceThreshold": 97,
    "priority": 3750,
    "headerPatterns": [
      {
        "regExp": "(?i).*(peru|pe).*(region|regi\u00f3n).*(name|nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "PE Region Name"
        ],
        "negativeExamples": [
          "Region Name CA"
        ]
      },
      {
        "regExp": "(?i).*(peruvian|peru|pe).*(region|regi\u00f3n).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Peruvian Region"
        ],
        "negativeExamples": [
          "Region EU"
        ]
      },
      {
        "regExp": "(?i).*(region|regi\u00f3n).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Region Name"
        ],
        "negativeExamples": [
          "Region Code"
        ]
      },
      {
        "regExp": "(?i).*(region|regi\u00f3n).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Regi\u00f3n"
        ],
        "negativeExamples": [
          "Province"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "San Mart\u00edn",
      "Madre de Dios",
      "La Libertad",
      "Lima",
      "\u00c1ncash",
      "Apur\u00edmac",
      "Jun\u00edn",
      "Hu\u00e1nuco"
    ],
    "negativeContentExamples": [
      "San Martin",
      "Madre de Di\u00f3s",
      "La Libertad Region",
      "Regi\u00f3n Lima",
      "Lima Metropolitana",
      "Cuzco",
      "Huanuco",
      "Callao Province"
    ],
    "positiveHeaderExamples": [
      "Regi\u00f3n",
      "Region",
      "Peruvian Region",
      "Peru Region Name",
      "PE Region",
      "Region Name",
      "Nombre de Regi\u00f3n",
      "Region (PE)"
    ],
    "negativeHeaderExamples": [
      "Province",
      "Country",
      "City",
      "Region Code",
      "Administrative Region",
      "Department Name",
      "State",
      "Postal Region"
    ],
    "explanation": "Identifies the official Spanish names of Peru\u2019s first-level administrative regions (regiones). Best used to validate or standardize geographic attributes referring to Peruvian regions in datasets, ensuring correct spelling and diacritics.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:30.417788"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_AU",
    "description": "This type captures abbreviated codes for Australian states and territories used in official documentation and geographic identification systems. The values represent standardized abbreviations derived from state names using uppercase letters without periods or additional punctuation.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "NSW",
      "VIC",
      "QLD",
      "SA",
      "WA",
      "TAS",
      "NT",
      "ACT"
    ],
    "backout": "^[A-Z]{2,3}$",
    "confidenceThreshold": 98,
    "priority": 3770,
    "headerPatterns": [
      {
        "regExp": "(?i).*australian[ _-]*state[ _-]*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Australian State Code"
        ],
        "negativeExamples": [
          "Australian State"
        ]
      },
      {
        "regExp": "(?i).*au[ _-]*state[ _-]*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "AU State Code"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*state[ _/-]*territory[ _-]*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State/Territory Code"
        ],
        "negativeExamples": [
          "Territory"
        ]
      },
      {
        "regExp": "(?i).*state[ _-]*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Code"
        ],
        "negativeExamples": [
          "State Name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "NSW",
      "VIC",
      "QLD",
      "SA",
      "WA",
      "TAS",
      "NT",
      "ACT"
    ],
    "negativeContentExamples": [
      "NS",
      "NSWS",
      "N.S.W",
      "NSW.",
      "vic",
      "ACT1",
      "WAU",
      "QL"
    ],
    "positiveHeaderExamples": [
      "State Code",
      "Australian State",
      "State",
      "Australian State Code",
      "AU State Code",
      "State/Territory Code",
      "State Abbreviation",
      "AUS State Abbrev"
    ],
    "negativeHeaderExamples": [
      "State Name",
      "Country",
      "Territory",
      "Province Code",
      "Region Code",
      "Country Code",
      "State ID",
      "Location"
    ],
    "explanation": "This semantic type represents the finite set of official Australian state and territory abbreviations used in addresses and geographic datasets. It is implemented as a list for precision, with a backout pattern ensuring values are 2\u20133 uppercase letters to prevent overly broad matches. Typical use cases include validating address fields, normalizing geographic attributes, and filtering columns labeled as state codes specific to Australia.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:31.035173"
  },
  {
    "resultType": "generated",
    "semanticType": "NATIONALITY_EN",
    "description": "This type captures nationality designations as they are commonly expressed in English for identification, documentation, and demographic purposes. The values represent standard nationality terms following English language conventions and international usage without abbreviations or alternative language forms.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AMERICAN",
      "BRITISH",
      "FRENCH",
      "GERMAN",
      "CANADIAN",
      "AUSTRALIAN",
      "INDIAN",
      "JAPANESE",
      "CHINESE",
      "ITALIAN",
      "SPANISH",
      "RUSSIAN",
      "BRAZILIAN",
      "MEXICAN",
      "SOUTH AFRICAN",
      "SAUDI ARABIAN",
      "NEW ZEALANDER",
      "PUERTO RICAN",
      "COSTA RICAN",
      "TURKISH",
      "EGYPTIAN",
      "NIGERIAN",
      "KENYAN",
      "ARGENTINE",
      "IRISH"
    ],
    "backout": "^[A-Z][A-Z -]{2,29}$",
    "confidenceThreshold": 94,
    "priority": 3100,
    "headerPatterns": [
      {
        "regExp": "(?i).*(customer|applicant|user).*(nationality|citizenship).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_nationality"
        ],
        "negativeExamples": [
          "customer_country"
        ]
      },
      {
        "regExp": "(?i).*(primary|legal).*(citizenship).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "primary_citizenship"
        ],
        "negativeExamples": [
          "primary_country"
        ]
      },
      {
        "regExp": "(?i).*place.*of.*origin.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "place_of_origin"
        ],
        "negativeExamples": [
          "place_of_birth"
        ]
      },
      {
        "regExp": "(?i).*(nationality|citizenship).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Citizenship"
        ],
        "negativeExamples": [
          "Language"
        ]
      },
      {
        "regExp": "(?i).*nationality.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Nationality"
        ],
        "negativeExamples": [
          "Country"
        ]
      }
    ],
    "positiveContentExamples": [
      "American",
      "British",
      "French",
      "Japanese",
      "South African",
      "Saudi Arabian",
      "New Zealander",
      "Puerto Rican"
    ],
    "negativeContentExamples": [
      "United States",
      "England",
      "Japan",
      "New Zealand",
      "Saudi Arabia",
      "Puerto Rico",
      "EU citizen",
      "French language"
    ],
    "positiveHeaderExamples": [
      "Nationality",
      "Citizenship",
      "Origin",
      "Customer Nationality",
      "Primary Citizenship",
      "Place of Origin",
      "Applicant Nationality",
      "User Origin"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Ethnicity",
      "Language",
      "Residence Country",
      "Birthplace",
      "Region",
      "Locale",
      "Mother Tongue"
    ],
    "explanation": "Identifies English demonyms/nationality adjectives and multi-word nationality forms used in personal records (e.g., American, South African, Saudi Arabian). Useful for classifying fields that describe a person's nationality or citizenship status, distinct from country names or places of birth.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:36.697606"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_BR",
    "description": "This type identifies Brazilian municipality names used for local administrative identification within Brazil's governmental structure. The format consists of proper noun text strings representing official municipality names in Portuguese without abbreviations or special formatting characters.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z\u00c0-\u00dd][a-z\u00e0-\u00ff]+)((\\s+(de|do|da|dos|das|e)\\s+([A-Z\u00c0-\u00dd][a-z\u00e0-\u00ff]+))|(\\s+([A-Z\u00c0-\u00dd][a-z\u00e0-\u00ff]+))){1,5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 3550,
    "headerPatterns": [
      {
        "regExp": "(?i).*(municipality|munic\u00edpio).*(brazil|brasil|br).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Brazilian Municipality"
        ],
        "negativeExamples": [
          "Municipality Code"
        ]
      },
      {
        "regExp": "(?i).*(municipality|munic\u00edpio).*(name|nome).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Municipality Name"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(nome[ _]?do[ _]?munic\u00edpio|nome[ _]?munic\u00edpio).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Nome do Munic\u00edpio"
        ],
        "negativeExamples": [
          "State"
        ]
      },
      {
        "regExp": "(?i).*\\b(municipality|munic\u00edpio)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Municipality"
        ],
        "negativeExamples": [
          "Province"
        ]
      },
      {
        "regExp": "(?i).*\\bname\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "S\u00e3o Paulo",
      "Rio de Janeiro",
      "Belo Horizonte",
      "Porto Alegre",
      "Juiz de Fora",
      "S\u00e3o Jos\u00e9 dos Campos",
      "Foz do Igua\u00e7u",
      "Mogi das Cruzes"
    ],
    "negativeContentExamples": [
      "RIO DE JANEIRO",
      "sao paulo",
      "Porto-Alegre",
      "S\u00e3o_Paulo",
      "Campinas/SP",
      "Rio de",
      "SantoAndre",
      "Rio_de_Janeiro"
    ],
    "positiveHeaderExamples": [
      "Munic\u00edpio",
      "Municipality",
      "Brazilian Municipality",
      "Nome do Munic\u00edpio",
      "Municipality Name",
      "Nome Munic\u00edpio",
      "Munic\u00edpio Brasileiro",
      "Nome de Munic\u00edpio"
    ],
    "negativeHeaderExamples": [
      "State",
      "Country",
      "Municipality Code",
      "State Code",
      "City",
      "County",
      "Province",
      "District"
    ],
    "explanation": "Identifies Brazilian municipality names written as multi-word proper nouns with optional Portuguese prepositions (de, do, da, dos, das, e) and spaces only. It excludes abbreviations, codes, punctuation, and hyphenated or underscored forms to minimize ambiguity. Use for columns whose values are municipality names in Brazil, typically paired with state or region fields for disambiguation.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:37.682562"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_ZA",
    "description": "This type captures abbreviated codes for South African provinces used in official documentation and geographic identification systems. The values represent standardized two-character abbreviations derived from province names using uppercase letters without periods or additional punctuation.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "EC",
      "FS",
      "GP",
      "KZ",
      "LP",
      "MP",
      "NW",
      "NC",
      "WC"
    ],
    "backout": "^[A-Z]{2}$",
    "confidenceThreshold": 96,
    "priority": 3720,
    "headerPatterns": [
      {
        "regExp": "(?i).*za.*province.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "ZA Province Code"
        ],
        "negativeExamples": [
          "Province Code"
        ]
      },
      {
        "regExp": "(?i).*sa.*province.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "SA Province"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      },
      {
        "regExp": "(?i).*province.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Province Code"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*prov.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Prov Code"
        ],
        "negativeExamples": [
          "Region Code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "EC",
      "FS",
      "GP",
      "KZ",
      "LP",
      "MP",
      "NW",
      "NC"
    ],
    "negativeContentExamples": [
      "KZN",
      "GP.",
      "gp",
      "ZA",
      "WC-",
      "EC1",
      "NW ",
      "Gauteng"
    ],
    "positiveHeaderExamples": [
      "Province Code",
      "SA Province",
      "Province",
      "ZA Province Code",
      "Prov Code",
      "Province Abbrev",
      "Province ID",
      "Province 2-Letter Code"
    ],
    "negativeHeaderExamples": [
      "Province Name",
      "Country",
      "District",
      "Postal Code",
      "Country Code",
      "State Code",
      "Region",
      "ISO Subdivision"
    ],
    "explanation": "South African province codes are a small, finite set of two-letter uppercase abbreviations used to reference provinces. Using a list-based plugin with a strict two-letter backout ensures high precision while allowing graceful fallback when unseen but similarly shaped values appear in datasets.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:37.964001"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.INSEE_CODE_FR",
    "description": "This type represents French INSEE codes used for official statistical identification of communes within France's administrative system. The format consists of exactly five consecutive numeric digits without spaces, letters, or special formatting characters for standardized territorial referencing.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{5}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3540,
    "headerPatterns": [
      {
        "regExp": "(?i).*commune.*insee.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Commune INSEE Code"
        ],
        "negativeExamples": [
          "INSEE Region Code"
        ]
      },
      {
        "regExp": "(?i).*code.*insee.*commune.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "code_insee_commune"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      },
      {
        "regExp": "(?i).*insee.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "INSEE Code"
        ],
        "negativeExamples": [
          "City Name"
        ]
      },
      {
        "regExp": "(?i).*insee.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "INSEE"
        ],
        "negativeExamples": [
          "Department Name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Amount"
        ]
      }
    ],
    "positiveContentExamples": [
      "01001",
      "13055",
      "33063",
      "35238",
      "59350",
      "69012",
      "75056",
      "44109"
    ],
    "negativeContentExamples": [
      "7505",
      "2A123",
      "75 056",
      "750-56",
      "A75056",
      "75056A",
      "A75056B",
      "7505 6"
    ],
    "positiveHeaderExamples": [
      "Code INSEE",
      "INSEE Code",
      "INSEE",
      "Commune INSEE Code",
      "code_insee_commune",
      "INSEE commune code",
      "code insee",
      "insee_id"
    ],
    "negativeHeaderExamples": [
      "City Name",
      "Department",
      "Postal Code",
      "Commune Name",
      "Department Code",
      "Country Code",
      "SIREN",
      "Address"
    ],
    "explanation": "French INSEE commune codes are structured as exactly five digits, used for consistent identification of municipalities in administrative and statistical datasets. This pattern targets purely numeric, five-digit values and pairs best with headers explicitly referencing INSEE and codes to disambiguate from other 5-digit fields such as postal codes.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:39.760822"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_BR",
    "description": "This type captures abbreviated codes for Brazilian states and the federal district used in official documentation and geographic identification systems. The values represent standardized two-character abbreviations derived from state names using uppercase letters without periods or additional punctuation.",
    "pluginType": "regex",
    "regexPattern": "\\b(AC|AL|AP|AM|BA|CE|DF|ES|GO|MA|MT|MS|MG|PA|PB|PR|PE|PI|RJ|RN|RS|RO|RR|SC|SP|SE|TO)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3780,
    "headerPatterns": [
      {
        "regExp": "(?i).*(brazil|brasil).*state.*code.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Brazilian State Code"
        ],
        "negativeExamples": [
          "State Name"
        ]
      },
      {
        "regExp": "(?i).*(brazil|brasil).*state.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Brazilian State"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(estado).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Estado"
        ],
        "negativeExamples": [
          "Region"
        ]
      },
      {
        "regExp": "(?i).*(state).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Code"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "SP",
      "RJ",
      "MG",
      "ES",
      "DF",
      "BA",
      "PR",
      "RS"
    ],
    "negativeContentExamples": [
      "sp",
      "Sp",
      "SPO",
      "RJ1",
      "BR",
      "XX",
      "PB_",
      "R0"
    ],
    "positiveHeaderExamples": [
      "Estado",
      "State Code",
      "Brazilian State",
      "Brazilian State Code",
      "State Abbreviation",
      "BR State Code",
      "State Short Code"
    ],
    "negativeHeaderExamples": [
      "State Name",
      "Country",
      "Region",
      "Province",
      "Postal Code",
      "Country Code",
      "City"
    ],
    "explanation": "Identifies two-letter uppercase abbreviations for Brazilian states and the federal district. Useful for validating location fields, standardizing geographic identifiers, and mapping to reference datasets. The regex enumerates the official codes and uses word boundaries to avoid overmatching within longer strings.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:49.619503"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_NL",
    "description": "Identifies Dutch municipality names used for local administrative identification within the Netherlands governmental structure. Values are proper-noun text strings in Dutch, using alphabetic characters with optional spaces, hyphens, and apostrophes, and may include Dutch diacritics. Abbreviations and special formatting characters are excluded.",
    "pluginType": "regex",
    "regexPattern": "\\b(['\u2019]s-)?[A-Z\u00c0-\u00d6\u00d8-\u00dd][A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff'\u2019]+([ -][A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff'\u2019]+)*(\\s\\([A-Z]{2,3}\\))?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3600,
    "headerPatterns": [
      {
        "regExp": "(?i).*(dutch|nl).*(municipality|gemeente).*(name|naam).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Municipality Name (NL)"
        ],
        "negativeExamples": [
          "Municipality Code"
        ]
      },
      {
        "regExp": "(?i).*(dutch|nl).*(municipalit(y|ies)).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Dutch Municipality"
        ],
        "negativeExamples": [
          "Country Municipality"
        ]
      },
      {
        "regExp": "(?i).*(gemeente).*(naam|name).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Gemeente Naam"
        ],
        "negativeExamples": [
          "Gemeente Code"
        ]
      },
      {
        "regExp": "(?i).*(municipality|gemeente|muni|gem).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Gemeente"
        ],
        "negativeExamples": [
          "Province"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Municipality Name"
        ],
        "negativeExamples": [
          "Municipality Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Amsterdam",
      "Rotterdam",
      "Utrecht",
      "Den Haag",
      "Eindhoven",
      "'s-Hertogenbosch",
      "Alphen aan den Rijn",
      "S\u00fadwest-Frysl\u00e2n"
    ],
    "negativeContentExamples": [
      "amsterdam",
      "Amsterdam-123",
      "Province Noord-Holland",
      "NL Amsterdam",
      "'s Hertogenbosch",
      "Alphen a/d Rijn",
      "Groningen.",
      "Den  Haag"
    ],
    "positiveHeaderExamples": [
      "Gemeente",
      "Municipality",
      "Dutch Municipality",
      "Gemeente Naam",
      "Municipality Name",
      "NL Municipality",
      "Gemeente NL",
      "Municipality (NL)"
    ],
    "negativeHeaderExamples": [
      "Province",
      "Country",
      "Municipality Code",
      "Province Name",
      "Country Code",
      "Postal Code",
      "City"
    ],
    "explanation": "This semantic type targets official names of Dutch municipalities, capturing proper Dutch naming conventions including optional leading 's- forms, spaces, hyphens, apostrophes, and diacritics. It excludes abbreviations, appended codes, numeric suffixes, and non-Dutch or formatted variants. Use it to identify columns containing municipality names within the Netherlands for geospatial or administrative analyses.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:52.897449"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_CODE_BR",
    "description": "This type represents Brazilian municipality codes used for official statistical identification of municipal areas within Brazil's administrative system. The format consists of exactly seven consecutive numeric digits without spaces, letters, or special formatting characters for standardized municipal referencing.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{7}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 3570,
    "headerPatterns": [
      {
        "regExp": "(?i).*(c[o\u00f3]digo).*do.*(munic[i\u00ed]pio).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "C\u00f3digo do Munic\u00edpio"
        ],
        "negativeExamples": [
          "Municipality Code"
        ]
      },
      {
        "regExp": "(?i).*(municipality).*(code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Municipality Code"
        ],
        "negativeExamples": [
          "Municipality Name"
        ]
      },
      {
        "regExp": "(?i).*ibge.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IBGE Code"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*(cod).*(municipio|munic\u00edpio|mun).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "cod_municipio"
        ],
        "negativeExamples": [
          "cod_estado"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "1100015",
      "3304557",
      "2927408",
      "4216206",
      "1501402",
      "2304400",
      "5208707",
      "0123456"
    ],
    "negativeContentExamples": [
      "110001",
      "11000155",
      "11 00015",
      "1100-015",
      "1100015a",
      "a1100015",
      "AB1100015",
      "123 4567"
    ],
    "positiveHeaderExamples": [
      "C\u00f3digo do Munic\u00edpio",
      "Municipality Code",
      "IBGE Code",
      "Municipal Code",
      "Codigo Municipio",
      "IBGE Municipality Code",
      "cod_municipio",
      "Municipio Code"
    ],
    "negativeHeaderExamples": [
      "Municipality Name",
      "State",
      "Country",
      "City Name",
      "Municipality ID",
      "Province Code",
      "Region",
      "Postal Code"
    ],
    "explanation": "Brazilian municipality codes are seven-digit numeric identifiers used by official statistics and administrative systems to uniquely reference municipalities. This semantic type validates tokens that are exactly seven digits with no separators or letters, making it suitable for data quality checks, schema mapping, and join keys against municipal-level datasets.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:55.799596"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_AU",
    "description": "This type captures the complete names of Australian states and territories as they are used in official documentation and government administration. The values represent full state names using proper English spelling and standard formatting as established by Australian constitutional and administrative systems.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "NEW SOUTH WALES",
      "VICTORIA",
      "QUEENSLAND",
      "SOUTH AUSTRALIA",
      "WESTERN AUSTRALIA",
      "TASMANIA",
      "NORTHERN TERRITORY",
      "AUSTRALIAN CAPITAL TERRITORY"
    ],
    "backout": "^[A-Za-z]+( [A-Za-z]+){0,3}$",
    "confidenceThreshold": 98,
    "priority": 3810,
    "headerPatterns": [
      {
        "regExp": "(?i).*australian.*state.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Australian State Name"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*(state|territory).*full.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Full Name"
        ],
        "negativeExamples": [
          "State Abbrev"
        ]
      },
      {
        "regExp": "(?i).*(au|australia|australian).*(state|territory).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Australian State"
        ],
        "negativeExamples": [
          "Country State"
        ]
      },
      {
        "regExp": "(?i).*(state|territory).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State"
        ],
        "negativeExamples": [
          "Region"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "New South Wales",
      "Victoria",
      "Queensland",
      "South Australia",
      "Western Australia",
      "Tasmania",
      "Northern Territory",
      "Australian Capital Territory"
    ],
    "negativeContentExamples": [
      "NSW",
      "New South Wales (NSW)",
      "Victoria State",
      "Queensland, Australia",
      "South Australia - SA",
      "Western Australia WA",
      "Northern Terr",
      "Australian Capital Territory (ACT)"
    ],
    "positiveHeaderExamples": [
      "State",
      "Australian State",
      "State Name",
      "Australian State Name",
      "State or Territory",
      "AU State",
      "State Full Name",
      "State/Territory Name"
    ],
    "negativeHeaderExamples": [
      "State Code",
      "Country",
      "Territory",
      "Province",
      "Region",
      "State Abbreviation",
      "AU Territory Code",
      "Country Subdivision Code"
    ],
    "explanation": "This semantic type identifies columns containing the full names of Australian states and territories. It is intended for datasets where the jurisdiction is Australia and full names are stored rather than abbreviations. The list plugin ensures high precision by matching only the official names, while the backout pattern provides a safe structural fallback for values shaped like multi-word names.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:56.133026"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_UNION_NAME_IN",
    "description": "This type captures the complete names of Indian states and union territories as they are used in official documentation and government administration. The values represent full state and union territory names using proper English spelling and standard formatting as established by the Indian constitutional and administrative systems.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(ANDHRA PRADESH|ARUNACHAL PRADESH|ASSAM|BIHAR|CHHATTISGARH|GOA|GUJARAT|HARYANA|HIMACHAL PRADESH|JHARKHAND|KARNATAKA|KERALA|MADHYA PRADESH|MAHARASHTRA|MANIPUR|MEGHALAYA|MIZORAM|NAGALAND|ODISHA|PUNJAB|RAJASTHAN|SIKKIM|TAMIL NADU|TELANGANA|TRIPURA|UTTAR PRADESH|UTTARAKHAND|WEST BENGAL|ANDAMAN AND NICOBAR ISLANDS|CHANDIGARH|DADRA AND NAGAR HAVELI AND DAMAN AND DIU|DELHI|JAMMU AND KASHMIR|LADAKH|LAKSHADWEEP|PUDUCHERRY)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3890,
    "headerPatterns": [
      {
        "regExp": "(?i).*india.*(state|union.*territory).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "India State Name"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*(state|union.*territory).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Union Territory Name"
        ],
        "negativeExamples": [
          "Territory Code"
        ]
      },
      {
        "regExp": "(?i).*indian.*state.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Indian State"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(union.*territory|ut).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Union Territory"
        ],
        "negativeExamples": [
          "Union Territory Code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Maharashtra",
      "Tamil Nadu",
      "West Bengal",
      "Andaman and Nicobar Islands",
      "Jammu and Kashmir",
      "Dadra and Nagar Haveli and Daman and Diu",
      "Puducherry",
      "Uttar Pradesh"
    ],
    "negativeContentExamples": [
      "Maharastra",
      "TamilNadu",
      "West Bengal State",
      "Andaman & Nicobar Islands",
      "Jammu & Kashmir",
      "NCT of Delhi",
      "Orissa",
      "Uttar-Pradesh"
    ],
    "positiveHeaderExamples": [
      "State",
      "Indian State",
      "Union Territory",
      "State Name",
      "State/UT Name",
      "India State Name",
      "Union Territory Name",
      "State or UT"
    ],
    "negativeHeaderExamples": [
      "State Code",
      "Country",
      "District",
      "Province",
      "Region",
      "Country Name",
      "Territory Code",
      "Postal Code"
    ],
    "explanation": "The semantic type identifies full official names of India's states and union territories for use in address normalization, administrative geography classification, and validation of location fields in datasets. It is strict to the standard English spellings and formatting used in official contexts to minimize ambiguity and improve matching precision.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:58.079788"
  },
  {
    "resultType": "generated",
    "semanticType": "NAME.FIRST",
    "description": "This type captures individual given names as they appear in personal identification, records, and formal documentation across different cultures. The values represent first names using standard spelling and formatting conventions without including middle names, surnames, or titles.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z][a-z]{1,24}|[A-Z]{2,25})([-']([A-Z][a-z]{1,24}|[A-Z]{2,25}))?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3030,
    "headerPatterns": [
      {
        "regExp": "(?i).*(customer|user|person|employee)[ _-]*first[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "customer_first_name"
        ],
        "negativeExamples": [
          "customer_last_name"
        ]
      },
      {
        "regExp": "(?i).*first[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "First Name"
        ],
        "negativeExamples": [
          "Last Name"
        ]
      },
      {
        "regExp": "(?i).*given[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Given Name"
        ],
        "negativeExamples": [
          "Full Name"
        ]
      },
      {
        "regExp": "(?i).*forename.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Forename"
        ],
        "negativeExamples": [
          "Middle Name"
        ]
      },
      {
        "regExp": "(?i).*(f[_-]?name|fname|first[_-]?nm).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "fname"
        ],
        "negativeExamples": [
          "lname"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Alice",
      "John",
      "ANNA",
      "Jean-Luc",
      "O'Neil",
      "Li",
      "Mary-Jane",
      "De'Andre"
    ],
    "negativeContentExamples": [
      "Mary Jane",
      "J",
      "Ann3",
      "-Alice",
      "O\u2019Neil",
      "D'angelo",
      "Jean--Luc",
      "Anna-"
    ],
    "positiveHeaderExamples": [
      "First Name",
      "Given Name",
      "Forename",
      "Customer First Name",
      "user_first_name",
      "First_Name",
      "fname",
      "Employee Given Name"
    ],
    "negativeHeaderExamples": [
      "Last Name",
      "Full Name",
      "Middle Name",
      "Surname",
      "Family Name",
      "Display Name",
      "Account Name",
      "Customer Last Name"
    ],
    "explanation": "Identifies a single given name token commonly used as a person's first name, optionally with one internal hyphen or apostrophe and supporting capitalized or all-uppercase tokens. Useful for normalizing and validating columns that contain only first names, differentiating them from middle names, surnames, or composite full names.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:16:59.803767"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_FIPS_US",
    "description": "This type captures FIPS state codes used in US federal government databases and statistical reporting systems. The values represent two-digit numerical identifiers assigned to each state and territory using zero-padded format without separators or additional characters.",
    "pluginType": "regex",
    "regexPattern": "\\b(01|02|04|05|06|08|09|10|11|12|13|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32|33|34|35|36|37|38|39|40|41|42|44|45|46|47|48|49|50|51|53|54|55|56|60|66|69|72|78)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 3790,
    "headerPatterns": [
      {
        "regExp": "(?i).*state.*fips.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State FIPS Code"
        ],
        "negativeExamples": [
          "County FIPS Code"
        ]
      },
      {
        "regExp": "(?i).*(us|usa).*state.*fips.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "US State FIPS"
        ],
        "negativeExamples": [
          "FIPS Code"
        ]
      },
      {
        "regExp": "(?i).*fips.*state.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "FIPS State Code"
        ],
        "negativeExamples": [
          "State Name"
        ]
      },
      {
        "regExp": "(?i).*(state|st).*fips.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State FIPS"
        ],
        "negativeExamples": [
          "County FIPS"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "01",
      "04",
      "06",
      "11",
      "36",
      "48",
      "56",
      "72"
    ],
    "negativeContentExamples": [
      "03",
      "07",
      "57",
      "00",
      "1",
      "006",
      "A06",
      "79"
    ],
    "positiveHeaderExamples": [
      "State FIPS",
      "FIPS Code",
      "State Code",
      "State FIPS Code",
      "US State FIPS",
      "FIPS State Code",
      "FIPS State",
      "State FIPS Identifier"
    ],
    "negativeHeaderExamples": [
      "State Name",
      "Country",
      "County FIPS",
      "Zip Code",
      "ISO Code",
      "County Code",
      "Province Code",
      "Country FIPS"
    ],
    "explanation": "This semantic type identifies two-digit, zero-padded FIPS codes assigned to US states and territories. It is useful for joining and validating datasets against federal geographic identifiers and ensures codes are strictly limited to the official state/territory set without separators or additional characters.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:17:00.434165"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_IT",
    "description": "This type identifies Italian province names used for administrative identification within Italy's governmental structure. The format consists of proper noun text strings representing official province names in Italian without abbreviations or special formatting characters.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(?!provincia\\b)(?!citta\\b)(?!citt\u00e0\\b)([A-Z][a-z\u00e0-\u00f6\u00f8-\u00ff]+(\\s(e|di|del|della|delle|dei|degli|de|dello|valle|val)|\\s[A-Z][a-z\u00e0-\u00f6\u00f8-\u00ff]+){0,5}\\s[A-Z][a-z\u00e0-\u00f6\u00f8-\u00ff]+|[A-Z][a-z\u00e0-\u00f6\u00f8-\u00ff]+)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 3680,
    "headerPatterns": [
      {
        "regExp": "(?i).*(province|provincia).*(name|nome).*(it|italian).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province_name_it"
        ],
        "negativeExamples": [
          "Province Code"
        ]
      },
      {
        "regExp": "(?i).*(italian|it).*(province|provincia).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Italian Province"
        ],
        "negativeExamples": [
          "Italian Region"
        ]
      },
      {
        "regExp": "(?i).*\\b(province|provincia)\\b.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Province"
        ],
        "negativeExamples": [
          "Region"
        ]
      },
      {
        "regExp": "(?i).*\\bprov\\b.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "prov"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Roma",
      "Torino",
      "Milano",
      "Bergamo",
      "La Spezia",
      "Reggio Emilia",
      "Vibo Valentia",
      "Monza e della Brianza"
    ],
    "negativeContentExamples": [
      "L'Aquila",
      "Forl\u00ec-Cesena",
      "Verbano-Cusio-Ossola",
      "Provincia di Roma",
      "Roma 2",
      "Milano (MI)",
      "Citt\u00e0 Metropolitana di Napoli",
      "Pisa."
    ],
    "positiveHeaderExamples": [
      "Provincia",
      "Province",
      "Italian Province",
      "province_name_it",
      "provincia_nome",
      "province name",
      "nome provincia",
      "prov"
    ],
    "negativeHeaderExamples": [
      "Province Code",
      "Region",
      "Country",
      "Postal Code",
      "State",
      "City",
      "Region Name",
      "Code"
    ],
    "explanation": "Province names in Italian are typically single or multi-word proper nouns, possibly including lowercase connectors like e, di, del, and della, but without abbreviations, punctuation, or codes. This semantic type is useful for validating and classifying columns that contain normalized Italian province names in administrative datasets, address registries, and regional statistics where the values are the names only, not codes or prefixed phrases such as 'Provincia di ...'.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:17:01.120900"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.REGION_NAME_FR",
    "description": "This type captures the official names of French regions as they are used in government documentation and administrative contexts. The values represent complete regional names using proper French spelling, including diacritical marks and standard formatting as established by French territorial administration.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AUVERGNE-RH\u00d4NE-ALPES",
      "BOURGOGNE-FRANCHE-COMT\u00c9",
      "BRETAGNE",
      "CENTRE-VAL DE LOIRE",
      "CORSE",
      "GRAND EST",
      "HAUTS-DE-FRANCE",
      "\u00ceLE-DE-FRANCE",
      "NORMANDIE",
      "NOUVELLE-AQUITAINE",
      "OCCITANIE",
      "PAYS DE LA LOIRE",
      "PROVENCE-ALPES-C\u00d4TE D'AZUR",
      "GUADELOUPE",
      "MARTINIQUE",
      "GUYANE",
      "LA R\u00c9UNION",
      "MAYOTTE"
    ],
    "backout": "^[A-Z\u00c0\u00c2\u00c4\u00c7\u00c9\u00c8\u00ca\u00cb\u00ce\u00cf\u00d4\u00d6\u00d9\u00db\u00dc\u0178' \\-]{2,40}$",
    "confidenceThreshold": 98,
    "priority": 3730,
    "headerPatterns": [
      {
        "regExp": "(?i).*(french|france).*region.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "French Region"
        ],
        "negativeExamples": [
          "Region"
        ]
      },
      {
        "regExp": "(?i).*r\u00e9gion.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "R\u00e9gion"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*region.*fr.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "region_fr"
        ],
        "negativeExamples": [
          "department_fr"
        ]
      },
      {
        "regExp": "(?i).*(reg|rgn).*fr.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "reg_fr"
        ],
        "negativeExamples": [
          "register"
        ]
      },
      {
        "regExp": "(?i).*region.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Region"
        ],
        "negativeExamples": [
          "City"
        ]
      }
    ],
    "positiveContentExamples": [
      "\u00ceLE-DE-FRANCE",
      "AUVERGNE-RH\u00d4NE-ALPES",
      "BOURGOGNE-FRANCHE-COMT\u00c9",
      "PROVENCE-ALPES-C\u00d4TE D'AZUR",
      "PAYS DE LA LOIRE",
      "NOUVELLE-AQUITAINE",
      "HAUTS-DE-FRANCE",
      "LA R\u00c9UNION"
    ],
    "negativeContentExamples": [
      "Ile-de-France",
      "Grand-Est",
      "Provence-Alpes-Cote d'Azur",
      "Pays-de-la-Loire",
      "Auvergne Rh\u00f4ne Alpes",
      "Guyane Fran\u00e7aise",
      "Normandy",
      "Aquitaine"
    ],
    "positiveHeaderExamples": [
      "R\u00e9gion",
      "Region",
      "French Region",
      "region_fr",
      "reg_fr",
      "french_region",
      "r\u00e9gion_france",
      "R\u00e9gion FR"
    ],
    "negativeHeaderExamples": [
      "Department",
      "Country",
      "City",
      "Region Code",
      "Province",
      "State",
      "County",
      "Region ID"
    ],
    "explanation": "This semantic type identifies the official names of the 18 regions of France, including metropolitan and overseas regions, using correct French spelling and diacritics. It is appropriate for columns containing region names in French administrative datasets, geospatial attributes, and government records. The list-based approach ensures high precision by matching only the recognized official region names, while the backout pattern guards against malformed uppercase strings that resemble the domain.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:17:03.168299"
  },
  {
    "resultType": "generated",
    "semanticType": "JOB_TITLE_EN",
    "description": "Captures job titles and occupational designations as they appear in professional contexts, employment records, and organizational structures. Values represent standard professional roles, specialized positions, or functional titles using conventional workplace terminology.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b((senior|sr|junior|jr|lead|chief|principal|assistant|associate|executive|vice|deputy|global|regional)\\s+)?([A-Za-z]+[\\s/-]){0,3}(head|engineer|developer|manager|director|analyst|officer|consultant|specialist|technician|coordinator|administrator|architect|scientist|accountant|designer|supervisor|representative|advisor|controller|planner|buyer|auditor|attorney|nurse|physician|teacher|professor|driver|operator|chef|mechanic|electrician|plumber|foreman|welder|pharmacist|recruiter|strategist|editor|producer|researcher|programmer|tester)\\b(\\s+(of|for)\\s+[A-Za-z][A-Za-z\\s/-]{1,30})?(\\s+(i|ii|iii|iv))?\\b|\\b(ceo|cfo|cto|coo|cio|cmo|cdo|cso|cpo|vp|avp)(\\s+[A-Za-z]+){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 2950,
    "headerPatterns": [
      {
        "regExp": "(?i).*(job\\s*title|employee\\s*title|staff\\s*title).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Job Title"
        ],
        "negativeExamples": [
          "Job Code"
        ]
      },
      {
        "regExp": "(?i).*(employee|staff)\\s*(position|role).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Staff Position"
        ],
        "negativeExamples": [
          "Employee Name"
        ]
      },
      {
        "regExp": "(?i).*(occupation|job\\s*role).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Job Role"
        ],
        "negativeExamples": [
          "Job Location"
        ]
      },
      {
        "regExp": "(?i).*(position|role)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Position"
        ],
        "negativeExamples": [
          "Company"
        ]
      },
      {
        "regExp": "(?i).*title.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Title"
        ],
        "negativeExamples": [
          "Salary"
        ]
      }
    ],
    "positiveContentExamples": [
      "Software Engineer",
      "Senior Data Analyst",
      "Chief Financial Officer",
      "VP Sales",
      "Director of Operations",
      "Product Manager",
      "Customer Support Representative",
      "Head of Marketing"
    ],
    "negativeContentExamples": [
      "Job Code 123",
      "Salary Grade 5",
      "Project Managerial",
      "Marketing Department",
      "Engineering Team",
      "Position ID",
      "Title of Book",
      "Senior"
    ],
    "positiveHeaderExamples": [
      "Job Title",
      "Position",
      "Occupation",
      "Employee Title",
      "Role",
      "Staff Position",
      "Job Role"
    ],
    "negativeHeaderExamples": [
      "Name",
      "Company",
      "Salary",
      "Job Code",
      "Start Date",
      "Department",
      "Employee ID"
    ],
    "explanation": "This semantic type identifies English job titles typically found in HR systems, resumes, org charts, and workforce datasets. The regex looks for common seniority prefixes, a constrained number of contextual tokens, and a required role keyword or executive acronym (CEO, CTO, VP, AVP), optionally followed by bounded qualifiers like \"of Marketing\" or Roman numeral levels. The patterns are designed to avoid over-broad matches by requiring a recognizable role term and bounded token counts.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:17:05.802656"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_EC",
    "description": "This type identifies Ecuadorian province names used for regional administrative identification within Ecuador's governmental structure. The format consists of proper noun text strings representing official province names in Spanish without abbreviations or special formatting characters.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AZUAY",
      "BOL\u00cdVAR",
      "CA\u00d1AR",
      "CARCHI",
      "CHIMBORAZO",
      "COTOPAXI",
      "EL ORO",
      "ESMERALDAS",
      "GAL\u00c1PAGOS",
      "GUAYAS",
      "IMBABURA",
      "LOJA",
      "LOS R\u00cdOS",
      "MANAB\u00cd",
      "MORONA SANTIAGO",
      "NAPO",
      "ORELLANA",
      "PASTAZA",
      "PICHINCHA",
      "SANTA ELENA",
      "SANTO DOMINGO DE LOS TS\u00c1CHILAS",
      "SUCUMB\u00cdOS",
      "TUNGURAHUA",
      "ZAMORA CHINCHIPE"
    ],
    "backout": "^[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1 ]{4,30}$",
    "confidenceThreshold": 96,
    "priority": 3650,
    "headerPatterns": [
      {
        "regExp": "(?i).*(ecuador|ecuadorian|ec).*provinc.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Ecuador province name"
        ],
        "negativeExamples": [
          "Ecuador province code"
        ]
      },
      {
        "regExp": "(?i).*(ecuador|ec).*provinc.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Provincia Ecuador"
        ],
        "negativeExamples": [
          "Ecuador Region"
        ]
      },
      {
        "regExp": "(?i).*provinc.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "province_name"
        ],
        "negativeExamples": [
          "province_code"
        ]
      },
      {
        "regExp": "(?i).*(provincia|province|prov).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Province"
        ],
        "negativeExamples": [
          "Province Code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Pichincha",
      "Guayas",
      "Manab\u00ed",
      "Azuay",
      "El Oro",
      "Los R\u00edos",
      "Santo Domingo de los Ts\u00e1chilas",
      "Zamora Chinchipe"
    ],
    "negativeContentExamples": [
      "Galapagos",
      "Manabi",
      "Los Rios",
      "Santo Domingo",
      "Sta. Elena",
      "Zamora-Chinchipe",
      "Esmeraldas Province",
      "Pichincha EC"
    ],
    "positiveHeaderExamples": [
      "Provincia",
      "Province",
      "Ecuadorian Province",
      "Provincia Ecuador",
      "Province Name",
      "EC Province",
      "Ecuador Province Name",
      "Nombre Provincia"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Region",
      "City",
      "State",
      "Department",
      "County",
      "Province Code",
      "Location"
    ],
    "explanation": "This semantic type captures the official names of Ecuador's first-level administrative divisions (provincias). It is intended for columns storing the textual province name in Spanish, without abbreviations or appended qualifiers. Typical uses include address normalization, geospatial aggregation, and regional reporting within Ecuador.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:17:11.816848"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_ES",
    "description": "This type identifies Spanish province names used for regional administrative identification within Spain's governmental structure. The format consists of proper noun text strings representing official province names in Spanish without abbreviations or special formatting characters.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(Albacete|Alicante|Almer\u00eda|\u00c1lava|Asturias|\u00c1vila|Badajoz|Barcelona|Burgos|C\u00e1ceres|C\u00e1diz|Cantabria|Castell\u00f3n|Ciudad Real|C\u00f3rdoba|Cuenca|Gerona|Granada|Guadalajara|Guip\u00fazcoa|Huelva|Huesca|Ja\u00e9n|La Rioja|Las Palmas|Le\u00f3n|Lugo|Madrid|M\u00e1laga|Murcia|Navarra|Palencia|Pontevedra|Salamanca|Santa Cruz de Tenerife|Segovia|Sevilla|Soria|Tarragona|Teruel|Toledo|Valencia|Valladolid|Vizcaya|Zamora|Zaragoza)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 3660,
    "headerPatterns": [
      {
        "regExp": "(?i).*province.*name.*es.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Province Name ES"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(provincia|province).*(name|nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Provincia Nombre"
        ],
        "negativeExamples": [
          "Region"
        ]
      },
      {
        "regExp": "(?i).*spanish.*(provincia|province).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Spanish Province"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*(prov|provincia|province).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Provincia"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Postal Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Madrid",
      "Barcelona",
      "Sevilla",
      "Zaragoza",
      "Valencia",
      "M\u00e1laga",
      "Salamanca",
      "Santa Cruz de Tenerife"
    ],
    "negativeContentExamples": [
      "Provincia de Madrid",
      "Comunidad de Madrid",
      "Santa Cruz Tenerife",
      "Las Palmas de Gran Canaria",
      "Valencia, Espa\u00f1a",
      "C\u00e1diz 12",
      "Province Sevilla",
      "Madrid City"
    ],
    "positiveHeaderExamples": [
      "Provincia",
      "Province",
      "Spanish Province",
      "Province Name ES",
      "Provincia Nombre",
      "Prov"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Region",
      "City",
      "State Code",
      "Customer Name",
      "Postal Code"
    ],
    "explanation": "This semantic type targets strings that are exactly Spanish province names, using a controlled set of official Spanish forms. It is intended for columns storing province names for regional classification, address normalization, or administrative reporting. Header patterns are designed from specific variants to general primitives to support a wide range of column naming conventions while minimizing false positives.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:17:12.550287"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.YEAR_OF_BIRTH",
    "description": "This type captures birth years as they appear in demographic data, personal records, and age-related analysis using four-digit year notation. The values represent the year component of birth dates without month or day information, typically following standard calendar year formatting conventions.",
    "pluginType": "regex",
    "regexPattern": "\\b(18[0-9]{2}|19[0-9]{2}|20(0[0-9]|1[0-9]|2[0-5]))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 3210,
    "headerPatterns": [
      {
        "regExp": "(?i).*year[ _-]*of[ _-]*birth.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Year of Birth"
        ],
        "negativeExamples": [
          "Date of Birth"
        ]
      },
      {
        "regExp": "(?i).*birth[ _-]*year.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Birth Year"
        ],
        "negativeExamples": [
          "Birth Date"
        ]
      },
      {
        "regExp": "(?i).*person.*birth.*year.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Person Birth Year"
        ],
        "negativeExamples": [
          "Person Age"
        ]
      },
      {
        "regExp": "(?i).*\\byob\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "YOB"
        ],
        "negativeExamples": [
          "DOB"
        ]
      },
      {
        "regExp": "(?i).*year[ _-]*born.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Year Born"
        ],
        "negativeExamples": [
          "Born Year"
        ]
      },
      {
        "regExp": "(?i).*year.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Year"
        ],
        "negativeExamples": [
          "Age"
        ]
      }
    ],
    "positiveContentExamples": [
      "1800",
      "1905",
      "1950",
      "1987",
      "1999",
      "2000",
      "2012",
      "2025"
    ],
    "negativeContentExamples": [
      "1799",
      "2100",
      "0990",
      "198",
      "19800",
      "198A",
      "1990/01",
      "1990s"
    ],
    "positiveHeaderExamples": [
      "Birth Year",
      "Year Born",
      "Year of Birth",
      "YOB",
      "Year_of_Birth",
      "Person Birth Year",
      "Birth Yr"
    ],
    "negativeHeaderExamples": [
      "Age",
      "Date of Birth",
      "Current Year",
      "Year",
      "DOB",
      "Birthdate",
      "Fiscal Year",
      "Year Created"
    ],
    "explanation": "This semantic type detects four-digit birth years commonly found in demographic and identity datasets. It restricts matches to plausible birth-year ranges from 1800 through 2025, excluding partial dates, non-numeric tokens, and years outside this band. It is useful for age calculations, cohort analysis, and normalization of personal records where only the year component is present.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:17:17.549213"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_UNION_IN",
    "description": "This type captures abbreviated codes for Indian states and union territories used in official documentation and geographic identification systems. The values represent standardized two-character abbreviations derived from state names using uppercase letters without periods or additional punctuation.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AP",
      "AR",
      "AS",
      "BR",
      "CG",
      "DL",
      "GA",
      "GJ",
      "HR",
      "HP",
      "JH",
      "KA",
      "KL",
      "MP",
      "MH",
      "MN",
      "ML",
      "MZ",
      "NL",
      "OD",
      "PB",
      "RJ",
      "TN",
      "TS",
      "WB"
    ],
    "backout": "^[A-Z]{2}$",
    "confidenceThreshold": 96,
    "priority": 3880,
    "headerPatterns": [
      {
        "regExp": "(?i).*union.*territory.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Union Territory Code"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*(india|indian).*(state|st).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Indian State Code"
        ],
        "negativeExamples": [
          "State Name"
        ]
      },
      {
        "regExp": "(?i).*(state|st).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Code"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*(india|indian).*(state|st).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Indian State"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "DL",
      "KA",
      "MH",
      "TN",
      "TS",
      "GJ",
      "OD",
      "PB"
    ],
    "negativeContentExamples": [
      "D-L",
      "Ka",
      "MH1",
      "T N",
      "GUA",
      "O D",
      "J&K",
      "WB."
    ],
    "positiveHeaderExamples": [
      "State Code",
      "Indian State",
      "Union Territory Code",
      "Indian State Code",
      "State/UT Code",
      "State Abbreviation"
    ],
    "negativeHeaderExamples": [
      "State Name",
      "Country",
      "District",
      "Country Code",
      "Province",
      "Postal Code"
    ],
    "explanation": "Two-letter uppercase abbreviations identifying Indian states and union territories. Useful for standardizing regional identifiers in datasets such as addresses, administrative records, and geographic categorizations. The list-based approach ensures precise matching to known two-letter codes, while the backout pattern guards the shape for broader validation when needed.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:17:18.354332"
  },
  {
    "resultType": "generated",
    "semanticType": "NATIONALITY_NL",
    "description": "This type captures nationality designations as they are expressed in Dutch for identification and demographic purposes in Dutch-speaking contexts. Values are standard Dutch demonyms/adjectival nationality terms (e.g., Nederlands, Italiaans), using proper Dutch linguistic forms and without abbreviations or foreign-language equivalents.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "NEDERLANDS",
      "BELGISCH",
      "DUITS",
      "FRANS",
      "SPAANS",
      "ITALIAANS",
      "PORTUGEES",
      "ENGELS",
      "ZWEEDS",
      "NOORS",
      "DEENS",
      "POOLS",
      "RUSSISCH",
      "GRIEKS",
      "TURKS",
      "MAROKKAANS",
      "EGYPTISCH",
      "ZUID-AFRIKAANS",
      "INDIAAS",
      "PAKISTAANS",
      "CHINEES",
      "JAPANS",
      "KOREAANS",
      "AUSTRALISCH",
      "AMERIKAANS"
    ],
    "backout": "^[A-Z\\-]{3,20}$",
    "confidenceThreshold": 94,
    "priority": 3110,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\b(persoon|klant|burger|werknemer)[ _-]*nationaliteit\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Klant_nationaliteit"
        ],
        "negativeExamples": [
          "Land"
        ]
      },
      {
        "regExp": "(?i).*\\bstaatsburgerschap\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Staatsburgerschap"
        ],
        "negativeExamples": [
          "Taal"
        ]
      },
      {
        "regExp": "(?i).*\\bafkomst\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Afkomst"
        ],
        "negativeExamples": [
          "Etniciteit"
        ]
      },
      {
        "regExp": "(?i).*\\bnationalit\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "nationalit_omschrijving"
        ],
        "negativeExamples": [
          "Herkomstland"
        ]
      },
      {
        "regExp": "(?i).*\\bnationaliteit\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Nationaliteit"
        ],
        "negativeExamples": [
          "Geboorteland"
        ]
      }
    ],
    "positiveContentExamples": [
      "Nederlands",
      "Duits",
      "Frans",
      "Italiaans",
      "Chinees",
      "Marokkaans",
      "Zuid-Afrikaans",
      "Roemeens"
    ],
    "negativeContentExamples": [
      "Nederland",
      "Belgi\u00eb",
      "Duitsland",
      "Frankrijk",
      "Spanje",
      "Itali\u00eb",
      "China",
      "Marokko"
    ],
    "positiveHeaderExamples": [
      "Nationaliteit",
      "Staatsburgerschap",
      "Afkomst",
      "Persoon_nationaliteit",
      "Klant nationaliteit",
      "Herkomst"
    ],
    "negativeHeaderExamples": [
      "Land",
      "Etniciteit",
      "Taal",
      "Geboorteland",
      "Herkomstland",
      "Woonland"
    ],
    "explanation": "IDENTITY.NATIONALITY_NL identifies Dutch-language nationality terms (demonyms) such as Nederlands, Italiaans, or Chinees that describe a person's nationality. It is suited for columns labeled with terms like nationaliteit, staatsburgerschap, or afkomst where the cell values are Dutch demonyms rather than country names. This helps distinguish personal nationality attributes from geographic country fields.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:17:18.775201"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_BR",
    "description": "This type captures the complete names of Brazilian states and the federal district as they are used in official documentation and government administration. The values represent full state names using proper Portuguese spelling including diacritical marks and standard formatting as established by Brazilian constitutional and administrative systems.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(acre|alagoas|amap\u00e1|amazonas|bahia|cear\u00e1|distrito federal|esp\u00edrito santo|goi\u00e1s|maranh\u00e3o|mato grosso|mato grosso do sul|minas gerais|par\u00e1|para\u00edba|paran\u00e1|pernambuco|piau\u00ed|rio de janeiro|rio grande do norte|rio grande do sul|rond\u00f4nia|roraima|santa catarina|s\u00e3o paulo|sergipe|tocantins)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3820,
    "headerPatterns": [
      {
        "regExp": "(?i).*state.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Name"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*brazilian.*state.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Brazilian State"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*nome.*estado.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Nome do Estado"
        ],
        "negativeExamples": [
          "Region"
        ]
      },
      {
        "regExp": "(?i).*estado.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Estado"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*state.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State"
        ],
        "negativeExamples": [
          "Region"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "S\u00e3o Paulo",
      "Rio de Janeiro",
      "Mato Grosso do Sul",
      "Par\u00e1",
      "Esp\u00edrito Santo",
      "Cear\u00e1",
      "Distrito Federal",
      "Santa Catarina"
    ],
    "negativeContentExamples": [
      "Sao Paulo",
      "Espirito Santo",
      "Maranhao",
      "Goias",
      "Santa-Catarina",
      "RJ",
      "Rio Janeiro",
      "Amazona"
    ],
    "positiveHeaderExamples": [
      "Estado",
      "State",
      "Brazilian State",
      "State Name",
      "Nome do Estado",
      "Brazilian State Name",
      "Estado Nome"
    ],
    "negativeHeaderExamples": [
      "State Code",
      "Country",
      "Region",
      "UF",
      "Province",
      "Subdivision",
      "City"
    ],
    "explanation": "Detects full Brazilian state and federal district names written in Portuguese with correct diacritics (e.g., S\u00e3o Paulo, Esp\u00edrito Santo, Cear\u00e1). Useful for validating or classifying columns that contain official state names rather than abbreviations or codes. This type is specific to Brazilian administrative units and excludes UF abbreviations or state codes.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:17:21.054418"
  },
  {
    "resultType": "generated",
    "semanticType": "VIN",
    "description": "This type captures standardized vehicle identification numbers used by automotive manufacturers and regulatory agencies for vehicle tracking and identification. The values represent exactly 17 alphanumeric characters following international VIN standards with specific positional encoding for manufacturer, vehicle characteristics, and serial information.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-HJ-NPR-Z0-9]{8}[0-9X][A-HJ-NPR-Z0-9]{8}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 99,
    "priority": 4050,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bvehicle\\b.*\\bidentification\\b.*\\bnumber\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Vehicle Identification Number"
        ],
        "negativeExamples": [
          "Vehicle ID"
        ]
      },
      {
        "regExp": "(?i).*\\bvin\\b.*\\bnumber\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "VIN Number"
        ],
        "negativeExamples": [
          "VIN"
        ]
      },
      {
        "regExp": "(?i).*\\bvehicle\\b.*\\bid\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Vehicle ID"
        ],
        "negativeExamples": [
          "Customer ID"
        ]
      },
      {
        "regExp": "(?i).*\\bvin\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "VIN"
        ],
        "negativeExamples": [
          "License Plate"
        ]
      },
      {
        "regExp": "(?i).*\\bidentifier\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Identifier"
        ],
        "negativeExamples": [
          "Index"
        ]
      }
    ],
    "positiveContentExamples": [
      "1HGCM82633A004352",
      "JH4DA9350LS000123",
      "2FTRX18W1XCA12345",
      "3FAHP0HA6AR123456",
      "KMHDU46D57U123456",
      "SALWR2EF2FA000789",
      "WAUZZZ8K7DA123456",
      "5YJSA1AG9DFP76543"
    ],
    "negativeContentExamples": [
      "1HGCM82633A00435",
      "1HGCM82633A0043527",
      "1HGCM82633A0I4352",
      "1HGCM82633A0O4352",
      "1HGCM82633A0Q4352",
      "1HGCM826Z3A004352",
      "1HG-CM82633A004352",
      "1hgcm82633a004352"
    ],
    "positiveHeaderExamples": [
      "VIN",
      "Vehicle ID",
      "VIN Number",
      "Vehicle Identification Number",
      "Veh ID",
      "Vehicle Identifier",
      "VIN No"
    ],
    "negativeHeaderExamples": [
      "License Plate",
      "Model",
      "Make",
      "Serial Number",
      "Engine Number",
      "Registration ID",
      "Customer ID",
      "Chassis Code"
    ],
    "explanation": "This semantic type identifies 17-character Vehicle Identification Numbers. The value pattern enforces uppercase alphanumeric characters excluding I, O, and Q, with position 9 restricted to a digit or X to align with the VIN check-digit slot. It is suitable for tagging and validating columns that store VINs and for filtering out close but invalid identifiers such as license plates or serial numbers. The pattern does not compute or verify the check-digit algorithm; it validates structural form only.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:17:21.195042"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_NAME_PE",
    "description": "This type identifies Peruvian province names used for regional administrative identification within Peru's governmental structure. The format consists of proper noun text strings representing official province names in Spanish without abbreviations or special formatting characters.",
    "pluginType": "regex",
    "regexPattern": "\\b([A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00fc\u00f1]{1,})(\\s(de|del|la|el|los|las|y|san|santa|santo|dos))?(\\s[A-Z\u00c1\u00c9\u00cd\u00d3\u00da\u00dc\u00d1][a-z\u00e1\u00e9\u00ed\u00f3\u00fa\u00fc\u00f1]{2,}){0,4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 3700,
    "headerPatterns": [
      {
        "regExp": "(?i).*(peru|per\u00fa|pe).*(province|provincia).*(name|nombre).*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "Peruvian province name"
        ],
        "negativeExamples": [
          "Province code"
        ]
      },
      {
        "regExp": "(?i).*(peru|per\u00fa|pe).*(province|provincia).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "Peruvian Province"
        ],
        "negativeExamples": [
          "Region Peru"
        ]
      },
      {
        "regExp": "(?i).*(province|provincia).*(name|nombre).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "Provincia Nombre"
        ],
        "negativeExamples": [
          "Region Name"
        ]
      },
      {
        "regExp": "(?i).*(prov|provincia).*(nm|name|nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "prov nombre"
        ],
        "negativeExamples": [
          "city name"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Huaral",
      "S\u00e1nchez Carri\u00f3n",
      "La Convenci\u00f3n",
      "General S\u00e1nchez Cerro",
      "Dos de Mayo",
      "Mariscal Nieto",
      "Hu\u00e1nuco",
      "Datem del Mara\u00f1\u00f3n"
    ],
    "negativeContentExamples": [
      "Huaral-Peru",
      "Huaral/Lima",
      "Huaral (Lima)",
      "Prov. Huaral",
      "2 de Mayo",
      "Huaral 01",
      "Lima, PE",
      "01 Huaral"
    ],
    "positiveHeaderExamples": [
      "Provincia",
      "Province",
      "Peruvian Province",
      "Province Name",
      "Provincia Nombre",
      "Nombre de Provincia",
      "Provincia PE",
      "PE Province"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Region",
      "City",
      "Province Code",
      "Region Name",
      "City Name",
      "Department",
      "Postal Code"
    ],
    "explanation": "This semantic type captures province-level administrative names within Peru, expressed as natural-language Spanish proper nouns (e.g., single- or multi-word names with optional common connectors like de/del). It is useful for validating and standardizing columns that contain province names, enabling regional rollups, joins with geographic reference data, and data quality checks distinct from regions/departments or cities.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:17:22.222040"
  },
  {
    "resultType": "generated",
    "semanticType": "TELEPHONE",
    "description": "This type captures telephone numbers in various formats used for voice communication including landline and mobile numbers. The values represent numeric sequences with optional country codes, area codes, and formatting characters such as parentheses, hyphens, or spaces following international or regional conventions.",
    "pluginType": "regex",
    "regexPattern": "\\b(\\+?[0-9]{1,3}[ \\-\\.])?(\\([0-9]{2,4}\\)|[0-9]{2,4})?[ \\-\\.]?[0-9]{3,4}[ \\-\\.][0-9]{4,6}\\b|\\b[0-9]{10,11}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4020,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\b(phone|telephone)\\b.*\\b(number|no)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Phone Number"
        ],
        "negativeExamples": [
          "Fax Number"
        ]
      },
      {
        "regExp": "(?i).*\\b(mobile|cell)\\b.*\\b(phone|tel|telephone)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Mobile Phone"
        ],
        "negativeExamples": [
          "Email Address"
        ]
      },
      {
        "regExp": "(?i).*\\b(contact)\\b.*\\b(phone|tel|telephone)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Contact Telephone"
        ],
        "negativeExamples": [
          "Contact Name"
        ]
      },
      {
        "regExp": "(?i).*\\b(tel|ph)\\b.*\\b(no|num)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Tel No"
        ],
        "negativeExamples": [
          "Account Number"
        ]
      },
      {
        "regExp": "(?i).*\\b(phone|telephone|tel)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Phone"
        ],
        "negativeExamples": [
          "Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "555-1234",
      "(212) 555-1234",
      "212-555-1234",
      "+1 212 555 1234",
      "+44 20 7946 0958",
      "+1 (800) 555-0199",
      "020 7946 0958",
      "8005550199"
    ],
    "negativeContentExamples": [
      "555-123",
      "1-800-FLOWERS",
      "(212 555-1234",
      "212) 555-1234",
      "+ 44 20 7946 0958",
      "1234567890123456",
      "Tel: 212-555-1234",
      "555.123."
    ],
    "positiveHeaderExamples": [
      "Phone Number",
      "Telephone",
      "Phone",
      "Mobile Phone",
      "Primary Phone",
      "Contact Telephone",
      "Cell Phone"
    ],
    "negativeHeaderExamples": [
      "Email Address",
      "Fax Number",
      "Address",
      "Account Number",
      "Zip Code",
      "Contact Name",
      "IMEI Number"
    ],
    "explanation": "IDENTITY.TELEPHONE identifies values that look like telephone numbers across common international and regional formats, including optional leading '+' country codes, optional parenthesized area codes, and separators such as spaces, hyphens, or dots. It is useful for validating and discovering phone-related fields in datasets where formatting varies. Header patterns prioritize precise phrases (e.g., 'phone number') and then broaden to common variants and abbreviations while ensuring the primitive term is covered.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:17:23.458548"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_NUMBER",
    "description": "Captures house or building numbers used in street addressing systems to identify specific properties along thoroughfares. Values are primarily numeric and may include short alphabetic suffixes or ranges to reflect local numbering conventions.",
    "pluginType": "regex",
    "regexPattern": "\\b[1-9][0-9]{0,5}([A-Za-z]{1,2})?(\\-[1-9][0-9]{0,5}([A-Za-z]{1,2})?)?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 95,
    "priority": 4010,
    "headerPatterns": [
      {
        "regExp": "(?i).*house.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "House Number"
        ],
        "negativeExamples": [
          "Street Name"
        ]
      },
      {
        "regExp": "(?i).*street.*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street Number"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*(building|property|address).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Building Number"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*(house|street).*(no|num|nbr)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "House No"
        ],
        "negativeExamples": [
          "Street Name"
        ]
      },
      {
        "regExp": "(?i).*number.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Number"
        ],
        "negativeExamples": [
          "Street Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "12",
      "7",
      "221B",
      "101",
      "4A",
      "120B-120D",
      "999999",
      "58C"
    ],
    "negativeContentExamples": [
      "012",
      "0",
      "A12",
      "12 A",
      "12/3",
      "12--14",
      "1234567",
      "12-"
    ],
    "positiveHeaderExamples": [
      "House Number",
      "Street Number",
      "Number",
      "Building Number",
      "Property Number",
      "Address Number",
      "House No",
      "Street Num"
    ],
    "negativeHeaderExamples": [
      "Street Name",
      "Address",
      "City",
      "Postal Code",
      "Unit",
      "Apartment",
      "Latitude",
      "Street Type"
    ],
    "explanation": "This semantic type targets property identifiers used as the numeric component of street addresses. Typical forms include pure digits (e.g., 12), digits with a short letter suffix (e.g., 221B), and simple hyphenated ranges (e.g., 12-14). It excludes tokens with leading zeros, embedded spaces between number and suffix, slashes, double hyphens, or excessively long numeric sequences.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:17:24.433827"
  },
  {
    "resultType": "generated",
    "semanticType": "COORDINATE.EASTING",
    "description": "This coordinate represents the horizontal position in a map projection measured as distance east from a central meridian or grid origin. The value is typically a decimal number expressed in linear units like meters with positive values indicating eastward direction.",
    "pluginType": "regex",
    "regexPattern": "\\b([1-9]\\d{3,6})(\\.\\d+)?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 2400,
    "headerPatterns": [
      {
        "regExp": "(?i).*easting.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Easting Value"
        ],
        "negativeExamples": [
          "Longitude"
        ]
      },
      {
        "regExp": "(?i).*x[\\s_]*coordinate.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "X Coordinate"
        ],
        "negativeExamples": [
          "Y Coordinate"
        ]
      },
      {
        "regExp": "(?i).*grid.*x.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Grid X"
        ],
        "negativeExamples": [
          "Grid Y"
        ]
      },
      {
        "regExp": "(?i).*x[\\s_]*coord.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "x_coord"
        ],
        "negativeExamples": [
          "x_count"
        ]
      },
      {
        "regExp": "(?i).*coordinate.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Coordinate"
        ],
        "negativeExamples": [
          "Address"
        ]
      }
    ],
    "positiveContentExamples": [
      "234567",
      "500000",
      "678912.34",
      "1000.0",
      "7423651",
      "320000.5",
      "8123456.789",
      "160000"
    ],
    "negativeContentExamples": [
      "123",
      "-345678",
      "345678.",
      "12.345",
      "003456",
      "345,678",
      "0000",
      "12,345.67"
    ],
    "positiveHeaderExamples": [
      "Easting",
      "X Coordinate",
      "Easting Value",
      "Grid X",
      "Map Easting",
      "Local Easting"
    ],
    "negativeHeaderExamples": [
      "Longitude",
      "Latitude",
      "Address",
      "Y Coordinate",
      "X Count",
      "Postal Code"
    ],
    "explanation": "This type captures numeric easting values used in projected coordinate systems, typically expressed as a positive integer or decimal number representing distance east from a defined origin. It is intended for columns that store the X-axis component of a projected grid, not longitude angles. Use when parsing map grid coordinates or engineering survey data where the horizontal component is recorded independently.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:17:26.791260"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.RACE_ABBR_EN",
    "description": "This type captures abbreviated racial and ethnic designations as they appear in demographic surveys, forms, and statistical analysis using shortened code formats. The values represent standard abbreviations for racial and ethnic categories following conventional demographic coding systems without full descriptive terms.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "W",
      "WH",
      "WHT",
      "B",
      "BLK",
      "A",
      "ASN",
      "I",
      "AI",
      "AIAN",
      "H",
      "HIS",
      "HISP",
      "NH",
      "NHIS",
      "PI",
      "NHPI",
      "MR",
      "MULTI",
      "MIX",
      "2+",
      "OT",
      "OTH",
      "UNK",
      "U"
    ],
    "backout": "^[A-Z0-9+]{1,5}$",
    "confidenceThreshold": 93,
    "priority": 3190,
    "headerPatterns": [
      {
        "regExp": "(?i).*(race|ethnic).*(code|abbr|abbrev|abbreviation).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Race Abbr"
        ],
        "negativeExamples": [
          "Race"
        ]
      },
      {
        "regExp": "(?i).*(race|ethnicity).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Ethnic Group"
        ],
        "negativeExamples": [
          "Nationality"
        ]
      },
      {
        "regExp": "(?i).*(abbr|abbrev|abbreviation|cd).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Abbr"
        ],
        "negativeExamples": [
          "Name"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Race"
        ]
      }
    ],
    "positiveContentExamples": [
      "W",
      "BLK",
      "HISP",
      "NH",
      "NHPI",
      "AIAN",
      "MULTI",
      "2+"
    ],
    "negativeContentExamples": [
      "WHITE",
      "BLACK",
      "ASIAN",
      "HISPANIC",
      "NON-HISP",
      "2PLUS",
      "OTHER",
      "N/A"
    ],
    "positiveHeaderExamples": [
      "Race Code",
      "Ethnicity Code",
      "Race Abbr",
      "Race Abbreviation",
      "Ethnic Code",
      "Race Cd",
      "Ethnicity Abbr"
    ],
    "negativeHeaderExamples": [
      "Race",
      "Ethnicity",
      "Nationality",
      "Country Code",
      "Postal Code",
      "Name"
    ],
    "explanation": "Abbreviated race/ethnicity codes commonly used in demographic datasets, allowing consistent identification of categories via short codes instead of full text labels. Useful for standardizing analytics pipelines, deduplicating category variants, and harmonizing survey outputs where space-limited encodings are used.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:17:29.732844"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.REGION_NAME_TZ",
    "description": "Official names of administrative regions in the United Republic of Tanzania, expressed in standard English or Swahili spelling as used in government records and territorial organization. Values are complete region names, not districts, cities, or provinces.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "ARUSHA",
      "DAR ES SALAAM",
      "DODOMA",
      "IRINGA",
      "KAGERA",
      "KATAVI",
      "KIGOMA",
      "KILIMANJARO",
      "LINDI",
      "MANYARA",
      "MARA",
      "MBEYA",
      "MOROGORO",
      "MTWARA",
      "MWANZA",
      "NJOMBE",
      "PWANI",
      "RUKWA",
      "RUVUMA",
      "SHINYANGA",
      "SINGIDA",
      "TABORA",
      "TANGA",
      "MJINI MAGHARIBI",
      "KASKAZINI UNGUJA"
    ],
    "backout": "^[A-Za-z][A-Za-z ]{2,30}$",
    "confidenceThreshold": 96,
    "priority": 3760,
    "headerPatterns": [
      {
        "regExp": "(?i).*(tanzania|tanzanian|tz).*(region|mkoa).*(name).*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "TZ Region Name"
        ],
        "negativeExamples": [
          "Country Name"
        ]
      },
      {
        "regExp": "(?i).*(tanzania|tanzanian|tz).*(region|mkoa).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Tanzanian Region"
        ],
        "negativeExamples": [
          "District"
        ]
      },
      {
        "regExp": "(?i).*region.*name.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Region Name"
        ],
        "negativeExamples": [
          "Country Name"
        ]
      },
      {
        "regExp": "(?i).*(reg|rgn|mkoa).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Mkoa"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Arusha",
      "Dar es Salaam",
      "Dodoma",
      "Kagera",
      "Kilimanjaro",
      "Mjini Magharibi",
      "Kaskazini Unguja",
      "Pwani"
    ],
    "negativeContentExamples": [
      "Dar es Salaam Region",
      "Kilmanjaro",
      "Arusha City",
      "Pwani Region",
      "Kaskazini Unguja North",
      "Mjini-Magharibi",
      "Kilimanjaro, TZ",
      "Region of Mara"
    ],
    "positiveHeaderExamples": [
      "Region",
      "Tanzanian Region",
      "Mkoa",
      "Region Name",
      "TZ Region Name",
      "Tanzania Region",
      "Regional Name",
      "TZ Region"
    ],
    "negativeHeaderExamples": [
      "Country",
      "District",
      "City",
      "Province",
      "County",
      "State",
      "Municipality",
      "Location Name"
    ],
    "explanation": "This semantic type identifies Tanzanian administrative region names on both Mainland and Zanzibar using a curated list of official names in English or Swahili. It is useful for validating geographic columns, standardizing regional aggregations, and disambiguating regions from districts or cities. The list-based approach ensures high precision, while the backout pattern provides a structural fallback for auditing potential near-miss values.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:17:33.089088"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_DE",
    "description": "This type captures the complete names of German federal states as they are used in official documentation and government administration. The values represent full state names using proper German spelling including umlauts and standard formatting as established by the German federal constitutional system.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "BADEN-W\u00dcRTTEMBERG",
      "BAYERN",
      "BERLIN",
      "BRANDENBURG",
      "BREMEN",
      "HAMBURG",
      "HESSEN",
      "MECKLENBURG-VORPOMMERN",
      "NIEDERSACHSEN",
      "NORDRHEIN-WESTFALEN",
      "RHEINLAND-PFALZ",
      "SAARLAND",
      "SACHSEN",
      "SACHSEN-ANHALT",
      "SCHLESWIG-HOLSTEIN",
      "TH\u00dcRINGEN"
    ],
    "backout": "^[A-Za-z\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df]{3,20}([ -][A-Za-z\u00c4\u00d6\u00dc\u00e4\u00f6\u00fc\u00df]{2,20})*$",
    "confidenceThreshold": 98,
    "priority": 3830,
    "headerPatterns": [
      {
        "regExp": "(?i).*(german|de)[ _-]*state[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "German State Name"
        ],
        "negativeExamples": [
          "German State Code"
        ]
      },
      {
        "regExp": "(?i).*bundesland[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Bundesland Name"
        ],
        "negativeExamples": [
          "Bundesland Code"
        ]
      },
      {
        "regExp": "(?i).*(bundesland|german[ _-]*state|de[ _-]*state).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "German State"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*state.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State"
        ],
        "negativeExamples": [
          "Region"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Baden-W\u00fcrttemberg",
      "Bayern",
      "Berlin",
      "Mecklenburg-Vorpommern",
      "Nordrhein-Westfalen",
      "Rheinland-Pfalz",
      "Schleswig-Holstein",
      "Th\u00fcringen"
    ],
    "negativeContentExamples": [
      "Baden Wurttemberg",
      "Nordrhein Westfalen",
      "Thuringen",
      "Hesse",
      "Lower Saxony",
      "Saxony-Anhalt",
      "Rheinland Pfalz",
      "Berlin City"
    ],
    "positiveHeaderExamples": [
      "Bundesland",
      "State",
      "German State",
      "Bundesland Name",
      "German State Name",
      "DE State",
      "State Name"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Region",
      "City",
      "Country Code",
      "Province",
      "Region Name",
      "County",
      "Canton"
    ],
    "explanation": "This semantic type identifies the official full names of the 16 German federal states (Bundesl\u00e4nder) using correct German spelling, including umlauts and standard hyphenation. It is useful for validating geographic fields tied to German administrative divisions, normalizing inputs, and ensuring consistent state naming in datasets that reference Germany's federal states.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:17:34.098108"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS3_EN",
    "description": "This type captures additional addressing details that provide further location specificity for complex buildings or facilities. The values represent building names, floor designations, room numbers, or directional information using standard English addressing conventions and common abbreviations.",
    "pluginType": "regex",
    "regexPattern": "\\b((floor|fl|level|lvl)[\\s-]*[A-Z0-9]{1,3})\\b|\\b((lower|upper|ground)[\\s-]*(level|floor)([\\s-]*[A-Z0-9]{1,2})?)\\b|\\b((room|rm|lab)[\\s-]*[A-Z0-9]{1,4}(\\s*-\\s*[A-Z0-9]{1,4})?)\\b|\\b(mezzanine|basement|lobby|penthouse)\\b|\\b((north|south|east|west)[\\s-]*(wing|tower|building|block)([\\s-]*[A-Z0-9]{1,3})?)\\b|\\b((building|bldg|tower|annex|block|wing|pavilion|hall|center|centre)[\\s-]*[A-Z0-9]{1,3})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 3930,
    "headerPatterns": [
      {
        "regExp": "(?i).*(address.*line.*3|addr.*line.*3|addressline3|addr3|address_3).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address Line 3"
        ],
        "negativeExamples": [
          "Address Line 2"
        ]
      },
      {
        "regExp": "(?i).*(building|bldg).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Building"
        ],
        "negativeExamples": [
          "Street Address"
        ]
      },
      {
        "regExp": "(?i).*(floor|fl|level|lvl).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Floor"
        ],
        "negativeExamples": [
          "Apt"
        ]
      },
      {
        "regExp": "(?i).*(room|rm|wing|tower|block).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Wing"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address Line 3"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "North Tower",
      "East Wing",
      "Building B",
      "Bldg 3",
      "Floor 12",
      "FL 2",
      "Level B1",
      "Room 204"
    ],
    "negativeContentExamples": [
      "Apt 3B",
      "Suite 500",
      "Unit 12",
      "123 Main Street",
      "PO Box 123",
      "Level",
      "North Entrance",
      "Building"
    ],
    "positiveHeaderExamples": [
      "Address Line 3",
      "Building",
      "Floor",
      "AddressLine3",
      "Addr Line 3",
      "Building Name",
      "Level",
      "Room"
    ],
    "negativeHeaderExamples": [
      "Street Address",
      "Apt",
      "ZIP Code",
      "Address Line 1",
      "Address Line 2",
      "Suite",
      "City",
      "Unit"
    ],
    "explanation": "This semantic type targets the third address line commonly used to denote internal building location details such as building identifiers, floors, rooms, and directional subsections (e.g., East Wing, North Tower). It intentionally focuses on intra-facility descriptors rather than street, unit, apartment, suite, postal, or city information, enabling precise placement within large complexes.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:17:34.718039"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS4_EN",
    "description": "Specialized addressing details for complex facilities beyond standard street, city, state, and postal fields. Typical values denote wings, entrances, docks, gates, bays, or doors using standard English descriptors and simple identifiers.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b((north|south|east|west|northeast|northwest|southeast|southwest|main|central)[ -]+(wing|entrance|gate|dock|bay|door))\\b|\\b(wing[ -]+[A-Z0-9]{1,3})\\b|\\b(entrance[ -]+[A-Z0-9]{1,3})\\b|\\b((loading|receiving|shipping)[ -]+dock[ -]+[A-Z0-9]{1,3})\\b|\\b(dock[ -]+[A-Z0-9]{1,3})\\b|\\b(gate[ -]+[0-9]{1,3})\\b|\\b(bay[ -]+[0-9]{1,3})\\b|\\b(door[ -]+[A-Z0-9]{1,3})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 92,
    "priority": 3940,
    "headerPatterns": [
      {
        "regExp": "(?i).*(address|addr).*(line|ln).*(4).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address Line 4"
        ],
        "negativeExamples": [
          "Address Line 3"
        ]
      },
      {
        "regExp": "(?i).*(address|addr).*(line|ln).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address Line"
        ],
        "negativeExamples": [
          "Street Address"
        ]
      },
      {
        "regExp": "(?i).*(addr4|address4|address_4).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "addr4"
        ],
        "negativeExamples": [
          "addr3"
        ]
      },
      {
        "regExp": "(?i).*(wing|entrance|dock|gate|bay|door).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Entrance"
        ],
        "negativeExamples": [
          "Suite"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "address"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "North Wing",
      "Wing B",
      "Main Entrance",
      "Loading Dock 7",
      "Dock A3",
      "Gate 12",
      "Bay 03",
      "Door C"
    ],
    "negativeContentExamples": [
      "Northern Wing",
      "Wng B",
      "Entrance#2",
      "DockA",
      "Gate12B",
      "Doors C",
      "LoadingDock 7",
      "Bay04"
    ],
    "positiveHeaderExamples": [
      "Address Line 4",
      "Wing",
      "Entrance",
      "Addr4",
      "Address4",
      "Loading Dock",
      "Facility Wing",
      "Address Line"
    ],
    "negativeHeaderExamples": [
      "Street Address",
      "Suite",
      "ZIP Code",
      "Address Line 2",
      "Building",
      "City",
      "Country",
      "Province"
    ],
    "explanation": "This semantic type targets facility-level address qualifiers commonly placed in a fourth address line, such as wings, entrances, docks, gates, bays, or doors. It is useful for logistics, deliveries, and internal campus/facility navigation where additional on-site routing details are required.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:17:34.826999"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_US",
    "description": "This type captures the complete names of US states and territories as they are used in official documentation and government administration. The values represent full state names using proper English spelling and standard formatting as established by the US constitutional and administrative systems.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(Alabama|Alaska|American Samoa|Arizona|Arkansas|California|Colorado|Connecticut|Delaware|District of Columbia|Florida|Georgia|Guam|Hawaii|Idaho|Illinois|Indiana|Iowa|Kansas|Kentucky|Louisiana|Maine|Maryland|Massachusetts|Michigan|Minnesota|Mississippi|Missouri|Montana|Nebraska|Nevada|New Hampshire|New Jersey|New Mexico|New York|North Carolina|North Dakota|Northern Mariana Islands|Ohio|Oklahoma|Oregon|Pennsylvania|Puerto Rico|Rhode Island|South Carolina|South Dakota|Tennessee|Texas|Utah|Vermont|Virginia|Washington|West Virginia|Wisconsin|Wyoming|U\\.S\\. Virgin Islands|US Virgin Islands)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3850,
    "headerPatterns": [
      {
        "regExp": "(?i).*(us|u\\.s\\.).*state.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "US State Name"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*(state|province).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Name"
        ],
        "negativeExamples": [
          "Country Name"
        ]
      },
      {
        "regExp": "(?i).*(us|u\\.s\\.).*state.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "US State"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*state.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State"
        ],
        "negativeExamples": [
          "County"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "California",
      "New York",
      "Texas",
      "District of Columbia",
      "Puerto Rico",
      "American Samoa",
      "North Dakota",
      "U.S. Virgin Islands"
    ],
    "negativeContentExamples": [
      "CA",
      "California State",
      "NewYork",
      "Washington DC",
      "N Carolina",
      "Puerto-Rico",
      "Virgin Islands",
      "Massachusets"
    ],
    "positiveHeaderExamples": [
      "State",
      "State Name",
      "US State",
      "US State Name",
      "State/Province Name",
      "State Full Name",
      "State (US)",
      "United States State"
    ],
    "negativeHeaderExamples": [
      "State Code",
      "Country",
      "County",
      "State Abbrev",
      "Province",
      "Country Code",
      "Region",
      "Territory Code"
    ],
    "explanation": "This semantic type identifies full US state and territory names in datasets, enabling accurate normalization, validation, and geospatial joins where full jurisdiction names are expected rather than abbreviations. It is useful for compliance reporting, address standardization, and analytics that depend on canonical US jurisdiction names.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:17:38.418753"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_NAME_MX",
    "description": "This type captures the complete names of Mexican states and federal entities as they are used in official documentation and government administration. The values represent full state names using proper Spanish spelling including diacritical marks and standard formatting as established by the Mexican federal constitutional system.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(AGUASCALIENTES|BAJA CALIFORNIA SUR|BAJA CALIFORNIA|CAMPECHE|CHIAPAS|CHIHUAHUA|CIUDAD DE M\u00c9XICO|COAHUILA DE ZARAGOZA|COLIMA|DURANGO|GUANAJUATO|GUERRERO|HIDALGO|JALISCO|ESTADO DE M\u00c9XICO|MICHOAC\u00c1N DE OCAMPO|MORELOS|NAYARIT|NUEVO LE\u00d3N|OAXACA|PUEBLA|QUER\u00c9TARO|QUINTANA ROO|SAN LUIS POTOS\u00cd|SINALOA|SONORA|TABASCO|TAMAULIPAS|TLAXCALA|VERACRUZ DE IGNACIO DE LA LLAVE|YUCAT\u00c1N|ZACATECAS)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3840,
    "headerPatterns": [
      {
        "regExp": "(?i).*(mexican|m\u00e9xico|mx).*(state|estado).*(name|nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Mexican State Name"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*(mexican|m\u00e9xico|mx).*(state|estado).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Mexican State"
        ],
        "negativeExamples": [
          "Mexico Country"
        ]
      },
      {
        "regExp": "(?i).*(mx|m\u00e9x|mex)[ _-]?(state|edo).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "mx_state"
        ],
        "negativeExamples": [
          "mx_code"
        ]
      },
      {
        "regExp": "(?i).*(state|estado)[ _-]?(name|nombre).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "state_name"
        ],
        "negativeExamples": [
          "region_name"
        ]
      },
      {
        "regExp": "(?i).*(state|estado).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Estado"
        ],
        "negativeExamples": [
          "Province"
        ]
      }
    ],
    "positiveContentExamples": [
      "Aguascalientes",
      "Baja California",
      "Baja California Sur",
      "Coahuila de Zaragoza",
      "Ciudad de M\u00e9xico",
      "Estado de M\u00e9xico",
      "Michoac\u00e1n de Ocampo",
      "San Luis Potos\u00ed"
    ],
    "negativeContentExamples": [
      "Coahuila",
      "Veracruz",
      "Mexico City",
      "Queretaro",
      "M\u00e9xico",
      "Baja California Norte",
      "Nuevo Leon",
      "Chihuahua, MX"
    ],
    "positiveHeaderExamples": [
      "Estado",
      "State",
      "Mexican State",
      "state_name",
      "nombre_estado",
      "mx_state",
      "estado nombre",
      "state (mx)"
    ],
    "negativeHeaderExamples": [
      "State Code",
      "Country",
      "Municipality",
      "Province",
      "Region",
      "Country Name",
      "mx_code",
      "city"
    ],
    "explanation": "This semantic type identifies full, official names of the 32 Mexican federal entities, preserving correct Spanish orthography and diacritics. It is suitable for validating columns where the dataset is expected to contain complete state names rather than abbreviations, codes, or informal variants.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:17:40.688937"
  },
  {
    "resultType": "generated",
    "semanticType": "TIMEZONE.IANA",
    "description": "This type captures IANA time zone identifiers following the Olson database format for precise temporal coordination across global locations. The values represent hierarchical location-based identifiers using continent/city or region/city patterns with underscores replacing spaces in location names.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(africa|america|antarctica|arctic|asia|atlantic|australia|europe|indian|pacific|etc)/([A-Za-z][A-Za-z0-9-]*(_[A-Za-z][A-Za-z0-9-]*)*)(/([A-Za-z][A-Za-z0-9-]*(_[A-Za-z][A-Za-z0-9-]*)*))?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 4030,
    "headerPatterns": [
      {
        "regExp": "(?i).*iana.*time.*zone.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "IANA Timezone"
        ],
        "negativeExamples": [
          "Time Zone"
        ]
      },
      {
        "regExp": "(?i).*olson.*time.*zone.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Olson Time Zone"
        ],
        "negativeExamples": [
          "Timezone"
        ]
      },
      {
        "regExp": "(?i).*(timezone[_ ]?id|time[_ ]?zone[_ ]?id|tzid).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Timezone ID"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*time.*zone.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Time Zone"
        ],
        "negativeExamples": [
          "UTC Offset"
        ]
      },
      {
        "regExp": "(?i).*(tzid|tz).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "TZID"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*timezone.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Timezone"
        ],
        "negativeExamples": [
          "Date"
        ]
      }
    ],
    "positiveContentExamples": [
      "America/New_York",
      "Europe/London",
      "Asia/Kolkata",
      "Pacific/Auckland",
      "Africa/Johannesburg",
      "America/Argentina/Buenos_Aires",
      "Australia/Sydney",
      "Etc/UTC"
    ],
    "negativeContentExamples": [
      "AmericaNew_York",
      "US/Eastern",
      "America/New__York",
      "Africa//Cairo",
      "America/New York",
      "Etc/GMT+5",
      "America/123City",
      "Asia/Seoul/Mapo-Gu/Extra"
    ],
    "positiveHeaderExamples": [
      "Timezone",
      "Time Zone",
      "IANA Timezone",
      "Olson Time Zone",
      "Timezone ID",
      "TZID",
      "System Timezone",
      "TZ"
    ],
    "negativeHeaderExamples": [
      "UTC Offset",
      "Country",
      "City",
      "Locale",
      "Date",
      "Coordinates",
      "Region",
      "Time Offset"
    ],
    "explanation": "IANA time zone identifiers are standardized strings from the tz database that encode a region and location hierarchy such as Continent/City or Region/City, optionally with a subregion. These values are used to unambiguously represent civil time rules globally, independent of numeric offsets, which can change due to daylight saving time or local legislation.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:17:47.945383"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_MARKER_EN",
    "description": "This type captures street type indicators used in English-language addressing to classify different kinds of roads and thoroughfares. The values represent standard suffix terms that appear after street names to indicate the road type using common English abbreviations and full forms.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(avenue|ave\\.?|street|st\\.?|road|rd\\.?|boulevard|blvd\\.?|lane|ln\\.?|drive|dr\\.?|court|ct\\.?|circle|cir\\.?|terrace|ter\\.?|parkway|pkwy\\.?|place|pl\\.?|square|sq\\.?|trail|trl\\.?|highway|hwy\\.?|freeway|fwy\\.?|way|walk|mews|crescent|cres\\.?|gardens|gdn\\.?|gdns\\.?|route|rte\\.?|alley|aly\\.?|bypass|byp\\.?|close|cl\\.?|plaza|plz\\.?)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 3970,
    "headerPatterns": [
      {
        "regExp": "(?i).*street.*suffix.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street Suffix"
        ],
        "negativeExamples": [
          "Street Name"
        ]
      },
      {
        "regExp": "(?i).*street.*type.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street Type"
        ],
        "negativeExamples": [
          "House Number"
        ]
      },
      {
        "regExp": "(?i).*street.*marker.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street Marker"
        ],
        "negativeExamples": [
          "Address"
        ]
      },
      {
        "regExp": "(?i).*(road|street|avenue|highway).*(suffix|type|marker).*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Road Type"
        ],
        "negativeExamples": [
          "Road Name"
        ]
      },
      {
        "regExp": "(?i).*(st|rd|ave|blvd).*(type|suffix).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "St Type"
        ],
        "negativeExamples": [
          "St Name"
        ]
      },
      {
        "regExp": "(?i).*suffix.*",
        "confidence": 89,
        "mandatory": true,
        "positiveExamples": [
          "Suffix"
        ],
        "negativeExamples": [
          "Prefix"
        ]
      }
    ],
    "positiveContentExamples": [
      "St",
      "St.",
      "Street",
      "Rd",
      "Ave",
      "Blvd",
      "Dr.",
      "Highway"
    ],
    "negativeContentExamples": [
      "Sts",
      "Avee",
      "rd5",
      "Drs",
      "Hwy-",
      "Circl",
      "Pkway",
      "Blv"
    ],
    "positiveHeaderExamples": [
      "Street Type",
      "Street Suffix",
      "Street Marker",
      "Road Type",
      "Avenue Suffix",
      "St Type",
      "Hwy Suffix"
    ],
    "negativeHeaderExamples": [
      "Street Name",
      "House Number",
      "Address",
      "Road Name",
      "Customer Name",
      "Postal Code",
      "City"
    ],
    "explanation": "Identifies common English street suffix terms that follow a street name, covering both full forms and widely used abbreviations (with or without periods). Useful for parsing, normalizing, or validating address components, especially when separating street names from their road-type markers.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:17:57.977783"
  },
  {
    "resultType": "generated",
    "semanticType": "URI.URL",
    "description": "This type captures web addresses and resource locators used to identify and access content across networks including websites, files, and services. The values represent complete URL strings including protocol schemes, domain names, paths, and optional parameters following standardized URI formatting conventions.",
    "pluginType": "regex",
    "regexPattern": "\\b(http|https|ftp)://([A-Za-z0-9-]+\\.)+[A-Za-z]{2,63}(:[0-9]{2,5})?(/[A-Za-z0-9._~!$&'()*+,;=:@%/-]*)?(\\?[A-Za-z0-9._~!$&'()*+,;=:@%/?-]*)?(#[A-Za-z0-9._~!$&'()*+,;=:@%/?-]*)?",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4040,
    "headerPatterns": [
      {
        "regExp": "(?i).*website.*url.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Website URL"
        ],
        "negativeExamples": [
          "Website Domain"
        ]
      },
      {
        "regExp": "(?i).*website.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Website"
        ],
        "negativeExamples": [
          "Domain Name"
        ]
      },
      {
        "regExp": "(?i).*uri.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "URI"
        ],
        "negativeExamples": [
          "IP Address"
        ]
      },
      {
        "regExp": "(?i).*web.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Web Address"
        ],
        "negativeExamples": [
          "Email Address"
        ]
      },
      {
        "regExp": "(?i).*url.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "URL"
        ],
        "negativeExamples": [
          "File Path"
        ]
      }
    ],
    "positiveContentExamples": [
      "https://example.com",
      "http://www.example.org/about",
      "https://sub.domain.co.uk/path/to/resource?x=1&y=2",
      "ftp://files.example.net/downloads/archive.zip",
      "https://api.example.io/v1/users#top",
      "https://example.travel/?q=summer%20deals",
      "http://blog.example.com:8080/posts/2025/08/entry?id=42",
      "https://cdn.example.de/assets/images/logo.png"
    ],
    "negativeContentExamples": [
      "www.example.com",
      "https://localhost/dashboard",
      "http://192.168.1.1/settings",
      "https://example",
      "http//example.com",
      "https:///example.com",
      "file:///Users/me/file.txt",
      "mailto:user@example.com"
    ],
    "positiveHeaderExamples": [
      "URL",
      "Website",
      "Web Address",
      "Website URL",
      "Page URL",
      "Landing URL",
      "Target URL",
      "Site Link"
    ],
    "negativeHeaderExamples": [
      "Domain Name",
      "Email Address",
      "File Path",
      "Hostname",
      "IP Address",
      "Page Title",
      "URI Scheme",
      "Website Domain"
    ],
    "explanation": "Matches complete URLs that include a scheme (http, https, or ftp), a dot-delimited domain with a valid TLD, and optional components such as port, path, query, and fragment. Designed to identify web resource locators in logs, exports, and datasets where full URLs are expected.\nThe pattern intentionally requires a scheme and a registrable-style domain to avoid false positives from hostnames, IPs, or bare domains; it does not match mailto/file URIs, localhost-only references, or scheme-less values like www.example.com.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:17:58.520789"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS_EN",
    "description": "This type captures street addresses as they are formatted in English-speaking contexts for postal delivery and location identification. The values represent complete address strings combining house numbers, street names, and street types using standard English formatting and common abbreviations.",
    "pluginType": "regex",
    "regexPattern": "\\b\\d{1,6}(-\\d{1,6})?[A-Za-z]?\\s+(N|S|E|W|NE|NW|SE|SW|North|South|East|West)?\\s*([A-Za-z0-9]+[.'-]?\\s+){1,3}(Street|St|Avenue|Ave|Road|Rd|Drive|Dr|Lane|Ln|Boulevard|Blvd|Court|Ct|Circle|Cir|Place|Pl|Terrace|Ter|Way|Parkway|Pkwy|Highway|Hwy)\\b(\\s+(N|S|E|W|NE|NW|SE|SW|North|South|East|West))?(\\s+(Apt|Suite|Ste|Unit|#)\\s*[A-Za-z0-9-]+)?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 3960,
    "headerPatterns": [
      {
        "regExp": "(?i).*street[\\s_]*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street Address"
        ],
        "negativeExamples": [
          "Street Name"
        ]
      },
      {
        "regExp": "(?i).*(mailing|shipping|service)\\s*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Shipping Address"
        ],
        "negativeExamples": [
          "Shipping City"
        ]
      },
      {
        "regExp": "(?i).*residential[\\s_]*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Residential Address"
        ],
        "negativeExamples": [
          "Residential Unit"
        ]
      },
      {
        "regExp": "(?i).*(addr|strt)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Addr"
        ],
        "negativeExamples": [
          "Adder"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address"
        ],
        "negativeExamples": [
          "Street"
        ]
      }
    ],
    "positiveContentExamples": [
      "123 Main St",
      "742 Evergreen Terrace",
      "1600 Pennsylvania Ave NW",
      "55 W 46th St",
      "221B Baker Street",
      "500 Big Rock Blvd Apt 2B",
      "12-14 High Rd",
      "9 King's Way Ste 300"
    ],
    "negativeContentExamples": [
      "Main Street",
      "123 Main",
      "Baker Street 221B",
      "No 4 Privet Drive",
      "123 Main St, London",
      "1600 Pennsylvania",
      "10 Downing St.",
      "123 Main Street Unit"
    ],
    "positiveHeaderExamples": [
      "Street Address",
      "Address",
      "Street",
      "Mailing Address",
      "Shipping Address",
      "Residential Address",
      "Addr"
    ],
    "negativeHeaderExamples": [
      "City",
      "ZIP Code",
      "Country",
      "Street Name",
      "Building Number",
      "State/Province",
      "Location Code"
    ],
    "explanation": "Street addresses in English typically start with a house number (optionally with a letter or range), followed by an optional directional, a street name of one to three tokens, a recognized street type suffix, and optionally a trailing directional and/or unit designator (e.g., Apt, Suite). This type is useful for identifying and validating single-line address fields that contain the thoroughfare portion of an address.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:18:09.158427"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.SUBURB_AU",
    "description": "This type captures Australian suburb names as they are used in postal addressing and geographic identification systems. The values represent locality names using proper English spelling and standard formatting as established by Australian postal and administrative conventions.",
    "pluginType": "regex",
    "regexPattern": "\\b((St|St\\.|Mt|Mt\\.)|[A-Z][a-z]+[a-zA-Z]{0,22}|[A-Z]'[A-Za-z]{2,24}|[A-Z][a-z]+-[A-Z][a-zA-Z]{1,22})( ([A-Z][a-z]+[a-zA-Z]{0,22}|[A-Z]'[A-Za-z]{2,24}|[A-Z][a-z]+-[A-Z][a-zA-Z]{1,22})){0,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3910,
    "headerPatterns": [
      {
        "regExp": "(?i).*(australia|au).*(suburb).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Australian Suburb Name"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*(suburb).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Suburb Name"
        ],
        "negativeExamples": [
          "Postcode"
        ]
      },
      {
        "regExp": "(?i).*(australia|au).*(suburb).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Australian Suburb"
        ],
        "negativeExamples": [
          "State"
        ]
      },
      {
        "regExp": "(?i).*(suburb).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Suburb"
        ],
        "negativeExamples": [
          "Postcode"
        ]
      },
      {
        "regExp": "(?i).*(locality).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Locality Name"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*(name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Postcode"
        ]
      }
    ],
    "positiveContentExamples": [
      "St Kilda",
      "St Leonards",
      "Mount Gambier",
      "Alice Springs",
      "Port Macquarie",
      "O'Connor",
      "Bondi Beach",
      "Glenelg North"
    ],
    "negativeContentExamples": [
      "St Kilda VIC",
      "Bondi Beach 2026",
      "Southbank, VIC",
      "15 Alice Street",
      "OConnor",
      "St.Kilda",
      "Kings Park NSW",
      "North Sydney, NSW"
    ],
    "positiveHeaderExamples": [
      "Suburb",
      "Australian Suburb",
      "Suburb Name",
      "AU Suburb",
      "Locality Name",
      "Suburb (AU)",
      "Residential Suburb",
      "Australian Locality Name"
    ],
    "negativeHeaderExamples": [
      "State",
      "City",
      "Postcode",
      "Street",
      "Address",
      "Region",
      "Country",
      "Town Code"
    ],
    "explanation": "Australian suburb names typically consist of one to four capitalized words separated by spaces, and may include common forms like St/Mt abbreviations, internal apostrophes (e.g., O'Connor), or a single hyphen within a word (e.g., Smithfield-West). The regex enforces capitalized tokens with lowercase letters to avoid matching state codes or postcodes, and limits token count to typical suburb name lengths. Use this type to classify locality fields representing Australian suburbs in addresses or geospatial datasets, especially when paired with headers indicating suburb/locality context.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:18:10.853355"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_NAME_BARE_<LANGUAGE>",
    "description": "This type captures the core identifying portion of street names without street type markers or suffixes in different language contexts. The values represent the primary name component using proper spelling, capitalization, and linguistic conventions appropriate to the specified language locale. Examples vary by language: Main, K\u00f6nig.",
    "pluginType": "regex",
    "regexPattern": "\\b(?!Street\\b)(?!St\\b)(?!Road\\b)(?!Rd\\b)(?!Avenue\\b)(?!Ave\\b)(?!Boulevard\\b)(?!Blvd\\b)(?!Lane\\b)(?!Ln\\b)(?!Drive\\b)(?!Dr\\b)(?!Court\\b)(?!Ct\\b)(?!Place\\b)(?!Pl\\b)(?!Way\\b)(?!Rue\\b)(?!Strasse\\b)(?!Stra\u00dfe\\b)(?!Straat\\b)(?!Weg\\b)(\\p{Lu}\\p{L}{2,}|\\p{Lu}{2,4})([-']\\p{Lu}\\p{L}{2,})*(\\s+(de|del|la|le|di|da|du|van|von|y|of)\\s+(\\p{Lu}\\p{L}{2,}|\\p{Lu}{2,4})([-']\\p{Lu}\\p{L}{2,})*)*(\\s+(?!Street\\b|St\\b|Road\\b|Rd\\b|Avenue\\b|Ave\\b|Boulevard\\b|Blvd\\b|Lane\\b|Ln\\b|Drive\\b|Dr\\b|Court\\b|Ct\\b|Place\\b|Pl\\b|Way\\b|Rue\\b|Strasse\\b|Stra\u00dfe\\b|Straat\\b|Weg\\b)(\\p{Lu}\\p{L}{2,}|\\p{Lu}{2,4})([-']\\p{Lu}\\p{L}{2,})*)?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3980,
    "headerPatterns": [
      {
        "regExp": "(?i).*(street|road|stra\u00dfe|strasse|straat).*(name|nm).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street Name"
        ],
        "negativeExamples": [
          "Street Number"
        ]
      },
      {
        "regExp": "(?i).*(thoroughfare|via|rue|calle).*(name|nm).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Thoroughfare Name"
        ],
        "negativeExamples": [
          "Postcode"
        ]
      },
      {
        "regExp": "(?i).*(road|street|stra\u00dfe|strasse|straat).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Straat"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*(st|rd)\\s*(name|nm).*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "st_name"
        ],
        "negativeExamples": [
          "st_number"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "country"
        ]
      }
    ],
    "positiveContentExamples": [
      "Main",
      "K\u00f6nig",
      "San Mart\u00edn",
      "O'Connell",
      "Saint-Michel",
      "Libertad",
      "De la Cruz",
      "Orchard"
    ],
    "negativeContentExamples": [
      "Main Street",
      "Rue de la Paix",
      "Calle Libertad",
      "Orchard Rd",
      "O'Connell St",
      "5th Avenue",
      "Street",
      "Road"
    ],
    "positiveHeaderExamples": [
      "Street Name",
      "Straat",
      "Road Name",
      "StreetName",
      "Thoroughfare Name",
      "RoadName",
      "Straatnaam",
      "Way Name"
    ],
    "negativeHeaderExamples": [
      "Street Number",
      "Postcode",
      "City",
      "Address Line",
      "Country",
      "ZIP Code",
      "Street Type",
      "House Number"
    ],
    "explanation": "Use this semantic type when the column contains the core street name without any type markers such as Street, Road, Ave, Rue, or Stra\u00dfe. It supports multi-word names, common lowercase connectors (e.g., de, van, von), hyphens, and apostrophes, and is intended for locale-aware street name bases.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:18:13.537153"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PREFECTURE_NAME_JA",
    "description": "This type identifies Japanese prefecture names used for regional administrative identification within Japan's governmental structure. The format consists of proper noun text strings representing official prefecture names in Japanese characters without abbreviations or romanization.",
    "pluginType": "regex",
    "regexPattern": "(?<![\u4e00-\u9faf\u3041-\u3093\u30a1-\u30f3\u30fc])(\u6771\u4eac\u90fd|\u5317\u6d77\u9053|\u4eac\u90fd\u5e9c|\u5927\u962a\u5e9c|[\u4e00-\u9faf]{2,4}(\u90fd|\u9053|\u5e9c|\u770c))(?![\u4e00-\u9faf\u3041-\u3093\u30a1-\u30f3\u30fc])",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 3610,
    "headerPatterns": [
      {
        "regExp": "(?i).*(\u90fd\u9053\u5e9c\u770c\u540d|prefecture[\\s_]*name).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u90fd\u9053\u5e9c\u770c\u540d"
        ],
        "negativeExamples": [
          "\u56fd\u540d"
        ]
      },
      {
        "regExp": "(?i).*(japanese|ja|jp).*(prefecture).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Japanese Prefecture"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*\u90fd\u9053\u5e9c\u770c.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "\u90fd\u9053\u5e9c\u770c"
        ],
        "negativeExamples": [
          "\u56fd"
        ]
      },
      {
        "regExp": "(?i).*prefecture.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Prefecture"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "name"
        ],
        "negativeExamples": [
          "code"
        ]
      }
    ],
    "positiveContentExamples": [
      "\u6771\u4eac\u90fd",
      "\u5317\u6d77\u9053",
      "\u4eac\u90fd\u5e9c",
      "\u5927\u962a\u5e9c",
      "\u795e\u5948\u5ddd\u770c",
      "\u9752\u68ee\u770c",
      "\u5175\u5eab\u770c",
      "\u6c96\u7e04\u770c"
    ],
    "negativeContentExamples": [
      "\u6771\u4eac",
      "\u4eac\u90fd\u5e02",
      "\u5927\u962a",
      "\u795e\u5948\u5ddd",
      "\u5317\u6d77\u9053\u672d\u5e4c\u5e02",
      "\u5175\u5eab\u770c\u7acb\u5927\u5b66",
      "\u6c96\u7e04\u770c\u90a3\u8987\u5e02",
      "\u6771\u4eac\u90fd"
    ],
    "positiveHeaderExamples": [
      "\u90fd\u9053\u5e9c\u770c",
      "Prefecture",
      "Japanese Prefecture",
      "\u90fd\u9053\u5e9c\u770c\u540d",
      "Prefecture Name",
      "JP Prefecture"
    ],
    "negativeHeaderExamples": [
      "\u56fd",
      "Country",
      "City",
      "State",
      "Province",
      "Region",
      "County"
    ],
    "explanation": "Identifies values that are official Japanese prefecture names written in Japanese characters and ending with the correct administrative suffix (\u90fd, \u9053, \u5e9c, \u770c), including special cases for \u6771\u4eac\u90fd, \u5317\u6d77\u9053, \u5927\u962a\u5e9c, and \u4eac\u90fd\u5e9c. Useful for normalizing regional attributes, validating address components, and geospatial aggregation where the prefecture is expected as a standalone label without additional locality or organizational text.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:18:16.656326"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.PROVINCE_CA",
    "description": "This type represents official Canadian province and territory two-letter postal codes used for identifying provinces and territories within Canada's federal system. The format is exactly two uppercase letters with no spaces, numbers, or special characters.",
    "pluginType": "list",
    "regexPattern": null,
    "listValues": [
      "AB",
      "BC",
      "MB",
      "NB",
      "NL",
      "NS",
      "NT",
      "NU",
      "ON",
      "PE",
      "QC",
      "SK",
      "YT"
    ],
    "backout": "^[A-Z]{2}$",
    "confidenceThreshold": 95,
    "priority": 3620,
    "headerPatterns": [
      {
        "regExp": "(?i).*canadian.*province.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Canadian Province Code"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      },
      {
        "regExp": "(?i).*canadian.*province.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Canadian Province"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*province.*code.*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "Province Code"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      },
      {
        "regExp": "(?i).*prov.*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Prov Code"
        ],
        "negativeExamples": [
          "Province"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Territory"
        ]
      }
    ],
    "positiveContentExamples": [
      "AB",
      "BC",
      "MB",
      "NB",
      "NL",
      "NS",
      "ON",
      "QC"
    ],
    "negativeContentExamples": [
      "CA",
      "Qc",
      "QUE",
      "ON-CA",
      "AB1",
      "QC.",
      "PEI",
      "YK"
    ],
    "positiveHeaderExamples": [
      "Province Code",
      "Canadian Province",
      "Province",
      "Prov Code",
      "CA Province Code",
      "Province Abbreviation",
      "Province/Territory Code"
    ],
    "negativeHeaderExamples": [
      "Province Name",
      "Country",
      "Territory",
      "State Code",
      "Postal Code",
      "Province ID",
      "Country Code",
      "Region"
    ],
    "explanation": "STATE_PROVINCE.PROVINCE_CA detects Canadian province and territory postal codes consisting of exactly two uppercase letters. It is useful for validating address components, normalizing location codes, and constraining user input to official Canadian province/territory codes.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:18:17.357536"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_NAME_EN",
    "description": "Full English street names consisting of the identifying street name plus a spelled-out street type suffix (e.g., Street, Avenue, Road). Supports multi-word names, hyphenated tokens, and apostrophes, with optional spelled-out directional prefixes (e.g., North, Southwest).",
    "pluginType": "regex",
    "regexPattern": "\\b((North|South|East|West|Northeast|Northwest|Southeast|Southwest) )?([A-Z][a-z]*('[A-Za-z]+)?)([ -][A-Z][a-z]*('[A-Za-z]+)?){0,3} (Street|Avenue|Road|Boulevard|Drive|Court|Lane|Terrace|Place|Way|Square|Circle|Trail|Parkway|Highway|Close|Crescent|Alley)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 4000,
    "headerPatterns": [
      {
        "regExp": "(?i).*(street|road|avenue|boulevard|drive|lane|court|terrace|place|way|square|circle|trail|parkway|highway|close|crescent|alley)[ _-]*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street Name"
        ],
        "negativeExamples": [
          "Street Type"
        ]
      },
      {
        "regExp": "(?i).*(address|addr)[ _-]*(street|road|avenue|boulevard|drive|lane|court|terrace|place|way|square|circle|trail|parkway|highway|close|crescent|alley).*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "Address Street"
        ],
        "negativeExamples": [
          "City Street"
        ]
      },
      {
        "regExp": "(?i).*\\b(st|rd|ave|blvd|dr|ln|ct|ter|pl|wy|sq|cir|trl|pkwy|hwy|cres|aly)\\b[ _-]*name.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "Rd Name"
        ],
        "negativeExamples": [
          "Rd Number"
        ]
      },
      {
        "regExp": "(?i).*\\bstreet\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "Street"
        ],
        "negativeExamples": [
          "House Number"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 88,
        "mandatory": true,
        "positiveExamples": [
          "Road Name"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "Main Street",
      "Old Mill Road",
      "Baker Street",
      "Queen's Avenue",
      "North Elm Street",
      "Cedar Lane",
      "Maple Crescent",
      "Sunrise Boulevard"
    ],
    "negativeContentExamples": [
      "5th Avenue",
      "Main St",
      "123 Main Street",
      "Elm Rd",
      "Oak Street NW",
      "N Elm Street",
      "Main Street, Apt 2",
      "Avenue of Pines"
    ],
    "positiveHeaderExamples": [
      "Street Name",
      "Road Name",
      "Street",
      "Avenue Name",
      "Street Name EN",
      "Primary Street Name",
      "Thoroughfare Name",
      "Boulevard Name"
    ],
    "negativeHeaderExamples": [
      "House Number",
      "City",
      "ZIP Code",
      "Street Type",
      "Street Number",
      "Address Line 1",
      "Road Type",
      "Country"
    ],
    "explanation": "This type identifies English street names that include a proper name and a spelled-out street type suffix, optionally preceded by a spelled-out directional. It intentionally excludes house numbers, abbreviations like St/Rd/Ave, trailing unit/directional tokens, and address lines that contain extra elements beyond the street name itself.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:18:29.578947"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.MUNICIPALITY_CODE_NL",
    "description": "This type represents Dutch municipality codes used for official statistical identification of municipal areas within the Netherlands administrative system. The format consists of exactly four consecutive numeric digits without spaces, letters, or special formatting characters for standardized municipal referencing.",
    "pluginType": "regex",
    "regexPattern": "\\b[0-9]{4}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 3580,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bcbs\\b.*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "CBS Code"
        ],
        "negativeExamples": [
          "Municipality Code"
        ]
      },
      {
        "regExp": "(?i).*\\bgemeente\\b.*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Gemeente Code"
        ],
        "negativeExamples": [
          "CBS Code"
        ]
      },
      {
        "regExp": "(?i).*\\bmunicipality\\b.*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Municipality Code"
        ],
        "negativeExamples": [
          "Municipality Name"
        ]
      },
      {
        "regExp": "(?i).*\\b(muni|gem)\\b.*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Muni Code"
        ],
        "negativeExamples": [
          "Municipality Name"
        ]
      },
      {
        "regExp": "(?i).*\\bcode\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Province"
        ]
      }
    ],
    "positiveContentExamples": [
      "0102",
      "0345",
      "0723",
      "1234",
      "2501",
      "4007",
      "7890",
      "9801"
    ],
    "negativeContentExamples": [
      "123",
      "12345",
      "12-34",
      "A1234",
      "1234A",
      "1O23",
      "1,234",
      "01234"
    ],
    "positiveHeaderExamples": [
      "Gemeente Code",
      "Municipality Code",
      "CBS Code",
      "NL Municipality Code",
      "Muni Code",
      "GemeenteCode",
      "CBS Municipality Code",
      "Municipality Code NL"
    ],
    "negativeHeaderExamples": [
      "Municipality Name",
      "Province",
      "Country",
      "City Code",
      "Postal Code",
      "Municipality ID",
      "Province Code",
      "Country Code"
    ],
    "explanation": "Four-digit municipality codes are used to reference Dutch municipalities consistently across administrative and statistical systems. This type focuses solely on values that are exactly four ASCII digits with no separators or letters. It is useful for validating and classifying Dutch municipality identifiers in datasets where headers explicitly point to municipality or CBS codes.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:18:34.029522"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.DEPARTMENT_NAME_FR",
    "description": "Identifies official French department names used for administrative identification within France. Values are proper-noun strings in French that may include accents, hyphens, and apostrophes, and may include the preposition \"de\" with a space as in \"Territoire de Belfort\". Abbreviations, numeric department codes, or appended codes are excluded.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z\u00c0-\u00d6\u00d8-\u00de][A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff']+(-[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff']+)*( (de) [A-Z\u00c0-\u00d6\u00d8-\u00de][A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff']+(-[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff']+)*){0,2}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 96,
    "priority": 3510,
    "headerPatterns": [
      {
        "regExp": "(?i).*(french|fr).*department.*name.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "French Department Name"
        ],
        "negativeExamples": [
          "Department Code"
        ]
      },
      {
        "regExp": "(?i).*(french|fr).*department.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "French Department"
        ],
        "negativeExamples": [
          "Department Store"
        ]
      },
      {
        "regExp": "(?i).*(d\u00e9partement|departement|dept|dep).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "D\u00e9partement"
        ],
        "negativeExamples": [
          "Department ID"
        ]
      },
      {
        "regExp": "(?i).*department.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Department"
        ],
        "negativeExamples": [
          "Region"
        ]
      }
    ],
    "positiveContentExamples": [
      "Val-de-Marne",
      "C\u00f4tes-d'Armor",
      "Bouches-du-Rh\u00f4ne",
      "Loire-Atlantique",
      "Hauts-de-Seine",
      "Territoire de Belfort",
      "Pyr\u00e9n\u00e9es-Orientales",
      "Deux-S\u00e8vres"
    ],
    "negativeContentExamples": [
      "Bouches du Rh\u00f4ne",
      "Seine et Marne",
      "Val d Oise",
      "Haut Rhin",
      "59 Nord",
      "Alpes Maritimes",
      "United States",
      "Paris 75"
    ],
    "positiveHeaderExamples": [
      "D\u00e9partement",
      "Department",
      "French Department",
      "French Department Name",
      "D\u00e9partement fran\u00e7ais",
      "Dept FR",
      "Department Name",
      "Departement"
    ],
    "negativeHeaderExamples": [
      "Country",
      "Region",
      "City",
      "Department Code",
      "Department Store",
      "Province",
      "State",
      "Postal Code"
    ],
    "explanation": "This semantic type targets French department names as standalone proper nouns, commonly appearing in address or administrative datasets. The regex accommodates accents, hyphens (including forms like d', du, des within hyphenated segments), and the spaced preposition \"de\" for cases like \"Territoire de Belfort\". It intentionally excludes numeric department codes, appended codes, and non-official spacing (e.g., replacing required hyphens with spaces). Use the provided header patterns to further constrain detection to columns that clearly denote departments.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:18:48.609151"
  },
  {
    "resultType": "generated",
    "semanticType": "IPADDRESS.IPV6",
    "description": "IPv6 addresses are hexadecimal identifiers used for network device addressing in the modern Internet protocol. An IPv6 address consists of eight groups of one to four hexadecimal digits separated by colons, and supports zero-compression (::) and omission of leading zeros.",
    "pluginType": "regex",
    "regexPattern": "(?<![A-Fa-f0-9])(([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4}|([0-9A-Fa-f]{1,4}:){1,7}:|:([0-9A-Fa-f]{1,4}:){1,7}[0-9A-Fa-f]{1,4}|([0-9A-Fa-f]{1,4}:){1,6}:[0-9A-Fa-f]{1,4}|([0-9A-Fa-f]{1,4}:){1,5}(:[0-9A-Fa-f]{1,4}){1,2}|([0-9A-Fa-f]{1,4}:){1,4}(:[0-9A-Fa-f]{1,4}){1,3}|([0-9A-Fa-f]{1,4}:){1,3}(:[0-9A-Fa-f]{1,4}){1,4}|([0-9A-Fa-f]{1,4}:){1,2}(:[0-9A-Fa-f]{1,4}){1,5}|[0-9A-Fa-f]{1,4}(:[0-9A-Fa-f]{1,4}){1,6}|:(:[0-9A-Fa-f]{1,4}){1,7})(?![A-Fa-f0-9])",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 2940,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bipv6\\b.*\\baddress\\b.*",
        "confidence": 98,
        "mandatory": true,
        "positiveExamples": [
          "IPv6 Address"
        ],
        "negativeExamples": [
          "IPv4 Address"
        ]
      },
      {
        "regExp": "(?i).*\\bipv6\\b.*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "IPv6"
        ],
        "negativeExamples": [
          "IPv4 Address"
        ]
      },
      {
        "regExp": "(?i).*\\bip\\b.*\\baddress\\b.*",
        "confidence": 94,
        "mandatory": true,
        "positiveExamples": [
          "IP Address"
        ],
        "negativeExamples": [
          "Postal Address"
        ]
      },
      {
        "regExp": "(?i).*(\\bip6\\b|\\bip\\b[^a-z0-9]*\\bv6\\b|\\binternet protocol v6\\b).*",
        "confidence": 93,
        "mandatory": true,
        "positiveExamples": [
          "IP6"
        ],
        "negativeExamples": [
          "MAC Address"
        ]
      },
      {
        "regExp": "(?i).*\\bip\\b.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "IP"
        ],
        "negativeExamples": [
          "Domain Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "2001:0db8:85a3:0000:0000:8a2e:0370:7334",
      "2001:db8:85a3:0:0:8A2E:370:7334",
      "2001:db8::8a2e:370:7334",
      "fe80::1",
      "::1",
      "2001:db8:0:0:0:0:2:1",
      "2001:db8:0:1::1",
      "2607:f8b0:4005:805::200e"
    ],
    "negativeContentExamples": [
      "2001:db8:85a3::8a2e:370:7334:",
      "2001:db8:85a3:::8a2e:370:7334",
      "2001:db8:85a3:0:0:8a2e:370",
      "fe80:0:0:0:0:0:0",
      "2001:db8:85a3:0:0:8a2e:370:7334:1234",
      "2001-db8-85a3-0000-0000-8a2e-0370-7334",
      "2001:db8:85a3:z:0:8a2e:370:7334",
      "::ffff:192.0.2.128"
    ],
    "positiveHeaderExamples": [
      "IPv6 Address",
      "IPv6",
      "IP Address",
      "IP6",
      "Client IPv6 Address",
      "Device IPv6",
      "Internet Protocol v6",
      "User IPv6"
    ],
    "negativeHeaderExamples": [
      "IPv4 Address",
      "Domain Name",
      "MAC Address",
      "Hostname",
      "Email Address",
      "Postal Address",
      "URL",
      "Network Address"
    ],
    "explanation": "This semantic type detects IPv6 addresses represented as eight groups of one to four hexadecimal digits separated by colons, including standard zero-compression (::) and omission of leading zeros. It is suitable for validating or profiling network data fields that store IPv6 addresses and for distinguishing them from other identifiers such as MAC addresses or hostnames.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:18:50.798095"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_US",
    "description": "This type captures abbreviated codes for US states and territories used in official documentation and geographic identification systems. The values represent standardized two-character abbreviations derived from state names using uppercase letters without periods or additional punctuation.",
    "pluginType": "regex",
    "regexPattern": "\\b(AL|AK|AZ|AR|CA|CO|CT|DE|FL|GA|HI|ID|IL|IN|IA|KS|KY|LA|ME|MD|MA|MI|MN|MS|MO|MT|NE|NV|NH|NJ|NM|NY|NC|ND|OH|OK|OR|PA|RI|SC|SD|TN|TX|UT|VT|VA|WA|WV|WI|WY|DC|PR|GU|VI|AS|MP)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3900,
    "headerPatterns": [
      {
        "regExp": "(?i).*us.*state.*code.*",
        "confidence": 97,
        "mandatory": true,
        "positiveExamples": [
          "US State Code"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*usps.*state.*(code|abbrev|abbr).*",
        "confidence": 96,
        "mandatory": true,
        "positiveExamples": [
          "USPS State Code"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      },
      {
        "regExp": "(?i).*state.*(code|abbrev|abbr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Code"
        ],
        "negativeExamples": [
          "State Name"
        ]
      },
      {
        "regExp": "(?i).*(st|state).*cd.*",
        "confidence": 92,
        "mandatory": true,
        "positiveExamples": [
          "state_cd"
        ],
        "negativeExamples": [
          "country_cd"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 90,
        "mandatory": true,
        "positiveExamples": [
          "code"
        ],
        "negativeExamples": [
          "name"
        ]
      }
    ],
    "positiveContentExamples": [
      "CA",
      "NY",
      "TX",
      "DC",
      "PR",
      "GU",
      "VI",
      "AS"
    ],
    "negativeContentExamples": [
      "Ca",
      "CA.",
      "CAL",
      "US",
      "QC",
      "FM",
      "AA",
      "D.C."
    ],
    "positiveHeaderExamples": [
      "State Code",
      "US State",
      "State",
      "US State Code",
      "USPS State Code",
      "State Abbreviation",
      "State Abbrev"
    ],
    "negativeHeaderExamples": [
      "State Name",
      "Country",
      "County",
      "Province",
      "Country Code",
      "ZIP Code",
      "Region"
    ],
    "explanation": "This semantic type identifies official two-letter uppercase abbreviations for US states and territories (e.g., CA, NY, PR, DC). It is useful for validating and standardizing location fields that store state or territory codes in datasets such as addresses, customer records, and geographic catalogs.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:19:15.104298"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_MX",
    "description": "This type captures abbreviated codes for Mexican states and the federal entity used in official and geographic identification contexts. Values are standardized uppercase abbreviations composed only of letters, without periods or other punctuation. It is intended for compact state identifiers rather than full state names.",
    "pluginType": "regex",
    "regexPattern": "\\b(AGU|BCN|BCS|CAM|CHH|CHP|CMX|COA|COL|DUR|GUA|GRO|HID|JAL|MEX|MIC|MOR|NAY|NLE|OAX|PUE|QUE|ROO|SLP|SIN|SON|TAB|TAM|TLA|VER|YUC|ZAC)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3800,
    "headerPatterns": [
      {
        "regExp": "(?i).*(mx|mexican).*state.*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Mexican State Code"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*(mx|mexican).*(state|estado).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Mexican State"
        ],
        "negativeExamples": [
          "State Name"
        ]
      },
      {
        "regExp": "(?i).*(state|estado).*(abbr|abbrev|abbreviation).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Abbreviation"
        ],
        "negativeExamples": [
          "State Name"
        ]
      },
      {
        "regExp": "(?i).*(state|estado).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Estado"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Code"
        ],
        "negativeExamples": [
          "State Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "AGU",
      "BCN",
      "BCS",
      "CHH",
      "CMX",
      "JAL",
      "NLE",
      "SLP"
    ],
    "negativeContentExamples": [
      "CDMX",
      "DF",
      "GTO",
      "QRO",
      "BC",
      "MICH",
      "NL",
      "JALISCO"
    ],
    "positiveHeaderExamples": [
      "Estado",
      "State Code",
      "Mexican State",
      "Mexican State Code",
      "State Abbreviation",
      "MX State Code",
      "Estado MX",
      "Entidad Federativa"
    ],
    "negativeHeaderExamples": [
      "State Name",
      "Country",
      "Municipality",
      "Province",
      "Region",
      "County",
      "Department",
      "City"
    ],
    "explanation": "This semantic type identifies standardized uppercase abbreviations for Mexican states and Mexico City as found in official and geospatial datasets. It is useful for validating and classifying compact state codes, enabling consistent joins and filtering where full state names are not provided.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:19:23.775925"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_PROVINCE_NA",
    "description": "This type captures abbreviated codes for states and provinces across North America including US states, Canadian provinces, and Mexican states. The values represent standardized abbreviations using uppercase letters without periods, following each country's official abbreviation conventions.",
    "pluginType": "regex",
    "regexPattern": "\\b[A-Z]{2,3}\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 97,
    "priority": 3860,
    "headerPatterns": [
      {
        "regExp": "(?i).*(state[ _/-]*province|province[ _/-]*state).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State/Province"
        ],
        "negativeExamples": [
          "State Name"
        ]
      },
      {
        "regExp": "(?i).*(state[ _/-]*code|province[ _/-]*code).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Code"
        ],
        "negativeExamples": [
          "Country Code"
        ]
      },
      {
        "regExp": "(?i).*(st|prov)[ _/-]*(code|cd|abbr).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Prov Abbr"
        ],
        "negativeExamples": [
          "Province Name"
        ]
      },
      {
        "regExp": "(?i).*(state|province).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Province Code"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*code.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Code"
        ],
        "negativeExamples": [
          "Name"
        ]
      }
    ],
    "positiveContentExamples": [
      "NY",
      "CA",
      "TX",
      "ON",
      "QC",
      "BC",
      "NL",
      "BCS"
    ],
    "negativeContentExamples": [
      "ca",
      "N Y",
      "AB1",
      "CDMX",
      "B.C",
      "N-L",
      "Q C",
      "\u00c9Q"
    ],
    "positiveHeaderExamples": [
      "State Code",
      "Province Code",
      "State/Province",
      "US State Code",
      "Province Abbr",
      "State Abbreviation",
      "State Province Code"
    ],
    "negativeHeaderExamples": [
      "State Name",
      "Province Name",
      "Country",
      "Postal Code",
      "Country Code",
      "Region",
      "City Code"
    ],
    "explanation": "Abbreviated state and province codes for North America, limited to 2\u20133 uppercase letters without periods. Typical use cases include address normalization, geocoding pipelines, and regional aggregation where standardized subnational codes are required. The pattern is intentionally constrained to uppercase alphabetic tokens with word boundaries to avoid accidental matches with longer identifiers or mixed-character strings.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:19:24.985955"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS_<LANGUAGE>",
    "description": "This type captures street addresses as they are formatted in different languages and cultural contexts for postal delivery and location identification. The values represent complete address strings using proper formatting, character sets, and conventions appropriate to the specified language locale. Examples vary by language: 123 Main Street, Hauptstra\u00dfe 45.",
    "pluginType": "regex",
    "regexPattern": "\\b(\\d{1,5}[A-Za-z]?\\s+[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff0-9' -]{1,}\\s+(Street|St|Avenue|Ave|Road|Rd|Boulevard|Blvd|Lane|Ln|Drive|Dr|Court|Ct|Place|Pl|Way|Terrace|Ter|Rue|Calle|Via|Avenida|Av)\\b|\\d{1,5}[A-Za-z]?\\s+(Rue|Calle|Via|Avenida|Av|Avenue|Ave|Street|St|Road|Rd|Boulevard|Blvd|Lane|Ln|Drive|Dr|Court|Ct|Place|Pl|Way|Terrace|Ter)\\s+[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff0-9' -]{1,}\\b|(Rue|Calle|Via|Avenida|Av|Avenue|Ave|Street|St|Road|Rd|Boulevard|Blvd|Lane|Ln|Drive|Dr|Court|Ct|Place|Pl|Way|Terrace|Ter)\\s+[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff0-9' -]{1,}\\s+\\d{1,5}[A-Za-z]?\\b|[A-Za-z\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u00ff' -]{1,}(stra\u00dfe|strasse|weg|gasse)\\s+\\d{1,5}[A-Za-z]?\\b)",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 3950,
    "headerPatterns": [
      {
        "regExp": "(?i).*(shipping|billing|mailing).*street.*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Shipping Street Address"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*(street.*address|address.*street).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street Address"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      },
      {
        "regExp": "(?i).*address.*line.*1.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address Line 1"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*(street|thoroughfare).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "123 Main Street",
      "742 Evergreen Terrace",
      "10 Downing St",
      "221B Baker Street",
      "5 Avenida Libertad",
      "14 Rue de la Paix",
      "Via Roma 12",
      "Hauptstra\u00dfe 45"
    ],
    "negativeContentExamples": [
      "Main Street",
      "123 Main",
      "PO Box 123",
      "Avenue Q",
      "45-67 Queens Blvd",
      "221B",
      "12 Rue",
      "Hauptstra\u00dfe"
    ],
    "positiveHeaderExamples": [
      "Street Address",
      "Address",
      "Street",
      "Shipping Street Address",
      "Address Line 1",
      "Billing Address",
      "Mailing Street"
    ],
    "negativeHeaderExamples": [
      "City",
      "Country",
      "ZIP Code",
      "State",
      "Province",
      "Latitude",
      "Customer Name"
    ],
    "explanation": "Identifies complete street-level address lines across languages, accommodating both number-first (e.g., 123 Main Street, 14 Rue de la Paix) and name-first conventions with language-specific street terms (e.g., Stra\u00dfe/Strasse, Rue, Via, Avenida). Use this type to detect columns containing a full street address line suitable for mailing or geocoding, distinct from city, postal code, or region fields.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:19:39.067043"
  },
  {
    "resultType": "generated",
    "semanticType": "STATE_PROVINCE.STATE_PROVINCE_NAME_NA",
    "description": "This type captures complete names of states and provinces across North America including US states, Canadian provinces, and Mexican states. The values represent full territorial names using proper spelling and formatting conventions appropriate to each country's linguistic standards.",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(\\p{L}{4,}|(\\p{L}{3,}(([-' ](\\p{L}{3,}|de|del|of|y|la|las|los)){1,4})))\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 98,
    "priority": 3870,
    "headerPatterns": [
      {
        "regExp": "(?i).*state.*province.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State/Province Name"
        ],
        "negativeExamples": [
          "State Code"
        ]
      },
      {
        "regExp": "(?i).*(state|province).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State Name"
        ],
        "negativeExamples": [
          "Province Code"
        ]
      },
      {
        "regExp": "(?i).*(state.*province|province.*state).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "State or Province"
        ],
        "negativeExamples": [
          "Country"
        ]
      },
      {
        "regExp": "(?i).*prov.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Prov Name"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Code"
        ]
      }
    ],
    "positiveContentExamples": [
      "California",
      "New York",
      "Texas",
      "British Columbia",
      "Qu\u00e9bec",
      "Nuevo Le\u00f3n",
      "Baja California Sur",
      "Ciudad de M\u00e9xico"
    ],
    "negativeContentExamples": [
      "CA",
      "TX",
      "Que.",
      "N.Y.",
      "Washington DC",
      "Ontario-CA",
      "MX-BCS",
      "B.C."
    ],
    "positiveHeaderExamples": [
      "State",
      "Province",
      "State/Province Name",
      "State Name",
      "Province Name",
      "State or Province",
      "Prov Name",
      "Subnational Name"
    ],
    "negativeHeaderExamples": [
      "State Code",
      "Province Code",
      "Country",
      "Country Code",
      "Postal Code",
      "City",
      "County",
      "Territory Code"
    ],
    "explanation": "Identifies full state and province names across the United States, Canada, and Mexico. Values are alphabetic with optional spaces, hyphens, apostrophes, and common connectors (de, del, of, y, la/las/los), covering one- to multi-word names. Use this for normalized subnational names where abbreviations or codes are not expected. High threshold and header-driven patterns minimize confusion with person or place names outside this domain.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:19:49.493864"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_ADDRESS2_EN",
    "description": "Supplementary addressing information in English that specifies sub-premise details such as apartment numbers, suites, units, or floors. Typical formats include abbreviations and optional punctuation with a numeric designator, for example \"Apt 5B\", \"Ste-210\", or \"Floor 3\".",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(Apartment|Apt\\.|Apt|Suite|Ste\\.|Ste|Unit|Floor|Flr|Fl|Room|Rm\\.|Rm)\\b[ ]{0,2}[#-]?[ ]{0,1}([A-Za-z]?\\d{1,4}[A-Za-z]?)([ -]\\d{1,4}[A-Za-z]?)?\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 3920,
    "headerPatterns": [
      {
        "regExp": "(?i).*(address[ _-]?line[ _-]?2|addr[ _-]?line[ _-]?2|address2|addr2).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address Line 2"
        ],
        "negativeExamples": [
          "Street Address"
        ]
      },
      {
        "regExp": "(?i).*(address[ _-]?line|addr[ _-]?line).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Addr Line 2"
        ],
        "negativeExamples": [
          "ZIP Code"
        ]
      },
      {
        "regExp": "(?i).*(apartment|apt).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Apt"
        ],
        "negativeExamples": [
          "City"
        ]
      },
      {
        "regExp": "(?i).*(suite|ste|unit).*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Suite"
        ],
        "negativeExamples": [
          "State"
        ]
      },
      {
        "regExp": "(?i).*address.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address Line 2"
        ],
        "negativeExamples": [
          "City"
        ]
      }
    ],
    "positiveContentExamples": [
      "Apt 5B",
      "Apt. #5B",
      "Apartment 12",
      "Suite 210",
      "Ste-0210",
      "Unit #12A",
      "Floor 3",
      "Rm 412"
    ],
    "negativeContentExamples": [
      "Apt",
      "Suite #",
      "Unit Twelve",
      "Fl- B",
      "Level 3",
      "Building B",
      "Address Line 2",
      "PO Box 123"
    ],
    "positiveHeaderExamples": [
      "Address Line 2",
      "Address2",
      "Addr Line 2",
      "Addr2",
      "Apt",
      "Suite",
      "Unit",
      "Address Line-2"
    ],
    "negativeHeaderExamples": [
      "Street Address",
      "City",
      "ZIP Code",
      "Address Line 1",
      "Postal Code",
      "State",
      "Country",
      "Street"
    ],
    "explanation": "This semantic type identifies secondary address line content containing sub-premise details such as apartment, suite, unit, floor, or room designations followed by a numeric (optionally alphanumeric) identifier. It is useful for parsing or validating Address Line 2 fields in datasets where the main street address is stored separately from sub-premise information.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:20:09.461428"
  },
  {
    "resultType": "generated",
    "semanticType": "PERSON.AGE_RANGE",
    "description": "Captures age ranges as they appear in demographic analysis, marketing research, and population studies using span notation. Values represent age brackets formatted with beginning and ending ages or descriptive range indicators (e.g., numeric spans with hyphen/en dash/em dash, \"to\", or terminal indicators like \"+\", \"and over\", or prefixes like \"Under\").",
    "pluginType": "regex",
    "regexPattern": "(?i)\\b(under\\s+\\d{1,3}\\b|over\\s+\\d{1,3}\\b|\\d{1,3}\\s*(to|-|\u2013|\u2014)\\s*\\d{1,3}\\b|\\d{1,3}\\s+and\\s+over\\b|\\d{1,3}\\s*\\+\\b)\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 93,
    "priority": 3160,
    "headerPatterns": [
      {
        "regExp": "(?i).*\\bage[_\\s-]*(range|group|bracket)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Age Range"
        ],
        "negativeExamples": [
          "Birth Year"
        ]
      },
      {
        "regExp": "(?i).*\\bage[_\\s-]*band\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Age Band"
        ],
        "negativeExamples": [
          "Name"
        ]
      },
      {
        "regExp": "(?i).*\\bdemographic\\b.*\\bage\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Demographic Age Group"
        ],
        "negativeExamples": [
          "Age"
        ]
      },
      {
        "regExp": "(?i).*\\bage[_\\s-]*(grp|rng|brkt)\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Age grp"
        ],
        "negativeExamples": [
          "Birth Year"
        ]
      },
      {
        "regExp": "(?i).*\\bage\\b.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Age Group"
        ],
        "negativeExamples": [
          "Birth Year"
        ]
      }
    ],
    "positiveContentExamples": [
      "0-4",
      "5\u20139",
      "10 to 14",
      "15 - 19",
      "20\u201424",
      "25-34",
      "65+",
      "65 and over"
    ],
    "negativeContentExamples": [
      "18",
      "18/24",
      "Under18",
      "under-18",
      "17 and under",
      "65 and older",
      "65-",
      "18,24"
    ],
    "positiveHeaderExamples": [
      "Age Range",
      "Age Group",
      "Age Bracket",
      "Age Band",
      "Demographic Age Group",
      "Customer Age Range",
      "Cohort Age Group"
    ],
    "negativeHeaderExamples": [
      "Age",
      "Birth Year",
      "Name",
      "DOB",
      "Year of Birth",
      "Gender"
    ],
    "explanation": "This semantic type identifies values that represent age brackets, including numeric ranges separated by hyphen/en dash/em dash or the word \"to\", as well as open-ended forms such as \"65+\", \"65 and over\", and prefixed forms like \"Under 18\". It is designed for segmenting populations into standardized age cohorts commonly used in analytics and reporting.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:21:17.168328"
  },
  {
    "resultType": "generated",
    "semanticType": "STREET_NAME_BARE_EN",
    "description": "Core identifying portion of English street names without type designators or suffixes (e.g., not including Street, Avenue, Rd, Blvd). Values are the primary name component using standard English capitalization, allowing multi-word names, hyphenation, apostrophes, and numeric ordinals.",
    "pluginType": "regex",
    "regexPattern": "\\b(((?!(Street|Avenue|Ave|Road|Rd|Boulevard|Blvd|Drive|Dr|Court|Ct|Place|Pl|Lane|Ln|Way|Terrace|Ter|Trail|Trl|Highway|Hwy|Route|Rte|Circle|Cir|Square|Sq)\\b)[A-Z][a-z]*('[A-Za-z]+)?(-[A-Z][a-z]+)*|Saint|[1-9][0-9]{0,2}(st|nd|rd|th))([ -]((of|the|and)|((?!(Street|Avenue|Ave|Road|Rd|Boulevard|Blvd|Drive|Dr|Court|Ct|Place|Pl|Lane|Ln|Way|Terrace|Ter|Trail|Trl|Highway|Hwy|Route|Rte|Circle|Cir|Square|Sq)\\b)[A-Z][a-z]*('[A-Za-z]+)?(-[A-Z][a-z]+)*)|Saint|[1-9][0-9]{0,2}(st|nd|rd|th))){0,3})\\b",
    "listValues": null,
    "backout": null,
    "confidenceThreshold": 94,
    "priority": 3990,
    "headerPatterns": [
      {
        "regExp": "(?i).*address.*street.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Address Street Name"
        ],
        "negativeExamples": [
          "Full Address"
        ]
      },
      {
        "regExp": "(?i).*(street|road).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street Name"
        ],
        "negativeExamples": [
          "Street Type"
        ]
      },
      {
        "regExp": "(?i).*road.*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Road Name"
        ],
        "negativeExamples": [
          "Road Type"
        ]
      },
      {
        "regExp": "(?i).*street.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Street"
        ],
        "negativeExamples": [
          "Street Type"
        ]
      },
      {
        "regExp": "(?i).*(st|rd).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Rd Name"
        ],
        "negativeExamples": [
          "St Type"
        ]
      },
      {
        "regExp": "(?i).*name.*",
        "confidence": 95,
        "mandatory": true,
        "positiveExamples": [
          "Name"
        ],
        "negativeExamples": [
          "Number"
        ]
      }
    ],
    "positiveContentExamples": [
      "Maple",
      "King's",
      "Old Town",
      "Saint Michael",
      "3rd",
      "Queen Anne",
      "O'Connor",
      "New Market"
    ],
    "negativeContentExamples": [
      "Maple Street",
      "Main Rd",
      "ST JOHN",
      "oak",
      "5th Ave",
      "St George",
      "Elm Dr.",
      "Avenue"
    ],
    "positiveHeaderExamples": [
      "Street Name",
      "Road Name",
      "Street",
      "Address Street Name",
      "Rd Name",
      "StreetName",
      "Primary Street Name"
    ],
    "negativeHeaderExamples": [
      "Street Type",
      "House Number",
      "Full Address",
      "Road Type",
      "City",
      "Postal Code",
      "Number"
    ],
    "explanation": "This semantic type detects the main name portion of English street names, excluding any street type markers or suffixes such as Street, Avenue, Rd, Blvd, or similar. It supports one to four tokens, mixed with common connectors (of, the, and), hyphenation, apostrophes, and numeric ordinals (e.g., 3rd), while enforcing typical capitalization patterns. The header patterns prioritize explicit street-name columns and gracefully back off to the primitive concept of a name.",
    "description_pattern": "P3",
    "generated_at": "2025-08-10T17:24:06.252772"
  }
]